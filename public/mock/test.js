!function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = "function" == typeof require && require;
                if (!u && a)
                    return a(o, !0);
                if (i)
                    return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND",
                    f
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e)
            }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
    }
    for (var i = "function" == typeof require && require, o = 0; o < r.length; o++)
        s(r[o]);
    return s
}({
    1: [function(require, module, exports) {
        var THREE = {
            REVISION: "78"
        };
        "function" == typeof define && define.amd ? define("three", THREE) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = THREE),
        void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
        void 0 === Math.sign && (Math.sign = function(x) {
                return x < 0 ? -1 : x > 0 ? 1 : +x
            }
        ),
        void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
            get: function() {
                return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]
            }
        }),
        void 0 === Object.assign && !function() {
            Object.assign = function(target) {
                "use strict";
                if (void 0 === target || null === target)
                    throw new TypeError("Cannot convert undefined or null to object");
                for (var output = Object(target), index = 1; index < arguments.length; index++) {
                    var source = arguments[index];
                    if (void 0 !== source && null !== source)
                        for (var nextKey in source)
                            Object.prototype.hasOwnProperty.call(source, nextKey) && (output[nextKey] = source[nextKey])
                }
                return output
            }
        }(),
            Object.assign(THREE, {
                MOUSE: {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2
                },
                CullFaceNone: 0,
                CullFaceBack: 1,
                CullFaceFront: 2,
                CullFaceFrontBack: 3,
                FrontFaceDirectionCW: 0,
                FrontFaceDirectionCCW: 1,
                BasicShadowMap: 0,
                PCFShadowMap: 1,
                PCFSoftShadowMap: 2,
                FrontSide: 0,
                BackSide: 1,
                DoubleSide: 2,
                FlatShading: 1,
                SmoothShading: 2,
                NoColors: 0,
                FaceColors: 1,
                VertexColors: 2,
                NoBlending: 0,
                NormalBlending: 1,
                AdditiveBlending: 2,
                SubtractiveBlending: 3,
                MultiplyBlending: 4,
                CustomBlending: 5,
                AddEquation: 100,
                SubtractEquation: 101,
                ReverseSubtractEquation: 102,
                MinEquation: 103,
                MaxEquation: 104,
                ZeroFactor: 200,
                OneFactor: 201,
                SrcColorFactor: 202,
                OneMinusSrcColorFactor: 203,
                SrcAlphaFactor: 204,
                OneMinusSrcAlphaFactor: 205,
                DstAlphaFactor: 206,
                OneMinusDstAlphaFactor: 207,
                DstColorFactor: 208,
                OneMinusDstColorFactor: 209,
                SrcAlphaSaturateFactor: 210,
                NeverDepth: 0,
                AlwaysDepth: 1,
                LessDepth: 2,
                LessEqualDepth: 3,
                EqualDepth: 4,
                GreaterEqualDepth: 5,
                GreaterDepth: 6,
                NotEqualDepth: 7,
                MultiplyOperation: 0,
                MixOperation: 1,
                AddOperation: 2,
                NoToneMapping: 0,
                LinearToneMapping: 1,
                ReinhardToneMapping: 2,
                Uncharted2ToneMapping: 3,
                CineonToneMapping: 4,
                UVMapping: 300,
                CubeReflectionMapping: 301,
                CubeRefractionMapping: 302,
                EquirectangularReflectionMapping: 303,
                EquirectangularRefractionMapping: 304,
                SphericalReflectionMapping: 305,
                CubeUVReflectionMapping: 306,
                CubeUVRefractionMapping: 307,
                RepeatWrapping: 1e3,
                ClampToEdgeWrapping: 1001,
                MirroredRepeatWrapping: 1002,
                NearestFilter: 1003,
                NearestMipMapNearestFilter: 1004,
                NearestMipMapLinearFilter: 1005,
                LinearFilter: 1006,
                LinearMipMapNearestFilter: 1007,
                LinearMipMapLinearFilter: 1008,
                UnsignedByteType: 1009,
                ByteType: 1010,
                ShortType: 1011,
                UnsignedShortType: 1012,
                IntType: 1013,
                UnsignedIntType: 1014,
                FloatType: 1015,
                HalfFloatType: 1025,
                UnsignedShort4444Type: 1016,
                UnsignedShort5551Type: 1017,
                UnsignedShort565Type: 1018,
                AlphaFormat: 1019,
                RGBFormat: 1020,
                RGBAFormat: 1021,
                LuminanceFormat: 1022,
                LuminanceAlphaFormat: 1023,
                RGBEFormat: THREE.RGBAFormat,
                DepthFormat: 1026,
                RGB_S3TC_DXT1_Format: 2001,
                RGBA_S3TC_DXT1_Format: 2002,
                RGBA_S3TC_DXT3_Format: 2003,
                RGBA_S3TC_DXT5_Format: 2004,
                RGB_PVRTC_4BPPV1_Format: 2100,
                RGB_PVRTC_2BPPV1_Format: 2101,
                RGBA_PVRTC_4BPPV1_Format: 2102,
                RGBA_PVRTC_2BPPV1_Format: 2103,
                RGB_ETC1_Format: 2151,
                LoopOnce: 2200,
                LoopRepeat: 2201,
                LoopPingPong: 2202,
                InterpolateDiscrete: 2300,
                InterpolateLinear: 2301,
                InterpolateSmooth: 2302,
                ZeroCurvatureEnding: 2400,
                ZeroSlopeEnding: 2401,
                WrapAroundEnding: 2402,
                TrianglesDrawMode: 0,
                TriangleStripDrawMode: 1,
                TriangleFanDrawMode: 2,
                LinearEncoding: 3e3,
                sRGBEncoding: 3001,
                GammaEncoding: 3007,
                RGBEEncoding: 3002,
                LogLuvEncoding: 3003,
                RGBM7Encoding: 3004,
                RGBM16Encoding: 3005,
                RGBDEncoding: 3006,
                BasicDepthPacking: 3200,
                RGBADepthPacking: 3201
            }),
            THREE.Color = function(r, g, b) {
                return void 0 === g && void 0 === b ? this.set(r) : this.setRGB(r, g, b)
            }
            ,
            THREE.Color.prototype = {
                constructor: THREE.Color,
                r: 1,
                g: 1,
                b: 1,
                set: function(value) {
                    return value instanceof THREE.Color ? this.copy(value) : "number" == typeof value ? this.setHex(value) : "string" == typeof value && this.setStyle(value),
                        this
                },
                setScalar: function(scalar) {
                    this.r = scalar,
                        this.g = scalar,
                        this.b = scalar
                },
                setHex: function(hex) {
                    return hex = Math.floor(hex),
                        this.r = (hex >> 16 & 255) / 255,
                        this.g = (hex >> 8 & 255) / 255,
                        this.b = (255 & hex) / 255,
                        this
                },
                setRGB: function(r, g, b) {
                    return this.r = r,
                        this.g = g,
                        this.b = b,
                        this
                },
                setHSL: function() {
                    function hue2rgb(p, q, t) {
                        return t < 0 && (t += 1),
                        t > 1 && (t -= 1),
                            t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + 6 * (q - p) * (2 / 3 - t) : p
                    }
                    return function(h, s, l) {
                        if (h = THREE.Math.euclideanModulo(h, 1),
                                s = THREE.Math.clamp(s, 0, 1),
                                l = THREE.Math.clamp(l, 0, 1),
                            0 === s)
                            this.r = this.g = this.b = l;
                        else {
                            var p = l <= .5 ? l * (1 + s) : l + s - l * s
                                , q = 2 * l - p;
                            this.r = hue2rgb(q, p, h + 1 / 3),
                                this.g = hue2rgb(q, p, h),
                                this.b = hue2rgb(q, p, h - 1 / 3)
                        }
                        return this
                    }
                }(),
                setStyle: function(style) {
                    function handleAlpha(string) {
                        void 0 !== string && parseFloat(string) < 1 && console.warn("THREE.Color: Alpha component of " + style + " will be ignored.")
                    }
                    var m;
                    if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
                        var color, name = m[1], components = m[2];
                        switch (name) {
                            case "rgb":
                            case "rgba":
                                if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components))
                                    return this.r = Math.min(255, parseInt(color[1], 10)) / 255,
                                        this.g = Math.min(255, parseInt(color[2], 10)) / 255,
                                        this.b = Math.min(255, parseInt(color[3], 10)) / 255,
                                        handleAlpha(color[5]),
                                        this;
                                if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components))
                                    return this.r = Math.min(100, parseInt(color[1], 10)) / 100,
                                        this.g = Math.min(100, parseInt(color[2], 10)) / 100,
                                        this.b = Math.min(100, parseInt(color[3], 10)) / 100,
                                        handleAlpha(color[5]),
                                        this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                                    var h = parseFloat(color[1]) / 360
                                        , s = parseInt(color[2], 10) / 100
                                        , l = parseInt(color[3], 10) / 100;
                                    return handleAlpha(color[5]),
                                        this.setHSL(h, s, l)
                                }
                        }
                    } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
                        var hex = m[1]
                            , size = hex.length;
                        if (3 === size)
                            return this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255,
                                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255,
                                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255,
                                this;
                        if (6 === size)
                            return this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255,
                                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255,
                                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255,
                                this
                    }
                    if (style && style.length > 0) {
                        var hex = THREE.ColorKeywords[style];
                        void 0 !== hex ? this.setHex(hex) : console.warn("THREE.Color: Unknown color " + style)
                    }
                    return this
                },
                clone: function() {
                    return new this.constructor(this.r,this.g,this.b)
                },
                copy: function(color) {
                    return this.r = color.r,
                        this.g = color.g,
                        this.b = color.b,
                        this
                },
                copyGammaToLinear: function(color, gammaFactor) {
                    return void 0 === gammaFactor && (gammaFactor = 2),
                        this.r = Math.pow(color.r, gammaFactor),
                        this.g = Math.pow(color.g, gammaFactor),
                        this.b = Math.pow(color.b, gammaFactor),
                        this
                },
                copyLinearToGamma: function(color, gammaFactor) {
                    void 0 === gammaFactor && (gammaFactor = 2);
                    var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
                    return this.r = Math.pow(color.r, safeInverse),
                        this.g = Math.pow(color.g, safeInverse),
                        this.b = Math.pow(color.b, safeInverse),
                        this
                },
                convertGammaToLinear: function() {
                    var r = this.r
                        , g = this.g
                        , b = this.b;
                    return this.r = r * r,
                        this.g = g * g,
                        this.b = b * b,
                        this
                },
                convertLinearToGamma: function() {
                    return this.r = Math.sqrt(this.r),
                        this.g = Math.sqrt(this.g),
                        this.b = Math.sqrt(this.b),
                        this
                },
                getHex: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(optionalTarget) {
                    var hue, saturation, hsl = optionalTarget || {
                            h: 0,
                            s: 0,
                            l: 0
                        }, r = this.r, g = this.g, b = this.b, max = Math.max(r, g, b), min = Math.min(r, g, b), lightness = (min + max) / 2;
                    if (min === max)
                        hue = 0,
                            saturation = 0;
                    else {
                        var delta = max - min;
                        switch (saturation = lightness <= .5 ? delta / (max + min) : delta / (2 - max - min),
                            max) {
                            case r:
                                hue = (g - b) / delta + (g < b ? 6 : 0);
                                break;
                            case g:
                                hue = (b - r) / delta + 2;
                                break;
                            case b:
                                hue = (r - g) / delta + 4
                        }
                        hue /= 6
                    }
                    return hsl.h = hue,
                        hsl.s = saturation,
                        hsl.l = lightness,
                        hsl
                },
                getStyle: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function(h, s, l) {
                    var hsl = this.getHSL();
                    return hsl.h += h,
                        hsl.s += s,
                        hsl.l += l,
                        this.setHSL(hsl.h, hsl.s, hsl.l),
                        this
                },
                add: function(color) {
                    return this.r += color.r,
                        this.g += color.g,
                        this.b += color.b,
                        this
                },
                addColors: function(color1, color2) {
                    return this.r = color1.r + color2.r,
                        this.g = color1.g + color2.g,
                        this.b = color1.b + color2.b,
                        this
                },
                addScalar: function(s) {
                    return this.r += s,
                        this.g += s,
                        this.b += s,
                        this
                },
                multiply: function(color) {
                    return this.r *= color.r,
                        this.g *= color.g,
                        this.b *= color.b,
                        this
                },
                multiplyScalar: function(s) {
                    return this.r *= s,
                        this.g *= s,
                        this.b *= s,
                        this
                },
                lerp: function(color, alpha) {
                    return this.r += (color.r - this.r) * alpha,
                        this.g += (color.g - this.g) * alpha,
                        this.b += (color.b - this.b) * alpha,
                        this
                },
                equals: function(c) {
                    return c.r === this.r && c.g === this.g && c.b === this.b
                },
                fromArray: function(array, offset) {
                    return void 0 === offset && (offset = 0),
                        this.r = array[offset],
                        this.g = array[offset + 1],
                        this.b = array[offset + 2],
                        this
                },
                toArray: function(array, offset) {
                    return void 0 === array && (array = []),
                    void 0 === offset && (offset = 0),
                        array[offset] = this.r,
                        array[offset + 1] = this.g,
                        array[offset + 2] = this.b,
                        array
                }
            },
            THREE.ColorKeywords = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            THREE.Quaternion = function(x, y, z, w) {
                this._x = x || 0,
                    this._y = y || 0,
                    this._z = z || 0,
                    this._w = void 0 !== w ? w : 1
            }
            ,
            THREE.Quaternion.prototype = {
                constructor: THREE.Quaternion,
                get x() {
                    return this._x
                },
                set x(value) {
                    this._x = value,
                        this.onChangeCallback()
                },
                get y() {
                    return this._y
                },
                set y(value) {
                    this._y = value,
                        this.onChangeCallback()
                },
                get z() {
                    return this._z
                },
                set z(value) {
                    this._z = value,
                        this.onChangeCallback()
                },
                get w() {
                    return this._w
                },
                set w(value) {
                    this._w = value,
                        this.onChangeCallback()
                },
                set: function(x, y, z, w) {
                    return this._x = x,
                        this._y = y,
                        this._z = z,
                        this._w = w,
                        this.onChangeCallback(),
                        this
                },
                clone: function() {
                    return new this.constructor(this._x,this._y,this._z,this._w)
                },
                copy: function(quaternion) {
                    return this._x = quaternion.x,
                        this._y = quaternion.y,
                        this._z = quaternion.z,
                        this._w = quaternion.w,
                        this.onChangeCallback(),
                        this
                },
                setFromEuler: function(euler, update) {
                    if (euler instanceof THREE.Euler == !1)
                        throw new Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var c1 = Math.cos(euler._x / 2)
                        , c2 = Math.cos(euler._y / 2)
                        , c3 = Math.cos(euler._z / 2)
                        , s1 = Math.sin(euler._x / 2)
                        , s2 = Math.sin(euler._y / 2)
                        , s3 = Math.sin(euler._z / 2)
                        , order = euler.order;
                    return "XYZ" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3,
                        this._y = c1 * s2 * c3 - s1 * c2 * s3,
                        this._z = c1 * c2 * s3 + s1 * s2 * c3,
                        this._w = c1 * c2 * c3 - s1 * s2 * s3) : "YXZ" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3,
                        this._y = c1 * s2 * c3 - s1 * c2 * s3,
                        this._z = c1 * c2 * s3 - s1 * s2 * c3,
                        this._w = c1 * c2 * c3 + s1 * s2 * s3) : "ZXY" === order ? (this._x = s1 * c2 * c3 - c1 * s2 * s3,
                        this._y = c1 * s2 * c3 + s1 * c2 * s3,
                        this._z = c1 * c2 * s3 + s1 * s2 * c3,
                        this._w = c1 * c2 * c3 - s1 * s2 * s3) : "ZYX" === order ? (this._x = s1 * c2 * c3 - c1 * s2 * s3,
                        this._y = c1 * s2 * c3 + s1 * c2 * s3,
                        this._z = c1 * c2 * s3 - s1 * s2 * c3,
                        this._w = c1 * c2 * c3 + s1 * s2 * s3) : "YZX" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3,
                        this._y = c1 * s2 * c3 + s1 * c2 * s3,
                        this._z = c1 * c2 * s3 - s1 * s2 * c3,
                        this._w = c1 * c2 * c3 - s1 * s2 * s3) : "XZY" === order && (this._x = s1 * c2 * c3 - c1 * s2 * s3,
                        this._y = c1 * s2 * c3 - s1 * c2 * s3,
                        this._z = c1 * c2 * s3 + s1 * s2 * c3,
                        this._w = c1 * c2 * c3 + s1 * s2 * s3),
                    update !== !1 && this.onChangeCallback(),
                        this
                },
                setFromAxisAngle: function(axis, angle) {
                    var halfAngle = angle / 2
                        , s = Math.sin(halfAngle);
                    return this._x = axis.x * s,
                        this._y = axis.y * s,
                        this._z = axis.z * s,
                        this._w = Math.cos(halfAngle),
                        this.onChangeCallback(),
                        this
                },
                setFromRotationMatrix: function(m) {
                    var s, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
                    return trace > 0 ? (s = .5 / Math.sqrt(trace + 1),
                        this._w = .25 / s,
                        this._x = (m32 - m23) * s,
                        this._y = (m13 - m31) * s,
                        this._z = (m21 - m12) * s) : m11 > m22 && m11 > m33 ? (s = 2 * Math.sqrt(1 + m11 - m22 - m33),
                        this._w = (m32 - m23) / s,
                        this._x = .25 * s,
                        this._y = (m12 + m21) / s,
                        this._z = (m13 + m31) / s) : m22 > m33 ? (s = 2 * Math.sqrt(1 + m22 - m11 - m33),
                        this._w = (m13 - m31) / s,
                        this._x = (m12 + m21) / s,
                        this._y = .25 * s,
                        this._z = (m23 + m32) / s) : (s = 2 * Math.sqrt(1 + m33 - m11 - m22),
                        this._w = (m21 - m12) / s,
                        this._x = (m13 + m31) / s,
                        this._y = (m23 + m32) / s,
                        this._z = .25 * s),
                        this.onChangeCallback(),
                        this
                },
                setFromUnitVectors: function() {
                    var v1, r, EPS = 1e-6;
                    return function(vFrom, vTo) {
                        return void 0 === v1 && (v1 = new THREE.Vector3),
                            r = vFrom.dot(vTo) + 1,
                            r < EPS ? (r = 0,
                                Math.abs(vFrom.x) > Math.abs(vFrom.z) ? v1.set(-vFrom.y, vFrom.x, 0) : v1.set(0, -vFrom.z, vFrom.y)) : v1.crossVectors(vFrom, vTo),
                            this._x = v1.x,
                            this._y = v1.y,
                            this._z = v1.z,
                            this._w = r,
                            this.normalize()
                    }
                }(),
                inverse: function() {
                    return this.conjugate().normalize()
                },
                conjugate: function() {
                    return this._x *= -1,
                        this._y *= -1,
                        this._z *= -1,
                        this.onChangeCallback(),
                        this
                },
                dot: function(v) {
                    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var l = this.length();
                    return 0 === l ? (this._x = 0,
                        this._y = 0,
                        this._z = 0,
                        this._w = 1) : (l = 1 / l,
                        this._x = this._x * l,
                        this._y = this._y * l,
                        this._z = this._z * l,
                        this._w = this._w * l),
                        this.onChangeCallback(),
                        this
                },
                multiply: function(q, p) {
                    return void 0 !== p ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
                        this.multiplyQuaternions(q, p)) : this.multiplyQuaternions(this, q)
                },
                premultiply: function(q) {
                    return this.multiplyQuaternions(q, this)
                },
                multiplyQuaternions: function(a, b) {
                    var qax = a._x
                        , qay = a._y
                        , qaz = a._z
                        , qaw = a._w
                        , qbx = b._x
                        , qby = b._y
                        , qbz = b._z
                        , qbw = b._w;
                    return this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby,
                        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz,
                        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx,
                        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz,
                        this.onChangeCallback(),
                        this
                },
                slerp: function(qb, t) {
                    if (0 === t)
                        return this;
                    if (1 === t)
                        return this.copy(qb);
                    var x = this._x
                        , y = this._y
                        , z = this._z
                        , w = this._w
                        , cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
                    if (cosHalfTheta < 0 ? (this._w = -qb._w,
                            this._x = -qb._x,
                            this._y = -qb._y,
                            this._z = -qb._z,
                            cosHalfTheta = -cosHalfTheta) : this.copy(qb),
                        cosHalfTheta >= 1)
                        return this._w = w,
                            this._x = x,
                            this._y = y,
                            this._z = z,
                            this;
                    var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
                    if (Math.abs(sinHalfTheta) < .001)
                        return this._w = .5 * (w + this._w),
                            this._x = .5 * (x + this._x),
                            this._y = .5 * (y + this._y),
                            this._z = .5 * (z + this._z),
                            this;
                    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta)
                        , ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta
                        , ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
                    return this._w = w * ratioA + this._w * ratioB,
                        this._x = x * ratioA + this._x * ratioB,
                        this._y = y * ratioA + this._y * ratioB,
                        this._z = z * ratioA + this._z * ratioB,
                        this.onChangeCallback(),
                        this
                },
                equals: function(quaternion) {
                    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w
                },
                fromArray: function(array, offset) {
                    return void 0 === offset && (offset = 0),
                        this._x = array[offset],
                        this._y = array[offset + 1],
                        this._z = array[offset + 2],
                        this._w = array[offset + 3],
                        this.onChangeCallback(),
                        this
                },
                toArray: function(array, offset) {
                    return void 0 === array && (array = []),
                    void 0 === offset && (offset = 0),
                        array[offset] = this._x,
                        array[offset + 1] = this._y,
                        array[offset + 2] = this._z,
                        array[offset + 3] = this._w,
                        array
                },
                onChange: function(callback) {
                    return this.onChangeCallback = callback,
                        this
                },
                onChangeCallback: function() {}
            },
            Object.assign(THREE.Quaternion, {
                slerp: function(qa, qb, qm, t) {
                    return qm.copy(qa).slerp(qb, t)
                },
                slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
                    var x0 = src0[srcOffset0 + 0]
                        , y0 = src0[srcOffset0 + 1]
                        , z0 = src0[srcOffset0 + 2]
                        , w0 = src0[srcOffset0 + 3]
                        , x1 = src1[srcOffset1 + 0]
                        , y1 = src1[srcOffset1 + 1]
                        , z1 = src1[srcOffset1 + 2]
                        , w1 = src1[srcOffset1 + 3];
                    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                        var s = 1 - t
                            , cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1
                            , dir = cos >= 0 ? 1 : -1
                            , sqrSin = 1 - cos * cos;
                        if (sqrSin > Number.EPSILON) {
                            var sin = Math.sqrt(sqrSin)
                                , len = Math.atan2(sin, cos * dir);
                            s = Math.sin(s * len) / sin,
                                t = Math.sin(t * len) / sin
                        }
                        var tDir = t * dir;
                        if (x0 = x0 * s + x1 * tDir,
                                y0 = y0 * s + y1 * tDir,
                                z0 = z0 * s + z1 * tDir,
                                w0 = w0 * s + w1 * tDir,
                            s === 1 - t) {
                            var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                            x0 *= f,
                                y0 *= f,
                                z0 *= f,
                                w0 *= f
                        }
                    }
                    dst[dstOffset] = x0,
                        dst[dstOffset + 1] = y0,
                        dst[dstOffset + 2] = z0,
                        dst[dstOffset + 3] = w0
                }
            }),
            THREE.Vector2 = function(x, y) {
                this.x = x || 0,
                    this.y = y || 0
            }
            ,
            THREE.Vector2.prototype = {
                constructor: THREE.Vector2,
                get width() {
                    return this.x
                },
                set width(value) {
                    this.x = value
                },
                get height() {
                    return this.y
                },
                set height(value) {
                    this.y = value
                },
                set: function(x, y) {
                    return this.x = x,
                        this.y = y,
                        this
                },
                setScalar: function(scalar) {
                    return this.x = scalar,
                        this.y = scalar,
                        this
                },
                setX: function(x) {
                    return this.x = x,
                        this
                },
                setY: function(y) {
                    return this.y = y,
                        this
                },
                setComponent: function(index, value) {
                    switch (index) {
                        case 0:
                            this.x = value;
                            break;
                        case 1:
                            this.y = value;
                            break;
                        default:
                            throw new Error("index is out of range: " + index)
                    }
                },
                getComponent: function(index) {
                    switch (index) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + index)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x,this.y)
                },
                copy: function(v) {
                    return this.x = v.x,
                        this.y = v.y,
                        this
                },
                add: function(v, w) {
                    return void 0 !== w ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                        this.addVectors(v, w)) : (this.x += v.x,
                        this.y += v.y,
                        this)
                },
                addScalar: function(s) {
                    return this.x += s,
                        this.y += s,
                        this
                },
                addVectors: function(a, b) {
                    return this.x = a.x + b.x,
                        this.y = a.y + b.y,
                        this
                },
                addScaledVector: function(v, s) {
                    return this.x += v.x * s,
                        this.y += v.y * s,
                        this
                },
                sub: function(v, w) {
                    return void 0 !== w ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                        this.subVectors(v, w)) : (this.x -= v.x,
                        this.y -= v.y,
                        this)
                },
                subScalar: function(s) {
                    return this.x -= s,
                        this.y -= s,
                        this
                },
                subVectors: function(a, b) {
                    return this.x = a.x - b.x,
                        this.y = a.y - b.y,
                        this
                },
                multiply: function(v) {
                    return this.x *= v.x,
                        this.y *= v.y,
                        this
                },
                multiplyScalar: function(scalar) {
                    return isFinite(scalar) ? (this.x *= scalar,
                        this.y *= scalar) : (this.x = 0,
                        this.y = 0),
                        this
                },
                divide: function(v) {
                    return this.x /= v.x,
                        this.y /= v.y,
                        this
                },
                divideScalar: function(scalar) {
                    return this.multiplyScalar(1 / scalar)
                },
                min: function(v) {
                    return this.x = Math.min(this.x, v.x),
                        this.y = Math.min(this.y, v.y),
                        this
                },
                max: function(v) {
                    return this.x = Math.max(this.x, v.x),
                        this.y = Math.max(this.y, v.y),
                        this
                },
                clamp: function(min, max) {
                    return this.x = Math.max(min.x, Math.min(max.x, this.x)),
                        this.y = Math.max(min.y, Math.min(max.y, this.y)),
                        this
                },
                clampScalar: function() {
                    var min, max;
                    return function(minVal, maxVal) {
                        return void 0 === min && (min = new THREE.Vector2,
                            max = new THREE.Vector2),
                            min.set(minVal, minVal),
                            max.set(maxVal, maxVal),
                            this.clamp(min, max)
                    }
                }(),
                clampLength: function(min, max) {
                    var length = this.length();
                    return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length)
                },
                floor: function() {
                    return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this
                },
                round: function() {
                    return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                        this
                },
                negate: function() {
                    return this.x = -this.x,
                        this.y = -this.y,
                        this
                },
                dot: function(v) {
                    return this.x * v.x + this.y * v.y
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                angle: function() {
                    var angle = Math.atan2(this.y, this.x);
                    return angle < 0 && (angle += 2 * Math.PI),
                        angle
                },
                distanceTo: function(v) {
                    return Math.sqrt(this.distanceToSquared(v))
                },
                distanceToSquared: function(v) {
                    var dx = this.x - v.x
                        , dy = this.y - v.y;
                    return dx * dx + dy * dy
                },
                setLength: function(length) {
                    return this.multiplyScalar(length / this.length())
                },
                lerp: function(v, alpha) {
                    return this.x += (v.x - this.x) * alpha,
                        this.y += (v.y - this.y) * alpha,
                        this
                },
                lerpVectors: function(v1, v2, alpha) {
                    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1)
                },
                equals: function(v) {
                    return v.x === this.x && v.y === this.y
                },
                fromArray: function(array, offset) {
                    return void 0 === offset && (offset = 0),
                        this.x = array[offset],
                        this.y = array[offset + 1],
                        this
                },
                toArray: function(array, offset) {
                    return void 0 === array && (array = []),
                    void 0 === offset && (offset = 0),
                        array[offset] = this.x,
                        array[offset + 1] = this.y,
                        array
                },
                fromAttribute: function(attribute, index, offset) {
                    return void 0 === offset && (offset = 0),
                        index = index * attribute.itemSize + offset,
                        this.x = attribute.array[index],
                        this.y = attribute.array[index + 1],
                        this
                },
                rotateAround: function(center, angle) {
                    var c = Math.cos(angle)
                        , s = Math.sin(angle)
                        , x = this.x - center.x
                        , y = this.y - center.y;
                    return this.x = x * c - y * s + center.x,
                        this.y = x * s + y * c + center.y,
                        this
                }
            },
            THREE.Vector3 = function(x, y, z) {
                this.x = x || 0,
                    this.y = y || 0,
                    this.z = z || 0
            }
            ,
            THREE.Vector3.prototype = {
                constructor: THREE.Vector3,
                set: function(x, y, z) {
                    return this.x = x,
                        this.y = y,
                        this.z = z,
                        this
                },
                setScalar: function(scalar) {
                    return this.x = scalar,
                        this.y = scalar,
                        this.z = scalar,
                        this
                },
                setX: function(x) {
                    return this.x = x,
                        this
                },
                setY: function(y) {
                    return this.y = y,
                        this
                },
                setZ: function(z) {
                    return this.z = z,
                        this
                },
                setComponent: function(index, value) {
                    switch (index) {
                        case 0:
                            this.x = value;
                            break;
                        case 1:
                            this.y = value;
                            break;
                        case 2:
                            this.z = value;
                            break;
                        default:
                            throw new Error("index is out of range: " + index)
                    }
                },
                getComponent: function(index) {
                    switch (index) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + index)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x,this.y,this.z)
                },
                copy: function(v) {
                    return this.x = v.x,
                        this.y = v.y,
                        this.z = v.z,
                        this
                },
                add: function(v, w) {
                    return void 0 !== w ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                        this.addVectors(v, w)) : (this.x += v.x,
                        this.y += v.y,
                        this.z += v.z,
                        this)
                },
                addScalar: function(s) {
                    return this.x += s,
                        this.y += s,
                        this.z += s,
                        this
                },
                addVectors: function(a, b) {
                    return this.x = a.x + b.x,
                        this.y = a.y + b.y,
                        this.z = a.z + b.z,
                        this
                },
                addScaledVector: function(v, s) {
                    return this.x += v.x * s,
                        this.y += v.y * s,
                        this.z += v.z * s,
                        this
                },
                sub: function(v, w) {
                    return void 0 !== w ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                        this.subVectors(v, w)) : (this.x -= v.x,
                        this.y -= v.y,
                        this.z -= v.z,
                        this)
                },
                subScalar: function(s) {
                    return this.x -= s,
                        this.y -= s,
                        this.z -= s,
                        this
                },
                subVectors: function(a, b) {
                    return this.x = a.x - b.x,
                        this.y = a.y - b.y,
                        this.z = a.z - b.z,
                        this
                },
                multiply: function(v, w) {
                    return void 0 !== w ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
                        this.multiplyVectors(v, w)) : (this.x *= v.x,
                        this.y *= v.y,
                        this.z *= v.z,
                        this)
                },
                multiplyScalar: function(scalar) {
                    return isFinite(scalar) ? (this.x *= scalar,
                        this.y *= scalar,
                        this.z *= scalar) : (this.x = 0,
                        this.y = 0,
                        this.z = 0),
                        this
                },
                multiplyVectors: function(a, b) {
                    return this.x = a.x * b.x,
                        this.y = a.y * b.y,
                        this.z = a.z * b.z,
                        this
                },
                applyEuler: function() {
                    var quaternion;
                    return function(euler) {
                        return euler instanceof THREE.Euler == !1 && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                        void 0 === quaternion && (quaternion = new THREE.Quaternion),
                            this.applyQuaternion(quaternion.setFromEuler(euler))
                    }
                }(),
                applyAxisAngle: function() {
                    var quaternion;
                    return function(axis, angle) {
                        return void 0 === quaternion && (quaternion = new THREE.Quaternion),
                            this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle))
                    }
                }(),
                applyMatrix3: function(m) {
                    var x = this.x
                        , y = this.y
                        , z = this.z
                        , e = m.elements;
                    return this.x = e[0] * x + e[3] * y + e[6] * z,
                        this.y = e[1] * x + e[4] * y + e[7] * z,
                        this.z = e[2] * x + e[5] * y + e[8] * z,
                        this
                },
                applyMatrix4: function(m) {
                    var x = this.x
                        , y = this.y
                        , z = this.z
                        , e = m.elements;
                    return this.x = e[0] * x + e[4] * y + e[8] * z + e[12],
                        this.y = e[1] * x + e[5] * y + e[9] * z + e[13],
                        this.z = e[2] * x + e[6] * y + e[10] * z + e[14],
                        this
                },
                applyProjection: function(m) {
                    var x = this.x
                        , y = this.y
                        , z = this.z
                        , e = m.elements
                        , d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
                    return this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d,
                        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d,
                        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d,
                        this
                },
                applyQuaternion: function(q) {
                    var x = this.x
                        , y = this.y
                        , z = this.z
                        , qx = q.x
                        , qy = q.y
                        , qz = q.z
                        , qw = q.w
                        , ix = qw * x + qy * z - qz * y
                        , iy = qw * y + qz * x - qx * z
                        , iz = qw * z + qx * y - qy * x
                        , iw = -qx * x - qy * y - qz * z;
                    return this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy,
                        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz,
                        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx,
                        this
                },
                project: function() {
                    var matrix;
                    return function(camera) {
                        return void 0 === matrix && (matrix = new THREE.Matrix4),
                            matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld)),
                            this.applyProjection(matrix)
                    }
                }(),
                unproject: function() {
                    var matrix;
                    return function(camera) {
                        return void 0 === matrix && (matrix = new THREE.Matrix4),
                            matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix)),
                            this.applyProjection(matrix)
                    }
                }(),
                transformDirection: function(m) {
                    var x = this.x
                        , y = this.y
                        , z = this.z
                        , e = m.elements;
                    return this.x = e[0] * x + e[4] * y + e[8] * z,
                        this.y = e[1] * x + e[5] * y + e[9] * z,
                        this.z = e[2] * x + e[6] * y + e[10] * z,
                        this.normalize()
                },
                divide: function(v) {
                    return this.x /= v.x,
                        this.y /= v.y,
                        this.z /= v.z,
                        this
                },
                divideScalar: function(scalar) {
                    return this.multiplyScalar(1 / scalar)
                },
                min: function(v) {
                    return this.x = Math.min(this.x, v.x),
                        this.y = Math.min(this.y, v.y),
                        this.z = Math.min(this.z, v.z),
                        this
                },
                max: function(v) {
                    return this.x = Math.max(this.x, v.x),
                        this.y = Math.max(this.y, v.y),
                        this.z = Math.max(this.z, v.z),
                        this
                },
                clamp: function(min, max) {
                    return this.x = Math.max(min.x, Math.min(max.x, this.x)),
                        this.y = Math.max(min.y, Math.min(max.y, this.y)),
                        this.z = Math.max(min.z, Math.min(max.z, this.z)),
                        this
                },
                clampScalar: function() {
                    var min, max;
                    return function(minVal, maxVal) {
                        return void 0 === min && (min = new THREE.Vector3,
                            max = new THREE.Vector3),
                            min.set(minVal, minVal, minVal),
                            max.set(maxVal, maxVal, maxVal),
                            this.clamp(min, max)
                    }
                }(),
                clampLength: function(min, max) {
                    var length = this.length();
                    return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length)
                },
                floor: function() {
                    return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this
                },
                round: function() {
                    return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                        this
                },
                negate: function() {
                    return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this
                },
                dot: function(v) {
                    return this.x * v.x + this.y * v.y + this.z * v.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                setLength: function(length) {
                    return this.multiplyScalar(length / this.length())
                },
                lerp: function(v, alpha) {
                    return this.x += (v.x - this.x) * alpha,
                        this.y += (v.y - this.y) * alpha,
                        this.z += (v.z - this.z) * alpha,
                        this
                },
                lerpVectors: function(v1, v2, alpha) {
                    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1)
                },
                cross: function(v, w) {
                    if (void 0 !== w)
                        return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
                            this.crossVectors(v, w);
                    var x = this.x
                        , y = this.y
                        , z = this.z;
                    return this.x = y * v.z - z * v.y,
                        this.y = z * v.x - x * v.z,
                        this.z = x * v.y - y * v.x,
                        this
                },
                crossVectors: function(a, b) {
                    var ax = a.x
                        , ay = a.y
                        , az = a.z
                        , bx = b.x
                        , by = b.y
                        , bz = b.z;
                    return this.x = ay * bz - az * by,
                        this.y = az * bx - ax * bz,
                        this.z = ax * by - ay * bx,
                        this
                },
                projectOnVector: function(vector) {
                    var scalar = vector.dot(this) / vector.lengthSq();
                    return this.copy(vector).multiplyScalar(scalar)
                },
                projectOnPlane: function() {
                    var v1;
                    return function(planeNormal) {
                        return void 0 === v1 && (v1 = new THREE.Vector3),
                            v1.copy(this).projectOnVector(planeNormal),
                            this.sub(v1)
                    }
                }(),
                reflect: function() {
                    var v1;
                    return function(normal) {
                        return void 0 === v1 && (v1 = new THREE.Vector3),
                            this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)))
                    }
                }(),
                angleTo: function(v) {
                    var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
                    return Math.acos(THREE.Math.clamp(theta, -1, 1))
                },
                distanceTo: function(v) {
                    return Math.sqrt(this.distanceToSquared(v))
                },
                distanceToSquared: function(v) {
                    var dx = this.x - v.x
                        , dy = this.y - v.y
                        , dz = this.z - v.z;
                    return dx * dx + dy * dy + dz * dz
                },
                setFromSpherical: function(s) {
                    var sinPhiRadius = Math.sin(s.phi) * s.radius;
                    return this.x = sinPhiRadius * Math.sin(s.theta),
                        this.y = Math.cos(s.phi) * s.radius,
                        this.z = sinPhiRadius * Math.cos(s.theta),
                        this
                },
                setFromMatrixPosition: function(m) {
                    return this.setFromMatrixColumn(m, 3)
                },
                setFromMatrixScale: function(m) {
                    var sx = this.setFromMatrixColumn(m, 0).length()
                        , sy = this.setFromMatrixColumn(m, 1).length()
                        , sz = this.setFromMatrixColumn(m, 2).length();
                    return this.x = sx,
                        this.y = sy,
                        this.z = sz,
                        this
                },
                setFromMatrixColumn: function(m, index) {
                    if ("number" == typeof m) {
                        console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
                        var temp = m;
                        m = index,
                            index = temp
                    }
                    return this.fromArray(m.elements, 4 * index)
                },
                equals: function(v) {
                    return v.x === this.x && v.y === this.y && v.z === this.z
                },
                fromArray: function(array, offset) {
                    return void 0 === offset && (offset = 0),
                        this.x = array[offset],
                        this.y = array[offset + 1],
                        this.z = array[offset + 2],
                        this
                },
                toArray: function(array, offset) {
                    return void 0 === array && (array = []),
                    void 0 === offset && (offset = 0),
                        array[offset] = this.x,
                        array[offset + 1] = this.y,
                        array[offset + 2] = this.z,
                        array
                },
                fromAttribute: function(attribute, index, offset) {
                    return void 0 === offset && (offset = 0),
                        index = index * attribute.itemSize + offset,
                        this.x = attribute.array[index],
                        this.y = attribute.array[index + 1],
                        this.z = attribute.array[index + 2],
                        this
                }
            },
            THREE.Vector4 = function(x, y, z, w) {
                this.x = x || 0,
                    this.y = y || 0,
                    this.z = z || 0,
                    this.w = void 0 !== w ? w : 1
            }
            ,
            THREE.Vector4.prototype = {
                constructor: THREE.Vector4,
                set: function(x, y, z, w) {
                    return this.x = x,
                        this.y = y,
                        this.z = z,
                        this.w = w,
                        this
                },
                setScalar: function(scalar) {
                    return this.x = scalar,
                        this.y = scalar,
                        this.z = scalar,
                        this.w = scalar,
                        this
                },
                setX: function(x) {
                    return this.x = x,
                        this
                },
                setY: function(y) {
                    return this.y = y,
                        this
                },
                setZ: function(z) {
                    return this.z = z,
                        this
                },
                setW: function(w) {
                    return this.w = w,
                        this
                },
                setComponent: function(index, value) {
                    switch (index) {
                        case 0:
                            this.x = value;
                            break;
                        case 1:
                            this.y = value;
                            break;
                        case 2:
                            this.z = value;
                            break;
                        case 3:
                            this.w = value;
                            break;
                        default:
                            throw new Error("index is out of range: " + index)
                    }
                },
                getComponent: function(index) {
                    switch (index) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + index)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x,this.y,this.z,this.w)
                },
                copy: function(v) {
                    return this.x = v.x,
                        this.y = v.y,
                        this.z = v.z,
                        this.w = void 0 !== v.w ? v.w : 1,
                        this
                },
                add: function(v, w) {
                    return void 0 !== w ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                        this.addVectors(v, w)) : (this.x += v.x,
                        this.y += v.y,
                        this.z += v.z,
                        this.w += v.w,
                        this)
                },
                addScalar: function(s) {
                    return this.x += s,
                        this.y += s,
                        this.z += s,
                        this.w += s,
                        this
                },
                addVectors: function(a, b) {
                    return this.x = a.x + b.x,
                        this.y = a.y + b.y,
                        this.z = a.z + b.z,
                        this.w = a.w + b.w,
                        this
                },
                addScaledVector: function(v, s) {
                    return this.x += v.x * s,
                        this.y += v.y * s,
                        this.z += v.z * s,
                        this.w += v.w * s,
                        this
                },
                sub: function(v, w) {
                    return void 0 !== w ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                        this.subVectors(v, w)) : (this.x -= v.x,
                        this.y -= v.y,
                        this.z -= v.z,
                        this.w -= v.w,
                        this)
                },
                subScalar: function(s) {
                    return this.x -= s,
                        this.y -= s,
                        this.z -= s,
                        this.w -= s,
                        this
                },
                subVectors: function(a, b) {
                    return this.x = a.x - b.x,
                        this.y = a.y - b.y,
                        this.z = a.z - b.z,
                        this.w = a.w - b.w,
                        this
                },
                multiplyScalar: function(scalar) {
                    return isFinite(scalar) ? (this.x *= scalar,
                        this.y *= scalar,
                        this.z *= scalar,
                        this.w *= scalar) : (this.x = 0,
                        this.y = 0,
                        this.z = 0,
                        this.w = 0),
                        this
                },
                applyMatrix4: function(m) {
                    var x = this.x
                        , y = this.y
                        , z = this.z
                        , w = this.w
                        , e = m.elements;
                    return this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w,
                        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w,
                        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w,
                        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w,
                        this
                },
                divideScalar: function(scalar) {
                    return this.multiplyScalar(1 / scalar)
                },
                setAxisAngleFromQuaternion: function(q) {
                    this.w = 2 * Math.acos(q.w);
                    var s = Math.sqrt(1 - q.w * q.w);
                    return s < 1e-4 ? (this.x = 1,
                        this.y = 0,
                        this.z = 0) : (this.x = q.x / s,
                        this.y = q.y / s,
                        this.z = q.z / s),
                        this
                },
                setAxisAngleFromRotationMatrix: function(m) {
                    var angle, x, y, z, epsilon = .01, epsilon2 = .1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
                    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
                        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2)
                            return this.set(1, 0, 0, 0),
                                this;
                        angle = Math.PI;
                        var xx = (m11 + 1) / 2
                            , yy = (m22 + 1) / 2
                            , zz = (m33 + 1) / 2
                            , xy = (m12 + m21) / 4
                            , xz = (m13 + m31) / 4
                            , yz = (m23 + m32) / 4;
                        return xx > yy && xx > zz ? xx < epsilon ? (x = 0,
                            y = .707106781,
                            z = .707106781) : (x = Math.sqrt(xx),
                            y = xy / x,
                            z = xz / x) : yy > zz ? yy < epsilon ? (x = .707106781,
                            y = 0,
                            z = .707106781) : (y = Math.sqrt(yy),
                            x = xy / y,
                            z = yz / y) : zz < epsilon ? (x = .707106781,
                            y = .707106781,
                            z = 0) : (z = Math.sqrt(zz),
                            x = xz / z,
                            y = yz / z),
                            this.set(x, y, z, angle),
                            this
                    }
                    var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
                    return Math.abs(s) < .001 && (s = 1),
                        this.x = (m32 - m23) / s,
                        this.y = (m13 - m31) / s,
                        this.z = (m21 - m12) / s,
                        this.w = Math.acos((m11 + m22 + m33 - 1) / 2),
                        this
                },
                min: function(v) {
                    return this.x = Math.min(this.x, v.x),
                        this.y = Math.min(this.y, v.y),
                        this.z = Math.min(this.z, v.z),
                        this.w = Math.min(this.w, v.w),
                        this
                },
                max: function(v) {
                    return this.x = Math.max(this.x, v.x),
                        this.y = Math.max(this.y, v.y),
                        this.z = Math.max(this.z, v.z),
                        this.w = Math.max(this.w, v.w),
                        this
                },
                clamp: function(min, max) {
                    return this.x = Math.max(min.x, Math.min(max.x, this.x)),
                        this.y = Math.max(min.y, Math.min(max.y, this.y)),
                        this.z = Math.max(min.z, Math.min(max.z, this.z)),
                        this.w = Math.max(min.w, Math.min(max.w, this.w)),
                        this
                },
                clampScalar: function() {
                    var min, max;
                    return function(minVal, maxVal) {
                        return void 0 === min && (min = new THREE.Vector4,
                            max = new THREE.Vector4),
                            min.set(minVal, minVal, minVal, minVal),
                            max.set(maxVal, maxVal, maxVal, maxVal),
                            this.clamp(min, max)
                    }
                }(),
                floor: function() {
                    return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this.w = Math.floor(this.w),
                        this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this.w = Math.ceil(this.w),
                        this
                },
                round: function() {
                    return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this.w = Math.round(this.w),
                        this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
                        this
                },
                negate: function() {
                    return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this.w = -this.w,
                        this
                },
                dot: function(v) {
                    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                setLength: function(length) {
                    return this.multiplyScalar(length / this.length())
                },
                lerp: function(v, alpha) {
                    return this.x += (v.x - this.x) * alpha,
                        this.y += (v.y - this.y) * alpha,
                        this.z += (v.z - this.z) * alpha,
                        this.w += (v.w - this.w) * alpha,
                        this
                },
                lerpVectors: function(v1, v2, alpha) {
                    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1)
                },
                equals: function(v) {
                    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w
                },
                fromArray: function(array, offset) {
                    return void 0 === offset && (offset = 0),
                        this.x = array[offset],
                        this.y = array[offset + 1],
                        this.z = array[offset + 2],
                        this.w = array[offset + 3],
                        this
                },
                toArray: function(array, offset) {
                    return void 0 === array && (array = []),
                    void 0 === offset && (offset = 0),
                        array[offset] = this.x,
                        array[offset + 1] = this.y,
                        array[offset + 2] = this.z,
                        array[offset + 3] = this.w,
                        array
                },
                fromAttribute: function(attribute, index, offset) {
                    return void 0 === offset && (offset = 0),
                        index = index * attribute.itemSize + offset,
                        this.x = attribute.array[index],
                        this.y = attribute.array[index + 1],
                        this.z = attribute.array[index + 2],
                        this.w = attribute.array[index + 3],
                        this
                }
            },
            THREE.Euler = function(x, y, z, order) {
                this._x = x || 0,
                    this._y = y || 0,
                    this._z = z || 0,
                    this._order = order || THREE.Euler.DefaultOrder
            }
            ,
            THREE.Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
            THREE.Euler.DefaultOrder = "XYZ",
            THREE.Euler.prototype = {
                constructor: THREE.Euler,
                get x() {
                    return this._x
                },
                set x(value) {
                    this._x = value,
                        this.onChangeCallback()
                },
                get y() {
                    return this._y
                },
                set y(value) {
                    this._y = value,
                        this.onChangeCallback()
                },
                get z() {
                    return this._z
                },
                set z(value) {
                    this._z = value,
                        this.onChangeCallback()
                },
                get order() {
                    return this._order
                },
                set order(value) {
                    this._order = value,
                        this.onChangeCallback()
                },
                set: function(x, y, z, order) {
                    return this._x = x,
                        this._y = y,
                        this._z = z,
                        this._order = order || this._order,
                        this.onChangeCallback(),
                        this
                },
                clone: function() {
                    return new this.constructor(this._x,this._y,this._z,this._order)
                },
                copy: function(euler) {
                    return this._x = euler._x,
                        this._y = euler._y,
                        this._z = euler._z,
                        this._order = euler._order,
                        this.onChangeCallback(),
                        this
                },
                setFromRotationMatrix: function(m, order, update) {
                    var clamp = THREE.Math.clamp
                        , te = m.elements
                        , m11 = te[0]
                        , m12 = te[4]
                        , m13 = te[8]
                        , m21 = te[1]
                        , m22 = te[5]
                        , m23 = te[9]
                        , m31 = te[2]
                        , m32 = te[6]
                        , m33 = te[10];
                    return order = order || this._order,
                        "XYZ" === order ? (this._y = Math.asin(clamp(m13, -1, 1)),
                            Math.abs(m13) < .99999 ? (this._x = Math.atan2(-m23, m33),
                                this._z = Math.atan2(-m12, m11)) : (this._x = Math.atan2(m32, m22),
                                this._z = 0)) : "YXZ" === order ? (this._x = Math.asin(-clamp(m23, -1, 1)),
                            Math.abs(m23) < .99999 ? (this._y = Math.atan2(m13, m33),
                                this._z = Math.atan2(m21, m22)) : (this._y = Math.atan2(-m31, m11),
                                this._z = 0)) : "ZXY" === order ? (this._x = Math.asin(clamp(m32, -1, 1)),
                            Math.abs(m32) < .99999 ? (this._y = Math.atan2(-m31, m33),
                                this._z = Math.atan2(-m12, m22)) : (this._y = 0,
                                this._z = Math.atan2(m21, m11))) : "ZYX" === order ? (this._y = Math.asin(-clamp(m31, -1, 1)),
                            Math.abs(m31) < .99999 ? (this._x = Math.atan2(m32, m33),
                                this._z = Math.atan2(m21, m11)) : (this._x = 0,
                                this._z = Math.atan2(-m12, m22))) : "YZX" === order ? (this._z = Math.asin(clamp(m21, -1, 1)),
                            Math.abs(m21) < .99999 ? (this._x = Math.atan2(-m23, m22),
                                this._y = Math.atan2(-m31, m11)) : (this._x = 0,
                                this._y = Math.atan2(m13, m33))) : "XZY" === order ? (this._z = Math.asin(-clamp(m12, -1, 1)),
                            Math.abs(m12) < .99999 ? (this._x = Math.atan2(m32, m22),
                                this._y = Math.atan2(m13, m11)) : (this._x = Math.atan2(-m23, m33),
                                this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order),
                        this._order = order,
                    update !== !1 && this.onChangeCallback(),
                        this
                },
                setFromQuaternion: function() {
                    var matrix;
                    return function(q, order, update) {
                        return void 0 === matrix && (matrix = new THREE.Matrix4),
                            matrix.makeRotationFromQuaternion(q),
                            this.setFromRotationMatrix(matrix, order, update)
                    }
                }(),
                setFromVector3: function(v, order) {
                    return this.set(v.x, v.y, v.z, order || this._order)
                },
                reorder: function() {
                    var q = new THREE.Quaternion;
                    return function(newOrder) {
                        return q.setFromEuler(this),
                            this.setFromQuaternion(q, newOrder)
                    }
                }(),
                equals: function(euler) {
                    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order
                },
                fromArray: function(array) {
                    return this._x = array[0],
                        this._y = array[1],
                        this._z = array[2],
                    void 0 !== array[3] && (this._order = array[3]),
                        this.onChangeCallback(),
                        this
                },
                toArray: function(array, offset) {
                    return void 0 === array && (array = []),
                    void 0 === offset && (offset = 0),
                        array[offset] = this._x,
                        array[offset + 1] = this._y,
                        array[offset + 2] = this._z,
                        array[offset + 3] = this._order,
                        array
                },
                toVector3: function(optionalResult) {
                    return optionalResult ? optionalResult.set(this._x, this._y, this._z) : new THREE.Vector3(this._x,this._y,this._z)
                },
                onChange: function(callback) {
                    return this.onChangeCallback = callback,
                        this
                },
                onChangeCallback: function() {}
            },
            THREE.Line3 = function(start, end) {
                this.start = void 0 !== start ? start : new THREE.Vector3,
                    this.end = void 0 !== end ? end : new THREE.Vector3
            }
            ,
            THREE.Line3.prototype = {
                constructor: THREE.Line3,
                set: function(start, end) {
                    return this.start.copy(start),
                        this.end.copy(end),
                        this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(line) {
                    return this.start.copy(line.start),
                        this.end.copy(line.end),
                        this
                },
                center: function(optionalTarget) {
                    var result = optionalTarget || new THREE.Vector3;
                    return result.addVectors(this.start, this.end).multiplyScalar(.5)
                },
                delta: function(optionalTarget) {
                    var result = optionalTarget || new THREE.Vector3;
                    return result.subVectors(this.end, this.start)
                },
                distanceSq: function() {
                    return this.start.distanceToSquared(this.end)
                },
                distance: function() {
                    return this.start.distanceTo(this.end)
                },
                at: function(t, optionalTarget) {
                    var result = optionalTarget || new THREE.Vector3;
                    return this.delta(result).multiplyScalar(t).add(this.start)
                },
                closestPointToPointParameter: function() {
                    var startP = new THREE.Vector3
                        , startEnd = new THREE.Vector3;
                    return function(point, clampToLine) {
                        startP.subVectors(point, this.start),
                            startEnd.subVectors(this.end, this.start);
                        var startEnd2 = startEnd.dot(startEnd)
                            , startEnd_startP = startEnd.dot(startP)
                            , t = startEnd_startP / startEnd2;
                        return clampToLine && (t = THREE.Math.clamp(t, 0, 1)),
                            t
                    }
                }(),
                closestPointToPoint: function(point, clampToLine, optionalTarget) {
                    var t = this.closestPointToPointParameter(point, clampToLine)
                        , result = optionalTarget || new THREE.Vector3;
                    return this.delta(result).multiplyScalar(t).add(this.start)
                },
                applyMatrix4: function(matrix) {
                    return this.start.applyMatrix4(matrix),
                        this.end.applyMatrix4(matrix),
                        this
                },
                equals: function(line) {
                    return line.start.equals(this.start) && line.end.equals(this.end)
                }
            },
            THREE.Box2 = function(min, max) {
                this.min = void 0 !== min ? min : new THREE.Vector2(+(1 / 0),+(1 / 0)),
                    this.max = void 0 !== max ? max : new THREE.Vector2(-(1 / 0),-(1 / 0))
            }
            ,
            THREE.Box2.prototype = {
                constructor: THREE.Box2,
                set: function(min, max) {
                    return this.min.copy(min),
                        this.max.copy(max),
                        this
                },
                setFromPoints: function(points) {
                    this.makeEmpty();
                    for (var i = 0, il = points.length; i < il; i++)
                        this.expandByPoint(points[i]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var v1 = new THREE.Vector2;
                    return function(center, size) {
                        var halfSize = v1.copy(size).multiplyScalar(.5);
                        return this.min.copy(center).sub(halfSize),
                            this.max.copy(center).add(halfSize),
                            this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(box) {
                    return this.min.copy(box.min),
                        this.max.copy(box.max),
                        this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = +(1 / 0),
                        this.max.x = this.max.y = -(1 / 0),
                        this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                },
                center: function(optionalTarget) {
                    var result = optionalTarget || new THREE.Vector2;
                    return result.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                size: function(optionalTarget) {
                    var result = optionalTarget || new THREE.Vector2;
                    return result.subVectors(this.max, this.min)
                },
                expandByPoint: function(point) {
                    return this.min.min(point),
                        this.max.max(point),
                        this
                },
                expandByVector: function(vector) {
                    return this.min.sub(vector),
                        this.max.add(vector),
                        this
                },
                expandByScalar: function(scalar) {
                    return this.min.addScalar(-scalar),
                        this.max.addScalar(scalar),
                        this
                },
                containsPoint: function(point) {
                    return !(point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y)
                },
                containsBox: function(box) {
                    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y
                },
                getParameter: function(point, optionalTarget) {
                    var result = optionalTarget || new THREE.Vector2;
                    return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y))
                },
                intersectsBox: function(box) {
                    return !(box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y)
                },
                clampPoint: function(point, optionalTarget) {
                    var result = optionalTarget || new THREE.Vector2;
                    return result.copy(point).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var v1 = new THREE.Vector2;
                    return function(point) {
                        var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                        return clampedPoint.sub(point).length()
                    }
                }(),
                intersect: function(box) {
                    return this.min.max(box.min),
                        this.max.min(box.max),
                        this
                },
                union: function(box) {
                    return this.min.min(box.min),
                        this.max.max(box.max),
                        this
                },
                translate: function(offset) {
                    return this.min.add(offset),
                        this.max.add(offset),
                        this
                },
                equals: function(box) {
                    return box.min.equals(this.min) && box.max.equals(this.max)
                }
            },
            THREE.Box3 = function(min, max) {
                this.min = void 0 !== min ? min : new THREE.Vector3(+(1 / 0),+(1 / 0),+(1 / 0)),
                    this.max = void 0 !== max ? max : new THREE.Vector3(-(1 / 0),-(1 / 0),-(1 / 0))
            }
            ,
            THREE.Box3.prototype = {
                constructor: THREE.Box3,
                set: function(min, max) {
                    return this.min.copy(min),
                        this.max.copy(max),
                        this
                },
                setFromArray: function(array) {
                    for (var minX = +(1 / 0), minY = +(1 / 0), minZ = +(1 / 0), maxX = -(1 / 0), maxY = -(1 / 0), maxZ = -(1 / 0), i = 0, l = array.length; i < l; i += 3) {
                        var x = array[i]
                            , y = array[i + 1]
                            , z = array[i + 2];
                        x < minX && (minX = x),
                        y < minY && (minY = y),
                        z < minZ && (minZ = z),
                        x > maxX && (maxX = x),
                        y > maxY && (maxY = y),
                        z > maxZ && (maxZ = z)
                    }
                    this.min.set(minX, minY, minZ),
                        this.max.set(maxX, maxY, maxZ)
                },
                setFromPoints: function(points) {
                    this.makeEmpty();
                    for (var i = 0, il = points.length; i < il; i++)
                        this.expandByPoint(points[i]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var v1 = new THREE.Vector3;
                    return function(center, size) {
                        var halfSize = v1.copy(size).multiplyScalar(.5);
                        return this.min.copy(center).sub(halfSize),
                            this.max.copy(center).add(halfSize),
                            this
                    }
                }(),
                setFromObject: function() {
                    var v1 = new THREE.Vector3;
                    return function(object) {
                        var scope = this;
                        return object.updateMatrixWorld(!0),
                            this.makeEmpty(),
                            object.traverse(function(node) {
                                var geometry = node.geometry;
                                if (void 0 !== geometry)
                                    if (geometry instanceof THREE.Geometry)
                                        for (var vertices = geometry.vertices, i = 0, il = vertices.length; i < il; i++)
                                            v1.copy(vertices[i]),
                                                v1.applyMatrix4(node.matrixWorld),
                                                scope.expandByPoint(v1);
                                    else if (geometry instanceof THREE.BufferGeometry && void 0 !== geometry.attributes.position)
                                        for (var positions = geometry.attributes.position.array, i = 0, il = positions.length; i < il; i += 3)
                                            v1.fromArray(positions, i),
                                                v1.applyMatrix4(node.matrixWorld),
                                                scope.expandByPoint(v1)
                            }),
                            this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(box) {
                    return this.min.copy(box.min),
                        this.max.copy(box.max),
                        this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = this.min.z = +(1 / 0),
                        this.max.x = this.max.y = this.max.z = -(1 / 0),
                        this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                center: function(optionalTarget) {
                    var result = optionalTarget || new THREE.Vector3;
                    return result.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                size: function(optionalTarget) {
                    var result = optionalTarget || new THREE.Vector3;
                    return result.subVectors(this.max, this.min)
                },
                expandByPoint: function(point) {
                    return this.min.min(point),
                        this.max.max(point),
                        this
                },
                expandByVector: function(vector) {
                    return this.min.sub(vector),
                        this.max.add(vector),
                        this
                },
                expandByScalar: function(scalar) {
                    return this.min.addScalar(-scalar),
                        this.max.addScalar(scalar),
                        this
                },
                containsPoint: function(point) {
                    return !(point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z)
                },
                containsBox: function(box) {
                    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z
                },
                getParameter: function(point, optionalTarget) {
                    var result = optionalTarget || new THREE.Vector3;
                    return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function(box) {
                    return !(box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z)
                },
                intersectsSphere: function() {
                    var closestPoint;
                    return function(sphere) {
                        return void 0 === closestPoint && (closestPoint = new THREE.Vector3),
                            this.clampPoint(sphere.center, closestPoint),
                        closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius
                    }
                }(),
                intersectsPlane: function(plane) {
                    var min, max;
                    return plane.normal.x > 0 ? (min = plane.normal.x * this.min.x,
                        max = plane.normal.x * this.max.x) : (min = plane.normal.x * this.max.x,
                        max = plane.normal.x * this.min.x),
                        plane.normal.y > 0 ? (min += plane.normal.y * this.min.y,
                            max += plane.normal.y * this.max.y) : (min += plane.normal.y * this.max.y,
                            max += plane.normal.y * this.min.y),
                        plane.normal.z > 0 ? (min += plane.normal.z * this.min.z,
                            max += plane.normal.z * this.max.z) : (min += plane.normal.z * this.max.z,
                            max += plane.normal.z * this.min.z),
                    min <= plane.constant && max >= plane.constant
                },
                clampPoint: function(point, optionalTarget) {
                    var result = optionalTarget || new THREE.Vector3;
                    return result.copy(point).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var v1 = new THREE.Vector3;
                    return function(point) {
                        var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                        return clampedPoint.sub(point).length()
                    }
                }(),
                getBoundingSphere: function() {
                    var v1 = new THREE.Vector3;
                    return function(optionalTarget) {
                        var result = optionalTarget || new THREE.Sphere;
                        return result.center = this.center(),
                            result.radius = .5 * this.size(v1).length(),
                            result
                    }
                }(),
                intersect: function(box) {
                    return this.min.max(box.min),
                        this.max.min(box.max),
                    this.isEmpty() && this.makeEmpty(),
                        this
                },
                union: function(box) {
                    return this.min.min(box.min),
                        this.max.max(box.max),
                        this
                },
                applyMatrix4: function() {
                    var points = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
                    return function(matrix) {
                        return this.isEmpty() ? this : (points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix),
                            points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix),
                            points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix),
                            points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix),
                            points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix),
                            points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix),
                            points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix),
                            points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix),
                            this.setFromPoints(points),
                            this)
                    }
                }(),
                translate: function(offset) {
                    return this.min.add(offset),
                        this.max.add(offset),
                        this
                },
                equals: function(box) {
                    return box.min.equals(this.min) && box.max.equals(this.max)
                }
            },
            THREE.Matrix3 = function() {
                this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]),
                arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            ,
            THREE.Matrix3.prototype = {
                constructor: THREE.Matrix3,
                set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
                    var te = this.elements;
                    return te[0] = n11,
                        te[1] = n21,
                        te[2] = n31,
                        te[3] = n12,
                        te[4] = n22,
                        te[5] = n32,
                        te[6] = n13,
                        te[7] = n23,
                        te[8] = n33,
                        this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                        this
                },
                clone: function() {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function(m) {
                    var me = m.elements;
                    return this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]),
                        this
                },
                setFromMatrix4: function(m) {
                    var me = m.elements;
                    return this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]),
                        this
                },
                applyToVector3Array: function() {
                    var v1;
                    return function(array, offset, length) {
                        void 0 === v1 && (v1 = new THREE.Vector3),
                        void 0 === offset && (offset = 0),
                        void 0 === length && (length = array.length);
                        for (var i = 0, j = offset; i < length; i += 3,
                            j += 3)
                            v1.fromArray(array, j),
                                v1.applyMatrix3(this),
                                v1.toArray(array, j);
                        return array
                    }
                }(),
                applyToBuffer: function() {
                    var v1;
                    return function(buffer, offset, length) {
                        void 0 === v1 && (v1 = new THREE.Vector3),
                        void 0 === offset && (offset = 0),
                        void 0 === length && (length = buffer.length / buffer.itemSize);
                        for (var i = 0, j = offset; i < length; i++,
                            j++)
                            v1.x = buffer.getX(j),
                                v1.y = buffer.getY(j),
                                v1.z = buffer.getZ(j),
                                v1.applyMatrix3(this),
                                buffer.setXYZ(v1.x, v1.y, v1.z);
                        return buffer
                    }
                }(),
                multiplyScalar: function(s) {
                    var te = this.elements;
                    return te[0] *= s,
                        te[3] *= s,
                        te[6] *= s,
                        te[1] *= s,
                        te[4] *= s,
                        te[7] *= s,
                        te[2] *= s,
                        te[5] *= s,
                        te[8] *= s,
                        this
                },
                determinant: function() {
                    var te = this.elements
                        , a = te[0]
                        , b = te[1]
                        , c = te[2]
                        , d = te[3]
                        , e = te[4]
                        , f = te[5]
                        , g = te[6]
                        , h = te[7]
                        , i = te[8];
                    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g
                },
                getInverse: function(matrix, throwOnDegenerate) {
                    matrix instanceof THREE.Matrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
                    var me = matrix.elements
                        , te = this.elements
                        , n11 = me[0]
                        , n21 = me[1]
                        , n31 = me[2]
                        , n12 = me[3]
                        , n22 = me[4]
                        , n32 = me[5]
                        , n13 = me[6]
                        , n23 = me[7]
                        , n33 = me[8]
                        , t11 = n33 * n22 - n32 * n23
                        , t12 = n32 * n13 - n33 * n12
                        , t13 = n23 * n12 - n22 * n13
                        , det = n11 * t11 + n21 * t12 + n31 * t13;
                    if (0 === det) {
                        var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
                        if (throwOnDegenerate)
                            throw new Error(msg);
                        return console.warn(msg),
                            this.identity()
                    }
                    var detInv = 1 / det;
                    return te[0] = t11 * detInv,
                        te[1] = (n31 * n23 - n33 * n21) * detInv,
                        te[2] = (n32 * n21 - n31 * n22) * detInv,
                        te[3] = t12 * detInv,
                        te[4] = (n33 * n11 - n31 * n13) * detInv,
                        te[5] = (n31 * n12 - n32 * n11) * detInv,
                        te[6] = t13 * detInv,
                        te[7] = (n21 * n13 - n23 * n11) * detInv,
                        te[8] = (n22 * n11 - n21 * n12) * detInv,
                        this
                },
                transpose: function() {
                    var tmp, m = this.elements;
                    return tmp = m[1],
                        m[1] = m[3],
                        m[3] = tmp,
                        tmp = m[2],
                        m[2] = m[6],
                        m[6] = tmp,
                        tmp = m[5],
                        m[5] = m[7],
                        m[7] = tmp,
                        this
                },
                flattenToArrayOffset: function(array, offset) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."),
                        this.toArray(array, offset)
                },
                getNormalMatrix: function(matrix4) {
                    return this.setFromMatrix4(matrix4).getInverse(this).transpose()
                },
                transposeIntoArray: function(r) {
                    var m = this.elements;
                    return r[0] = m[0],
                        r[1] = m[3],
                        r[2] = m[6],
                        r[3] = m[1],
                        r[4] = m[4],
                        r[5] = m[7],
                        r[6] = m[2],
                        r[7] = m[5],
                        r[8] = m[8],
                        this
                },
                fromArray: function(array) {
                    return this.elements.set(array),
                        this
                },
                toArray: function(array, offset) {
                    void 0 === array && (array = []),
                    void 0 === offset && (offset = 0);
                    var te = this.elements;
                    return array[offset] = te[0],
                        array[offset + 1] = te[1],
                        array[offset + 2] = te[2],
                        array[offset + 3] = te[3],
                        array[offset + 4] = te[4],
                        array[offset + 5] = te[5],
                        array[offset + 6] = te[6],
                        array[offset + 7] = te[7],
                        array[offset + 8] = te[8],
                        array
                }
            },
            THREE.Matrix4 = function() {
                this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
                arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            ,
            THREE.Matrix4.prototype = {
                constructor: THREE.Matrix4,
                set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
                    var te = this.elements;
                    return te[0] = n11,
                        te[4] = n12,
                        te[8] = n13,
                        te[12] = n14,
                        te[1] = n21,
                        te[5] = n22,
                        te[9] = n23,
                        te[13] = n24,
                        te[2] = n31,
                        te[6] = n32,
                        te[10] = n33,
                        te[14] = n34,
                        te[3] = n41,
                        te[7] = n42,
                        te[11] = n43,
                        te[15] = n44,
                        this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                },
                clone: function() {
                    return (new THREE.Matrix4).fromArray(this.elements)
                },
                copy: function(m) {
                    return this.elements.set(m.elements),
                        this
                },
                copyPosition: function(m) {
                    var te = this.elements
                        , me = m.elements;
                    return te[12] = me[12],
                        te[13] = me[13],
                        te[14] = me[14],
                        this
                },
                extractBasis: function(xAxis, yAxis, zAxis) {
                    return xAxis.setFromMatrixColumn(this, 0),
                        yAxis.setFromMatrixColumn(this, 1),
                        zAxis.setFromMatrixColumn(this, 2),
                        this
                },
                makeBasis: function(xAxis, yAxis, zAxis) {
                    return this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1),
                        this
                },
                extractRotation: function() {
                    var v1;
                    return function(m) {
                        void 0 === v1 && (v1 = new THREE.Vector3);
                        var te = this.elements
                            , me = m.elements
                            , scaleX = 1 / v1.setFromMatrixColumn(m, 0).length()
                            , scaleY = 1 / v1.setFromMatrixColumn(m, 1).length()
                            , scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
                        return te[0] = me[0] * scaleX,
                            te[1] = me[1] * scaleX,
                            te[2] = me[2] * scaleX,
                            te[4] = me[4] * scaleY,
                            te[5] = me[5] * scaleY,
                            te[6] = me[6] * scaleY,
                            te[8] = me[8] * scaleZ,
                            te[9] = me[9] * scaleZ,
                            te[10] = me[10] * scaleZ,
                            this
                    }
                }(),
                makeRotationFromEuler: function(euler) {
                    euler instanceof THREE.Euler == !1 && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var te = this.elements
                        , x = euler.x
                        , y = euler.y
                        , z = euler.z
                        , a = Math.cos(x)
                        , b = Math.sin(x)
                        , c = Math.cos(y)
                        , d = Math.sin(y)
                        , e = Math.cos(z)
                        , f = Math.sin(z);
                    if ("XYZ" === euler.order) {
                        var ae = a * e
                            , af = a * f
                            , be = b * e
                            , bf = b * f;
                        te[0] = c * e,
                            te[4] = -c * f,
                            te[8] = d,
                            te[1] = af + be * d,
                            te[5] = ae - bf * d,
                            te[9] = -b * c,
                            te[2] = bf - ae * d,
                            te[6] = be + af * d,
                            te[10] = a * c
                    } else if ("YXZ" === euler.order) {
                        var ce = c * e
                            , cf = c * f
                            , de = d * e
                            , df = d * f;
                        te[0] = ce + df * b,
                            te[4] = de * b - cf,
                            te[8] = a * d,
                            te[1] = a * f,
                            te[5] = a * e,
                            te[9] = -b,
                            te[2] = cf * b - de,
                            te[6] = df + ce * b,
                            te[10] = a * c
                    } else if ("ZXY" === euler.order) {
                        var ce = c * e
                            , cf = c * f
                            , de = d * e
                            , df = d * f;
                        te[0] = ce - df * b,
                            te[4] = -a * f,
                            te[8] = de + cf * b,
                            te[1] = cf + de * b,
                            te[5] = a * e,
                            te[9] = df - ce * b,
                            te[2] = -a * d,
                            te[6] = b,
                            te[10] = a * c
                    } else if ("ZYX" === euler.order) {
                        var ae = a * e
                            , af = a * f
                            , be = b * e
                            , bf = b * f;
                        te[0] = c * e,
                            te[4] = be * d - af,
                            te[8] = ae * d + bf,
                            te[1] = c * f,
                            te[5] = bf * d + ae,
                            te[9] = af * d - be,
                            te[2] = -d,
                            te[6] = b * c,
                            te[10] = a * c
                    } else if ("YZX" === euler.order) {
                        var ac = a * c
                            , ad = a * d
                            , bc = b * c
                            , bd = b * d;
                        te[0] = c * e,
                            te[4] = bd - ac * f,
                            te[8] = bc * f + ad,
                            te[1] = f,
                            te[5] = a * e,
                            te[9] = -b * e,
                            te[2] = -d * e,
                            te[6] = ad * f + bc,
                            te[10] = ac - bd * f
                    } else if ("XZY" === euler.order) {
                        var ac = a * c
                            , ad = a * d
                            , bc = b * c
                            , bd = b * d;
                        te[0] = c * e,
                            te[4] = -f,
                            te[8] = d * e,
                            te[1] = ac * f + bd,
                            te[5] = a * e,
                            te[9] = ad * f - bc,
                            te[2] = bc * f - ad,
                            te[6] = b * e,
                            te[10] = bd * f + ac
                    }
                    return te[3] = 0,
                        te[7] = 0,
                        te[11] = 0,
                        te[12] = 0,
                        te[13] = 0,
                        te[14] = 0,
                        te[15] = 1,
                        this
                },
                makeRotationFromQuaternion: function(q) {
                    var te = this.elements
                        , x = q.x
                        , y = q.y
                        , z = q.z
                        , w = q.w
                        , x2 = x + x
                        , y2 = y + y
                        , z2 = z + z
                        , xx = x * x2
                        , xy = x * y2
                        , xz = x * z2
                        , yy = y * y2
                        , yz = y * z2
                        , zz = z * z2
                        , wx = w * x2
                        , wy = w * y2
                        , wz = w * z2;
                    return te[0] = 1 - (yy + zz),
                        te[4] = xy - wz,
                        te[8] = xz + wy,
                        te[1] = xy + wz,
                        te[5] = 1 - (xx + zz),
                        te[9] = yz - wx,
                        te[2] = xz - wy,
                        te[6] = yz + wx,
                        te[10] = 1 - (xx + yy),
                        te[3] = 0,
                        te[7] = 0,
                        te[11] = 0,
                        te[12] = 0,
                        te[13] = 0,
                        te[14] = 0,
                        te[15] = 1,
                        this
                },
                lookAt: function() {
                    var x, y, z;
                    return function(eye, target, up) {
                        void 0 === x && (x = new THREE.Vector3,
                            y = new THREE.Vector3,
                            z = new THREE.Vector3);
                        var te = this.elements;
                        return z.subVectors(eye, target).normalize(),
                        0 === z.lengthSq() && (z.z = 1),
                            x.crossVectors(up, z).normalize(),
                        0 === x.lengthSq() && (z.z += 1e-4,
                            x.crossVectors(up, z).normalize()),
                            y.crossVectors(z, x),
                            te[0] = x.x,
                            te[4] = y.x,
                            te[8] = z.x,
                            te[1] = x.y,
                            te[5] = y.y,
                            te[9] = z.y,
                            te[2] = x.z,
                            te[6] = y.z,
                            te[10] = z.z,
                            this
                    }
                }(),
                multiply: function(m, n) {
                    return void 0 !== n ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
                        this.multiplyMatrices(m, n)) : this.multiplyMatrices(this, m)
                },
                premultiply: function(m) {
                    return this.multiplyMatrices(m, this)
                },
                multiplyMatrices: function(a, b) {
                    var ae = a.elements
                        , be = b.elements
                        , te = this.elements
                        , a11 = ae[0]
                        , a12 = ae[4]
                        , a13 = ae[8]
                        , a14 = ae[12]
                        , a21 = ae[1]
                        , a22 = ae[5]
                        , a23 = ae[9]
                        , a24 = ae[13]
                        , a31 = ae[2]
                        , a32 = ae[6]
                        , a33 = ae[10]
                        , a34 = ae[14]
                        , a41 = ae[3]
                        , a42 = ae[7]
                        , a43 = ae[11]
                        , a44 = ae[15]
                        , b11 = be[0]
                        , b12 = be[4]
                        , b13 = be[8]
                        , b14 = be[12]
                        , b21 = be[1]
                        , b22 = be[5]
                        , b23 = be[9]
                        , b24 = be[13]
                        , b31 = be[2]
                        , b32 = be[6]
                        , b33 = be[10]
                        , b34 = be[14]
                        , b41 = be[3]
                        , b42 = be[7]
                        , b43 = be[11]
                        , b44 = be[15];
                    return te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41,
                        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42,
                        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43,
                        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44,
                        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41,
                        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42,
                        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43,
                        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44,
                        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41,
                        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42,
                        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43,
                        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44,
                        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41,
                        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42,
                        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43,
                        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44,
                        this
                },
                multiplyToArray: function(a, b, r) {
                    var te = this.elements;
                    return this.multiplyMatrices(a, b),
                        r[0] = te[0],
                        r[1] = te[1],
                        r[2] = te[2],
                        r[3] = te[3],
                        r[4] = te[4],
                        r[5] = te[5],
                        r[6] = te[6],
                        r[7] = te[7],
                        r[8] = te[8],
                        r[9] = te[9],
                        r[10] = te[10],
                        r[11] = te[11],
                        r[12] = te[12],
                        r[13] = te[13],
                        r[14] = te[14],
                        r[15] = te[15],
                        this
                },
                multiplyScalar: function(s) {
                    var te = this.elements;
                    return te[0] *= s,
                        te[4] *= s,
                        te[8] *= s,
                        te[12] *= s,
                        te[1] *= s,
                        te[5] *= s,
                        te[9] *= s,
                        te[13] *= s,
                        te[2] *= s,
                        te[6] *= s,
                        te[10] *= s,
                        te[14] *= s,
                        te[3] *= s,
                        te[7] *= s,
                        te[11] *= s,
                        te[15] *= s,
                        this
                },
                applyToVector3Array: function() {
                    var v1;
                    return function(array, offset, length) {
                        void 0 === v1 && (v1 = new THREE.Vector3),
                        void 0 === offset && (offset = 0),
                        void 0 === length && (length = array.length);
                        for (var i = 0, j = offset; i < length; i += 3,
                            j += 3)
                            v1.fromArray(array, j),
                                v1.applyMatrix4(this),
                                v1.toArray(array, j);
                        return array
                    }
                }(),
                applyToBuffer: function() {
                    var v1;
                    return function(buffer, offset, length) {
                        void 0 === v1 && (v1 = new THREE.Vector3),
                        void 0 === offset && (offset = 0),
                        void 0 === length && (length = buffer.length / buffer.itemSize);
                        for (var i = 0, j = offset; i < length; i++,
                            j++)
                            v1.x = buffer.getX(j),
                                v1.y = buffer.getY(j),
                                v1.z = buffer.getZ(j),
                                v1.applyMatrix4(this),
                                buffer.setXYZ(v1.x, v1.y, v1.z);
                        return buffer
                    }
                }(),
                determinant: function() {
                    var te = this.elements
                        , n11 = te[0]
                        , n12 = te[4]
                        , n13 = te[8]
                        , n14 = te[12]
                        , n21 = te[1]
                        , n22 = te[5]
                        , n23 = te[9]
                        , n24 = te[13]
                        , n31 = te[2]
                        , n32 = te[6]
                        , n33 = te[10]
                        , n34 = te[14]
                        , n41 = te[3]
                        , n42 = te[7]
                        , n43 = te[11]
                        , n44 = te[15];
                    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31)
                },
                transpose: function() {
                    var tmp, te = this.elements;
                    return tmp = te[1],
                        te[1] = te[4],
                        te[4] = tmp,
                        tmp = te[2],
                        te[2] = te[8],
                        te[8] = tmp,
                        tmp = te[6],
                        te[6] = te[9],
                        te[9] = tmp,
                        tmp = te[3],
                        te[3] = te[12],
                        te[12] = tmp,
                        tmp = te[7],
                        te[7] = te[13],
                        te[13] = tmp,
                        tmp = te[11],
                        te[11] = te[14],
                        te[14] = tmp,
                        this
                },
                flattenToArrayOffset: function(array, offset) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."),
                        this.toArray(array, offset)
                },
                getPosition: function() {
                    var v1;
                    return function() {
                        return void 0 === v1 && (v1 = new THREE.Vector3),
                            console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
                            v1.setFromMatrixColumn(this, 3)
                    }
                }(),
                setPosition: function(v) {
                    var te = this.elements;
                    return te[12] = v.x,
                        te[13] = v.y,
                        te[14] = v.z,
                        this
                },
                getInverse: function(m, throwOnDegenerate) {
                    var te = this.elements
                        , me = m.elements
                        , n11 = me[0]
                        , n21 = me[1]
                        , n31 = me[2]
                        , n41 = me[3]
                        , n12 = me[4]
                        , n22 = me[5]
                        , n32 = me[6]
                        , n42 = me[7]
                        , n13 = me[8]
                        , n23 = me[9]
                        , n33 = me[10]
                        , n43 = me[11]
                        , n14 = me[12]
                        , n24 = me[13]
                        , n34 = me[14]
                        , n44 = me[15]
                        , t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44
                        , t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44
                        , t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44
                        , t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34
                        , det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
                    if (0 === det) {
                        var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                        if (throwOnDegenerate)
                            throw new Error(msg);
                        return console.warn(msg),
                            this.identity()
                    }
                    var detInv = 1 / det;
                    return te[0] = t11 * detInv,
                        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv,
                        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv,
                        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv,
                        te[4] = t12 * detInv,
                        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv,
                        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv,
                        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv,
                        te[8] = t13 * detInv,
                        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv,
                        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv,
                        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv,
                        te[12] = t14 * detInv,
                        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv,
                        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv,
                        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv,
                        this
                },
                scale: function(v) {
                    var te = this.elements
                        , x = v.x
                        , y = v.y
                        , z = v.z;
                    return te[0] *= x,
                        te[4] *= y,
                        te[8] *= z,
                        te[1] *= x,
                        te[5] *= y,
                        te[9] *= z,
                        te[2] *= x,
                        te[6] *= y,
                        te[10] *= z,
                        te[3] *= x,
                        te[7] *= y,
                        te[11] *= z,
                        this
                },
                getMaxScaleOnAxis: function() {
                    var te = this.elements
                        , scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2]
                        , scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6]
                        , scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
                    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq))
                },
                makeTranslation: function(x, y, z) {
                    return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1),
                        this
                },
                makeRotationX: function(theta) {
                    var c = Math.cos(theta)
                        , s = Math.sin(theta);
                    return this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1),
                        this
                },
                makeRotationY: function(theta) {
                    var c = Math.cos(theta)
                        , s = Math.sin(theta);
                    return this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1),
                        this
                },
                makeRotationZ: function(theta) {
                    var c = Math.cos(theta)
                        , s = Math.sin(theta);
                    return this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                },
                makeRotationAxis: function(axis, angle) {
                    var c = Math.cos(angle)
                        , s = Math.sin(angle)
                        , t = 1 - c
                        , x = axis.x
                        , y = axis.y
                        , z = axis.z
                        , tx = t * x
                        , ty = t * y;
                    return this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1),
                        this
                },
                makeScale: function(x, y, z) {
                    return this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1),
                        this
                },
                compose: function(position, quaternion, scale) {
                    return this.makeRotationFromQuaternion(quaternion),
                        this.scale(scale),
                        this.setPosition(position),
                        this
                },
                decompose: function() {
                    var vector, matrix;
                    return function(position, quaternion, scale) {
                        void 0 === vector && (vector = new THREE.Vector3,
                            matrix = new THREE.Matrix4);
                        var te = this.elements
                            , sx = vector.set(te[0], te[1], te[2]).length()
                            , sy = vector.set(te[4], te[5], te[6]).length()
                            , sz = vector.set(te[8], te[9], te[10]).length()
                            , det = this.determinant();
                        det < 0 && (sx = -sx),
                            position.x = te[12],
                            position.y = te[13],
                            position.z = te[14],
                            matrix.elements.set(this.elements);
                        var invSX = 1 / sx
                            , invSY = 1 / sy
                            , invSZ = 1 / sz;
                        return matrix.elements[0] *= invSX,
                            matrix.elements[1] *= invSX,
                            matrix.elements[2] *= invSX,
                            matrix.elements[4] *= invSY,
                            matrix.elements[5] *= invSY,
                            matrix.elements[6] *= invSY,
                            matrix.elements[8] *= invSZ,
                            matrix.elements[9] *= invSZ,
                            matrix.elements[10] *= invSZ,
                            quaternion.setFromRotationMatrix(matrix),
                            scale.x = sx,
                            scale.y = sy,
                            scale.z = sz,
                            this
                    }
                }(),
                makeFrustum: function(left, right, bottom, top, near, far) {
                    var te = this.elements
                        , x = 2 * near / (right - left)
                        , y = 2 * near / (top - bottom)
                        , a = (right + left) / (right - left)
                        , b = (top + bottom) / (top - bottom)
                        , c = -(far + near) / (far - near)
                        , d = -2 * far * near / (far - near);
                    return te[0] = x,
                        te[4] = 0,
                        te[8] = a,
                        te[12] = 0,
                        te[1] = 0,
                        te[5] = y,
                        te[9] = b,
                        te[13] = 0,
                        te[2] = 0,
                        te[6] = 0,
                        te[10] = c,
                        te[14] = d,
                        te[3] = 0,
                        te[7] = 0,
                        te[11] = -1,
                        te[15] = 0,
                        this
                },
                makePerspective: function(fov, aspect, near, far) {
                    var ymax = near * Math.tan(THREE.Math.DEG2RAD * fov * .5)
                        , ymin = -ymax
                        , xmin = ymin * aspect
                        , xmax = ymax * aspect;
                    return this.makeFrustum(xmin, xmax, ymin, ymax, near, far)
                },
                makeOrthographic: function(left, right, top, bottom, near, far) {
                    var te = this.elements
                        , w = 1 / (right - left)
                        , h = 1 / (top - bottom)
                        , p = 1 / (far - near)
                        , x = (right + left) * w
                        , y = (top + bottom) * h
                        , z = (far + near) * p;
                    return te[0] = 2 * w,
                        te[4] = 0,
                        te[8] = 0,
                        te[12] = -x,
                        te[1] = 0,
                        te[5] = 2 * h,
                        te[9] = 0,
                        te[13] = -y,
                        te[2] = 0,
                        te[6] = 0,
                        te[10] = -2 * p,
                        te[14] = -z,
                        te[3] = 0,
                        te[7] = 0,
                        te[11] = 0,
                        te[15] = 1,
                        this
                },
                equals: function(matrix) {
                    for (var te = this.elements, me = matrix.elements, i = 0; i < 16; i++)
                        if (te[i] !== me[i])
                            return !1;
                    return !0
                },
                fromArray: function(array) {
                    return this.elements.set(array),
                        this
                },
                toArray: function(array, offset) {
                    void 0 === array && (array = []),
                    void 0 === offset && (offset = 0);
                    var te = this.elements;
                    return array[offset] = te[0],
                        array[offset + 1] = te[1],
                        array[offset + 2] = te[2],
                        array[offset + 3] = te[3],
                        array[offset + 4] = te[4],
                        array[offset + 5] = te[5],
                        array[offset + 6] = te[6],
                        array[offset + 7] = te[7],
                        array[offset + 8] = te[8],
                        array[offset + 9] = te[9],
                        array[offset + 10] = te[10],
                        array[offset + 11] = te[11],
                        array[offset + 12] = te[12],
                        array[offset + 13] = te[13],
                        array[offset + 14] = te[14],
                        array[offset + 15] = te[15],
                        array
                }
            },
            THREE.Ray = function(origin, direction) {
                this.origin = void 0 !== origin ? origin : new THREE.Vector3,
                    this.direction = void 0 !== direction ? direction : new THREE.Vector3
            }
            ,
            THREE.Ray.prototype = {
                constructor: THREE.Ray,
                set: function(origin, direction) {
                    return this.origin.copy(origin),
                        this.direction.copy(direction),
                        this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(ray) {
                    return this.origin.copy(ray.origin),
                        this.direction.copy(ray.direction),
                        this
                },
                at: function(t, optionalTarget) {
                    var result = optionalTarget || new THREE.Vector3;
                    return result.copy(this.direction).multiplyScalar(t).add(this.origin)
                },
                lookAt: function(v) {
                    return this.direction.copy(v).sub(this.origin).normalize(),
                        this
                },
                recast: function() {
                    var v1 = new THREE.Vector3;
                    return function(t) {
                        return this.origin.copy(this.at(t, v1)),
                            this
                    }
                }(),
                closestPointToPoint: function(point, optionalTarget) {
                    var result = optionalTarget || new THREE.Vector3;
                    result.subVectors(point, this.origin);
                    var directionDistance = result.dot(this.direction);
                    return directionDistance < 0 ? result.copy(this.origin) : result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin)
                },
                distanceToPoint: function(point) {
                    return Math.sqrt(this.distanceSqToPoint(point))
                },
                distanceSqToPoint: function() {
                    var v1 = new THREE.Vector3;
                    return function(point) {
                        var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
                        return directionDistance < 0 ? this.origin.distanceToSquared(point) : (v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin),
                            v1.distanceToSquared(point))
                    }
                }(),
                distanceSqToSegment: function() {
                    var segCenter = new THREE.Vector3
                        , segDir = new THREE.Vector3
                        , diff = new THREE.Vector3;
                    return function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
                        segCenter.copy(v0).add(v1).multiplyScalar(.5),
                            segDir.copy(v1).sub(v0).normalize(),
                            diff.copy(this.origin).sub(segCenter);
                        var s0, s1, sqrDist, extDet, segExtent = .5 * v0.distanceTo(v1), a01 = -this.direction.dot(segDir), b0 = diff.dot(this.direction), b1 = -diff.dot(segDir), c = diff.lengthSq(), det = Math.abs(1 - a01 * a01);
                        if (det > 0)
                            if (s0 = a01 * b1 - b0,
                                    s1 = a01 * b0 - b1,
                                    extDet = segExtent * det,
                                s0 >= 0)
                                if (s1 >= -extDet)
                                    if (s1 <= extDet) {
                                        var invDet = 1 / det;
                                        s0 *= invDet,
                                            s1 *= invDet,
                                            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c
                                    } else
                                        s1 = segExtent,
                                            s0 = Math.max(0, -(a01 * s1 + b0)),
                                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                                else
                                    s1 = -segExtent,
                                        s0 = Math.max(0, -(a01 * s1 + b0)),
                                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                            else
                                s1 <= -extDet ? (s0 = Math.max(0, -(-a01 * segExtent + b0)),
                                    s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent),
                                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c) : s1 <= extDet ? (s0 = 0,
                                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent),
                                    sqrDist = s1 * (s1 + 2 * b1) + c) : (s0 = Math.max(0, -(a01 * segExtent + b0)),
                                    s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent),
                                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c);
                        else
                            s1 = a01 > 0 ? -segExtent : segExtent,
                                s0 = Math.max(0, -(a01 * s1 + b0)),
                                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        return optionalPointOnRay && optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin),
                        optionalPointOnSegment && optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter),
                            sqrDist
                    }
                }(),
                intersectSphere: function() {
                    var v1 = new THREE.Vector3;
                    return function(sphere, optionalTarget) {
                        v1.subVectors(sphere.center, this.origin);
                        var tca = v1.dot(this.direction)
                            , d2 = v1.dot(v1) - tca * tca
                            , radius2 = sphere.radius * sphere.radius;
                        if (d2 > radius2)
                            return null;
                        var thc = Math.sqrt(radius2 - d2)
                            , t0 = tca - thc
                            , t1 = tca + thc;
                        return t0 < 0 && t1 < 0 ? null : t0 < 0 ? this.at(t1, optionalTarget) : this.at(t0, optionalTarget)
                    }
                }(),
                intersectsSphere: function(sphere) {
                    return this.distanceToPoint(sphere.center) <= sphere.radius
                },
                distanceToPlane: function(plane) {
                    var denominator = plane.normal.dot(this.direction);
                    if (0 === denominator)
                        return 0 === plane.distanceToPoint(this.origin) ? 0 : null;
                    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
                    return t >= 0 ? t : null
                },
                intersectPlane: function(plane, optionalTarget) {
                    var t = this.distanceToPlane(plane);
                    return null === t ? null : this.at(t, optionalTarget)
                },
                intersectsPlane: function(plane) {
                    var distToPoint = plane.distanceToPoint(this.origin);
                    if (0 === distToPoint)
                        return !0;
                    var denominator = plane.normal.dot(this.direction);
                    return denominator * distToPoint < 0
                },
                intersectBox: function(box, optionalTarget) {
                    var tmin, tmax, tymin, tymax, tzmin, tzmax, invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z, origin = this.origin;
                    return invdirx >= 0 ? (tmin = (box.min.x - origin.x) * invdirx,
                        tmax = (box.max.x - origin.x) * invdirx) : (tmin = (box.max.x - origin.x) * invdirx,
                        tmax = (box.min.x - origin.x) * invdirx),
                        invdiry >= 0 ? (tymin = (box.min.y - origin.y) * invdiry,
                            tymax = (box.max.y - origin.y) * invdiry) : (tymin = (box.max.y - origin.y) * invdiry,
                            tymax = (box.min.y - origin.y) * invdiry),
                        tmin > tymax || tymin > tmax ? null : ((tymin > tmin || tmin !== tmin) && (tmin = tymin),
                        (tymax < tmax || tmax !== tmax) && (tmax = tymax),
                            invdirz >= 0 ? (tzmin = (box.min.z - origin.z) * invdirz,
                                tzmax = (box.max.z - origin.z) * invdirz) : (tzmin = (box.max.z - origin.z) * invdirz,
                                tzmax = (box.min.z - origin.z) * invdirz),
                            tmin > tzmax || tzmin > tmax ? null : ((tzmin > tmin || tmin !== tmin) && (tmin = tzmin),
                            (tzmax < tmax || tmax !== tmax) && (tmax = tzmax),
                                tmax < 0 ? null : this.at(tmin >= 0 ? tmin : tmax, optionalTarget)))
                },
                intersectsBox: function() {
                    var v = new THREE.Vector3;
                    return function(box) {
                        return null !== this.intersectBox(box, v)
                    }
                }(),
                intersectTriangle: function() {
                    var diff = new THREE.Vector3
                        , edge1 = new THREE.Vector3
                        , edge2 = new THREE.Vector3
                        , normal = new THREE.Vector3;
                    return function(a, b, c, backfaceCulling, optionalTarget) {
                        edge1.subVectors(b, a),
                            edge2.subVectors(c, a),
                            normal.crossVectors(edge1, edge2);
                        var sign, DdN = this.direction.dot(normal);
                        if (DdN > 0) {
                            if (backfaceCulling)
                                return null;
                            sign = 1
                        } else {
                            if (!(DdN < 0))
                                return null;
                            sign = -1,
                                DdN = -DdN
                        }
                        diff.subVectors(this.origin, a);
                        var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
                        if (DdQxE2 < 0)
                            return null;
                        var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
                        if (DdE1xQ < 0)
                            return null;
                        if (DdQxE2 + DdE1xQ > DdN)
                            return null;
                        var QdN = -sign * diff.dot(normal);
                        return QdN < 0 ? null : this.at(QdN / DdN, optionalTarget)
                    }
                }(),
                applyMatrix4: function(matrix4) {
                    return this.direction.add(this.origin).applyMatrix4(matrix4),
                        this.origin.applyMatrix4(matrix4),
                        this.direction.sub(this.origin),
                        this.direction.normalize(),
                        this
                },
                equals: function(ray) {
                    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction)
                }
            },
            THREE.Sphere = function(center, radius) {
                this.center = void 0 !== center ? center : new THREE.Vector3,
                    this.radius = void 0 !== radius ? radius : 0
            }
            ,
            THREE.Sphere.prototype = {
                constructor: THREE.Sphere,
                set: function(center, radius) {
                    return this.center.copy(center),
                        this.radius = radius,
                        this
                },
                setFromPoints: function() {
                    var box = new THREE.Box3;
                    return function(points, optionalCenter) {
                        var center = this.center;
                        void 0 !== optionalCenter ? center.copy(optionalCenter) : box.setFromPoints(points).center(center);
                        for (var maxRadiusSq = 0, i = 0, il = points.length; i < il; i++)
                            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
                        return this.radius = Math.sqrt(maxRadiusSq),
                            this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(sphere) {
                    return this.center.copy(sphere.center),
                        this.radius = sphere.radius,
                        this
                },
                empty: function() {
                    return this.radius <= 0
                },
                containsPoint: function(point) {
                    return point.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(point) {
                    return point.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(sphere) {
                    var radiusSum = this.radius + sphere.radius;
                    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum
                },
                intersectsBox: function(box) {
                    return box.intersectsSphere(this)
                },
                intersectsPlane: function(plane) {
                    return Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius
                },
                clampPoint: function(point, optionalTarget) {
                    var deltaLengthSq = this.center.distanceToSquared(point)
                        , result = optionalTarget || new THREE.Vector3;
                    return result.copy(point),
                    deltaLengthSq > this.radius * this.radius && (result.sub(this.center).normalize(),
                        result.multiplyScalar(this.radius).add(this.center)),
                        result
                },
                getBoundingBox: function(optionalTarget) {
                    var box = optionalTarget || new THREE.Box3;
                    return box.set(this.center, this.center),
                        box.expandByScalar(this.radius),
                        box
                },
                applyMatrix4: function(matrix) {
                    return this.center.applyMatrix4(matrix),
                        this.radius = this.radius * matrix.getMaxScaleOnAxis(),
                        this
                },
                translate: function(offset) {
                    return this.center.add(offset),
                        this
                },
                equals: function(sphere) {
                    return sphere.center.equals(this.center) && sphere.radius === this.radius
                }
            },
            THREE.Frustum = function(p0, p1, p2, p3, p4, p5) {
                this.planes = [void 0 !== p0 ? p0 : new THREE.Plane, void 0 !== p1 ? p1 : new THREE.Plane, void 0 !== p2 ? p2 : new THREE.Plane, void 0 !== p3 ? p3 : new THREE.Plane, void 0 !== p4 ? p4 : new THREE.Plane, void 0 !== p5 ? p5 : new THREE.Plane]
            }
            ,
            THREE.Frustum.prototype = {
                constructor: THREE.Frustum,
                set: function(p0, p1, p2, p3, p4, p5) {
                    var planes = this.planes;
                    return planes[0].copy(p0),
                        planes[1].copy(p1),
                        planes[2].copy(p2),
                        planes[3].copy(p3),
                        planes[4].copy(p4),
                        planes[5].copy(p5),
                        this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(frustum) {
                    for (var planes = this.planes, i = 0; i < 6; i++)
                        planes[i].copy(frustum.planes[i]);
                    return this
                },
                setFromMatrix: function(m) {
                    var planes = this.planes
                        , me = m.elements
                        , me0 = me[0]
                        , me1 = me[1]
                        , me2 = me[2]
                        , me3 = me[3]
                        , me4 = me[4]
                        , me5 = me[5]
                        , me6 = me[6]
                        , me7 = me[7]
                        , me8 = me[8]
                        , me9 = me[9]
                        , me10 = me[10]
                        , me11 = me[11]
                        , me12 = me[12]
                        , me13 = me[13]
                        , me14 = me[14]
                        , me15 = me[15];
                    return planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize(),
                        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize(),
                        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize(),
                        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize(),
                        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize(),
                        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize(),
                        this
                },
                intersectsObject: function() {
                    var sphere = new THREE.Sphere;
                    return function(object) {
                        var geometry = object.geometry;
                        return null === geometry.boundingSphere && geometry.computeBoundingSphere(),
                            sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld),
                            this.intersectsSphere(sphere)
                    }
                }(),
                intersectsSprite: function() {
                    var sphere = new THREE.Sphere;
                    return function(sprite) {
                        return sphere.center.set(0, 0, 0),
                            sphere.radius = .7071067811865476,
                            sphere.applyMatrix4(sprite.matrixWorld),
                            this.intersectsSphere(sphere)
                    }
                }(),
                intersectsSphere: function(sphere) {
                    for (var planes = this.planes, center = sphere.center, negRadius = -sphere.radius, i = 0; i < 6; i++) {
                        var distance = planes[i].distanceToPoint(center);
                        if (distance < negRadius)
                            return !1
                    }
                    return !0
                },
                intersectsBox: function() {
                    var p1 = new THREE.Vector3
                        , p2 = new THREE.Vector3;
                    return function(box) {
                        for (var planes = this.planes, i = 0; i < 6; i++) {
                            var plane = planes[i];
                            p1.x = plane.normal.x > 0 ? box.min.x : box.max.x,
                                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x,
                                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y,
                                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y,
                                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z,
                                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                            var d1 = plane.distanceToPoint(p1)
                                , d2 = plane.distanceToPoint(p2);
                            if (d1 < 0 && d2 < 0)
                                return !1
                        }
                        return !0
                    }
                }(),
                containsPoint: function(point) {
                    for (var planes = this.planes, i = 0; i < 6; i++)
                        if (planes[i].distanceToPoint(point) < 0)
                            return !1;
                    return !0
                }
            },
            THREE.Plane = function(normal, constant) {
                this.normal = void 0 !== normal ? normal : new THREE.Vector3(1,0,0),
                    this.constant = void 0 !== constant ? constant : 0
            }
            ,
            THREE.Plane.prototype = {
                constructor: THREE.Plane,
                set: function(normal, constant) {
                    return this.normal.copy(normal),
                        this.constant = constant,
                        this
                },
                setComponents: function(x, y, z, w) {
                    return this.normal.set(x, y, z),
                        this.constant = w,
                        this
                },
                setFromNormalAndCoplanarPoint: function(normal, point) {
                    return this.normal.copy(normal),
                        this.constant = -point.dot(this.normal),
                        this
                },
                setFromCoplanarPoints: function() {
                    var v1 = new THREE.Vector3
                        , v2 = new THREE.Vector3;
                    return function(a, b, c) {
                        var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
                        return this.setFromNormalAndCoplanarPoint(normal, a),
                            this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(plane) {
                    return this.normal.copy(plane.normal),
                        this.constant = plane.constant,
                        this
                },
                normalize: function() {
                    var inverseNormalLength = 1 / this.normal.length();
                    return this.normal.multiplyScalar(inverseNormalLength),
                        this.constant *= inverseNormalLength,
                        this
                },
                negate: function() {
                    return this.constant *= -1,
                        this.normal.negate(),
                        this
                },
                distanceToPoint: function(point) {
                    return this.normal.dot(point) + this.constant
                },
                distanceToSphere: function(sphere) {
                    return this.distanceToPoint(sphere.center) - sphere.radius
                },
                projectPoint: function(point, optionalTarget) {
                    return this.orthoPoint(point, optionalTarget).sub(point).negate()
                },
                orthoPoint: function(point, optionalTarget) {
                    var perpendicularMagnitude = this.distanceToPoint(point)
                        , result = optionalTarget || new THREE.Vector3;
                    return result.copy(this.normal).multiplyScalar(perpendicularMagnitude)
                },
                intersectLine: function() {
                    var v1 = new THREE.Vector3;
                    return function(line, optionalTarget) {
                        var result = optionalTarget || new THREE.Vector3
                            , direction = line.delta(v1)
                            , denominator = this.normal.dot(direction);
                        if (0 !== denominator) {
                            var t = -(line.start.dot(this.normal) + this.constant) / denominator;
                            if (!(t < 0 || t > 1))
                                return result.copy(direction).multiplyScalar(t).add(line.start)
                        } else if (0 === this.distanceToPoint(line.start))
                            return result.copy(line.start)
                    }
                }(),
                intersectsLine: function(line) {
                    var startSign = this.distanceToPoint(line.start)
                        , endSign = this.distanceToPoint(line.end);
                    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0
                },
                intersectsBox: function(box) {
                    return box.intersectsPlane(this)
                },
                intersectsSphere: function(sphere) {
                    return sphere.intersectsPlane(this)
                },
                coplanarPoint: function(optionalTarget) {
                    var result = optionalTarget || new THREE.Vector3;
                    return result.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function() {
                    var v1 = new THREE.Vector3
                        , m1 = new THREE.Matrix3;
                    return function(matrix, optionalNormalMatrix) {
                        var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix)
                            , normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix)
                            , normal = this.normal.applyMatrix3(normalMatrix).normalize();
                        return this.constant = -referencePoint.dot(normal),
                            this
                    }
                }(),
                translate: function(offset) {
                    return this.constant = this.constant - offset.dot(this.normal),
                        this
                },
                equals: function(plane) {
                    return plane.normal.equals(this.normal) && plane.constant === this.constant
                }
            },
            THREE.Spherical = function(radius, phi, theta) {
                return this.radius = void 0 !== radius ? radius : 1,
                    this.phi = void 0 !== phi ? phi : 0,
                    this.theta = void 0 !== theta ? theta : 0,
                    this
            }
            ,
            THREE.Spherical.prototype = {
                constructor: THREE.Spherical,
                set: function(radius, phi, theta) {
                    return this.radius = radius,
                        this.phi = phi,
                        this.theta = theta,
                        this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(other) {
                    return this.radius.copy(other.radius),
                        this.phi.copy(other.phi),
                        this.theta.copy(other.theta),
                        this
                },
                makeSafe: function() {
                    var EPS = 1e-6;
                    return this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi)),
                        this
                },
                setFromVector3: function(vec3) {
                    return this.radius = vec3.length(),
                        0 === this.radius ? (this.theta = 0,
                            this.phi = 0) : (this.theta = Math.atan2(vec3.x, vec3.z),
                            this.phi = Math.acos(THREE.Math.clamp(vec3.y / this.radius, -1, 1))),
                        this
                }
            },
            THREE.Math = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function() {
                    var r, chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), uuid = new Array(36), rnd = 0;
                    return function() {
                        for (var i = 0; i < 36; i++)
                            8 === i || 13 === i || 18 === i || 23 === i ? uuid[i] = "-" : 14 === i ? uuid[i] = "4" : (rnd <= 2 && (rnd = 33554432 + 16777216 * Math.random() | 0),
                                r = 15 & rnd,
                                rnd >>= 4,
                                uuid[i] = chars[19 === i ? 3 & r | 8 : r]);
                        return uuid.join("")
                    }
                }(),
                clamp: function(value, min, max) {
                    return Math.max(min, Math.min(max, value))
                },
                euclideanModulo: function(n, m) {
                    return (n % m + m) % m
                },
                mapLinear: function(x, a1, a2, b1, b2) {
                    return b1 + (x - a1) * (b2 - b1) / (a2 - a1)
                },
                smoothstep: function(x, min, max) {
                    return x <= min ? 0 : x >= max ? 1 : (x = (x - min) / (max - min),
                    x * x * (3 - 2 * x))
                },
                smootherstep: function(x, min, max) {
                    return x <= min ? 0 : x >= max ? 1 : (x = (x - min) / (max - min),
                    x * x * x * (x * (6 * x - 15) + 10))
                },
                random16: function() {
                    return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."),
                        Math.random()
                },
                randInt: function(low, high) {
                    return low + Math.floor(Math.random() * (high - low + 1))
                },
                randFloat: function(low, high) {
                    return low + Math.random() * (high - low)
                },
                randFloatSpread: function(range) {
                    return range * (.5 - Math.random())
                },
                degToRad: function(degrees) {
                    return degrees * THREE.Math.DEG2RAD
                },
                radToDeg: function(radians) {
                    return radians * THREE.Math.RAD2DEG
                },
                isPowerOfTwo: function(value) {
                    return 0 === (value & value - 1) && 0 !== value
                },
                nearestPowerOfTwo: function(value) {
                    return Math.pow(2, Math.round(Math.log(value) / Math.LN2))
                },
                nextPowerOfTwo: function(value) {
                    return value--,
                        value |= value >> 1,
                        value |= value >> 2,
                        value |= value >> 4,
                        value |= value >> 8,
                        value |= value >> 16,
                        value++,
                        value
                }
            },
            THREE.Spline = function(points) {
                function interpolate(p0, p1, p2, p3, t, t2, t3) {
                    var v0 = .5 * (p2 - p0)
                        , v1 = .5 * (p3 - p1);
                    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1
                }
                this.points = points;
                var point, intPoint, weight, w2, w3, pa, pb, pc, pd, c = [], v3 = {
                    x: 0,
                    y: 0,
                    z: 0
                };
                this.initFromArray = function(a) {
                    this.points = [];
                    for (var i = 0; i < a.length; i++)
                        this.points[i] = {
                            x: a[i][0],
                            y: a[i][1],
                            z: a[i][2]
                        }
                }
                    ,
                    this.getPoint = function(k) {
                        return point = (this.points.length - 1) * k,
                            intPoint = Math.floor(point),
                            weight = point - intPoint,
                            c[0] = 0 === intPoint ? intPoint : intPoint - 1,
                            c[1] = intPoint,
                            c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1,
                            c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2,
                            pa = this.points[c[0]],
                            pb = this.points[c[1]],
                            pc = this.points[c[2]],
                            pd = this.points[c[3]],
                            w2 = weight * weight,
                            w3 = weight * w2,
                            v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3),
                            v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3),
                            v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3),
                            v3
                    }
                    ,
                    this.getControlPointsArray = function() {
                        var i, p, l = this.points.length, coords = [];
                        for (i = 0; i < l; i++)
                            p = this.points[i],
                                coords[i] = [p.x, p.y, p.z];
                        return coords
                    }
                    ,
                    this.getLength = function(nSubDivisions) {
                        var i, index, nSamples, position, point = 0, intPoint = 0, oldIntPoint = 0, oldPosition = new THREE.Vector3, tmpVec = new THREE.Vector3, chunkLengths = [], totalLength = 0;
                        for (chunkLengths[0] = 0,
                             nSubDivisions || (nSubDivisions = 100),
                                 nSamples = this.points.length * nSubDivisions,
                                 oldPosition.copy(this.points[0]),
                                 i = 1; i < nSamples; i++)
                            index = i / nSamples,
                                position = this.getPoint(index),
                                tmpVec.copy(position),
                                totalLength += tmpVec.distanceTo(oldPosition),
                                oldPosition.copy(position),
                                point = (this.points.length - 1) * index,
                                intPoint = Math.floor(point),
                            intPoint !== oldIntPoint && (chunkLengths[intPoint] = totalLength,
                                oldIntPoint = intPoint);
                        return chunkLengths[chunkLengths.length] = totalLength,
                            {
                                chunks: chunkLengths,
                                total: totalLength
                            }
                    }
                    ,
                    this.reparametrizeByArcLength = function(samplingCoef) {
                        var i, j, index, indexCurrent, indexNext, realDistance, sampling, position, newpoints = [], tmpVec = new THREE.Vector3, sl = this.getLength();
                        for (newpoints.push(tmpVec.copy(this.points[0]).clone()),
                                 i = 1; i < this.points.length; i++) {
                            for (realDistance = sl.chunks[i] - sl.chunks[i - 1],
                                     sampling = Math.ceil(samplingCoef * realDistance / sl.total),
                                     indexCurrent = (i - 1) / (this.points.length - 1),
                                     indexNext = i / (this.points.length - 1),
                                     j = 1; j < sampling - 1; j++)
                                index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent),
                                    position = this.getPoint(index),
                                    newpoints.push(tmpVec.copy(position).clone());
                            newpoints.push(tmpVec.copy(this.points[i]).clone())
                        }
                        this.points = newpoints
                    }
            }
            ,
            THREE.Triangle = function(a, b, c) {
                this.a = void 0 !== a ? a : new THREE.Vector3,
                    this.b = void 0 !== b ? b : new THREE.Vector3,
                    this.c = void 0 !== c ? c : new THREE.Vector3
            }
            ,
            THREE.Triangle.normal = function() {
                var v0 = new THREE.Vector3;
                return function(a, b, c, optionalTarget) {
                    var result = optionalTarget || new THREE.Vector3;
                    result.subVectors(c, b),
                        v0.subVectors(a, b),
                        result.cross(v0);
                    var resultLengthSq = result.lengthSq();
                    return resultLengthSq > 0 ? result.multiplyScalar(1 / Math.sqrt(resultLengthSq)) : result.set(0, 0, 0)
                }
            }(),
            THREE.Triangle.barycoordFromPoint = function() {
                var v0 = new THREE.Vector3
                    , v1 = new THREE.Vector3
                    , v2 = new THREE.Vector3;
                return function(point, a, b, c, optionalTarget) {
                    v0.subVectors(c, a),
                        v1.subVectors(b, a),
                        v2.subVectors(point, a);
                    var dot00 = v0.dot(v0)
                        , dot01 = v0.dot(v1)
                        , dot02 = v0.dot(v2)
                        , dot11 = v1.dot(v1)
                        , dot12 = v1.dot(v2)
                        , denom = dot00 * dot11 - dot01 * dot01
                        , result = optionalTarget || new THREE.Vector3;
                    if (0 === denom)
                        return result.set(-2, -1, -1);
                    var invDenom = 1 / denom
                        , u = (dot11 * dot02 - dot01 * dot12) * invDenom
                        , v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                    return result.set(1 - u - v, v, u)
                }
            }(),
            THREE.Triangle.containsPoint = function() {
                var v1 = new THREE.Vector3;
                return function(point, a, b, c) {
                    var result = THREE.Triangle.barycoordFromPoint(point, a, b, c, v1);
                    return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1
                }
            }(),
            THREE.Triangle.prototype = {
                constructor: THREE.Triangle,
                set: function(a, b, c) {
                    return this.a.copy(a),
                        this.b.copy(b),
                        this.c.copy(c),
                        this
                },
                setFromPointsAndIndices: function(points, i0, i1, i2) {
                    return this.a.copy(points[i0]),
                        this.b.copy(points[i1]),
                        this.c.copy(points[i2]),
                        this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(triangle) {
                    return this.a.copy(triangle.a),
                        this.b.copy(triangle.b),
                        this.c.copy(triangle.c),
                        this
                },
                area: function() {
                    var v0 = new THREE.Vector3
                        , v1 = new THREE.Vector3;
                    return function() {
                        return v0.subVectors(this.c, this.b),
                            v1.subVectors(this.a, this.b),
                        .5 * v0.cross(v1).length()
                    }
                }(),
                midpoint: function(optionalTarget) {
                    var result = optionalTarget || new THREE.Vector3;
                    return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                normal: function(optionalTarget) {
                    return THREE.Triangle.normal(this.a, this.b, this.c, optionalTarget)
                },
                plane: function(optionalTarget) {
                    var result = optionalTarget || new THREE.Plane;
                    return result.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                barycoordFromPoint: function(point, optionalTarget) {
                    return THREE.Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget)
                },
                containsPoint: function(point) {
                    return THREE.Triangle.containsPoint(point, this.a, this.b, this.c)
                },
                closestPointToPoint: function() {
                    var plane, edgeList, projectedPoint, closestPoint;
                    return function(point, optionalTarget) {
                        void 0 === plane && (plane = new THREE.Plane,
                            edgeList = [new THREE.Line3, new THREE.Line3, new THREE.Line3],
                            projectedPoint = new THREE.Vector3,
                            closestPoint = new THREE.Vector3);
                        var result = optionalTarget || new THREE.Vector3
                            , minDistance = 1 / 0;
                        if (plane.setFromCoplanarPoints(this.a, this.b, this.c),
                                plane.projectPoint(point, projectedPoint),
                            this.containsPoint(projectedPoint) === !0)
                            result.copy(projectedPoint);
                        else {
                            edgeList[0].set(this.a, this.b),
                                edgeList[1].set(this.b, this.c),
                                edgeList[2].set(this.c, this.a);
                            for (var i = 0; i < edgeList.length; i++) {
                                edgeList[i].closestPointToPoint(projectedPoint, !0, closestPoint);
                                var distance = projectedPoint.distanceToSquared(closestPoint);
                                distance < minDistance && (minDistance = distance,
                                    result.copy(closestPoint))
                            }
                        }
                        return result
                    }
                }(),
                equals: function(triangle) {
                    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c)
                }
            },
            THREE.Interpolant = function(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                this.parameterPositions = parameterPositions,
                    this._cachedIndex = 0,
                    this.resultBuffer = void 0 !== resultBuffer ? resultBuffer : new sampleValues.constructor(sampleSize),
                    this.sampleValues = sampleValues,
                    this.valueSize = sampleSize
            }
            ,
            THREE.Interpolant.prototype = {
                constructor: THREE.Interpolant,
                evaluate: function(t) {
                    var pp = this.parameterPositions
                        , i1 = this._cachedIndex
                        , t1 = pp[i1]
                        , t0 = pp[i1 - 1];
                    validate_interval: {
                        seek: {
                            var right;
                            linear_scan: {
                                forward_scan: if (!(t < t1)) {
                                    for (var giveUpAt = i1 + 2; ; ) {
                                        if (void 0 === t1) {
                                            if (t < t0)
                                                break forward_scan;
                                            return i1 = pp.length,
                                                this._cachedIndex = i1,
                                                this.afterEnd_(i1 - 1, t, t0)
                                        }
                                        if (i1 === giveUpAt)
                                            break;
                                        if (t0 = t1,
                                                t1 = pp[++i1],
                                            t < t1)
                                            break seek
                                    }
                                    right = pp.length;
                                    break linear_scan
                                }
                                {
                                    if (t >= t0)
                                        break validate_interval;
                                    var t1global = pp[1];
                                    t < t1global && (i1 = 2,
                                        t0 = t1global);
                                    for (var giveUpAt = i1 - 2; ; ) {
                                        if (void 0 === t0)
                                            return this._cachedIndex = 0,
                                                this.beforeStart_(0, t, t1);
                                        if (i1 === giveUpAt)
                                            break;
                                        if (t1 = t0,
                                                t0 = pp[--i1 - 1],
                                            t >= t0)
                                            break seek
                                    }
                                    right = i1,
                                        i1 = 0
                                }
                            }
                            for (; i1 < right; ) {
                                var mid = i1 + right >>> 1;
                                t < pp[mid] ? right = mid : i1 = mid + 1
                            }
                            if (t1 = pp[i1],
                                    t0 = pp[i1 - 1],
                                void 0 === t0)
                                return this._cachedIndex = 0,
                                    this.beforeStart_(0, t, t1);
                            if (void 0 === t1)
                                return i1 = pp.length,
                                    this._cachedIndex = i1,
                                    this.afterEnd_(i1 - 1, t0, t)
                        }
                        this._cachedIndex = i1,
                            this.intervalChanged_(i1, t0, t1)
                    }
                    return this.interpolate_(i1, t0, t, t1)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function(index) {
                    for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride, i = 0; i !== stride; ++i)
                        result[i] = values[offset + i];
                    return result
                },
                interpolate_: function(i1, t0, t, t1) {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function(i1, t0, t1) {}
            },
            Object.assign(THREE.Interpolant.prototype, {
                beforeStart_: THREE.Interpolant.prototype.copySampleValue_,
                afterEnd_: THREE.Interpolant.prototype.copySampleValue_
            }),
            THREE.CubicInterpolant = function(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer),
                    this._weightPrev = -0,
                    this._offsetPrev = -0,
                    this._weightNext = -0,
                    this._offsetNext = -0
            }
            ,
            THREE.CubicInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
                constructor: THREE.CubicInterpolant,
                DefaultSettings_: {
                    endingStart: THREE.ZeroCurvatureEnding,
                    endingEnd: THREE.ZeroCurvatureEnding
                },
                intervalChanged_: function(i1, t0, t1) {
                    var pp = this.parameterPositions
                        , iPrev = i1 - 2
                        , iNext = i1 + 1
                        , tPrev = pp[iPrev]
                        , tNext = pp[iNext];
                    if (void 0 === tPrev)
                        switch (this.getSettings_().endingStart) {
                            case THREE.ZeroSlopeEnding:
                                iPrev = i1,
                                    tPrev = 2 * t0 - t1;
                                break;
                            case THREE.WrapAroundEnding:
                                iPrev = pp.length - 2,
                                    tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                                break;
                            default:
                                iPrev = i1,
                                    tPrev = t1
                        }
                    if (void 0 === tNext)
                        switch (this.getSettings_().endingEnd) {
                            case THREE.ZeroSlopeEnding:
                                iNext = i1,
                                    tNext = 2 * t1 - t0;
                                break;
                            case THREE.WrapAroundEnding:
                                iNext = 1,
                                    tNext = t1 + pp[1] - pp[0];
                                break;
                            default:
                                iNext = i1 - 1,
                                    tNext = t0
                        }
                    var halfDt = .5 * (t1 - t0)
                        , stride = this.valueSize;
                    this._weightPrev = halfDt / (t0 - tPrev),
                        this._weightNext = halfDt / (tNext - t1),
                        this._offsetPrev = iPrev * stride,
                        this._offsetNext = iNext * stride
                },
                interpolate_: function(i1, t0, t, t1) {
                    for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p, sP = -wP * ppp + 2 * wP * pp - wP * p, s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-.5 + wP) * p + 1, s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + .5 * p, sN = wN * ppp - wN * pp, i = 0; i !== stride; ++i)
                        result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
                    return result
                }
            }),
            THREE.DiscreteInterpolant = function(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer)
            }
            ,
            THREE.DiscreteInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
                constructor: THREE.DiscreteInterpolant,
                interpolate_: function(i1, t0, t, t1) {
                    return this.copySampleValue_(i1 - 1)
                }
            }),
            THREE.LinearInterpolant = function(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer)
            }
            ,
            THREE.LinearInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
                constructor: THREE.LinearInterpolant,
                interpolate_: function(i1, t0, t, t1) {
                    for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1, i = 0; i !== stride; ++i)
                        result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
                    return result
                }
            }),
            THREE.QuaternionLinearInterpolant = function(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer)
            }
            ,
            THREE.QuaternionLinearInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
                constructor: THREE.QuaternionLinearInterpolant,
                interpolate_: function(i1, t0, t, t1) {
                    for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0), end = offset + stride; offset !== end; offset += 4)
                        THREE.Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
                    return result
                }
            }),
            THREE.Clock = function(autoStart) {
                this.autoStart = void 0 === autoStart || autoStart,
                    this.startTime = 0,
                    this.oldTime = 0,
                    this.elapsedTime = 0,
                    this.running = !1
            }
            ,
            THREE.Clock.prototype = {
                constructor: THREE.Clock,
                start: function() {
                    this.startTime = (performance || Date).now(),
                        this.oldTime = this.startTime,
                        this.running = !0
                },
                stop: function() {
                    this.getElapsedTime(),
                        this.running = !1
                },
                getElapsedTime: function() {
                    return this.getDelta(),
                        this.elapsedTime
                },
                getDelta: function() {
                    var diff = 0;
                    if (this.autoStart && !this.running && this.start(),
                            this.running) {
                        var newTime = (performance || Date).now();
                        diff = (newTime - this.oldTime) / 1e3,
                            this.oldTime = newTime,
                            this.elapsedTime += diff
                    }
                    return diff
                }
            },
            THREE.EventDispatcher = function() {}
            ,
            Object.assign(THREE.EventDispatcher.prototype, {
                addEventListener: function(type, listener) {
                    void 0 === this._listeners && (this._listeners = {});
                    var listeners = this._listeners;
                    void 0 === listeners[type] && (listeners[type] = []),
                    listeners[type].indexOf(listener) === -1 && listeners[type].push(listener)
                },
                hasEventListener: function(type, listener) {
                    if (void 0 === this._listeners)
                        return !1;
                    var listeners = this._listeners;
                    return void 0 !== listeners[type] && listeners[type].indexOf(listener) !== -1
                },
                removeEventListener: function(type, listener) {
                    if (void 0 !== this._listeners) {
                        var listeners = this._listeners
                            , listenerArray = listeners[type];
                        if (void 0 !== listenerArray) {
                            var index = listenerArray.indexOf(listener);
                            index !== -1 && listenerArray.splice(index, 1)
                        }
                    }
                },
                dispatchEvent: function(event) {
                    if (void 0 !== this._listeners) {
                        var listeners = this._listeners
                            , listenerArray = listeners[event.type];
                        if (void 0 !== listenerArray) {
                            event.target = this;
                            var array = []
                                , i = 0
                                , length = listenerArray.length;
                            for (i = 0; i < length; i++)
                                array[i] = listenerArray[i];
                            for (i = 0; i < length; i++)
                                array[i].call(this, event)
                        }
                    }
                }
            }),
            THREE.Layers = function() {
                this.mask = 1
            }
            ,
            THREE.Layers.prototype = {
                constructor: THREE.Layers,
                set: function(channel) {
                    this.mask = 1 << channel
                },
                enable: function(channel) {
                    this.mask |= 1 << channel
                },
                toggle: function(channel) {
                    this.mask ^= 1 << channel
                },
                disable: function(channel) {
                    this.mask &= ~(1 << channel)
                },
                test: function(layers) {
                    return 0 !== (this.mask & layers.mask)
                }
            },
            function(THREE) {
                function ascSort(a, b) {
                    return a.distance - b.distance
                }
                function intersectObject(object, raycaster, intersects, recursive) {
                    if (object.visible !== !1 && (object.raycast(raycaster, intersects),
                        recursive === !0))
                        for (var children = object.children, i = 0, l = children.length; i < l; i++)
                            intersectObject(children[i], raycaster, intersects, !0)
                }
                THREE.Raycaster = function(origin, direction, near, far) {
                    this.ray = new THREE.Ray(origin,direction),
                        this.near = near || 0,
                        this.far = far || 1 / 0,
                        this.params = {
                            Mesh: {},
                            Line: {},
                            LOD: {},
                            Points: {
                                threshold: 1
                            },
                            Sprite: {}
                        },
                        Object.defineProperties(this.params, {
                            PointCloud: {
                                get: function() {
                                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                                        this.Points
                                }
                            }
                        })
                }
                    ,
                    THREE.Raycaster.prototype = {
                        constructor: THREE.Raycaster,
                        linePrecision: 1,
                        set: function(origin, direction) {
                            this.ray.set(origin, direction)
                        },
                        setFromCamera: function(coords, camera) {
                            camera instanceof THREE.PerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(camera.matrixWorld),
                                this.ray.direction.set(coords.x, coords.y, .5).unproject(camera).sub(this.ray.origin).normalize()) : camera instanceof THREE.OrthographicCamera ? (this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera),
                                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                        },
                        intersectObject: function(object, recursive) {
                            var intersects = [];
                            return intersectObject(object, this, intersects, recursive),
                                intersects.sort(ascSort),
                                intersects
                        },
                        intersectObjects: function(objects, recursive) {
                            var intersects = [];
                            if (Array.isArray(objects) === !1)
                                return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
                                    intersects;
                            for (var i = 0, l = objects.length; i < l; i++)
                                intersectObject(objects[i], this, intersects, recursive);
                            return intersects.sort(ascSort),
                                intersects
                        }
                    }
            }(THREE),
            THREE.Object3D = function() {
                function onRotationChange() {
                    quaternion.setFromEuler(rotation, !1)
                }
                function onQuaternionChange() {
                    rotation.setFromQuaternion(quaternion, void 0, !1)
                }
                Object.defineProperty(this, "id", {
                    value: THREE.Object3DIdCount++
                }),
                    this.uuid = THREE.Math.generateUUID(),
                    this.name = "",
                    this.type = "Object3D",
                    this.parent = null,
                    this.children = [],
                    this.up = THREE.Object3D.DefaultUp.clone();
                var position = new THREE.Vector3
                    , rotation = new THREE.Euler
                    , quaternion = new THREE.Quaternion
                    , scale = new THREE.Vector3(1,1,1);
                rotation.onChange(onRotationChange),
                    quaternion.onChange(onQuaternionChange),
                    Object.defineProperties(this, {
                        position: {
                            enumerable: !0,
                            value: position
                        },
                        rotation: {
                            enumerable: !0,
                            value: rotation
                        },
                        quaternion: {
                            enumerable: !0,
                            value: quaternion
                        },
                        scale: {
                            enumerable: !0,
                            value: scale
                        },
                        modelViewMatrix: {
                            value: new THREE.Matrix4
                        },
                        normalMatrix: {
                            value: new THREE.Matrix3
                        }
                    }),
                    this.matrix = new THREE.Matrix4,
                    this.matrixWorld = new THREE.Matrix4,
                    this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate,
                    this.matrixWorldNeedsUpdate = !1,
                    this.layers = new THREE.Layers,
                    this.visible = !0,
                    this.castShadow = !1,
                    this.receiveShadow = !1,
                    this.frustumCulled = !0,
                    this.renderOrder = 0,
                    this.userData = {}
            }
            ,
            THREE.Object3D.DefaultUp = new THREE.Vector3(0,1,0),
            THREE.Object3D.DefaultMatrixAutoUpdate = !0,
            Object.assign(THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {
                applyMatrix: function(matrix) {
                    this.matrix.multiplyMatrices(matrix, this.matrix),
                        this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                setRotationFromAxisAngle: function(axis, angle) {
                    this.quaternion.setFromAxisAngle(axis, angle)
                },
                setRotationFromEuler: function(euler) {
                    this.quaternion.setFromEuler(euler, !0)
                },
                setRotationFromMatrix: function(m) {
                    this.quaternion.setFromRotationMatrix(m)
                },
                setRotationFromQuaternion: function(q) {
                    this.quaternion.copy(q)
                },
                rotateOnAxis: function() {
                    var q1 = new THREE.Quaternion;
                    return function(axis, angle) {
                        return q1.setFromAxisAngle(axis, angle),
                            this.quaternion.multiply(q1),
                            this
                    }
                }(),
                rotateX: function() {
                    var v1 = new THREE.Vector3(1,0,0);
                    return function(angle) {
                        return this.rotateOnAxis(v1, angle)
                    }
                }(),
                rotateY: function() {
                    var v1 = new THREE.Vector3(0,1,0);
                    return function(angle) {
                        return this.rotateOnAxis(v1, angle)
                    }
                }(),
                rotateZ: function() {
                    var v1 = new THREE.Vector3(0,0,1);
                    return function(angle) {
                        return this.rotateOnAxis(v1, angle)
                    }
                }(),
                translateOnAxis: function() {
                    var v1 = new THREE.Vector3;
                    return function(axis, distance) {
                        return v1.copy(axis).applyQuaternion(this.quaternion),
                            this.position.add(v1.multiplyScalar(distance)),
                            this
                    }
                }(),
                translateX: function() {
                    var v1 = new THREE.Vector3(1,0,0);
                    return function(distance) {
                        return this.translateOnAxis(v1, distance)
                    }
                }(),
                translateY: function() {
                    var v1 = new THREE.Vector3(0,1,0);
                    return function(distance) {
                        return this.translateOnAxis(v1, distance)
                    }
                }(),
                translateZ: function() {
                    var v1 = new THREE.Vector3(0,0,1);
                    return function(distance) {
                        return this.translateOnAxis(v1, distance)
                    }
                }(),
                localToWorld: function(vector) {
                    return vector.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function() {
                    var m1 = new THREE.Matrix4;
                    return function(vector) {
                        return vector.applyMatrix4(m1.getInverse(this.matrixWorld))
                    }
                }(),
                lookAt: function() {
                    var m1 = new THREE.Matrix4;
                    return function(vector) {
                        m1.lookAt(vector, this.position, this.up),
                            this.quaternion.setFromRotationMatrix(m1)
                    }
                }(),
                add: function(object) {
                    if (arguments.length > 1) {
                        for (var i = 0; i < arguments.length; i++)
                            this.add(arguments[i]);
                        return this
                    }
                    return object === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", object),
                        this) : (object instanceof THREE.Object3D ? (null !== object.parent && object.parent.remove(object),
                        object.parent = this,
                        object.dispatchEvent({
                            type: "added"
                        }),
                        this.children.push(object)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object),
                        this)
                },
                remove: function(object) {
                    if (arguments.length > 1)
                        for (var i = 0; i < arguments.length; i++)
                            this.remove(arguments[i]);
                    var index = this.children.indexOf(object);
                    index !== -1 && (object.parent = null,
                        object.dispatchEvent({
                            type: "removed"
                        }),
                        this.children.splice(index, 1))
                },
                getObjectById: function(id) {
                    return this.getObjectByProperty("id", id)
                },
                getObjectByName: function(name) {
                    return this.getObjectByProperty("name", name)
                },
                getObjectByProperty: function(name, value) {
                    if (this[name] === value)
                        return this;
                    for (var i = 0, l = this.children.length; i < l; i++) {
                        var child = this.children[i]
                            , object = child.getObjectByProperty(name, value);
                        if (void 0 !== object)
                            return object
                    }
                },
                getWorldPosition: function(optionalTarget) {
                    var result = optionalTarget || new THREE.Vector3;
                    return this.updateMatrixWorld(!0),
                        result.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function() {
                    var position = new THREE.Vector3
                        , scale = new THREE.Vector3;
                    return function(optionalTarget) {
                        var result = optionalTarget || new THREE.Quaternion;
                        return this.updateMatrixWorld(!0),
                            this.matrixWorld.decompose(position, result, scale),
                            result
                    }
                }(),
                getWorldRotation: function() {
                    var quaternion = new THREE.Quaternion;
                    return function(optionalTarget) {
                        var result = optionalTarget || new THREE.Euler;
                        return this.getWorldQuaternion(quaternion),
                            result.setFromQuaternion(quaternion, this.rotation.order, !1)
                    }
                }(),
                getWorldScale: function() {
                    var position = new THREE.Vector3
                        , quaternion = new THREE.Quaternion;
                    return function(optionalTarget) {
                        var result = optionalTarget || new THREE.Vector3;
                        return this.updateMatrixWorld(!0),
                            this.matrixWorld.decompose(position, quaternion, result),
                            result
                    }
                }(),
                getWorldDirection: function() {
                    var quaternion = new THREE.Quaternion;
                    return function(optionalTarget) {
                        var result = optionalTarget || new THREE.Vector3;
                        return this.getWorldQuaternion(quaternion),
                            result.set(0, 0, 1).applyQuaternion(quaternion)
                    }
                }(),
                raycast: function() {},
                traverse: function(callback) {
                    callback(this);
                    for (var children = this.children, i = 0, l = children.length; i < l; i++)
                        children[i].traverse(callback)
                },
                traverseVisible: function(callback) {
                    if (this.visible !== !1) {
                        callback(this);
                        for (var children = this.children, i = 0, l = children.length; i < l; i++)
                            children[i].traverseVisible(callback)
                    }
                },
                traverseAncestors: function(callback) {
                    var parent = this.parent;
                    null !== parent && (callback(parent),
                        parent.traverseAncestors(callback))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale),
                        this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(force) {
                    this.matrixAutoUpdate === !0 && this.updateMatrix(),
                    this.matrixWorldNeedsUpdate !== !0 && force !== !0 || (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                        this.matrixWorldNeedsUpdate = !1,
                        force = !0);
                    for (var i = 0, l = this.children.length; i < l; i++)
                        this.children[i].updateMatrixWorld(force)
                },
                toJSON: function(meta) {
                    function extractFromCache(cache) {
                        var values = [];
                        for (var key in cache) {
                            var data = cache[key];
                            delete data.metadata,
                                values.push(data)
                        }
                        return values
                    }
                    var isRootObject = void 0 === meta || "" === meta
                        , output = {};
                    isRootObject && (meta = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {}
                    },
                        output.metadata = {
                            version: 4.4,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        });
                    var object = {};
                    if (object.uuid = this.uuid,
                            object.type = this.type,
                        "" !== this.name && (object.name = this.name),
                        "{}" !== JSON.stringify(this.userData) && (object.userData = this.userData),
                        this.castShadow === !0 && (object.castShadow = !0),
                        this.receiveShadow === !0 && (object.receiveShadow = !0),
                        this.visible === !1 && (object.visible = !1),
                            object.matrix = this.matrix.toArray(),
                        void 0 !== this.geometry && (void 0 === meta.geometries[this.geometry.uuid] && (meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta)),
                            object.geometry = this.geometry.uuid),
                        void 0 !== this.material && (void 0 === meta.materials[this.material.uuid] && (meta.materials[this.material.uuid] = this.material.toJSON(meta)),
                            object.material = this.material.uuid),
                        this.children.length > 0) {
                        object.children = [];
                        for (var i = 0; i < this.children.length; i++)
                            object.children.push(this.children[i].toJSON(meta).object)
                    }
                    if (isRootObject) {
                        var geometries = extractFromCache(meta.geometries)
                            , materials = extractFromCache(meta.materials)
                            , textures = extractFromCache(meta.textures)
                            , images = extractFromCache(meta.images);
                        geometries.length > 0 && (output.geometries = geometries),
                        materials.length > 0 && (output.materials = materials),
                        textures.length > 0 && (output.textures = textures),
                        images.length > 0 && (output.images = images)
                    }
                    return output.object = object,
                        output
                },
                clone: function(recursive) {
                    return (new this.constructor).copy(this, recursive)
                },
                copy: function(source, recursive) {
                    if (void 0 === recursive && (recursive = !0),
                            this.name = source.name,
                            this.up.copy(source.up),
                            this.position.copy(source.position),
                            this.quaternion.copy(source.quaternion),
                            this.scale.copy(source.scale),
                            this.matrix.copy(source.matrix),
                            this.matrixWorld.copy(source.matrixWorld),
                            this.matrixAutoUpdate = source.matrixAutoUpdate,
                            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate,
                            this.visible = source.visible,
                            this.castShadow = source.castShadow,
                            this.receiveShadow = source.receiveShadow,
                            this.frustumCulled = source.frustumCulled,
                            this.renderOrder = source.renderOrder,
                            this.userData = JSON.parse(JSON.stringify(source.userData)),
                        recursive === !0)
                        for (var i = 0; i < source.children.length; i++) {
                            var child = source.children[i];
                            this.add(child.clone())
                        }
                    return this
                }
            }),
            THREE.Object3DIdCount = 0,
            THREE.Face3 = function(a, b, c, normal, color, materialIndex) {
                this.a = a,
                    this.b = b,
                    this.c = c,
                    this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3,
                    this.vertexNormals = Array.isArray(normal) ? normal : [],
                    this.color = color instanceof THREE.Color ? color : new THREE.Color,
                    this.vertexColors = Array.isArray(color) ? color : [],
                    this.materialIndex = void 0 !== materialIndex ? materialIndex : 0
            }
            ,
            THREE.Face3.prototype = {
                constructor: THREE.Face3,
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(source) {
                    this.a = source.a,
                        this.b = source.b,
                        this.c = source.c,
                        this.normal.copy(source.normal),
                        this.color.copy(source.color),
                        this.materialIndex = source.materialIndex;
                    for (var i = 0, il = source.vertexNormals.length; i < il; i++)
                        this.vertexNormals[i] = source.vertexNormals[i].clone();
                    for (var i = 0, il = source.vertexColors.length; i < il; i++)
                        this.vertexColors[i] = source.vertexColors[i].clone();
                    return this
                }
            },
            THREE.BufferAttribute = function(array, itemSize, normalized) {
                this.uuid = THREE.Math.generateUUID(),
                    this.array = array,
                    this.itemSize = itemSize,
                    this.dynamic = !1,
                    this.updateRange = {
                        offset: 0,
                        count: -1
                    },
                    this.version = 0,
                    this.normalized = normalized === !0
            }
            ,
            THREE.BufferAttribute.prototype = {
                constructor: THREE.BufferAttribute,
                get count() {
                    return this.array.length / this.itemSize
                },
                set needsUpdate(value) {
                    value === !0 && this.version++
                },
                setDynamic: function(value) {
                    return this.dynamic = value,
                        this
                },
                copy: function(source) {
                    return this.array = new source.array.constructor(source.array),
                        this.itemSize = source.itemSize,
                        this.dynamic = source.dynamic,
                        this
                },
                copyAt: function(index1, attribute, index2) {
                    index1 *= this.itemSize,
                        index2 *= attribute.itemSize;
                    for (var i = 0, l = this.itemSize; i < l; i++)
                        this.array[index1 + i] = attribute.array[index2 + i];
                    return this
                },
                copyArray: function(array) {
                    return this.array.set(array),
                        this
                },
                copyColorsArray: function(colors) {
                    for (var array = this.array, offset = 0, i = 0, l = colors.length; i < l; i++) {
                        var color = colors[i];
                        void 0 === color && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i),
                            color = new THREE.Color),
                            array[offset++] = color.r,
                            array[offset++] = color.g,
                            array[offset++] = color.b
                    }
                    return this
                },
                copyIndicesArray: function(indices) {
                    for (var array = this.array, offset = 0, i = 0, l = indices.length; i < l; i++) {
                        var index = indices[i];
                        array[offset++] = index.a,
                            array[offset++] = index.b,
                            array[offset++] = index.c
                    }
                    return this
                },
                copyVector2sArray: function(vectors) {
                    for (var array = this.array, offset = 0, i = 0, l = vectors.length; i < l; i++) {
                        var vector = vectors[i];
                        void 0 === vector && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i),
                            vector = new THREE.Vector2),
                            array[offset++] = vector.x,
                            array[offset++] = vector.y
                    }
                    return this
                },
                copyVector3sArray: function(vectors) {
                    for (var array = this.array, offset = 0, i = 0, l = vectors.length; i < l; i++) {
                        var vector = vectors[i];
                        void 0 === vector && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i),
                            vector = new THREE.Vector3),
                            array[offset++] = vector.x,
                            array[offset++] = vector.y,
                            array[offset++] = vector.z
                    }
                    return this
                },
                copyVector4sArray: function(vectors) {
                    for (var array = this.array, offset = 0, i = 0, l = vectors.length; i < l; i++) {
                        var vector = vectors[i];
                        void 0 === vector && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
                            vector = new THREE.Vector4),
                            array[offset++] = vector.x,
                            array[offset++] = vector.y,
                            array[offset++] = vector.z,
                            array[offset++] = vector.w
                    }
                    return this
                },
                set: function(value, offset) {
                    return void 0 === offset && (offset = 0),
                        this.array.set(value, offset),
                        this
                },
                getX: function(index) {
                    return this.array[index * this.itemSize]
                },
                setX: function(index, x) {
                    return this.array[index * this.itemSize] = x,
                        this
                },
                getY: function(index) {
                    return this.array[index * this.itemSize + 1]
                },
                setY: function(index, y) {
                    return this.array[index * this.itemSize + 1] = y,
                        this
                },
                getZ: function(index) {
                    return this.array[index * this.itemSize + 2]
                },
                setZ: function(index, z) {
                    return this.array[index * this.itemSize + 2] = z,
                        this
                },
                getW: function(index) {
                    return this.array[index * this.itemSize + 3]
                },
                setW: function(index, w) {
                    return this.array[index * this.itemSize + 3] = w,
                        this
                },
                setXY: function(index, x, y) {
                    return index *= this.itemSize,
                        this.array[index + 0] = x,
                        this.array[index + 1] = y,
                        this
                },
                setXYZ: function(index, x, y, z) {
                    return index *= this.itemSize,
                        this.array[index + 0] = x,
                        this.array[index + 1] = y,
                        this.array[index + 2] = z,
                        this
                },
                setXYZW: function(index, x, y, z, w) {
                    return index *= this.itemSize,
                        this.array[index + 0] = x,
                        this.array[index + 1] = y,
                        this.array[index + 2] = z,
                        this.array[index + 3] = w,
                        this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            },
            THREE.Int8Attribute = function(array, itemSize) {
                return new THREE.BufferAttribute(new Int8Array(array),itemSize)
            }
            ,
            THREE.Uint8Attribute = function(array, itemSize) {
                return new THREE.BufferAttribute(new Uint8Array(array),itemSize)
            }
            ,
            THREE.Uint8ClampedAttribute = function(array, itemSize) {
                return new THREE.BufferAttribute(new Uint8ClampedArray(array),itemSize)
            }
            ,
            THREE.Int16Attribute = function(array, itemSize) {
                return new THREE.BufferAttribute(new Int16Array(array),itemSize)
            }
            ,
            THREE.Uint16Attribute = function(array, itemSize) {
                return new THREE.BufferAttribute(new Uint16Array(array),itemSize)
            }
            ,
            THREE.Int32Attribute = function(array, itemSize) {
                return new THREE.BufferAttribute(new Int32Array(array),itemSize)
            }
            ,
            THREE.Uint32Attribute = function(array, itemSize) {
                return new THREE.BufferAttribute(new Uint32Array(array),itemSize)
            }
            ,
            THREE.Float32Attribute = function(array, itemSize) {
                return new THREE.BufferAttribute(new Float32Array(array),itemSize)
            }
            ,
            THREE.Float64Attribute = function(array, itemSize) {
                return new THREE.BufferAttribute(new Float64Array(array),itemSize)
            }
            ,
            THREE.DynamicBufferAttribute = function(array, itemSize) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),
                    new THREE.BufferAttribute(array,itemSize).setDynamic(!0)
            }
            ,
            THREE.InstancedBufferAttribute = function(array, itemSize, meshPerAttribute) {
                THREE.BufferAttribute.call(this, array, itemSize),
                    this.meshPerAttribute = meshPerAttribute || 1
            }
            ,
            THREE.InstancedBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype),
            THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute,
            THREE.InstancedBufferAttribute.prototype.copy = function(source) {
                return THREE.BufferAttribute.prototype.copy.call(this, source),
                    this.meshPerAttribute = source.meshPerAttribute,
                    this
            }
            ,
            THREE.InterleavedBuffer = function(array, stride) {
                this.uuid = THREE.Math.generateUUID(),
                    this.array = array,
                    this.stride = stride,
                    this.dynamic = !1,
                    this.updateRange = {
                        offset: 0,
                        count: -1
                    },
                    this.version = 0
            }
            ,
            THREE.InterleavedBuffer.prototype = {
                constructor: THREE.InterleavedBuffer,
                get length() {
                    return this.array.length
                },
                get count() {
                    return this.array.length / this.stride
                },
                set needsUpdate(value) {
                    value === !0 && this.version++
                },
                setDynamic: function(value) {
                    return this.dynamic = value,
                        this
                },
                copy: function(source) {
                    return this.array = new source.array.constructor(source.array),
                        this.stride = source.stride,
                        this.dynamic = source.dynamic,
                        this
                },
                copyAt: function(index1, attribute, index2) {
                    index1 *= this.stride,
                        index2 *= attribute.stride;
                    for (var i = 0, l = this.stride; i < l; i++)
                        this.array[index1 + i] = attribute.array[index2 + i];
                    return this
                },
                set: function(value, offset) {
                    return void 0 === offset && (offset = 0),
                        this.array.set(value, offset),
                        this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            },
            THREE.InstancedInterleavedBuffer = function(array, stride, meshPerAttribute) {
                THREE.InterleavedBuffer.call(this, array, stride),
                    this.meshPerAttribute = meshPerAttribute || 1
            }
            ,
            THREE.InstancedInterleavedBuffer.prototype = Object.create(THREE.InterleavedBuffer.prototype),
            THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer,
            THREE.InstancedInterleavedBuffer.prototype.copy = function(source) {
                return THREE.InterleavedBuffer.prototype.copy.call(this, source),
                    this.meshPerAttribute = source.meshPerAttribute,
                    this
            }
            ,
            THREE.InterleavedBufferAttribute = function(interleavedBuffer, itemSize, offset) {
                this.uuid = THREE.Math.generateUUID(),
                    this.data = interleavedBuffer,
                    this.itemSize = itemSize,
                    this.offset = offset
            }
            ,
            THREE.InterleavedBufferAttribute.prototype = {
                constructor: THREE.InterleavedBufferAttribute,
                get length() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."),
                        this.array.length
                },
                get count() {
                    return this.data.count
                },
                setX: function(index, x) {
                    return this.data.array[index * this.data.stride + this.offset] = x,
                        this
                },
                setY: function(index, y) {
                    return this.data.array[index * this.data.stride + this.offset + 1] = y,
                        this
                },
                setZ: function(index, z) {
                    return this.data.array[index * this.data.stride + this.offset + 2] = z,
                        this
                },
                setW: function(index, w) {
                    return this.data.array[index * this.data.stride + this.offset + 3] = w,
                        this
                },
                getX: function(index) {
                    return this.data.array[index * this.data.stride + this.offset]
                },
                getY: function(index) {
                    return this.data.array[index * this.data.stride + this.offset + 1]
                },
                getZ: function(index) {
                    return this.data.array[index * this.data.stride + this.offset + 2]
                },
                getW: function(index) {
                    return this.data.array[index * this.data.stride + this.offset + 3]
                },
                setXY: function(index, x, y) {
                    return index = index * this.data.stride + this.offset,
                        this.data.array[index + 0] = x,
                        this.data.array[index + 1] = y,
                        this
                },
                setXYZ: function(index, x, y, z) {
                    return index = index * this.data.stride + this.offset,
                        this.data.array[index + 0] = x,
                        this.data.array[index + 1] = y,
                        this.data.array[index + 2] = z,
                        this
                },
                setXYZW: function(index, x, y, z, w) {
                    return index = index * this.data.stride + this.offset,
                        this.data.array[index + 0] = x,
                        this.data.array[index + 1] = y,
                        this.data.array[index + 2] = z,
                        this.data.array[index + 3] = w,
                        this
                }
            },
            THREE.Geometry = function() {
                Object.defineProperty(this, "id", {
                    value: THREE.GeometryIdCount++
                }),
                    this.uuid = THREE.Math.generateUUID(),
                    this.name = "",
                    this.type = "Geometry",
                    this.vertices = [],
                    this.colors = [],
                    this.faces = [],
                    this.faceVertexUvs = [[]],
                    this.morphTargets = [],
                    this.morphNormals = [],
                    this.skinWeights = [],
                    this.skinIndices = [],
                    this.lineDistances = [],
                    this.boundingBox = null,
                    this.boundingSphere = null,
                    this.verticesNeedUpdate = !1,
                    this.elementsNeedUpdate = !1,
                    this.uvsNeedUpdate = !1,
                    this.normalsNeedUpdate = !1,
                    this.colorsNeedUpdate = !1,
                    this.lineDistancesNeedUpdate = !1,
                    this.groupsNeedUpdate = !1
            }
            ,
            Object.assign(THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {
                applyMatrix: function(matrix) {
                    for (var normalMatrix = (new THREE.Matrix3).getNormalMatrix(matrix), i = 0, il = this.vertices.length; i < il; i++) {
                        var vertex = this.vertices[i];
                        vertex.applyMatrix4(matrix)
                    }
                    for (var i = 0, il = this.faces.length; i < il; i++) {
                        var face = this.faces[i];
                        face.normal.applyMatrix3(normalMatrix).normalize();
                        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++)
                            face.vertexNormals[j].applyMatrix3(normalMatrix).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(),
                    null !== this.boundingSphere && this.computeBoundingSphere(),
                        this.verticesNeedUpdate = !0,
                        this.normalsNeedUpdate = !0,
                        this
                },
                rotateX: function() {
                    var m1;
                    return function(angle) {
                        return void 0 === m1 && (m1 = new THREE.Matrix4),
                            m1.makeRotationX(angle),
                            this.applyMatrix(m1),
                            this
                    }
                }(),
                rotateY: function() {
                    var m1;
                    return function(angle) {
                        return void 0 === m1 && (m1 = new THREE.Matrix4),
                            m1.makeRotationY(angle),
                            this.applyMatrix(m1),
                            this
                    }
                }(),
                rotateZ: function() {
                    var m1;
                    return function(angle) {
                        return void 0 === m1 && (m1 = new THREE.Matrix4),
                            m1.makeRotationZ(angle),
                            this.applyMatrix(m1),
                            this
                    }
                }(),
                translate: function() {
                    var m1;
                    return function(x, y, z) {
                        return void 0 === m1 && (m1 = new THREE.Matrix4),
                            m1.makeTranslation(x, y, z),
                            this.applyMatrix(m1),
                            this
                    }
                }(),
                scale: function() {
                    var m1;
                    return function(x, y, z) {
                        return void 0 === m1 && (m1 = new THREE.Matrix4),
                            m1.makeScale(x, y, z),
                            this.applyMatrix(m1),
                            this
                    }
                }(),
                lookAt: function() {
                    var obj;
                    return function(vector) {
                        void 0 === obj && (obj = new THREE.Object3D),
                            obj.lookAt(vector),
                            obj.updateMatrix(),
                            this.applyMatrix(obj.matrix)
                    }
                }(),
                fromBufferGeometry: function(geometry) {
                    function addFace(a, b, c, materialIndex) {
                        var vertexNormals = void 0 !== normals ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : []
                            , vertexColors = void 0 !== colors ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : []
                            , face = new THREE.Face3(a,b,c,vertexNormals,vertexColors,materialIndex);
                        scope.faces.push(face),
                        void 0 !== uvs && scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]),
                        void 0 !== uvs2 && scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()])
                    }
                    var scope = this
                        , indices = null !== geometry.index ? geometry.index.array : void 0
                        , attributes = geometry.attributes
                        , positions = attributes.position.array
                        , normals = void 0 !== attributes.normal ? attributes.normal.array : void 0
                        , colors = void 0 !== attributes.color ? attributes.color.array : void 0
                        , uvs = void 0 !== attributes.uv ? attributes.uv.array : void 0
                        , uvs2 = void 0 !== attributes.uv2 ? attributes.uv2.array : void 0;
                    void 0 !== uvs2 && (this.faceVertexUvs[1] = []);
                    for (var tempNormals = [], tempUVs = [], tempUVs2 = [], i = 0, j = 0; i < positions.length; i += 3,
                        j += 2)
                        scope.vertices.push(new THREE.Vector3(positions[i],positions[i + 1],positions[i + 2])),
                        void 0 !== normals && tempNormals.push(new THREE.Vector3(normals[i],normals[i + 1],normals[i + 2])),
                        void 0 !== colors && scope.colors.push(new THREE.Color(colors[i],colors[i + 1],colors[i + 2])),
                        void 0 !== uvs && tempUVs.push(new THREE.Vector2(uvs[j],uvs[j + 1])),
                        void 0 !== uvs2 && tempUVs2.push(new THREE.Vector2(uvs2[j],uvs2[j + 1]));
                    if (void 0 !== indices) {
                        var groups = geometry.groups;
                        if (groups.length > 0)
                            for (var i = 0; i < groups.length; i++)
                                for (var group = groups[i], start = group.start, count = group.count, j = start, jl = start + count; j < jl; j += 3)
                                    addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
                        else
                            for (var i = 0; i < indices.length; i += 3)
                                addFace(indices[i], indices[i + 1], indices[i + 2])
                    } else
                        for (var i = 0; i < positions.length / 3; i += 3)
                            addFace(i, i + 1, i + 2);
                    return this.computeFaceNormals(),
                    null !== geometry.boundingBox && (this.boundingBox = geometry.boundingBox.clone()),
                    null !== geometry.boundingSphere && (this.boundingSphere = geometry.boundingSphere.clone()),
                        this
                },
                center: function() {
                    this.computeBoundingBox();
                    var offset = this.boundingBox.center().negate();
                    return this.translate(offset.x, offset.y, offset.z),
                        offset
                },
                normalize: function() {
                    this.computeBoundingSphere();
                    var center = this.boundingSphere.center
                        , radius = this.boundingSphere.radius
                        , s = 0 === radius ? 1 : 1 / radius
                        , matrix = new THREE.Matrix4;
                    return matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1),
                        this.applyMatrix(matrix),
                        this
                },
                computeFaceNormals: function() {
                    for (var cb = new THREE.Vector3, ab = new THREE.Vector3, f = 0, fl = this.faces.length; f < fl; f++) {
                        var face = this.faces[f]
                            , vA = this.vertices[face.a]
                            , vB = this.vertices[face.b]
                            , vC = this.vertices[face.c];
                        cb.subVectors(vC, vB),
                            ab.subVectors(vA, vB),
                            cb.cross(ab),
                            cb.normalize(),
                            face.normal.copy(cb)
                    }
                },
                computeVertexNormals: function(areaWeighted) {
                    void 0 === areaWeighted && (areaWeighted = !0);
                    var v, vl, f, fl, face, vertices;
                    for (vertices = new Array(this.vertices.length),
                             v = 0,
                             vl = this.vertices.length; v < vl; v++)
                        vertices[v] = new THREE.Vector3;
                    if (areaWeighted) {
                        var vA, vB, vC, cb = new THREE.Vector3, ab = new THREE.Vector3;
                        for (f = 0,
                                 fl = this.faces.length; f < fl; f++)
                            face = this.faces[f],
                                vA = this.vertices[face.a],
                                vB = this.vertices[face.b],
                                vC = this.vertices[face.c],
                                cb.subVectors(vC, vB),
                                ab.subVectors(vA, vB),
                                cb.cross(ab),
                                vertices[face.a].add(cb),
                                vertices[face.b].add(cb),
                                vertices[face.c].add(cb)
                    } else
                        for (f = 0,
                                 fl = this.faces.length; f < fl; f++)
                            face = this.faces[f],
                                vertices[face.a].add(face.normal),
                                vertices[face.b].add(face.normal),
                                vertices[face.c].add(face.normal);
                    for (v = 0,
                             vl = this.vertices.length; v < vl; v++)
                        vertices[v].normalize();
                    for (f = 0,
                             fl = this.faces.length; f < fl; f++) {
                        face = this.faces[f];
                        var vertexNormals = face.vertexNormals;
                        3 === vertexNormals.length ? (vertexNormals[0].copy(vertices[face.a]),
                            vertexNormals[1].copy(vertices[face.b]),
                            vertexNormals[2].copy(vertices[face.c])) : (vertexNormals[0] = vertices[face.a].clone(),
                            vertexNormals[1] = vertices[face.b].clone(),
                            vertexNormals[2] = vertices[face.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    var i, il, f, fl, face;
                    for (f = 0,
                             fl = this.faces.length; f < fl; f++)
                        for (face = this.faces[f],
                                 face.__originalFaceNormal ? face.__originalFaceNormal.copy(face.normal) : face.__originalFaceNormal = face.normal.clone(),
                             face.__originalVertexNormals || (face.__originalVertexNormals = []),
                                 i = 0,
                                 il = face.vertexNormals.length; i < il; i++)
                            face.__originalVertexNormals[i] ? face.__originalVertexNormals[i].copy(face.vertexNormals[i]) : face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                    var tmpGeo = new THREE.Geometry;
                    for (tmpGeo.faces = this.faces,
                             i = 0,
                             il = this.morphTargets.length; i < il; i++) {
                        if (!this.morphNormals[i]) {
                            this.morphNormals[i] = {},
                                this.morphNormals[i].faceNormals = [],
                                this.morphNormals[i].vertexNormals = [];
                            var faceNormal, vertexNormals, dstNormalsFace = this.morphNormals[i].faceNormals, dstNormalsVertex = this.morphNormals[i].vertexNormals;
                            for (f = 0,
                                     fl = this.faces.length; f < fl; f++)
                                faceNormal = new THREE.Vector3,
                                    vertexNormals = {
                                        a: new THREE.Vector3,
                                        b: new THREE.Vector3,
                                        c: new THREE.Vector3
                                    },
                                    dstNormalsFace.push(faceNormal),
                                    dstNormalsVertex.push(vertexNormals)
                        }
                        var morphNormals = this.morphNormals[i];
                        tmpGeo.vertices = this.morphTargets[i].vertices,
                            tmpGeo.computeFaceNormals(),
                            tmpGeo.computeVertexNormals();
                        var faceNormal, vertexNormals;
                        for (f = 0,
                                 fl = this.faces.length; f < fl; f++)
                            face = this.faces[f],
                                faceNormal = morphNormals.faceNormals[f],
                                vertexNormals = morphNormals.vertexNormals[f],
                                faceNormal.copy(face.normal),
                                vertexNormals.a.copy(face.vertexNormals[0]),
                                vertexNormals.b.copy(face.vertexNormals[1]),
                                vertexNormals.c.copy(face.vertexNormals[2])
                    }
                    for (f = 0,
                             fl = this.faces.length; f < fl; f++)
                        face = this.faces[f],
                            face.normal = face.__originalFaceNormal,
                            face.vertexNormals = face.__originalVertexNormals
                },
                computeTangents: function() {
                    console.warn("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function() {
                    for (var d = 0, vertices = this.vertices, i = 0, il = vertices.length; i < il; i++)
                        i > 0 && (d += vertices[i].distanceTo(vertices[i - 1])),
                            this.lineDistances[i] = d
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new THREE.Box3),
                        this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere),
                        this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(geometry, matrix, materialIndexOffset) {
                    if (geometry instanceof THREE.Geometry == !1)
                        return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
                    var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0];
                    void 0 === materialIndexOffset && (materialIndexOffset = 0),
                    void 0 !== matrix && (normalMatrix = (new THREE.Matrix3).getNormalMatrix(matrix));
                    for (var i = 0, il = vertices2.length; i < il; i++) {
                        var vertex = vertices2[i]
                            , vertexCopy = vertex.clone();
                        void 0 !== matrix && vertexCopy.applyMatrix4(matrix),
                            vertices1.push(vertexCopy)
                    }
                    for (i = 0,
                             il = faces2.length; i < il; i++) {
                        var faceCopy, normal, color, face = faces2[i], faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
                        faceCopy = new THREE.Face3(face.a + vertexOffset,face.b + vertexOffset,face.c + vertexOffset),
                            faceCopy.normal.copy(face.normal),
                        void 0 !== normalMatrix && faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                        for (var j = 0, jl = faceVertexNormals.length; j < jl; j++)
                            normal = faceVertexNormals[j].clone(),
                            void 0 !== normalMatrix && normal.applyMatrix3(normalMatrix).normalize(),
                                faceCopy.vertexNormals.push(normal);
                        faceCopy.color.copy(face.color);
                        for (var j = 0, jl = faceVertexColors.length; j < jl; j++)
                            color = faceVertexColors[j],
                                faceCopy.vertexColors.push(color.clone());
                        faceCopy.materialIndex = face.materialIndex + materialIndexOffset,
                            faces1.push(faceCopy)
                    }
                    for (i = 0,
                             il = uvs2.length; i < il; i++) {
                        var uv = uvs2[i]
                            , uvCopy = [];
                        if (void 0 !== uv) {
                            for (var j = 0, jl = uv.length; j < jl; j++)
                                uvCopy.push(uv[j].clone());
                            uvs1.push(uvCopy)
                        }
                    }
                },
                mergeMesh: function(mesh) {
                    return mesh instanceof THREE.Mesh == !1 ? void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh) : (mesh.matrixAutoUpdate && mesh.updateMatrix(),
                        void this.merge(mesh.geometry, mesh.matrix))
                },
                mergeVertices: function() {
                    var v, key, i, il, face, indices, j, jl, verticesMap = {}, unique = [], changes = [], precisionPoints = 4, precision = Math.pow(10, precisionPoints);
                    for (i = 0,
                             il = this.vertices.length; i < il; i++)
                        v = this.vertices[i],
                            key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision),
                            void 0 === verticesMap[key] ? (verticesMap[key] = i,
                                unique.push(this.vertices[i]),
                                changes[i] = unique.length - 1) : changes[i] = changes[verticesMap[key]];
                    var faceIndicesToRemove = [];
                    for (i = 0,
                             il = this.faces.length; i < il; i++) {
                        face = this.faces[i],
                            face.a = changes[face.a],
                            face.b = changes[face.b],
                            face.c = changes[face.c],
                            indices = [face.a, face.b, face.c];
                        for (var dupIndex = -1, n = 0; n < 3; n++)
                            if (indices[n] === indices[(n + 1) % 3]) {
                                dupIndex = n,
                                    faceIndicesToRemove.push(i);
                                break
                            }
                    }
                    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                        var idx = faceIndicesToRemove[i];
                        for (this.faces.splice(idx, 1),
                                 j = 0,
                                 jl = this.faceVertexUvs.length; j < jl; j++)
                            this.faceVertexUvs[j].splice(idx, 1)
                    }
                    var diff = this.vertices.length - unique.length;
                    return this.vertices = unique,
                        diff
                },
                sortFacesByMaterialIndex: function() {
                    function materialIndexSort(a, b) {
                        return a.materialIndex - b.materialIndex
                    }
                    for (var faces = this.faces, length = faces.length, i = 0; i < length; i++)
                        faces[i]._id = i;
                    faces.sort(materialIndexSort);
                    var newUvs1, newUvs2, uvs1 = this.faceVertexUvs[0], uvs2 = this.faceVertexUvs[1];
                    uvs1 && uvs1.length === length && (newUvs1 = []),
                    uvs2 && uvs2.length === length && (newUvs2 = []);
                    for (var i = 0; i < length; i++) {
                        var id = faces[i]._id;
                        newUvs1 && newUvs1.push(uvs1[id]),
                        newUvs2 && newUvs2.push(uvs2[id])
                    }
                    newUvs1 && (this.faceVertexUvs[0] = newUvs1),
                    newUvs2 && (this.faceVertexUvs[1] = newUvs2)
                },
                toJSON: function() {
                    function setBit(value, position, enabled) {
                        return enabled ? value | 1 << position : value & ~(1 << position)
                    }
                    function getNormalIndex(normal) {
                        var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
                        return void 0 !== normalsHash[hash] ? normalsHash[hash] : (normalsHash[hash] = normals.length / 3,
                            normals.push(normal.x, normal.y, normal.z),
                            normalsHash[hash])
                    }
                    function getColorIndex(color) {
                        var hash = color.r.toString() + color.g.toString() + color.b.toString();
                        return void 0 !== colorsHash[hash] ? colorsHash[hash] : (colorsHash[hash] = colors.length,
                            colors.push(color.getHex()),
                            colorsHash[hash])
                    }
                    function getUvIndex(uv) {
                        var hash = uv.x.toString() + uv.y.toString();
                        return void 0 !== uvsHash[hash] ? uvsHash[hash] : (uvsHash[hash] = uvs.length / 2,
                            uvs.push(uv.x, uv.y),
                            uvsHash[hash])
                    }
                    var data = {
                        metadata: {
                            version: 4.4,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (data.uuid = this.uuid,
                            data.type = this.type,
                        "" !== this.name && (data.name = this.name),
                        void 0 !== this.parameters) {
                        var parameters = this.parameters;
                        for (var key in parameters)
                            void 0 !== parameters[key] && (data[key] = parameters[key]);
                        return data
                    }
                    for (var vertices = [], i = 0; i < this.vertices.length; i++) {
                        var vertex = this.vertices[i];
                        vertices.push(vertex.x, vertex.y, vertex.z)
                    }
                    for (var faces = [], normals = [], normalsHash = {}, colors = [], colorsHash = {}, uvs = [], uvsHash = {}, i = 0; i < this.faces.length; i++) {
                        var face = this.faces[i]
                            , hasMaterial = !0
                            , hasFaceUv = !1
                            , hasFaceVertexUv = void 0 !== this.faceVertexUvs[0][i]
                            , hasFaceNormal = face.normal.length() > 0
                            , hasFaceVertexNormal = face.vertexNormals.length > 0
                            , hasFaceColor = 1 !== face.color.r || 1 !== face.color.g || 1 !== face.color.b
                            , hasFaceVertexColor = face.vertexColors.length > 0
                            , faceType = 0;
                        if (faceType = setBit(faceType, 0, 0),
                                faceType = setBit(faceType, 1, hasMaterial),
                                faceType = setBit(faceType, 2, hasFaceUv),
                                faceType = setBit(faceType, 3, hasFaceVertexUv),
                                faceType = setBit(faceType, 4, hasFaceNormal),
                                faceType = setBit(faceType, 5, hasFaceVertexNormal),
                                faceType = setBit(faceType, 6, hasFaceColor),
                                faceType = setBit(faceType, 7, hasFaceVertexColor),
                                faces.push(faceType),
                                faces.push(face.a, face.b, face.c),
                                faces.push(face.materialIndex),
                                hasFaceVertexUv) {
                            var faceVertexUvs = this.faceVertexUvs[0][i];
                            faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]))
                        }
                        if (hasFaceNormal && faces.push(getNormalIndex(face.normal)),
                                hasFaceVertexNormal) {
                            var vertexNormals = face.vertexNormals;
                            faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]))
                        }
                        if (hasFaceColor && faces.push(getColorIndex(face.color)),
                                hasFaceVertexColor) {
                            var vertexColors = face.vertexColors;
                            faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]))
                        }
                    }
                    return data.data = {},
                        data.data.vertices = vertices,
                        data.data.normals = normals,
                    colors.length > 0 && (data.data.colors = colors),
                    uvs.length > 0 && (data.data.uvs = [uvs]),
                        data.data.faces = faces,
                        data
                },
                clone: function() {
                    return (new THREE.Geometry).copy(this)
                },
                copy: function(source) {
                    this.vertices = [],
                        this.faces = [],
                        this.faceVertexUvs = [[]];
                    for (var vertices = source.vertices, i = 0, il = vertices.length; i < il; i++)
                        this.vertices.push(vertices[i].clone());
                    for (var faces = source.faces, i = 0, il = faces.length; i < il; i++)
                        this.faces.push(faces[i].clone());
                    for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {
                        var faceVertexUvs = source.faceVertexUvs[i];
                        void 0 === this.faceVertexUvs[i] && (this.faceVertexUvs[i] = []);
                        for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                            for (var uvs = faceVertexUvs[j], uvsCopy = [], k = 0, kl = uvs.length; k < kl; k++) {
                                var uv = uvs[k];
                                uvsCopy.push(uv.clone())
                            }
                            this.faceVertexUvs[i].push(uvsCopy)
                        }
                    }
                    return this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }),
            THREE.GeometryIdCount = 0,
        THREE.DirectGeometry = function() {
            Object.defineProperty(this, "id", {
                value: THREE.GeometryIdCount++
            }),
                this.uuid = THREE.Math.generateUUID(),
                this.name = "",
                this.type = "DirectGeometry",
                this.indices = [],
                this.vertices = [],
                this.normals = [],
                this.colors = [],
                this.uvs = [],
                this.uvs2 = [],
                this.groups = [],
                this.morphTargets = {},
                this.skinWeights = [],
                this.skinIndices = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.verticesNeedUpdate = !1,
                this.normalsNeedUpdate = !1,
                this.colorsNeedUpdate = !1,
                this.uvsNeedUpdate = !1,
                this.groupsNeedUpdate = !1
        }
        ,
        Object.assign(THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {
            computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
            computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
            computeFaceNormals: function() {
                console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.")
            },
            computeVertexNormals: function() {
                console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.")
            },
            computeGroups: function(geometry) {
                for (var group, materialIndex, groups = [], faces = geometry.faces, i = 0; i < faces.length; i++) {
                    var face = faces[i];
                    face.materialIndex !== materialIndex && (materialIndex = face.materialIndex,
                    void 0 !== group && (group.count = 3 * i - group.start,
                        groups.push(group)),
                        group = {
                            start: 3 * i,
                            materialIndex: materialIndex
                        })
                }
                void 0 !== group && (group.count = 3 * i - group.start,
                    groups.push(group)),
                    this.groups = groups
            },
            fromGeometry: function(geometry) {
                var morphTargetsPosition, faces = geometry.faces, vertices = geometry.vertices, faceVertexUvs = geometry.faceVertexUvs, hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0, hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0, morphTargets = geometry.morphTargets, morphTargetsLength = morphTargets.length;
                if (morphTargetsLength > 0) {
                    morphTargetsPosition = [];
                    for (var i = 0; i < morphTargetsLength; i++)
                        morphTargetsPosition[i] = [];
                    this.morphTargets.position = morphTargetsPosition
                }
                var morphTargetsNormal, morphNormals = geometry.morphNormals, morphNormalsLength = morphNormals.length;
                if (morphNormalsLength > 0) {
                    morphTargetsNormal = [];
                    for (var i = 0; i < morphNormalsLength; i++)
                        morphTargetsNormal[i] = [];
                    this.morphTargets.normal = morphTargetsNormal
                }
                for (var skinIndices = geometry.skinIndices, skinWeights = geometry.skinWeights, hasSkinIndices = skinIndices.length === vertices.length, hasSkinWeights = skinWeights.length === vertices.length, i = 0; i < faces.length; i++) {
                    var face = faces[i];
                    this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
                    var vertexNormals = face.vertexNormals;
                    if (3 === vertexNormals.length)
                        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
                    else {
                        var normal = face.normal;
                        this.normals.push(normal, normal, normal)
                    }
                    var vertexColors = face.vertexColors;
                    if (3 === vertexColors.length)
                        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
                    else {
                        var color = face.color;
                        this.colors.push(color, color, color)
                    }
                    if (hasFaceVertexUv === !0) {
                        var vertexUvs = faceVertexUvs[0][i];
                        void 0 !== vertexUvs ? this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i),
                            this.uvs.push(new THREE.Vector2, new THREE.Vector2, new THREE.Vector2))
                    }
                    if (hasFaceVertexUv2 === !0) {
                        var vertexUvs = faceVertexUvs[1][i];
                        void 0 !== vertexUvs ? this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i),
                            this.uvs2.push(new THREE.Vector2, new THREE.Vector2, new THREE.Vector2))
                    }
                    for (var j = 0; j < morphTargetsLength; j++) {
                        var morphTarget = morphTargets[j].vertices;
                        morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c])
                    }
                    for (var j = 0; j < morphNormalsLength; j++) {
                        var morphNormal = morphNormals[j].vertexNormals[i];
                        morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c)
                    }
                    hasSkinIndices && this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]),
                    hasSkinWeights && this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c])
                }
                return this.computeGroups(geometry),
                    this.verticesNeedUpdate = geometry.verticesNeedUpdate,
                    this.normalsNeedUpdate = geometry.normalsNeedUpdate,
                    this.colorsNeedUpdate = geometry.colorsNeedUpdate,
                    this.uvsNeedUpdate = geometry.uvsNeedUpdate,
                    this.groupsNeedUpdate = geometry.groupsNeedUpdate,
                    this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }),
        THREE.BufferGeometry = function() {
            Object.defineProperty(this, "id", {
                value: THREE.GeometryIdCount++
            }),
                this.uuid = THREE.Math.generateUUID(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }
        }
        ,
        Object.assign(THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {
            getIndex: function() {
                return this.index
            },
            setIndex: function(index) {
                this.index = index
            },
            addAttribute: function(name, attribute) {
                return attribute instanceof THREE.BufferAttribute == !1 && attribute instanceof THREE.InterleavedBufferAttribute == !1 ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
                    void this.addAttribute(name, new THREE.BufferAttribute(arguments[1],arguments[2]))) : "index" === name ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
                    void this.setIndex(attribute)) : (this.attributes[name] = attribute,
                    this)
            },
            getAttribute: function(name) {
                return this.attributes[name]
            },
            removeAttribute: function(name) {
                return delete this.attributes[name],
                    this
            },
            addGroup: function(start, count, materialIndex) {
                this.groups.push({
                    start: start,
                    count: count,
                    materialIndex: void 0 !== materialIndex ? materialIndex : 0
                })
            },
            clearGroups: function() {
                this.groups = []
            },
            setDrawRange: function(start, count) {
                this.drawRange.start = start,
                    this.drawRange.count = count
            },
            applyMatrix: function(matrix) {
                var position = this.attributes.position;
                void 0 !== position && (matrix.applyToVector3Array(position.array),
                    position.needsUpdate = !0);
                var normal = this.attributes.normal;
                if (void 0 !== normal) {
                    var normalMatrix = (new THREE.Matrix3).getNormalMatrix(matrix);
                    normalMatrix.applyToVector3Array(normal.array),
                        normal.needsUpdate = !0
                }
                return null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                    this
            },
            rotateX: function() {
                var m1;
                return function(angle) {
                    return void 0 === m1 && (m1 = new THREE.Matrix4),
                        m1.makeRotationX(angle),
                        this.applyMatrix(m1),
                        this
                }
            }(),
            rotateY: function() {
                var m1;
                return function(angle) {
                    return void 0 === m1 && (m1 = new THREE.Matrix4),
                        m1.makeRotationY(angle),
                        this.applyMatrix(m1),
                        this
                }
            }(),
            rotateZ: function() {
                var m1;
                return function(angle) {
                    return void 0 === m1 && (m1 = new THREE.Matrix4),
                        m1.makeRotationZ(angle),
                        this.applyMatrix(m1),
                        this
                }
            }(),
            translate: function() {
                var m1;
                return function(x, y, z) {
                    return void 0 === m1 && (m1 = new THREE.Matrix4),
                        m1.makeTranslation(x, y, z),
                        this.applyMatrix(m1),
                        this
                }
            }(),
            scale: function() {
                var m1;
                return function(x, y, z) {
                    return void 0 === m1 && (m1 = new THREE.Matrix4),
                        m1.makeScale(x, y, z),
                        this.applyMatrix(m1),
                        this
                }
            }(),
            lookAt: function() {
                var obj;
                return function(vector) {
                    void 0 === obj && (obj = new THREE.Object3D),
                        obj.lookAt(vector),
                        obj.updateMatrix(),
                        this.applyMatrix(obj.matrix)
                }
            }(),
            center: function() {
                this.computeBoundingBox();
                var offset = this.boundingBox.center().negate();
                return this.translate(offset.x, offset.y, offset.z),
                    offset
            },
            setFromObject: function(object) {
                var geometry = object.geometry;
                if (object instanceof THREE.Points || object instanceof THREE.Line) {
                    var positions = new THREE.Float32Attribute(3 * geometry.vertices.length,3)
                        , colors = new THREE.Float32Attribute(3 * geometry.colors.length,3);
                    if (this.addAttribute("position", positions.copyVector3sArray(geometry.vertices)),
                            this.addAttribute("color", colors.copyColorsArray(geometry.colors)),
                        geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                        var lineDistances = new THREE.Float32Attribute(geometry.lineDistances.length,1);
                        this.addAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances))
                    }
                    null !== geometry.boundingSphere && (this.boundingSphere = geometry.boundingSphere.clone()),
                    null !== geometry.boundingBox && (this.boundingBox = geometry.boundingBox.clone())
                } else
                    object instanceof THREE.Mesh && geometry instanceof THREE.Geometry && this.fromGeometry(geometry);
                return this
            },
            updateFromObject: function(object) {
                var geometry = object.geometry;
                if (object instanceof THREE.Mesh) {
                    var direct = geometry.__directGeometry;
                    if (void 0 === direct)
                        return this.fromGeometry(geometry);
                    direct.verticesNeedUpdate = geometry.verticesNeedUpdate,
                        direct.normalsNeedUpdate = geometry.normalsNeedUpdate,
                        direct.colorsNeedUpdate = geometry.colorsNeedUpdate,
                        direct.uvsNeedUpdate = geometry.uvsNeedUpdate,
                        direct.groupsNeedUpdate = geometry.groupsNeedUpdate,
                        geometry.verticesNeedUpdate = !1,
                        geometry.normalsNeedUpdate = !1,
                        geometry.colorsNeedUpdate = !1,
                        geometry.uvsNeedUpdate = !1,
                        geometry.groupsNeedUpdate = !1,
                        geometry = direct
                }
                if (geometry.verticesNeedUpdate === !0) {
                    var attribute = this.attributes.position;
                    void 0 !== attribute && (attribute.copyVector3sArray(geometry.vertices),
                        attribute.needsUpdate = !0),
                        geometry.verticesNeedUpdate = !1
                }
                if (geometry.normalsNeedUpdate === !0) {
                    var attribute = this.attributes.normal;
                    void 0 !== attribute && (attribute.copyVector3sArray(geometry.normals),
                        attribute.needsUpdate = !0),
                        geometry.normalsNeedUpdate = !1
                }
                if (geometry.colorsNeedUpdate === !0) {
                    var attribute = this.attributes.color;
                    void 0 !== attribute && (attribute.copyColorsArray(geometry.colors),
                        attribute.needsUpdate = !0),
                        geometry.colorsNeedUpdate = !1
                }
                if (geometry.uvsNeedUpdate) {
                    var attribute = this.attributes.uv;
                    void 0 !== attribute && (attribute.copyVector2sArray(geometry.uvs),
                        attribute.needsUpdate = !0),
                        geometry.uvsNeedUpdate = !1
                }
                if (geometry.lineDistancesNeedUpdate) {
                    var attribute = this.attributes.lineDistance;
                    void 0 !== attribute && (attribute.copyArray(geometry.lineDistances),
                        attribute.needsUpdate = !0),
                        geometry.lineDistancesNeedUpdate = !1
                }
                return geometry.groupsNeedUpdate && (geometry.computeGroups(object.geometry),
                    this.groups = geometry.groups,
                    geometry.groupsNeedUpdate = !1),
                    this
            },
            fromGeometry: function(geometry) {
                return geometry.__directGeometry = (new THREE.DirectGeometry).fromGeometry(geometry),
                    this.fromDirectGeometry(geometry.__directGeometry)
            },
            fromDirectGeometry: function(geometry) {
                var positions = new Float32Array(3 * geometry.vertices.length);
                if (this.addAttribute("position", new THREE.BufferAttribute(positions,3).copyVector3sArray(geometry.vertices)),
                    geometry.normals.length > 0) {
                    var normals = new Float32Array(3 * geometry.normals.length);
                    this.addAttribute("normal", new THREE.BufferAttribute(normals,3).copyVector3sArray(geometry.normals))
                }
                if (geometry.colors.length > 0) {
                    var colors = new Float32Array(3 * geometry.colors.length);
                    this.addAttribute("color", new THREE.BufferAttribute(colors,3).copyColorsArray(geometry.colors))
                }
                if (geometry.uvs.length > 0) {
                    var uvs = new Float32Array(2 * geometry.uvs.length);
                    this.addAttribute("uv", new THREE.BufferAttribute(uvs,2).copyVector2sArray(geometry.uvs))
                }
                if (geometry.uvs2.length > 0) {
                    var uvs2 = new Float32Array(2 * geometry.uvs2.length);
                    this.addAttribute("uv2", new THREE.BufferAttribute(uvs2,2).copyVector2sArray(geometry.uvs2))
                }
                if (geometry.indices.length > 0) {
                    var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array
                        , indices = new TypeArray(3 * geometry.indices.length);
                    this.setIndex(new THREE.BufferAttribute(indices,1).copyIndicesArray(geometry.indices))
                }
                this.groups = geometry.groups;
                for (var name in geometry.morphTargets) {
                    for (var array = [], morphTargets = geometry.morphTargets[name], i = 0, l = morphTargets.length; i < l; i++) {
                        var morphTarget = morphTargets[i]
                            , attribute = new THREE.Float32Attribute(3 * morphTarget.length,3);
                        array.push(attribute.copyVector3sArray(morphTarget))
                    }
                    this.morphAttributes[name] = array
                }
                if (geometry.skinIndices.length > 0) {
                    var skinIndices = new THREE.Float32Attribute(4 * geometry.skinIndices.length,4);
                    this.addAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices))
                }
                if (geometry.skinWeights.length > 0) {
                    var skinWeights = new THREE.Float32Attribute(4 * geometry.skinWeights.length,4);
                    this.addAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights))
                }
                return null !== geometry.boundingSphere && (this.boundingSphere = geometry.boundingSphere.clone()),
                null !== geometry.boundingBox && (this.boundingBox = geometry.boundingBox.clone()),
                    this
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new THREE.Box3);
                var positions = this.attributes.position.array;
                void 0 !== positions ? this.boundingBox.setFromArray(positions) : this.boundingBox.makeEmpty(),
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: function() {
                var box = new THREE.Box3
                    , vector = new THREE.Vector3;
                return function() {
                    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
                    var positions = this.attributes.position;
                    if (positions) {
                        var array = positions.array
                            , center = this.boundingSphere.center;
                        box.setFromArray(array),
                            box.center(center);
                        for (var maxRadiusSq = 0, i = 0, il = array.length; i < il; i += 3)
                            vector.fromArray(array, i),
                                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
                        this.boundingSphere.radius = Math.sqrt(maxRadiusSq),
                        isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
            }(),
            computeFaceNormals: function() {},
            computeVertexNormals: function() {
                var index = this.index
                    , attributes = this.attributes
                    , groups = this.groups;
                if (attributes.position) {
                    var positions = attributes.position.array;
                    if (void 0 === attributes.normal)
                        this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(positions.length),3));
                    else
                        for (var array = attributes.normal.array, i = 0, il = array.length; i < il; i++)
                            array[i] = 0;
                    var vA, vB, vC, normals = attributes.normal.array, pA = new THREE.Vector3, pB = new THREE.Vector3, pC = new THREE.Vector3, cb = new THREE.Vector3, ab = new THREE.Vector3;
                    if (index) {
                        var indices = index.array;
                        0 === groups.length && this.addGroup(0, indices.length);
                        for (var j = 0, jl = groups.length; j < jl; ++j)
                            for (var group = groups[j], start = group.start, count = group.count, i = start, il = start + count; i < il; i += 3)
                                vA = 3 * indices[i + 0],
                                    vB = 3 * indices[i + 1],
                                    vC = 3 * indices[i + 2],
                                    pA.fromArray(positions, vA),
                                    pB.fromArray(positions, vB),
                                    pC.fromArray(positions, vC),
                                    cb.subVectors(pC, pB),
                                    ab.subVectors(pA, pB),
                                    cb.cross(ab),
                                    normals[vA] += cb.x,
                                    normals[vA + 1] += cb.y,
                                    normals[vA + 2] += cb.z,
                                    normals[vB] += cb.x,
                                    normals[vB + 1] += cb.y,
                                    normals[vB + 2] += cb.z,
                                    normals[vC] += cb.x,
                                    normals[vC + 1] += cb.y,
                                    normals[vC + 2] += cb.z
                    } else
                        for (var i = 0, il = positions.length; i < il; i += 9)
                            pA.fromArray(positions, i),
                                pB.fromArray(positions, i + 3),
                                pC.fromArray(positions, i + 6),
                                cb.subVectors(pC, pB),
                                ab.subVectors(pA, pB),
                                cb.cross(ab),
                                normals[i] = cb.x,
                                normals[i + 1] = cb.y,
                                normals[i + 2] = cb.z,
                                normals[i + 3] = cb.x,
                                normals[i + 4] = cb.y,
                                normals[i + 5] = cb.z,
                                normals[i + 6] = cb.x,
                                normals[i + 7] = cb.y,
                                normals[i + 8] = cb.z;
                    this.normalizeNormals(),
                        attributes.normal.needsUpdate = !0
                }
            },
            merge: function(geometry, offset) {
                if (geometry instanceof THREE.BufferGeometry == !1)
                    return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
                void 0 === offset && (offset = 0);
                var attributes = this.attributes;
                for (var key in attributes)
                    if (void 0 !== geometry.attributes[key])
                        for (var attribute1 = attributes[key], attributeArray1 = attribute1.array, attribute2 = geometry.attributes[key], attributeArray2 = attribute2.array, attributeSize = attribute2.itemSize, i = 0, j = attributeSize * offset; i < attributeArray2.length; i++,
                            j++)
                            attributeArray1[j] = attributeArray2[i];
                return this
            },
            normalizeNormals: function() {
                for (var x, y, z, n, normals = this.attributes.normal.array, i = 0, il = normals.length; i < il; i += 3)
                    x = normals[i],
                        y = normals[i + 1],
                        z = normals[i + 2],
                        n = 1 / Math.sqrt(x * x + y * y + z * z),
                        normals[i] *= n,
                        normals[i + 1] *= n,
                        normals[i + 2] *= n
            },
            toNonIndexed: function() {
                if (null === this.index)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                        this;
                var geometry2 = new THREE.BufferGeometry
                    , indices = this.index.array
                    , attributes = this.attributes;
                for (var name in attributes) {
                    for (var attribute = attributes[name], array = attribute.array, itemSize = attribute.itemSize, array2 = new array.constructor(indices.length * itemSize), index = 0, index2 = 0, i = 0, l = indices.length; i < l; i++) {
                        index = indices[i] * itemSize;
                        for (var j = 0; j < itemSize; j++)
                            array2[index2++] = array[index++]
                    }
                    geometry2.addAttribute(name, new THREE.BufferAttribute(array2,itemSize))
                }
                return geometry2
            },
            toJSON: function() {
                var data = {
                    metadata: {
                        version: 4.4,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (data.uuid = this.uuid,
                        data.type = this.type,
                    "" !== this.name && (data.name = this.name),
                    void 0 !== this.parameters) {
                    var parameters = this.parameters;
                    for (var key in parameters)
                        void 0 !== parameters[key] && (data[key] = parameters[key]);
                    return data
                }
                data.data = {
                    attributes: {}
                };
                var index = this.index;
                if (null !== index) {
                    var array = Array.prototype.slice.call(index.array);
                    data.data.index = {
                        type: index.array.constructor.name,
                        array: array
                    }
                }
                var attributes = this.attributes;
                for (var key in attributes) {
                    var attribute = attributes[key]
                        , array = Array.prototype.slice.call(attribute.array);
                    data.data.attributes[key] = {
                        itemSize: attribute.itemSize,
                        type: attribute.array.constructor.name,
                        array: array,
                        normalized: attribute.normalized
                    }
                }
                var groups = this.groups;
                groups.length > 0 && (data.data.groups = JSON.parse(JSON.stringify(groups)));
                var boundingSphere = this.boundingSphere;
                return null !== boundingSphere && (data.data.boundingSphere = {
                    center: boundingSphere.center.toArray(),
                    radius: boundingSphere.radius
                }),
                    data
            },
            clone: function() {
                return (new THREE.BufferGeometry).copy(this)
            },
            copy: function(source) {
                var index = source.index;
                null !== index && this.setIndex(index.clone());
                var attributes = source.attributes;
                for (var name in attributes) {
                    var attribute = attributes[name];
                    this.addAttribute(name, attribute.clone())
                }
                for (var groups = source.groups, i = 0, l = groups.length; i < l; i++) {
                    var group = groups[i];
                    this.addGroup(group.start, group.count, group.materialIndex)
                }
                return this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }),
        THREE.BufferGeometry.MaxIndex = 65535,
        THREE.InstancedBufferGeometry = function() {
            THREE.BufferGeometry.call(this),
                this.type = "InstancedBufferGeometry",
                this.maxInstancedCount = void 0
        }
        ,
        THREE.InstancedBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
        THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry,
        THREE.InstancedBufferGeometry.prototype.addGroup = function(start, count, instances) {
            this.groups.push({
                start: start,
                count: count,
                instances: instances
            })
        }
        ,
        THREE.InstancedBufferGeometry.prototype.copy = function(source) {
            var index = source.index;
            null !== index && this.setIndex(index.clone());
            var attributes = source.attributes;
            for (var name in attributes) {
                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone())
            }
            for (var groups = source.groups, i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                this.addGroup(group.start, group.count, group.instances)
            }
            return this
        }
        ,
        THREE.Uniform = function(value) {
            "string" == typeof value && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
                value = arguments[1]),
                this.value = value,
                this.dynamic = !1
        }
        ,
        THREE.Uniform.prototype = {
            constructor: THREE.Uniform,
            onUpdate: function(callback) {
                return this.dynamic = !0,
                    this.onUpdateCallback = callback,
                    this
            }
        },
        THREE.AnimationAction = function() {
            throw new Error("THREE.AnimationAction: Use mixer.clipAction for construction.")
        }
        ,
        THREE.AnimationAction._new = function(mixer, clip, localRoot) {
            this._mixer = mixer,
                this._clip = clip,
                this._localRoot = localRoot || null;
            for (var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks), interpolantSettings = {
                endingStart: THREE.ZeroCurvatureEnding,
                endingEnd: THREE.ZeroCurvatureEnding
            }, i = 0; i !== nTracks; ++i) {
                var interpolant = tracks[i].createInterpolant(null);
                interpolants[i] = interpolant,
                    interpolant.settings = interpolantSettings
            }
            this._interpolantSettings = interpolantSettings,
                this._interpolants = interpolants,
                this._propertyBindings = new Array(nTracks),
                this._cacheIndex = null,
                this._byClipCacheIndex = null,
                this._timeScaleInterpolant = null,
                this._weightInterpolant = null,
                this.loop = THREE.LoopRepeat,
                this._loopCount = -1,
                this._startTime = null,
                this.time = 0,
                this.timeScale = 1,
                this._effectiveTimeScale = 1,
                this.weight = 1,
                this._effectiveWeight = 1,
                this.repetitions = 1 / 0,
                this.paused = !1,
                this.enabled = !0,
                this.clampWhenFinished = !1,
                this.zeroSlopeAtStart = !0,
                this.zeroSlopeAtEnd = !0
        }
        ,
        THREE.AnimationAction._new.prototype = {
            constructor: THREE.AnimationAction._new,
            play: function() {
                return this._mixer._activateAction(this),
                    this
            },
            stop: function() {
                return this._mixer._deactivateAction(this),
                    this.reset()
            },
            reset: function() {
                return this.paused = !1,
                    this.enabled = !0,
                    this.time = 0,
                    this._loopCount = -1,
                    this._startTime = null,
                    this.stopFading().stopWarping()
            },
            isRunning: function() {
                this._startTime;
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function() {
                return this._mixer._isActiveAction(this)
            },
            startAt: function(time) {
                return this._startTime = time,
                    this
            },
            setLoop: function(mode, repetitions) {
                return this.loop = mode,
                    this.repetitions = repetitions,
                    this
            },
            setEffectiveWeight: function(weight) {
                return this.weight = weight,
                    this._effectiveWeight = this.enabled ? weight : 0,
                    this.stopFading()
            },
            getEffectiveWeight: function() {
                return this._effectiveWeight
            },
            fadeIn: function(duration) {
                return this._scheduleFading(duration, 0, 1)
            },
            fadeOut: function(duration) {
                return this._scheduleFading(duration, 1, 0)
            },
            crossFadeFrom: function(fadeOutAction, duration, warp) {
                this._mixer;
                if (fadeOutAction.fadeOut(duration),
                        this.fadeIn(duration),
                        warp) {
                    var fadeInDuration = this._clip.duration
                        , fadeOutDuration = fadeOutAction._clip.duration
                        , startEndRatio = fadeOutDuration / fadeInDuration
                        , endStartRatio = fadeInDuration / fadeOutDuration;
                    fadeOutAction.warp(1, startEndRatio, duration),
                        this.warp(endStartRatio, 1, duration)
                }
                return this
            },
            crossFadeTo: function(fadeInAction, duration, warp) {
                return fadeInAction.crossFadeFrom(this, duration, warp)
            },
            stopFading: function() {
                var weightInterpolant = this._weightInterpolant;
                return null !== weightInterpolant && (this._weightInterpolant = null,
                    this._mixer._takeBackControlInterpolant(weightInterpolant)),
                    this
            },
            setEffectiveTimeScale: function(timeScale) {
                return this.timeScale = timeScale,
                    this._effectiveTimeScale = this.paused ? 0 : timeScale,
                    this.stopWarping()
            },
            getEffectiveTimeScale: function() {
                return this._effectiveTimeScale
            },
            setDuration: function(duration) {
                return this.timeScale = this._clip.duration / duration,
                    this.stopWarping()
            },
            syncWith: function(action) {
                return this.time = action.time,
                    this.timeScale = action.timeScale,
                    this.stopWarping()
            },
            halt: function(duration) {
                return this.warp(this._effectiveTimeScale, 0, duration)
            },
            warp: function(startTimeScale, endTimeScale, duration) {
                var mixer = this._mixer
                    , now = mixer.time
                    , interpolant = this._timeScaleInterpolant
                    , timeScale = this.timeScale;
                null === interpolant && (interpolant = mixer._lendControlInterpolant(),
                    this._timeScaleInterpolant = interpolant);
                var times = interpolant.parameterPositions
                    , values = interpolant.sampleValues;
                return times[0] = now,
                    times[1] = now + duration,
                    values[0] = startTimeScale / timeScale,
                    values[1] = endTimeScale / timeScale,
                    this
            },
            stopWarping: function() {
                var timeScaleInterpolant = this._timeScaleInterpolant;
                return null !== timeScaleInterpolant && (this._timeScaleInterpolant = null,
                    this._mixer._takeBackControlInterpolant(timeScaleInterpolant)),
                    this
            },
            getMixer: function() {
                return this._mixer
            },
            getClip: function() {
                return this._clip
            },
            getRoot: function() {
                return this._localRoot || this._mixer._root
            },
            _update: function(time, deltaTime, timeDirection, accuIndex) {
                var startTime = this._startTime;
                if (null !== startTime) {
                    var timeRunning = (time - startTime) * timeDirection;
                    if (timeRunning < 0 || 0 === timeDirection)
                        return;
                    this._startTime = null,
                        deltaTime = timeDirection * timeRunning
                }
                deltaTime *= this._updateTimeScale(time);
                var clipTime = this._updateTime(deltaTime)
                    , weight = this._updateWeight(time);
                if (weight > 0)
                    for (var interpolants = this._interpolants, propertyMixers = this._propertyBindings, j = 0, m = interpolants.length; j !== m; ++j)
                        interpolants[j].evaluate(clipTime),
                            propertyMixers[j].accumulate(accuIndex, weight)
            },
            _updateWeight: function(time) {
                var weight = 0;
                if (this.enabled) {
                    weight = this.weight;
                    var interpolant = this._weightInterpolant;
                    if (null !== interpolant) {
                        var interpolantValue = interpolant.evaluate(time)[0];
                        weight *= interpolantValue,
                        time > interpolant.parameterPositions[1] && (this.stopFading(),
                        0 === interpolantValue && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = weight,
                    weight
            },
            _updateTimeScale: function(time) {
                var timeScale = 0;
                if (!this.paused) {
                    timeScale = this.timeScale;
                    var interpolant = this._timeScaleInterpolant;
                    if (null !== interpolant) {
                        var interpolantValue = interpolant.evaluate(time)[0];
                        timeScale *= interpolantValue,
                        time > interpolant.parameterPositions[1] && (this.stopWarping(),
                            0 === timeScale ? this.paused = !0 : this.timeScale = timeScale)
                    }
                }
                return this._effectiveTimeScale = timeScale,
                    timeScale
            },
            _updateTime: function(deltaTime) {
                var time = this.time + deltaTime;
                if (0 === deltaTime)
                    return time;
                var duration = this._clip.duration
                    , loop = this.loop
                    , loopCount = this._loopCount;
                if (loop === THREE.LoopOnce) {
                    loopCount === -1 && (this.loopCount = 0,
                        this._setEndings(!0, !0, !1));
                    handle_stop: {
                        if (time >= duration)
                            time = duration;
                        else {
                            if (!(time < 0))
                                break handle_stop;
                            time = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: deltaTime < 0 ? -1 : 1
                            })
                    }
                } else {
                    var pingPong = loop === THREE.LoopPingPong;
                    if (loopCount === -1 && (deltaTime >= 0 ? (loopCount = 0,
                            this._setEndings(!0, 0 === this.repetitions, pingPong)) : this._setEndings(0 === this.repetitions, !0, pingPong)),
                        time >= duration || time < 0) {
                        var loopDelta = Math.floor(time / duration);
                        time -= duration * loopDelta,
                            loopCount += Math.abs(loopDelta);
                        var pending = this.repetitions - loopCount;
                        if (pending < 0)
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                time = deltaTime > 0 ? duration : 0,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: deltaTime > 0 ? 1 : -1
                                });
                        else {
                            if (0 === pending) {
                                var atStart = deltaTime < 0;
                                this._setEndings(atStart, !atStart, pingPong)
                            } else
                                this._setEndings(!1, !1, pingPong);
                            this._loopCount = loopCount,
                                this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: loopDelta
                                })
                        }
                    }
                    if (pingPong && 1 === (1 & loopCount))
                        return this.time = time,
                        duration - time
                }
                return this.time = time,
                    time
            },
            _setEndings: function(atStart, atEnd, pingPong) {
                var settings = this._interpolantSettings;
                pingPong ? (settings.endingStart = THREE.ZeroSlopeEnding,
                    settings.endingEnd = THREE.ZeroSlopeEnding) : (atStart ? settings.endingStart = this.zeroSlopeAtStart ? THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding : settings.endingStart = THREE.WrapAroundEnding,
                    atEnd ? settings.endingEnd = this.zeroSlopeAtEnd ? THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding : settings.endingEnd = THREE.WrapAroundEnding)
            },
            _scheduleFading: function(duration, weightNow, weightThen) {
                var mixer = this._mixer
                    , now = mixer.time
                    , interpolant = this._weightInterpolant;
                null === interpolant && (interpolant = mixer._lendControlInterpolant(),
                    this._weightInterpolant = interpolant);
                var times = interpolant.parameterPositions
                    , values = interpolant.sampleValues;
                return times[0] = now,
                    values[0] = weightNow,
                    times[1] = now + duration,
                    values[1] = weightThen,
                    this
            }
        },
        THREE.AnimationClip = function(name, duration, tracks) {
            this.name = name,
                this.tracks = tracks,
                this.duration = void 0 !== duration ? duration : -1,
                this.uuid = THREE.Math.generateUUID(),
            this.duration < 0 && this.resetDuration(),
                this.trim(),
                this.optimize()
        }
        ,
        THREE.AnimationClip.prototype = {
            constructor: THREE.AnimationClip,
            resetDuration: function() {
                for (var tracks = this.tracks, duration = 0, i = 0, n = tracks.length; i !== n; ++i) {
                    var track = this.tracks[i];
                    duration = Math.max(duration, track.times[track.times.length - 1])
                }
                this.duration = duration
            },
            trim: function() {
                for (var i = 0; i < this.tracks.length; i++)
                    this.tracks[i].trim(0, this.duration);
                return this
            },
            optimize: function() {
                for (var i = 0; i < this.tracks.length; i++)
                    this.tracks[i].optimize();
                return this
            }
        },
        Object.assign(THREE.AnimationClip, {
            parse: function(json) {
                for (var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1), i = 0, n = jsonTracks.length; i !== n; ++i)
                    tracks.push(THREE.KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
                return new THREE.AnimationClip(json.name,json.duration,tracks)
            },
            toJSON: function(clip) {
                for (var tracks = [], clipTracks = clip.tracks, json = {
                    name: clip.name,
                    duration: clip.duration,
                    tracks: tracks
                }, i = 0, n = clipTracks.length; i !== n; ++i)
                    tracks.push(THREE.KeyframeTrack.toJSON(clipTracks[i]));
                return json
            },
            CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
                for (var numMorphTargets = morphTargetSequence.length, tracks = [], i = 0; i < numMorphTargets; i++) {
                    var times = []
                        , values = [];
                    times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets),
                        values.push(0, 1, 0);
                    var order = THREE.AnimationUtils.getKeyframeOrder(times);
                    times = THREE.AnimationUtils.sortedArray(times, 1, order),
                        values = THREE.AnimationUtils.sortedArray(values, 1, order),
                    noLoop || 0 !== times[0] || (times.push(numMorphTargets),
                        values.push(values[0])),
                        tracks.push(new THREE.NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]",times,values).scale(1 / fps))
                }
                return new THREE.AnimationClip(name,-1,tracks)
            },
            findByName: function(objectOrClipArray, name) {
                var clipArray = objectOrClipArray;
                if (!Array.isArray(objectOrClipArray)) {
                    var o = objectOrClipArray;
                    clipArray = o.geometry && o.geometry.animations || o.animations
                }
                for (var i = 0; i < clipArray.length; i++)
                    if (clipArray[i].name === name)
                        return clipArray[i];
                return null
            },
            CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
                for (var animationToMorphTargets = {}, pattern = /^([\w-]*?)([\d]+)$/, i = 0, il = morphTargets.length; i < il; i++) {
                    var morphTarget = morphTargets[i]
                        , parts = morphTarget.name.match(pattern);
                    if (parts && parts.length > 1) {
                        var name = parts[1]
                            , animationMorphTargets = animationToMorphTargets[name];
                        animationMorphTargets || (animationToMorphTargets[name] = animationMorphTargets = []),
                            animationMorphTargets.push(morphTarget)
                    }
                }
                var clips = [];
                for (var name in animationToMorphTargets)
                    clips.push(THREE.AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
                return clips
            },
            parseAnimation: function(animation, bones, nodeName) {
                if (!animation)
                    return console.error("  no animation in JSONLoader data"),
                        null;
                for (var addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
                    if (0 !== animationKeys.length) {
                        var times = []
                            , values = [];
                        THREE.AnimationUtils.flattenJSON(animationKeys, times, values, propertyName),
                        0 !== times.length && destTracks.push(new trackType(trackName,times,values))
                    }
                }, tracks = [], clipName = animation.name || "default", duration = animation.length || -1, fps = animation.fps || 30, hierarchyTracks = animation.hierarchy || [], h = 0; h < hierarchyTracks.length; h++) {
                    var animationKeys = hierarchyTracks[h].keys;
                    if (animationKeys && 0 !== animationKeys.length)
                        if (animationKeys[0].morphTargets) {
                            for (var morphTargetNames = {}, k = 0; k < animationKeys.length; k++)
                                if (animationKeys[k].morphTargets)
                                    for (var m = 0; m < animationKeys[k].morphTargets.length; m++)
                                        morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                            for (var morphTargetName in morphTargetNames) {
                                for (var times = [], values = [], m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                                    var animationKey = animationKeys[k];
                                    times.push(animationKey.time),
                                        values.push(animationKey.morphTarget === morphTargetName ? 1 : 0)
                                }
                                tracks.push(new THREE.NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]",times,values))
                            }
                            duration = morphTargetNames.length * (fps || 1)
                        } else {
                            var boneName = ".bones[" + bones[h].name + "]";
                            addNonemptyTrack(THREE.VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks),
                                addNonemptyTrack(THREE.QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks),
                                addNonemptyTrack(THREE.VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks)
                        }
                }
                if (0 === tracks.length)
                    return null;
                var clip = new THREE.AnimationClip(clipName,duration,tracks);
                return clip
            }
        }),
        THREE.AnimationMixer = function(root) {
            this._root = root,
                this._initMemoryManager(),
                this._accuIndex = 0,
                this.time = 0,
                this.timeScale = 1
        }
        ,
        Object.assign(THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {
            clipAction: function(clip, optionalRoot) {
                var root = optionalRoot || this._root
                    , rootUuid = root.uuid
                    , clipObject = "string" == typeof clip ? THREE.AnimationClip.findByName(root, clip) : clip
                    , clipUuid = null !== clipObject ? clipObject.uuid : clip
                    , actionsForClip = this._actionsByClip[clipUuid]
                    , prototypeAction = null;
                if (void 0 !== actionsForClip) {
                    var existingAction = actionsForClip.actionByRoot[rootUuid];
                    if (void 0 !== existingAction)
                        return existingAction;
                    prototypeAction = actionsForClip.knownActions[0],
                    null === clipObject && (clipObject = prototypeAction._clip)
                }
                if (null === clipObject)
                    return null;
                var newAction = new THREE.AnimationMixer._Action(this,clipObject,optionalRoot);
                return this._bindAction(newAction, prototypeAction),
                    this._addInactiveAction(newAction, clipUuid, rootUuid),
                    newAction
            },
            existingAction: function(clip, optionalRoot) {
                var root = optionalRoot || this._root
                    , rootUuid = root.uuid
                    , clipObject = "string" == typeof clip ? THREE.AnimationClip.findByName(root, clip) : clip
                    , clipUuid = clipObject ? clipObject.uuid : clip
                    , actionsForClip = this._actionsByClip[clipUuid];
                return void 0 !== actionsForClip ? actionsForClip.actionByRoot[rootUuid] || null : null
            },
            stopAllAction: function() {
                var actions = this._actions
                    , nActions = this._nActiveActions
                    , bindings = this._bindings
                    , nBindings = this._nActiveBindings;
                this._nActiveActions = 0,
                    this._nActiveBindings = 0;
                for (var i = 0; i !== nActions; ++i)
                    actions[i].reset();
                for (var i = 0; i !== nBindings; ++i)
                    bindings[i].useCount = 0;
                return this
            },
            update: function(deltaTime) {
                deltaTime *= this.timeScale;
                for (var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1, i = 0; i !== nActions; ++i) {
                    var action = actions[i];
                    action.enabled && action._update(time, deltaTime, timeDirection, accuIndex)
                }
                for (var bindings = this._bindings, nBindings = this._nActiveBindings, i = 0; i !== nBindings; ++i)
                    bindings[i].apply(accuIndex);
                return this
            },
            getRoot: function() {
                return this._root
            },
            uncacheClip: function(clip) {
                var actions = this._actions
                    , clipUuid = clip.uuid
                    , actionsByClip = this._actionsByClip
                    , actionsForClip = actionsByClip[clipUuid];
                if (void 0 !== actionsForClip) {
                    for (var actionsToRemove = actionsForClip.knownActions, i = 0, n = actionsToRemove.length; i !== n; ++i) {
                        var action = actionsToRemove[i];
                        this._deactivateAction(action);
                        var cacheIndex = action._cacheIndex
                            , lastInactiveAction = actions[actions.length - 1];
                        action._cacheIndex = null,
                            action._byClipCacheIndex = null,
                            lastInactiveAction._cacheIndex = cacheIndex,
                            actions[cacheIndex] = lastInactiveAction,
                            actions.pop(),
                            this._removeInactiveBindingsForAction(action)
                    }
                    delete actionsByClip[clipUuid]
                }
            },
            uncacheRoot: function(root) {
                var rootUuid = root.uuid
                    , actionsByClip = this._actionsByClip;
                for (var clipUuid in actionsByClip) {
                    var actionByRoot = actionsByClip[clipUuid].actionByRoot
                        , action = actionByRoot[rootUuid];
                    void 0 !== action && (this._deactivateAction(action),
                        this._removeInactiveAction(action))
                }
                var bindingsByRoot = this._bindingsByRootAndName
                    , bindingByName = bindingsByRoot[rootUuid];
                if (void 0 !== bindingByName)
                    for (var trackName in bindingByName) {
                        var binding = bindingByName[trackName];
                        binding.restoreOriginalState(),
                            this._removeInactiveBinding(binding)
                    }
            },
            uncacheAction: function(clip, optionalRoot) {
                var action = this.existingAction(clip, optionalRoot);
                null !== action && (this._deactivateAction(action),
                    this._removeInactiveAction(action))
            }
        }),
        THREE.AnimationMixer._Action = THREE.AnimationAction._new,
        Object.assign(THREE.AnimationMixer.prototype, {
            _bindAction: function(action, prototypeAction) {
                var root = action._localRoot || this._root
                    , tracks = action._clip.tracks
                    , nTracks = tracks.length
                    , bindings = action._propertyBindings
                    , interpolants = action._interpolants
                    , rootUuid = root.uuid
                    , bindingsByRoot = this._bindingsByRootAndName
                    , bindingsByName = bindingsByRoot[rootUuid];
                void 0 === bindingsByName && (bindingsByName = {},
                    bindingsByRoot[rootUuid] = bindingsByName);
                for (var i = 0; i !== nTracks; ++i) {
                    var track = tracks[i]
                        , trackName = track.name
                        , binding = bindingsByName[trackName];
                    if (void 0 !== binding)
                        bindings[i] = binding;
                    else {
                        if (binding = bindings[i],
                            void 0 !== binding) {
                            null === binding._cacheIndex && (++binding.referenceCount,
                                this._addInactiveBinding(binding, rootUuid, trackName));
                            continue
                        }
                        var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                        binding = new THREE.PropertyMixer(THREE.PropertyBinding.create(root, trackName, path),track.ValueTypeName,track.getValueSize()),
                            ++binding.referenceCount,
                            this._addInactiveBinding(binding, rootUuid, trackName),
                            bindings[i] = binding
                    }
                    interpolants[i].resultBuffer = binding.buffer
                }
            },
            _activateAction: function(action) {
                if (!this._isActiveAction(action)) {
                    if (null === action._cacheIndex) {
                        var rootUuid = (action._localRoot || this._root).uuid
                            , clipUuid = action._clip.uuid
                            , actionsForClip = this._actionsByClip[clipUuid];
                        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]),
                            this._addInactiveAction(action, clipUuid, rootUuid)
                    }
                    for (var bindings = action._propertyBindings, i = 0, n = bindings.length; i !== n; ++i) {
                        var binding = bindings[i];
                        0 === binding.useCount++ && (this._lendBinding(binding),
                            binding.saveOriginalState())
                    }
                    this._lendAction(action)
                }
            },
            _deactivateAction: function(action) {
                if (this._isActiveAction(action)) {
                    for (var bindings = action._propertyBindings, i = 0, n = bindings.length; i !== n; ++i) {
                        var binding = bindings[i];
                        0 === --binding.useCount && (binding.restoreOriginalState(),
                            this._takeBackBinding(binding))
                    }
                    this._takeBackAction(action)
                }
            },
            _initMemoryManager: function() {
                this._actions = [],
                    this._nActiveActions = 0,
                    this._actionsByClip = {},
                    this._bindings = [],
                    this._nActiveBindings = 0,
                    this._bindingsByRootAndName = {},
                    this._controlInterpolants = [],
                    this._nActiveControlInterpolants = 0;
                var scope = this;
                this.stats = {
                    actions: {
                        get total() {
                            return scope._actions.length
                        },
                        get inUse() {
                            return scope._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return scope._bindings.length
                        },
                        get inUse() {
                            return scope._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return scope._controlInterpolants.length
                        },
                        get inUse() {
                            return scope._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function(action) {
                var index = action._cacheIndex;
                return null !== index && index < this._nActiveActions
            },
            _addInactiveAction: function(action, clipUuid, rootUuid) {
                var actions = this._actions
                    , actionsByClip = this._actionsByClip
                    , actionsForClip = actionsByClip[clipUuid];
                if (void 0 === actionsForClip)
                    actionsForClip = {
                        knownActions: [action],
                        actionByRoot: {}
                    },
                        action._byClipCacheIndex = 0,
                        actionsByClip[clipUuid] = actionsForClip;
                else {
                    var knownActions = actionsForClip.knownActions;
                    action._byClipCacheIndex = knownActions.length,
                        knownActions.push(action)
                }
                action._cacheIndex = actions.length,
                    actions.push(action),
                    actionsForClip.actionByRoot[rootUuid] = action
            },
            _removeInactiveAction: function(action) {
                var actions = this._actions
                    , lastInactiveAction = actions[actions.length - 1]
                    , cacheIndex = action._cacheIndex;
                lastInactiveAction._cacheIndex = cacheIndex,
                    actions[cacheIndex] = lastInactiveAction,
                    actions.pop(),
                    action._cacheIndex = null;
                var clipUuid = action._clip.uuid
                    , actionsByClip = this._actionsByClip
                    , actionsForClip = actionsByClip[clipUuid]
                    , knownActionsForClip = actionsForClip.knownActions
                    , lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1]
                    , byClipCacheIndex = action._byClipCacheIndex;
                lastKnownAction._byClipCacheIndex = byClipCacheIndex,
                    knownActionsForClip[byClipCacheIndex] = lastKnownAction,
                    knownActionsForClip.pop(),
                    action._byClipCacheIndex = null;
                var actionByRoot = actionsForClip.actionByRoot
                    , rootUuid = (actions._localRoot || this._root).uuid;
                delete actionByRoot[rootUuid],
                0 === knownActionsForClip.length && delete actionsByClip[clipUuid],
                    this._removeInactiveBindingsForAction(action)
            },
            _removeInactiveBindingsForAction: function(action) {
                for (var bindings = action._propertyBindings, i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    0 === --binding.referenceCount && this._removeInactiveBinding(binding)
                }
            },
            _lendAction: function(action) {
                var actions = this._actions
                    , prevIndex = action._cacheIndex
                    , lastActiveIndex = this._nActiveActions++
                    , firstInactiveAction = actions[lastActiveIndex];
                action._cacheIndex = lastActiveIndex,
                    actions[lastActiveIndex] = action,
                    firstInactiveAction._cacheIndex = prevIndex,
                    actions[prevIndex] = firstInactiveAction
            },
            _takeBackAction: function(action) {
                var actions = this._actions
                    , prevIndex = action._cacheIndex
                    , firstInactiveIndex = --this._nActiveActions
                    , lastActiveAction = actions[firstInactiveIndex];
                action._cacheIndex = firstInactiveIndex,
                    actions[firstInactiveIndex] = action,
                    lastActiveAction._cacheIndex = prevIndex,
                    actions[prevIndex] = lastActiveAction
            },
            _addInactiveBinding: function(binding, rootUuid, trackName) {
                var bindingsByRoot = this._bindingsByRootAndName
                    , bindingByName = bindingsByRoot[rootUuid]
                    , bindings = this._bindings;
                void 0 === bindingByName && (bindingByName = {},
                    bindingsByRoot[rootUuid] = bindingByName),
                    bindingByName[trackName] = binding,
                    binding._cacheIndex = bindings.length,
                    bindings.push(binding)
            },
            _removeInactiveBinding: function(binding) {
                var bindings = this._bindings
                    , propBinding = binding.binding
                    , rootUuid = propBinding.rootNode.uuid
                    , trackName = propBinding.path
                    , bindingsByRoot = this._bindingsByRootAndName
                    , bindingByName = bindingsByRoot[rootUuid]
                    , lastInactiveBinding = bindings[bindings.length - 1]
                    , cacheIndex = binding._cacheIndex;
                lastInactiveBinding._cacheIndex = cacheIndex,
                    bindings[cacheIndex] = lastInactiveBinding,
                    bindings.pop(),
                    delete bindingByName[trackName];
                remove_empty_map: {
                    for (var _ in bindingByName)
                        break remove_empty_map;
                    delete bindingsByRoot[rootUuid]
                }
            },
            _lendBinding: function(binding) {
                var bindings = this._bindings
                    , prevIndex = binding._cacheIndex
                    , lastActiveIndex = this._nActiveBindings++
                    , firstInactiveBinding = bindings[lastActiveIndex];
                binding._cacheIndex = lastActiveIndex,
                    bindings[lastActiveIndex] = binding,
                    firstInactiveBinding._cacheIndex = prevIndex,
                    bindings[prevIndex] = firstInactiveBinding
            },
            _takeBackBinding: function(binding) {
                var bindings = this._bindings
                    , prevIndex = binding._cacheIndex
                    , firstInactiveIndex = --this._nActiveBindings
                    , lastActiveBinding = bindings[firstInactiveIndex];
                binding._cacheIndex = firstInactiveIndex,
                    bindings[firstInactiveIndex] = binding,
                    lastActiveBinding._cacheIndex = prevIndex,
                    bindings[prevIndex] = lastActiveBinding
            },
            _lendControlInterpolant: function() {
                var interpolants = this._controlInterpolants
                    , lastActiveIndex = this._nActiveControlInterpolants++
                    , interpolant = interpolants[lastActiveIndex];
                return void 0 === interpolant && (interpolant = new THREE.LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
                    interpolant.__cacheIndex = lastActiveIndex,
                    interpolants[lastActiveIndex] = interpolant),
                    interpolant
            },
            _takeBackControlInterpolant: function(interpolant) {
                var interpolants = this._controlInterpolants
                    , prevIndex = interpolant.__cacheIndex
                    , firstInactiveIndex = --this._nActiveControlInterpolants
                    , lastActiveInterpolant = interpolants[firstInactiveIndex];
                interpolant.__cacheIndex = firstInactiveIndex,
                    interpolants[firstInactiveIndex] = interpolant,
                    lastActiveInterpolant.__cacheIndex = prevIndex,
                    interpolants[prevIndex] = lastActiveInterpolant
            },
            _controlInterpolantsResultBuffer: new Float32Array(1)
        }),
        THREE.AnimationObjectGroup = function(var_args) {
            this.uuid = THREE.Math.generateUUID(),
                this._objects = Array.prototype.slice.call(arguments),
                this.nCachedObjects_ = 0;
            var indices = {};
            this._indicesByUUID = indices;
            for (var i = 0, n = arguments.length; i !== n; ++i)
                indices[arguments[i].uuid] = i;
            this._paths = [],
                this._parsedPaths = [],
                this._bindings = [],
                this._bindingsIndicesByPath = {};
            var scope = this;
            this.stats = {
                objects: {
                    get total() {
                        return scope._objects.length
                    },
                    get inUse() {
                        return this.total - scope.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return scope._bindings.length
                }
            }
        }
        ,
        THREE.AnimationObjectGroup.prototype = {
            constructor: THREE.AnimationObjectGroup,
            add: function(var_args) {
                for (var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, i = 0, n = arguments.length; i !== n; ++i) {
                    var object = arguments[i]
                        , uuid = object.uuid
                        , index = indicesByUUID[uuid];
                    if (void 0 === index) {
                        index = nObjects++,
                            indicesByUUID[uuid] = index,
                            objects.push(object);
                        for (var j = 0, m = nBindings; j !== m; ++j)
                            bindings[j].push(new THREE.PropertyBinding(object,paths[j],parsedPaths[j]))
                    } else if (index < nCachedObjects) {
                        var knownObject = objects[index]
                            , firstActiveIndex = --nCachedObjects
                            , lastCachedObject = objects[firstActiveIndex];
                        indicesByUUID[lastCachedObject.uuid] = index,
                            objects[index] = lastCachedObject,
                            indicesByUUID[uuid] = firstActiveIndex,
                            objects[firstActiveIndex] = object;
                        for (var j = 0, m = nBindings; j !== m; ++j) {
                            var bindingsForPath = bindings[j]
                                , lastCached = bindingsForPath[firstActiveIndex]
                                , binding = bindingsForPath[index];
                            bindingsForPath[index] = lastCached,
                            void 0 === binding && (binding = new THREE.PropertyBinding(object,paths[j],parsedPaths[j])),
                                bindingsForPath[firstActiveIndex] = binding
                        }
                    } else
                        objects[index] !== knownObject && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
                }
                this.nCachedObjects_ = nCachedObjects
            },
            remove: function(var_args) {
                for (var objects = this._objects, nCachedObjects = (objects.length,
                    this.nCachedObjects_), indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length, i = 0, n = arguments.length; i !== n; ++i) {
                    var object = arguments[i]
                        , uuid = object.uuid
                        , index = indicesByUUID[uuid];
                    if (void 0 !== index && index >= nCachedObjects) {
                        var lastCachedIndex = nCachedObjects++
                            , firstActiveObject = objects[lastCachedIndex];
                        indicesByUUID[firstActiveObject.uuid] = index,
                            objects[index] = firstActiveObject,
                            indicesByUUID[uuid] = lastCachedIndex,
                            objects[lastCachedIndex] = object;
                        for (var j = 0, m = nBindings; j !== m; ++j) {
                            var bindingsForPath = bindings[j]
                                , firstActive = bindingsForPath[lastCachedIndex]
                                , binding = bindingsForPath[index];
                            bindingsForPath[index] = firstActive,
                                bindingsForPath[lastCachedIndex] = binding
                        }
                    }
                }
                this.nCachedObjects_ = nCachedObjects
            },
            uncache: function(var_args) {
                for (var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length, i = 0, n = arguments.length; i !== n; ++i) {
                    var object = arguments[i]
                        , uuid = object.uuid
                        , index = indicesByUUID[uuid];
                    if (void 0 !== index)
                        if (delete indicesByUUID[uuid],
                            index < nCachedObjects) {
                            var firstActiveIndex = --nCachedObjects
                                , lastCachedObject = objects[firstActiveIndex]
                                , lastIndex = --nObjects
                                , lastObject = objects[lastIndex];
                            indicesByUUID[lastCachedObject.uuid] = index,
                                objects[index] = lastCachedObject,
                                indicesByUUID[lastObject.uuid] = firstActiveIndex,
                                objects[firstActiveIndex] = lastObject,
                                objects.pop();
                            for (var j = 0, m = nBindings; j !== m; ++j) {
                                var bindingsForPath = bindings[j]
                                    , lastCached = bindingsForPath[firstActiveIndex]
                                    , last = bindingsForPath[lastIndex];
                                bindingsForPath[index] = lastCached,
                                    bindingsForPath[firstActiveIndex] = last,
                                    bindingsForPath.pop()
                            }
                        } else {
                            var lastIndex = --nObjects
                                , lastObject = objects[lastIndex];
                            indicesByUUID[lastObject.uuid] = index,
                                objects[index] = lastObject,
                                objects.pop();
                            for (var j = 0, m = nBindings; j !== m; ++j) {
                                var bindingsForPath = bindings[j];
                                bindingsForPath[index] = bindingsForPath[lastIndex],
                                    bindingsForPath.pop()
                            }
                        }
                }
                this.nCachedObjects_ = nCachedObjects
            },
            subscribe_: function(path, parsedPath) {
                var indicesByPath = this._bindingsIndicesByPath
                    , index = indicesByPath[path]
                    , bindings = this._bindings;
                if (void 0 !== index)
                    return bindings[index];
                var paths = this._paths
                    , parsedPaths = this._parsedPaths
                    , objects = this._objects
                    , nObjects = objects.length
                    , nCachedObjects = this.nCachedObjects_
                    , bindingsForPath = new Array(nObjects);
                index = bindings.length,
                    indicesByPath[path] = index,
                    paths.push(path),
                    parsedPaths.push(parsedPath),
                    bindings.push(bindingsForPath);
                for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                    var object = objects[i];
                    bindingsForPath[i] = new THREE.PropertyBinding(object,path,parsedPath)
                }
                return bindingsForPath
            },
            unsubscribe_: function(path) {
                var indicesByPath = this._bindingsIndicesByPath
                    , index = indicesByPath[path];
                if (void 0 !== index) {
                    var paths = this._paths
                        , parsedPaths = this._parsedPaths
                        , bindings = this._bindings
                        , lastBindingsIndex = bindings.length - 1
                        , lastBindings = bindings[lastBindingsIndex]
                        , lastBindingsPath = path[lastBindingsIndex];
                    indicesByPath[lastBindingsPath] = index,
                        bindings[index] = lastBindings,
                        bindings.pop(),
                        parsedPaths[index] = parsedPaths[lastBindingsIndex],
                        parsedPaths.pop(),
                        paths[index] = paths[lastBindingsIndex],
                        paths.pop()
                }
            }
        },
        THREE.AnimationUtils = {
            arraySlice: function(array, from, to) {
                return THREE.AnimationUtils.isTypedArray(array) ? new array.constructor(array.subarray(from, to)) : array.slice(from, to)
            },
            convertArray: function(array, type, forceClone) {
                return !array || !forceClone && array.constructor === type ? array : "number" == typeof type.BYTES_PER_ELEMENT ? new type(array) : Array.prototype.slice.call(array)
            },
            isTypedArray: function(object) {
                return ArrayBuffer.isView(object) && !(object instanceof DataView)
            },
            getKeyframeOrder: function(times) {
                function compareTime(i, j) {
                    return times[i] - times[j]
                }
                for (var n = times.length, result = new Array(n), i = 0; i !== n; ++i)
                    result[i] = i;
                return result.sort(compareTime),
                    result
            },
            sortedArray: function(values, stride, order) {
                for (var nValues = values.length, result = new values.constructor(nValues), i = 0, dstOffset = 0; dstOffset !== nValues; ++i)
                    for (var srcOffset = order[i] * stride, j = 0; j !== stride; ++j)
                        result[dstOffset++] = values[srcOffset + j];
                return result
            },
            flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
                for (var i = 1, key = jsonKeys[0]; void 0 !== key && void 0 === key[valuePropertyName]; )
                    key = jsonKeys[i++];
                if (void 0 !== key) {
                    var value = key[valuePropertyName];
                    if (void 0 !== value)
                        if (Array.isArray(value)) {
                            do
                                value = key[valuePropertyName],
                                void 0 !== value && (times.push(key.time),
                                    values.push.apply(values, value)),
                                    key = jsonKeys[i++];
                            while (void 0 !== key)
                        } else if (void 0 !== value.toArray) {
                            do
                                value = key[valuePropertyName],
                                void 0 !== value && (times.push(key.time),
                                    value.toArray(values, values.length)),
                                    key = jsonKeys[i++];
                            while (void 0 !== key)
                        } else
                            do
                                value = key[valuePropertyName],
                                void 0 !== value && (times.push(key.time),
                                    values.push(value)),
                                    key = jsonKeys[i++];
                            while (void 0 !== key)
                }
            }
        },
        THREE.KeyframeTrack = function(name, times, values, interpolation) {
            if (void 0 === name)
                throw new Error("track name is undefined");
            if (void 0 === times || 0 === times.length)
                throw new Error("no keyframes in track named " + name);
            this.name = name,
                this.times = THREE.AnimationUtils.convertArray(times, this.TimeBufferType),
                this.values = THREE.AnimationUtils.convertArray(values, this.ValueBufferType),
                this.setInterpolation(interpolation || this.DefaultInterpolation),
                this.validate(),
                this.optimize()
        }
        ,
        THREE.KeyframeTrack.prototype = {
            constructor: THREE.KeyframeTrack,
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: THREE.InterpolateLinear,
            InterpolantFactoryMethodDiscrete: function(result) {
                return new THREE.DiscreteInterpolant(this.times,this.values,this.getValueSize(),result)
            },
            InterpolantFactoryMethodLinear: function(result) {
                return new THREE.LinearInterpolant(this.times,this.values,this.getValueSize(),result)
            },
            InterpolantFactoryMethodSmooth: function(result) {
                return new THREE.CubicInterpolant(this.times,this.values,this.getValueSize(),result)
            },
            setInterpolation: function(interpolation) {
                var factoryMethod;
                switch (interpolation) {
                    case THREE.InterpolateDiscrete:
                        factoryMethod = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case THREE.InterpolateLinear:
                        factoryMethod = this.InterpolantFactoryMethodLinear;
                        break;
                    case THREE.InterpolateSmooth:
                        factoryMethod = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === factoryMethod) {
                    var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (interpolation === this.DefaultInterpolation)
                            throw new Error(message);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return void console.warn(message)
                }
                this.createInterpolant = factoryMethod
            },
            getInterpolation: function() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return THREE.InterpolateDiscrete;
                    case this.InterpolantFactoryMethodLinear:
                        return THREE.InterpolateLinear;
                    case this.InterpolantFactoryMethodSmooth:
                        return THREE.InterpolateSmooth
                }
            },
            getValueSize: function() {
                return this.values.length / this.times.length
            },
            shift: function(timeOffset) {
                if (0 !== timeOffset)
                    for (var times = this.times, i = 0, n = times.length; i !== n; ++i)
                        times[i] += timeOffset;
                return this
            },
            scale: function(timeScale) {
                if (1 !== timeScale)
                    for (var times = this.times, i = 0, n = times.length; i !== n; ++i)
                        times[i] *= timeScale;
                return this
            },
            trim: function(startTime, endTime) {
                for (var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1; from !== nKeys && times[from] < startTime; )
                    ++from;
                for (; to !== -1 && times[to] > endTime; )
                    --to;
                if (++to,
                    0 !== from || to !== nKeys) {
                    from >= to && (to = Math.max(to, 1),
                        from = to - 1);
                    var stride = this.getValueSize();
                    this.times = THREE.AnimationUtils.arraySlice(times, from, to),
                        this.values = THREE.AnimationUtils.arraySlice(this.values, from * stride, to * stride)
                }
                return this
            },
            validate: function() {
                var valid = !0
                    , valueSize = this.getValueSize();
                valueSize - Math.floor(valueSize) !== 0 && (console.error("invalid value size in track", this),
                    valid = !1);
                var times = this.times
                    , values = this.values
                    , nKeys = times.length;
                0 === nKeys && (console.error("track is empty", this),
                    valid = !1);
                for (var prevTime = null, i = 0; i !== nKeys; i++) {
                    var currTime = times[i];
                    if ("number" == typeof currTime && isNaN(currTime)) {
                        console.error("time is not a valid number", this, i, currTime),
                            valid = !1;
                        break
                    }
                    if (null !== prevTime && prevTime > currTime) {
                        console.error("out of order keys", this, i, currTime, prevTime),
                            valid = !1;
                        break
                    }
                    prevTime = currTime
                }
                if (void 0 !== values && THREE.AnimationUtils.isTypedArray(values))
                    for (var i = 0, n = values.length; i !== n; ++i) {
                        var value = values[i];
                        if (isNaN(value)) {
                            console.error("value is not a valid number", this, i, value),
                                valid = !1;
                            break
                        }
                    }
                return valid
            },
            optimize: function() {
                for (var times = this.times, values = this.values, stride = this.getValueSize(), writeIndex = 1, i = 1, n = times.length - 1; i <= n; ++i) {
                    var keep = !1
                        , time = times[i]
                        , timeNext = times[i + 1];
                    if (time !== timeNext && (1 !== i || time !== time[0]))
                        for (var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride, j = 0; j !== stride; ++j) {
                            var value = values[offset + j];
                            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                                keep = !0;
                                break
                            }
                        }
                    if (keep) {
                        if (i !== writeIndex) {
                            times[writeIndex] = times[i];
                            for (var readOffset = i * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j)
                                values[writeOffset + j] = values[readOffset + j]
                        }
                        ++writeIndex
                    }
                }
                return writeIndex !== times.length && (this.times = THREE.AnimationUtils.arraySlice(times, 0, writeIndex),
                    this.values = THREE.AnimationUtils.arraySlice(values, 0, writeIndex * stride)),
                    this
            }
        },
        Object.assign(THREE.KeyframeTrack, {
            parse: function(json) {
                if (void 0 === json.type)
                    throw new Error("track type undefined, can not parse");
                var trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName(json.type);
                if (void 0 === json.times) {
                    var times = []
                        , values = [];
                    THREE.AnimationUtils.flattenJSON(json.keys, times, values, "value"),
                        json.times = times,
                        json.values = values
                }
                return void 0 !== trackType.parse ? trackType.parse(json) : new trackType(json.name,json.times,json.values,json.interpolation)
            },
            toJSON: function(track) {
                var json, trackType = track.constructor;
                if (void 0 !== trackType.toJSON)
                    json = trackType.toJSON(track);
                else {
                    json = {
                        name: track.name,
                        times: THREE.AnimationUtils.convertArray(track.times, Array),
                        values: THREE.AnimationUtils.convertArray(track.values, Array)
                    };
                    var interpolation = track.getInterpolation();
                    interpolation !== track.DefaultInterpolation && (json.interpolation = interpolation)
                }
                return json.type = track.ValueTypeName,
                    json
            },
            _getTrackTypeForValueTypeName: function(typeName) {
                switch (typeName.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return THREE.NumberKeyframeTrack;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return THREE.VectorKeyframeTrack;
                    case "color":
                        return THREE.ColorKeyframeTrack;
                    case "quaternion":
                        return THREE.QuaternionKeyframeTrack;
                    case "bool":
                    case "boolean":
                        return THREE.BooleanKeyframeTrack;
                    case "string":
                        return THREE.StringKeyframeTrack
                }
                throw new Error("Unsupported typeName: " + typeName)
            }
        }),
        THREE.PropertyBinding = function(rootNode, path, parsedPath) {
            this.path = path,
                this.parsedPath = parsedPath || THREE.PropertyBinding.parseTrackName(path),
                this.node = THREE.PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode,
                this.rootNode = rootNode
        }
        ,
        THREE.PropertyBinding.prototype = {
            constructor: THREE.PropertyBinding,
            getValue: function(targetArray, offset) {
                this.bind(),
                    this.getValue(targetArray, offset)
            },
            setValue: function(sourceArray, offset) {
                this.bind(),
                    this.setValue(sourceArray, offset)
            },
            bind: function() {
                var targetObject = this.node
                    , parsedPath = this.parsedPath
                    , objectName = parsedPath.objectName
                    , propertyName = parsedPath.propertyName
                    , propertyIndex = parsedPath.propertyIndex;
                if (targetObject || (targetObject = THREE.PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode,
                        this.node = targetObject),
                        this.getValue = this._getValue_unavailable,
                        this.setValue = this._setValue_unavailable,
                        !targetObject)
                    return void console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
                if (objectName) {
                    var objectIndex = parsedPath.objectIndex;
                    switch (objectName) {
                        case "materials":
                            if (!targetObject.material)
                                return void console.error("  can not bind to material as node does not have a material", this);
                            if (!targetObject.material.materials)
                                return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                            targetObject = targetObject.material.materials;
                            break;
                        case "bones":
                            if (!targetObject.skeleton)
                                return void console.error("  can not bind to bones as node does not have a skeleton", this);
                            targetObject = targetObject.skeleton.bones;
                            for (var i = 0; i < targetObject.length; i++)
                                if (targetObject[i].name === objectIndex) {
                                    objectIndex = i;
                                    break
                                }
                            break;
                        default:
                            if (void 0 === targetObject[objectName])
                                return void console.error("  can not bind to objectName of node, undefined", this);
                            targetObject = targetObject[objectName]
                    }
                    if (void 0 !== objectIndex) {
                        if (void 0 === targetObject[objectIndex])
                            return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject);
                        targetObject = targetObject[objectIndex]
                    }
                }
                var nodeProperty = targetObject[propertyName];
                if (void 0 === nodeProperty) {
                    var nodeName = parsedPath.nodeName;
                    return void console.error("  trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject)
                }
                var versioning = this.Versioning.None;
                void 0 !== targetObject.needsUpdate ? (versioning = this.Versioning.NeedsUpdate,
                    this.targetObject = targetObject) : void 0 !== targetObject.matrixWorldNeedsUpdate && (versioning = this.Versioning.MatrixWorldNeedsUpdate,
                    this.targetObject = targetObject);
                var bindingType = this.BindingType.Direct;
                if (void 0 !== propertyIndex) {
                    if ("morphTargetInfluences" === propertyName) {
                        if (!targetObject.geometry)
                            return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                        if (!targetObject.geometry.morphTargets)
                            return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                        for (var i = 0; i < this.node.geometry.morphTargets.length; i++)
                            if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                                propertyIndex = i;
                                break
                            }
                    }
                    bindingType = this.BindingType.ArrayElement,
                        this.resolvedProperty = nodeProperty,
                        this.propertyIndex = propertyIndex
                } else
                    void 0 !== nodeProperty.fromArray && void 0 !== nodeProperty.toArray ? (bindingType = this.BindingType.HasFromToArray,
                        this.resolvedProperty = nodeProperty) : void 0 !== nodeProperty.length ? (bindingType = this.BindingType.EntireArray,
                        this.resolvedProperty = nodeProperty) : this.propertyName = propertyName;
                this.getValue = this.GetterByBindingType[bindingType],
                    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning]
            },
            unbind: function() {
                this.node = null,
                    this.getValue = this._getValue_unbound,
                    this.setValue = this._setValue_unbound
            }
        },
        Object.assign(THREE.PropertyBinding.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            _getValue_unbound: THREE.PropertyBinding.prototype.getValue,
            _setValue_unbound: THREE.PropertyBinding.prototype.setValue,
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(buffer, offset) {
                buffer[offset] = this.node[this.propertyName]
            }
                , function(buffer, offset) {
                    for (var source = this.resolvedProperty, i = 0, n = source.length; i !== n; ++i)
                        buffer[offset++] = source[i]
                }
                , function(buffer, offset) {
                    buffer[offset] = this.resolvedProperty[this.propertyIndex]
                }
                , function(buffer, offset) {
                    this.resolvedProperty.toArray(buffer, offset)
                }
            ],
            SetterByBindingTypeAndVersioning: [[function(buffer, offset) {
                this.node[this.propertyName] = buffer[offset]
            }
                , function(buffer, offset) {
                    this.node[this.propertyName] = buffer[offset],
                        this.targetObject.needsUpdate = !0
                }
                , function(buffer, offset) {
                    this.node[this.propertyName] = buffer[offset],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                }
            ], [function(buffer, offset) {
                for (var dest = this.resolvedProperty, i = 0, n = dest.length; i !== n; ++i)
                    dest[i] = buffer[offset++]
            }
                , function(buffer, offset) {
                    for (var dest = this.resolvedProperty, i = 0, n = dest.length; i !== n; ++i)
                        dest[i] = buffer[offset++];
                    this.targetObject.needsUpdate = !0
                }
                , function(buffer, offset) {
                    for (var dest = this.resolvedProperty, i = 0, n = dest.length; i !== n; ++i)
                        dest[i] = buffer[offset++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
            ], [function(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset]
            }
                , function(buffer, offset) {
                    this.resolvedProperty[this.propertyIndex] = buffer[offset],
                        this.targetObject.needsUpdate = !0
                }
                , function(buffer, offset) {
                    this.resolvedProperty[this.propertyIndex] = buffer[offset],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                }
            ], [function(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset)
            }
                , function(buffer, offset) {
                    this.resolvedProperty.fromArray(buffer, offset),
                        this.targetObject.needsUpdate = !0
                }
                , function(buffer, offset) {
                    this.resolvedProperty.fromArray(buffer, offset),
                        this.targetObject.matrixWorldNeedsUpdate = !0
                }
            ]]
        }),
        THREE.PropertyBinding.Composite = function(targetGroup, path, optionalParsedPath) {
            var parsedPath = optionalParsedPath || THREE.PropertyBinding.parseTrackName(path);
            this._targetGroup = targetGroup,
                this._bindings = targetGroup.subscribe_(path, parsedPath)
        }
        ,
        THREE.PropertyBinding.Composite.prototype = {
            constructor: THREE.PropertyBinding.Composite,
            getValue: function(array, offset) {
                this.bind();
                var firstValidIndex = this._targetGroup.nCachedObjects_
                    , binding = this._bindings[firstValidIndex];
                void 0 !== binding && binding.getValue(array, offset)
            },
            setValue: function(array, offset) {
                for (var bindings = this._bindings, i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i)
                    bindings[i].setValue(array, offset)
            },
            bind: function() {
                for (var bindings = this._bindings, i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i)
                    bindings[i].bind()
            },
            unbind: function() {
                for (var bindings = this._bindings, i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i)
                    bindings[i].unbind()
            }
        },
        THREE.PropertyBinding.create = function(root, path, parsedPath) {
            return root instanceof THREE.AnimationObjectGroup ? new THREE.PropertyBinding.Composite(root,path,parsedPath) : new THREE.PropertyBinding(root,path,parsedPath)
        }
        ,
        THREE.PropertyBinding.parseTrackName = function(trackName) {
            var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_.:\- ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/
                , matches = re.exec(trackName);
            if (!matches)
                throw new Error("cannot parse trackName at all: " + trackName);
            matches.index === re.lastIndex && re.lastIndex++;
            var results = {
                nodeName: matches[3],
                objectName: matches[5],
                objectIndex: matches[7],
                propertyName: matches[9],
                propertyIndex: matches[11]
            };
            if (null === results.propertyName || 0 === results.propertyName.length)
                throw new Error("can not parse propertyName from trackName: " + trackName);
            return results
        }
        ,
        THREE.PropertyBinding.findNode = function(root, nodeName) {
            if (!nodeName || "" === nodeName || "root" === nodeName || "." === nodeName || nodeName === -1 || nodeName === root.name || nodeName === root.uuid)
                return root;
            if (root.skeleton) {
                var searchSkeleton = function(skeleton) {
                    for (var i = 0; i < skeleton.bones.length; i++) {
                        var bone = skeleton.bones[i];
                        if (bone.name === nodeName)
                            return bone
                    }
                    return null
                }
                    , bone = searchSkeleton(root.skeleton);
                if (bone)
                    return bone
            }
            if (root.children) {
                var searchNodeSubtree = function(children) {
                    for (var i = 0; i < children.length; i++) {
                        var childNode = children[i];
                        if (childNode.name === nodeName || childNode.uuid === nodeName)
                            return childNode;
                        var result = searchNodeSubtree(childNode.children);
                        if (result)
                            return result
                    }
                    return null
                }
                    , subTreeNode = searchNodeSubtree(root.children);
                if (subTreeNode)
                    return subTreeNode
            }
            return null
        }
        ,
        THREE.PropertyMixer = function(binding, typeName, valueSize) {
            this.binding = binding,
                this.valueSize = valueSize;
            var mixFunction, bufferType = Float64Array;
            switch (typeName) {
                case "quaternion":
                    mixFunction = this._slerp;
                    break;
                case "string":
                case "bool":
                    bufferType = Array,
                        mixFunction = this._select;
                    break;
                default:
                    mixFunction = this._lerp
            }
            this.buffer = new bufferType(4 * valueSize),
                this._mixBufferRegion = mixFunction,
                this.cumulativeWeight = 0,
                this.useCount = 0,
                this.referenceCount = 0
        }
        ,
        THREE.PropertyMixer.prototype = {
            constructor: THREE.PropertyMixer,
            accumulate: function(accuIndex, weight) {
                var buffer = this.buffer
                    , stride = this.valueSize
                    , offset = accuIndex * stride + stride
                    , currentWeight = this.cumulativeWeight;
                if (0 === currentWeight) {
                    for (var i = 0; i !== stride; ++i)
                        buffer[offset + i] = buffer[i];
                    currentWeight = weight
                } else {
                    currentWeight += weight;
                    var mix = weight / currentWeight;
                    this._mixBufferRegion(buffer, offset, 0, mix, stride)
                }
                this.cumulativeWeight = currentWeight
            },
            apply: function(accuIndex) {
                var stride = this.valueSize
                    , buffer = this.buffer
                    , offset = accuIndex * stride + stride
                    , weight = this.cumulativeWeight
                    , binding = this.binding;
                if (this.cumulativeWeight = 0,
                    weight < 1) {
                    var originalValueOffset = 3 * stride;
                    this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride)
                }
                for (var i = stride, e = stride + stride; i !== e; ++i)
                    if (buffer[i] !== buffer[i + stride]) {
                        binding.setValue(buffer, offset);
                        break
                    }
            },
            saveOriginalState: function() {
                var binding = this.binding
                    , buffer = this.buffer
                    , stride = this.valueSize
                    , originalValueOffset = 3 * stride;
                binding.getValue(buffer, originalValueOffset);
                for (var i = stride, e = originalValueOffset; i !== e; ++i)
                    buffer[i] = buffer[originalValueOffset + i % stride];
                this.cumulativeWeight = 0
            },
            restoreOriginalState: function() {
                var originalValueOffset = 3 * this.valueSize;
                this.binding.setValue(this.buffer, originalValueOffset)
            },
            _select: function(buffer, dstOffset, srcOffset, t, stride) {
                if (t >= .5)
                    for (var i = 0; i !== stride; ++i)
                        buffer[dstOffset + i] = buffer[srcOffset + i]
            },
            _slerp: function(buffer, dstOffset, srcOffset, t, stride) {
                THREE.Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t)
            },
            _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
                for (var s = 1 - t, i = 0; i !== stride; ++i) {
                    var j = dstOffset + i;
                    buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t
                }
            }
        },
        THREE.BooleanKeyframeTrack = function(name, times, values) {
            THREE.KeyframeTrack.call(this, name, times, values)
        }
        ,
        THREE.BooleanKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
            constructor: THREE.BooleanKeyframeTrack,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: THREE.InterpolateDiscrete,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }),
        THREE.ColorKeyframeTrack = function(name, times, values, interpolation) {
            THREE.KeyframeTrack.call(this, name, times, values, interpolation)
        }
        ,
        THREE.ColorKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
            constructor: THREE.ColorKeyframeTrack,
            ValueTypeName: "color"
        }),
        THREE.NumberKeyframeTrack = function(name, times, values, interpolation) {
            THREE.KeyframeTrack.call(this, name, times, values, interpolation)
        }
        ,
        THREE.NumberKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
            constructor: THREE.NumberKeyframeTrack,
            ValueTypeName: "number"
        }),
        THREE.QuaternionKeyframeTrack = function(name, times, values, interpolation) {
            THREE.KeyframeTrack.call(this, name, times, values, interpolation)
        }
        ,
        THREE.QuaternionKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
            constructor: THREE.QuaternionKeyframeTrack,
            ValueTypeName: "quaternion",
            DefaultInterpolation: THREE.InterpolateLinear,
            InterpolantFactoryMethodLinear: function(result) {
                return new THREE.QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),result)
            },
            InterpolantFactoryMethodSmooth: void 0
        }),
        THREE.StringKeyframeTrack = function(name, times, values, interpolation) {
            THREE.KeyframeTrack.call(this, name, times, values, interpolation)
        }
        ,
        THREE.StringKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
            constructor: THREE.StringKeyframeTrack,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: THREE.InterpolateDiscrete,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }),
        THREE.VectorKeyframeTrack = function(name, times, values, interpolation) {
            THREE.KeyframeTrack.call(this, name, times, values, interpolation)
        }
        ,
        THREE.VectorKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
            constructor: THREE.VectorKeyframeTrack,
            ValueTypeName: "vector"
        }),
        THREE.Audio = function(listener) {
            THREE.Object3D.call(this),
                this.type = "Audio",
                this.context = listener.context,
                this.source = this.context.createBufferSource(),
                this.source.onended = this.onEnded.bind(this),
                this.gain = this.context.createGain(),
                this.gain.connect(listener.getInput()),
                this.autoplay = !1,
                this.startTime = 0,
                this.playbackRate = 1,
                this.isPlaying = !1,
                this.hasPlaybackControl = !0,
                this.sourceType = "empty",
                this.filters = []
        }
        ,
        THREE.Audio.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
            constructor: THREE.Audio,
            getOutput: function() {
                return this.gain
            },
            setNodeSource: function(audioNode) {
                return this.hasPlaybackControl = !1,
                    this.sourceType = "audioNode",
                    this.source = audioNode,
                    this.connect(),
                    this
            },
            setBuffer: function(audioBuffer) {
                return this.source.buffer = audioBuffer,
                    this.sourceType = "buffer",
                this.autoplay && this.play(),
                    this
            },
            play: function() {
                if (this.isPlaying === !0)
                    return void console.warn("THREE.Audio: Audio is already playing.");
                if (this.hasPlaybackControl === !1)
                    return void console.warn("THREE.Audio: this Audio has no playback control.");
                var source = this.context.createBufferSource();
                return source.buffer = this.source.buffer,
                    source.loop = this.source.loop,
                    source.onended = this.source.onended,
                    source.start(0, this.startTime),
                    source.playbackRate.value = this.playbackRate,
                    this.isPlaying = !0,
                    this.source = source,
                    this.connect()
            },
            pause: function() {
                return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(),
                    this.startTime = this.context.currentTime,
                    this.isPlaying = !1,
                    this)
            },
            stop: function() {
                return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(),
                    this.startTime = 0,
                    this.isPlaying = !1,
                    this)
            },
            connect: function() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (var i = 1, l = this.filters.length; i < l; i++)
                        this.filters[i - 1].connect(this.filters[i]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else
                    this.source.connect(this.getOutput());
                return this
            },
            disconnect: function() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (var i = 1, l = this.filters.length; i < l; i++)
                        this.filters[i - 1].disconnect(this.filters[i]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else
                    this.source.disconnect(this.getOutput());
                return this
            },
            getFilters: function() {
                return this.filters
            },
            setFilters: function(value) {
                return value || (value = []),
                    this.isPlaying === !0 ? (this.disconnect(),
                        this.filters = value,
                        this.connect()) : this.filters = value,
                    this
            },
            getFilter: function() {
                return this.getFilters()[0]
            },
            setFilter: function(filter) {
                return this.setFilters(filter ? [filter] : [])
            },
            setPlaybackRate: function(value) {
                return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = value,
                this.isPlaying === !0 && (this.source.playbackRate.value = this.playbackRate),
                    this)
            },
            getPlaybackRate: function() {
                return this.playbackRate
            },
            onEnded: function() {
                this.isPlaying = !1
            },
            getLoop: function() {
                return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
                    !1) : this.source.loop
            },
            setLoop: function(value) {
                return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : void (this.source.loop = value)
            },
            getVolume: function() {
                return this.gain.gain.value
            },
            setVolume: function(value) {
                return this.gain.gain.value = value,
                    this
            }
        }),
        THREE.AudioAnalyser = function(audio, fftSize) {
            this.analyser = audio.context.createAnalyser(),
                this.analyser.fftSize = void 0 !== fftSize ? fftSize : 2048,
                this.data = new Uint8Array(this.analyser.frequencyBinCount),
                audio.getOutput().connect(this.analyser)
        }
        ,
        Object.assign(THREE.AudioAnalyser.prototype, {
            getFrequencyData: function() {
                return this.analyser.getByteFrequencyData(this.data),
                    this.data
            },
            getAverageFrequency: function() {
                for (var value = 0, data = this.getFrequencyData(), i = 0; i < data.length; i++)
                    value += data[i];
                return value / data.length
            }
        }),
        Object.defineProperty(THREE, "AudioContext", {
            get: function() {
                var context;
                return function() {
                    return void 0 === context && (context = new (window.AudioContext || window.webkitAudioContext)),
                        context
                }
            }()
        }),
        THREE.PositionalAudio = function(listener) {
            THREE.Audio.call(this, listener),
                this.panner = this.context.createPanner(),
                this.panner.connect(this.gain)
        }
        ,
        THREE.PositionalAudio.prototype = Object.assign(Object.create(THREE.Audio.prototype), {
            constructor: THREE.PositionalAudio,
            getOutput: function() {
                return this.panner
            },
            getRefDistance: function() {
                return this.panner.refDistance
            },
            setRefDistance: function(value) {
                this.panner.refDistance = value
            },
            getRolloffFactor: function() {
                return this.panner.rolloffFactor
            },
            setRolloffFactor: function(value) {
                this.panner.rolloffFactor = value
            },
            getDistanceModel: function() {
                return this.panner.distanceModel
            },
            setDistanceModel: function(value) {
                this.panner.distanceModel = value
            },
            getMaxDistance: function() {
                return this.panner.maxDistance
            },
            setMaxDistance: function(value) {
                this.panner.maxDistance = value
            },
            updateMatrixWorld: function() {
                var position = new THREE.Vector3;
                return function(force) {
                    THREE.Object3D.prototype.updateMatrixWorld.call(this, force),
                        position.setFromMatrixPosition(this.matrixWorld),
                        this.panner.setPosition(position.x, position.y, position.z)
                }
            }()
        }),
        THREE.AudioListener = function() {
            THREE.Object3D.call(this),
                this.type = "AudioListener",
                this.context = THREE.AudioContext,
                this.gain = this.context.createGain(),
                this.gain.connect(this.context.destination),
                this.filter = null
        }
        ,
        THREE.AudioListener.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
            constructor: THREE.AudioListener,
            getInput: function() {
                return this.gain
            },
            removeFilter: function() {
                null !== this.filter && (this.gain.disconnect(this.filter),
                    this.filter.disconnect(this.context.destination),
                    this.gain.connect(this.context.destination),
                    this.filter = null)
            },
            getFilter: function() {
                return this.filter
            },
            setFilter: function(value) {
                null !== this.filter ? (this.gain.disconnect(this.filter),
                    this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
                    this.filter = value,
                    this.gain.connect(this.filter),
                    this.filter.connect(this.context.destination)
            },
            getMasterVolume: function() {
                return this.gain.gain.value
            },
            setMasterVolume: function(value) {
                this.gain.gain.value = value
            },
            updateMatrixWorld: function() {
                var position = new THREE.Vector3
                    , quaternion = new THREE.Quaternion
                    , scale = new THREE.Vector3
                    , orientation = new THREE.Vector3;
                return function(force) {
                    THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
                    var listener = this.context.listener
                        , up = this.up;
                    this.matrixWorld.decompose(position, quaternion, scale),
                        orientation.set(0, 0, -1).applyQuaternion(quaternion),
                        listener.setPosition(position.x, position.y, position.z),
                        listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z)
                }
            }()
        }),
        THREE.Camera = function() {
            THREE.Object3D.call(this),
                this.type = "Camera",
                this.matrixWorldInverse = new THREE.Matrix4,
                this.projectionMatrix = new THREE.Matrix4
        }
        ,
        THREE.Camera.prototype = Object.create(THREE.Object3D.prototype),
        THREE.Camera.prototype.constructor = THREE.Camera,
        THREE.Camera.prototype.getWorldDirection = function() {
            var quaternion = new THREE.Quaternion;
            return function(optionalTarget) {
                var result = optionalTarget || new THREE.Vector3;
                return this.getWorldQuaternion(quaternion),
                    result.set(0, 0, -1).applyQuaternion(quaternion)
            }
        }(),
        THREE.Camera.prototype.lookAt = function() {
            var m1 = new THREE.Matrix4;
            return function(vector) {
                m1.lookAt(this.position, vector, this.up),
                    this.quaternion.setFromRotationMatrix(m1)
            }
        }(),
        THREE.Camera.prototype.clone = function() {
            return (new this.constructor).copy(this)
        }
        ,
        THREE.Camera.prototype.copy = function(source) {
            return THREE.Object3D.prototype.copy.call(this, source),
                this.matrixWorldInverse.copy(source.matrixWorldInverse),
                this.projectionMatrix.copy(source.projectionMatrix),
                this
        }
        ,
        THREE.CubeCamera = function(near, far, cubeResolution) {
            THREE.Object3D.call(this),
                this.type = "CubeCamera";
            var fov = 90
                , aspect = 1
                , cameraPX = new THREE.PerspectiveCamera(fov,aspect,near,far);
            cameraPX.up.set(0, -1, 0),
                cameraPX.lookAt(new THREE.Vector3(1,0,0)),
                this.add(cameraPX);
            var cameraNX = new THREE.PerspectiveCamera(fov,aspect,near,far);
            cameraNX.up.set(0, -1, 0),
                cameraNX.lookAt(new THREE.Vector3(-1,0,0)),
                this.add(cameraNX);
            var cameraPY = new THREE.PerspectiveCamera(fov,aspect,near,far);
            cameraPY.up.set(0, 0, 1),
                cameraPY.lookAt(new THREE.Vector3(0,1,0)),
                this.add(cameraPY);
            var cameraNY = new THREE.PerspectiveCamera(fov,aspect,near,far);
            cameraNY.up.set(0, 0, -1),
                cameraNY.lookAt(new THREE.Vector3(0,-1,0)),
                this.add(cameraNY);
            var cameraPZ = new THREE.PerspectiveCamera(fov,aspect,near,far);
            cameraPZ.up.set(0, -1, 0),
                cameraPZ.lookAt(new THREE.Vector3(0,0,1)),
                this.add(cameraPZ);
            var cameraNZ = new THREE.PerspectiveCamera(fov,aspect,near,far);
            cameraNZ.up.set(0, -1, 0),
                cameraNZ.lookAt(new THREE.Vector3(0,0,-1)),
                this.add(cameraNZ);
            var options = {
                format: THREE.RGBFormat,
                magFilter: THREE.LinearFilter,
                minFilter: THREE.LinearFilter
            };
            this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution,cubeResolution,options),
                this.updateCubeMap = function(renderer, scene) {
                    null === this.parent && this.updateMatrixWorld();
                    var renderTarget = this.renderTarget
                        , generateMipmaps = renderTarget.texture.generateMipmaps;
                    renderTarget.texture.generateMipmaps = !1,
                        renderTarget.activeCubeFace = 0,
                        renderer.render(scene, cameraPX, renderTarget),
                        renderTarget.activeCubeFace = 1,
                        renderer.render(scene, cameraNX, renderTarget),
                        renderTarget.activeCubeFace = 2,
                        renderer.render(scene, cameraPY, renderTarget),
                        renderTarget.activeCubeFace = 3,
                        renderer.render(scene, cameraNY, renderTarget),
                        renderTarget.activeCubeFace = 4,
                        renderer.render(scene, cameraPZ, renderTarget),
                        renderTarget.texture.generateMipmaps = generateMipmaps,
                        renderTarget.activeCubeFace = 5,
                        renderer.render(scene, cameraNZ, renderTarget),
                        renderer.setRenderTarget(null)
                }
        }
        ,
        THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype),
        THREE.CubeCamera.prototype.constructor = THREE.CubeCamera,
        THREE.OrthographicCamera = function(left, right, top, bottom, near, far) {
            THREE.Camera.call(this),
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = left,
                this.right = right,
                this.top = top,
                this.bottom = bottom,
                this.near = void 0 !== near ? near : .1,
                this.far = void 0 !== far ? far : 2e3,
                this.updateProjectionMatrix()
        }
        ,
        THREE.OrthographicCamera.prototype = Object.assign(Object.create(THREE.Camera.prototype), {
            constructor: THREE.OrthographicCamera,
            copy: function(source) {
                return THREE.Camera.prototype.copy.call(this, source),
                    this.left = source.left,
                    this.right = source.right,
                    this.top = source.top,
                    this.bottom = source.bottom,
                    this.near = source.near,
                    this.far = source.far,
                    this.zoom = source.zoom,
                    this.view = null === source.view ? null : Object.assign({}, source.view),
                    this
            },
            setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
                this.view = {
                    fullWidth: fullWidth,
                    fullHeight: fullHeight,
                    offsetX: x,
                    offsetY: y,
                    width: width,
                    height: height
                },
                    this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                this.view = null,
                    this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var dx = (this.right - this.left) / (2 * this.zoom)
                    , dy = (this.top - this.bottom) / (2 * this.zoom)
                    , cx = (this.right + this.left) / 2
                    , cy = (this.top + this.bottom) / 2
                    , left = cx - dx
                    , right = cx + dx
                    , top = cy + dy
                    , bottom = cy - dy;
                if (null !== this.view) {
                    var zoomW = this.zoom / (this.view.width / this.view.fullWidth)
                        , zoomH = this.zoom / (this.view.height / this.view.fullHeight)
                        , scaleW = (this.right - this.left) / this.view.width
                        , scaleH = (this.top - this.bottom) / this.view.height;
                    left += scaleW * (this.view.offsetX / zoomW),
                        right = left + scaleW * (this.view.width / zoomW),
                        top -= scaleH * (this.view.offsetY / zoomH),
                        bottom = top - scaleH * (this.view.height / zoomH)
                }
                this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far)
            },
            toJSON: function(meta) {
                var data = THREE.Object3D.prototype.toJSON.call(this, meta);
                return data.object.zoom = this.zoom,
                    data.object.left = this.left,
                    data.object.right = this.right,
                    data.object.top = this.top,
                    data.object.bottom = this.bottom,
                    data.object.near = this.near,
                    data.object.far = this.far,
                null !== this.view && (data.object.view = Object.assign({}, this.view)),
                    data
            }
        }),
        THREE.PerspectiveCamera = function(fov, aspect, near, far) {
            THREE.Camera.call(this),
                this.type = "PerspectiveCamera",
                this.fov = void 0 !== fov ? fov : 50,
                this.zoom = 1,
                this.near = void 0 !== near ? near : .1,
                this.far = void 0 !== far ? far : 2e3,
                this.focus = 10,
                this.aspect = void 0 !== aspect ? aspect : 1,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
        }
        ,
        THREE.PerspectiveCamera.prototype = Object.assign(Object.create(THREE.Camera.prototype), {
            constructor: THREE.PerspectiveCamera,
            copy: function(source) {
                return THREE.Camera.prototype.copy.call(this, source),
                    this.fov = source.fov,
                    this.zoom = source.zoom,
                    this.near = source.near,
                    this.far = source.far,
                    this.focus = source.focus,
                    this.aspect = source.aspect,
                    this.view = null === source.view ? null : Object.assign({}, source.view),
                    this.filmGauge = source.filmGauge,
                    this.filmOffset = source.filmOffset,
                    this
            },
            setFocalLength: function(focalLength) {
                var vExtentSlope = .5 * this.getFilmHeight() / focalLength;
                this.fov = 2 * THREE.Math.RAD2DEG * Math.atan(vExtentSlope),
                    this.updateProjectionMatrix()
            },
            getFocalLength: function() {
                var vExtentSlope = Math.tan(.5 * THREE.Math.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / vExtentSlope
            },
            getEffectiveFOV: function() {
                return 2 * THREE.Math.RAD2DEG * Math.atan(Math.tan(.5 * THREE.Math.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function() {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function() {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
                this.aspect = fullWidth / fullHeight,
                    this.view = {
                        fullWidth: fullWidth,
                        fullHeight: fullHeight,
                        offsetX: x,
                        offsetY: y,
                        width: width,
                        height: height
                    },
                    this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                this.view = null,
                    this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var near = this.near
                    , top = near * Math.tan(.5 * THREE.Math.DEG2RAD * this.fov) / this.zoom
                    , height = 2 * top
                    , width = this.aspect * height
                    , left = -.5 * width
                    , view = this.view;
                if (null !== view) {
                    var fullWidth = view.fullWidth
                        , fullHeight = view.fullHeight;
                    left += view.offsetX * width / fullWidth,
                        top -= view.offsetY * height / fullHeight,
                        width *= view.width / fullWidth,
                        height *= view.height / fullHeight
                }
                var skew = this.filmOffset;
                0 !== skew && (left += near * skew / this.getFilmWidth()),
                    this.projectionMatrix.makeFrustum(left, left + width, top - height, top, near, this.far)
            },
            toJSON: function(meta) {
                var data = THREE.Object3D.prototype.toJSON.call(this, meta);
                return data.object.fov = this.fov,
                    data.object.zoom = this.zoom,
                    data.object.near = this.near,
                    data.object.far = this.far,
                    data.object.focus = this.focus,
                    data.object.aspect = this.aspect,
                null !== this.view && (data.object.view = Object.assign({}, this.view)),
                    data.object.filmGauge = this.filmGauge,
                    data.object.filmOffset = this.filmOffset,
                    data
            }
        }),
        THREE.StereoCamera = function() {
            this.type = "StereoCamera",
                this.aspect = 1,
                this.cameraL = new THREE.PerspectiveCamera,
                this.cameraL.layers.enable(1),
                this.cameraL.matrixAutoUpdate = !1,
                this.cameraR = new THREE.PerspectiveCamera,
                this.cameraR.layers.enable(2),
                this.cameraR.matrixAutoUpdate = !1
        }
        ,
        Object.assign(THREE.StereoCamera.prototype, {
            update: function() {
                var focus, fov, aspect, near, far, eyeRight = new THREE.Matrix4, eyeLeft = new THREE.Matrix4;
                return function(camera) {
                    var needsUpdate = focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far;
                    if (needsUpdate) {
                        focus = camera.focus,
                            fov = camera.fov,
                            aspect = camera.aspect * this.aspect,
                            near = camera.near,
                            far = camera.far;
                        var xmin, xmax, projectionMatrix = camera.projectionMatrix.clone(), eyeSep = .032, eyeSepOnProjection = eyeSep * near / focus, ymax = near * Math.tan(THREE.Math.DEG2RAD * fov * .5);
                        eyeLeft.elements[12] = -eyeSep,
                            eyeRight.elements[12] = eyeSep,
                            xmin = -ymax * aspect + eyeSepOnProjection,
                            xmax = ymax * aspect + eyeSepOnProjection,
                            projectionMatrix.elements[0] = 2 * near / (xmax - xmin),
                            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin),
                            this.cameraL.projectionMatrix.copy(projectionMatrix),
                            xmin = -ymax * aspect - eyeSepOnProjection,
                            xmax = ymax * aspect - eyeSepOnProjection,
                            projectionMatrix.elements[0] = 2 * near / (xmax - xmin),
                            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin),
                            this.cameraR.projectionMatrix.copy(projectionMatrix)
                    }
                    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft),
                        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight)
                }
            }()
        }),
        THREE.Light = function(color, intensity) {
            THREE.Object3D.call(this),
                this.type = "Light",
                this.color = new THREE.Color(color),
                this.intensity = void 0 !== intensity ? intensity : 1,
                this.receiveShadow = void 0
        }
        ,
        THREE.Light.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
            constructor: THREE.Light,
            copy: function(source) {
                return THREE.Object3D.prototype.copy.call(this, source),
                    this.color.copy(source.color),
                    this.intensity = source.intensity,
                    this
            },
            toJSON: function(meta) {
                var data = THREE.Object3D.prototype.toJSON.call(this, meta);
                return data.object.color = this.color.getHex(),
                    data.object.intensity = this.intensity,
                void 0 !== this.groundColor && (data.object.groundColor = this.groundColor.getHex()),
                void 0 !== this.distance && (data.object.distance = this.distance),
                void 0 !== this.angle && (data.object.angle = this.angle),
                void 0 !== this.decay && (data.object.decay = this.decay),
                void 0 !== this.penumbra && (data.object.penumbra = this.penumbra),
                    data
            }
        }),
        THREE.LightShadow = function(camera) {
            this.camera = camera,
                this.bias = 0,
                this.radius = 1,
                this.mapSize = new THREE.Vector2(512,512),
                this.map = null,
                this.matrix = new THREE.Matrix4
        }
        ,
        Object.assign(THREE.LightShadow.prototype, {
            copy: function(source) {
                return this.camera = source.camera.clone(),
                    this.bias = source.bias,
                    this.radius = source.radius,
                    this.mapSize.copy(source.mapSize),
                    this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }),
        THREE.AmbientLight = function(color, intensity) {
            THREE.Light.call(this, color, intensity),
                this.type = "AmbientLight",
                this.castShadow = void 0
        }
        ,
        THREE.AmbientLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
            constructor: THREE.AmbientLight
        }),
        THREE.DirectionalLight = function(color, intensity) {
            THREE.Light.call(this, color, intensity),
                this.type = "DirectionalLight",
                this.position.set(0, 1, 0),
                this.updateMatrix(),
                this.target = new THREE.Object3D,
                this.shadow = new THREE.DirectionalLightShadow
        }
        ,
        THREE.DirectionalLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
            constructor: THREE.DirectionalLight,
            copy: function(source) {
                return THREE.Light.prototype.copy.call(this, source),
                    this.target = source.target.clone(),
                    this.shadow = source.shadow.clone(),
                    this
            }
        }),
        THREE.DirectionalLightShadow = function(light) {
            THREE.LightShadow.call(this, new THREE.OrthographicCamera(-5,5,5,-5,.5,500))
        }
        ,
        THREE.DirectionalLightShadow.prototype = Object.assign(Object.create(THREE.LightShadow.prototype), {
            constructor: THREE.DirectionalLightShadow
        }),
        THREE.HemisphereLight = function(skyColor, groundColor, intensity) {
            THREE.Light.call(this, skyColor, intensity),
                this.type = "HemisphereLight",
                this.castShadow = void 0,
                this.position.set(0, 1, 0),
                this.updateMatrix(),
                this.groundColor = new THREE.Color(groundColor)
        }
        ,
        THREE.HemisphereLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
            constructor: THREE.HemisphereLight,
            copy: function(source) {
                return THREE.Light.prototype.copy.call(this, source),
                    this.groundColor.copy(source.groundColor),
                    this
            }
        }),
        THREE.PointLight = function(color, intensity, distance, decay) {
            THREE.Light.call(this, color, intensity),
                this.type = "PointLight",
                Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(power) {
                        this.intensity = power / (4 * Math.PI)
                    }
                }),
                this.distance = void 0 !== distance ? distance : 0,
                this.decay = void 0 !== decay ? decay : 1,
                this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90,1,.5,500))
        }
        ,
        THREE.PointLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
            constructor: THREE.PointLight,
            copy: function(source) {
                return THREE.Light.prototype.copy.call(this, source),
                    this.distance = source.distance,
                    this.decay = source.decay,
                    this.shadow = source.shadow.clone(),
                    this
            }
        }),
        THREE.SpotLight = function(color, intensity, distance, angle, penumbra, decay) {
            THREE.Light.call(this, color, intensity),
                this.type = "SpotLight",
                this.position.set(0, 1, 0),
                this.updateMatrix(),
                this.target = new THREE.Object3D,
                Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(power) {
                        this.intensity = power / Math.PI
                    }
                }),
                this.distance = void 0 !== distance ? distance : 0,
                this.angle = void 0 !== angle ? angle : Math.PI / 3,
                this.penumbra = void 0 !== penumbra ? penumbra : 0,
                this.decay = void 0 !== decay ? decay : 1,
                this.shadow = new THREE.SpotLightShadow
        }
        ,
        THREE.SpotLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
            constructor: THREE.SpotLight,
            copy: function(source) {
                return THREE.Light.prototype.copy.call(this, source),
                    this.distance = source.distance,
                    this.angle = source.angle,
                    this.penumbra = source.penumbra,
                    this.decay = source.decay,
                    this.target = source.target.clone(),
                    this.shadow = source.shadow.clone(),
                    this
            }
        }),
        THREE.SpotLightShadow = function() {
            THREE.LightShadow.call(this, new THREE.PerspectiveCamera(50,1,.5,500))
        }
        ,
        THREE.SpotLightShadow.prototype = Object.assign(Object.create(THREE.LightShadow.prototype), {
            constructor: THREE.SpotLightShadow,
            update: function(light) {
                var fov = 2 * THREE.Math.RAD2DEG * light.angle
                    , aspect = this.mapSize.width / this.mapSize.height
                    , far = light.distance || 500
                    , camera = this.camera;
                fov === camera.fov && aspect === camera.aspect && far === camera.far || (camera.fov = fov,
                    camera.aspect = aspect,
                    camera.far = far,
                    camera.updateProjectionMatrix())
            }
        }),
        THREE.AudioLoader = function(manager) {
            this.manager = void 0 !== manager ? manager : THREE.DefaultLoadingManager
        }
        ,
        Object.assign(THREE.AudioLoader.prototype, {
            load: function(url, onLoad, onProgress, onError) {
                var loader = new THREE.XHRLoader(this.manager);
                loader.setResponseType("arraybuffer"),
                    loader.load(url, function(buffer) {
                        var context = THREE.AudioContext;
                        context.decodeAudioData(buffer, function(audioBuffer) {
                            onLoad(audioBuffer)
                        })
                    }, onProgress, onError)
            }
        }),
        THREE.Cache = {
            enabled: !1,
            files: {},
            add: function(key, file) {
                this.enabled !== !1 && (this.files[key] = file)
            },
            get: function(key) {
                if (this.enabled !== !1)
                    return this.files[key]
            },
            remove: function(key) {
                delete this.files[key]
            },
            clear: function() {
                this.files = {}
            }
        },
        THREE.Loader = function() {
            this.onLoadStart = function() {}
                ,
                this.onLoadProgress = function() {}
                ,
                this.onLoadComplete = function() {}
        }
        ,
        THREE.Loader.prototype = {
            constructor: THREE.Loader,
            crossOrigin: void 0,
            extractUrlBase: function(url) {
                var parts = url.split("/");
                return 1 === parts.length ? "./" : (parts.pop(),
                parts.join("/") + "/")
            },
            initMaterials: function(materials, texturePath, crossOrigin) {
                for (var array = [], i = 0; i < materials.length; ++i)
                    array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
                return array
            },
            createMaterial: function() {
                var color, textureLoader, materialLoader;
                return function(m, texturePath, crossOrigin) {
                    function loadTexture(path, repeat, offset, wrap, anisotropy) {
                        var texture, fullPath = texturePath + path, loader = THREE.Loader.Handlers.get(fullPath);
                        null !== loader ? texture = loader.load(fullPath) : (textureLoader.setCrossOrigin(crossOrigin),
                            texture = textureLoader.load(fullPath)),
                        void 0 !== repeat && (texture.repeat.fromArray(repeat),
                        1 !== repeat[0] && (texture.wrapS = THREE.RepeatWrapping),
                        1 !== repeat[1] && (texture.wrapT = THREE.RepeatWrapping)),
                        void 0 !== offset && texture.offset.fromArray(offset),
                        void 0 !== wrap && ("repeat" === wrap[0] && (texture.wrapS = THREE.RepeatWrapping),
                        "mirror" === wrap[0] && (texture.wrapS = THREE.MirroredRepeatWrapping),
                        "repeat" === wrap[1] && (texture.wrapT = THREE.RepeatWrapping),
                        "mirror" === wrap[1] && (texture.wrapT = THREE.MirroredRepeatWrapping)),
                        void 0 !== anisotropy && (texture.anisotropy = anisotropy);
                        var uuid = THREE.Math.generateUUID();
                        return textures[uuid] = texture,
                            uuid
                    }
                    void 0 === color && (color = new THREE.Color),
                    void 0 === textureLoader && (textureLoader = new THREE.TextureLoader),
                    void 0 === materialLoader && (materialLoader = new THREE.MaterialLoader);
                    var textures = {}
                        , json = {
                        uuid: THREE.Math.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                    for (var name in m) {
                        var value = m[name];
                        switch (name) {
                            case "DbgColor":
                            case "DbgIndex":
                            case "opticalDensity":
                            case "illumination":
                                break;
                            case "DbgName":
                                json.name = value;
                                break;
                            case "blending":
                                json.blending = THREE[value];
                                break;
                            case "colorAmbient":
                            case "mapAmbient":
                                console.warn("THREE.Loader.createMaterial:", name, "is no longer supported.");
                                break;
                            case "colorDiffuse":
                                json.color = color.fromArray(value).getHex();
                                break;
                            case "colorSpecular":
                                json.specular = color.fromArray(value).getHex();
                                break;
                            case "colorEmissive":
                                json.emissive = color.fromArray(value).getHex();
                                break;
                            case "specularCoef":
                                json.shininess = value;
                                break;
                            case "shading":
                                "basic" === value.toLowerCase() && (json.type = "MeshBasicMaterial"),
                                "phong" === value.toLowerCase() && (json.type = "MeshPhongMaterial"),
                                "standard" === value.toLowerCase() && (json.type = "MeshStandardMaterial");
                                break;
                            case "mapDiffuse":
                                json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                                break;
                            case "mapDiffuseRepeat":
                            case "mapDiffuseOffset":
                            case "mapDiffuseWrap":
                            case "mapDiffuseAnisotropy":
                                break;
                            case "mapEmissive":
                                json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                                break;
                            case "mapEmissiveRepeat":
                            case "mapEmissiveOffset":
                            case "mapEmissiveWrap":
                            case "mapEmissiveAnisotropy":
                                break;
                            case "mapLight":
                                json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                                break;
                            case "mapLightRepeat":
                            case "mapLightOffset":
                            case "mapLightWrap":
                            case "mapLightAnisotropy":
                                break;
                            case "mapAO":
                                json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                                break;
                            case "mapAORepeat":
                            case "mapAOOffset":
                            case "mapAOWrap":
                            case "mapAOAnisotropy":
                                break;
                            case "mapBump":
                                json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                                break;
                            case "mapBumpScale":
                                json.bumpScale = value;
                                break;
                            case "mapBumpRepeat":
                            case "mapBumpOffset":
                            case "mapBumpWrap":
                            case "mapBumpAnisotropy":
                                break;
                            case "mapNormal":
                                json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                                break;
                            case "mapNormalFactor":
                                json.normalScale = [value, value];
                                break;
                            case "mapNormalRepeat":
                            case "mapNormalOffset":
                            case "mapNormalWrap":
                            case "mapNormalAnisotropy":
                                break;
                            case "mapSpecular":
                                json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                                break;
                            case "mapSpecularRepeat":
                            case "mapSpecularOffset":
                            case "mapSpecularWrap":
                            case "mapSpecularAnisotropy":
                                break;
                            case "mapMetalness":
                                json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                                break;
                            case "mapMetalnessRepeat":
                            case "mapMetalnessOffset":
                            case "mapMetalnessWrap":
                            case "mapMetalnessAnisotropy":
                                break;
                            case "mapRoughness":
                                json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                                break;
                            case "mapRoughnessRepeat":
                            case "mapRoughnessOffset":
                            case "mapRoughnessWrap":
                            case "mapRoughnessAnisotropy":
                                break;
                            case "mapAlpha":
                                json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                                break;
                            case "mapAlphaRepeat":
                            case "mapAlphaOffset":
                            case "mapAlphaWrap":
                            case "mapAlphaAnisotropy":
                                break;
                            case "flipSided":
                                json.side = THREE.BackSide;
                                break;
                            case "doubleSided":
                                json.side = THREE.DoubleSide;
                                break;
                            case "transparency":
                                console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),
                                    json.opacity = value;
                                break;
                            case "depthTest":
                            case "depthWrite":
                            case "colorWrite":
                            case "opacity":
                            case "reflectivity":
                            case "transparent":
                            case "visible":
                            case "wireframe":
                                json[name] = value;
                                break;
                            case "vertexColors":
                                value === !0 && (json.vertexColors = THREE.VertexColors),
                                "face" === value && (json.vertexColors = THREE.FaceColors);
                                break;
                            default:
                                console.error("THREE.Loader.createMaterial: Unsupported", name, value)
                        }
                    }
                    return "MeshBasicMaterial" === json.type && delete json.emissive,
                    "MeshPhongMaterial" !== json.type && delete json.specular,
                    json.opacity < 1 && (json.transparent = !0),
                        materialLoader.setTextures(textures),
                        materialLoader.parse(json)
                }
            }()
        },
        THREE.Loader.Handlers = {
            handlers: [],
            add: function(regex, loader) {
                this.handlers.push(regex, loader)
            },
            get: function(file) {
                for (var handlers = this.handlers, i = 0, l = handlers.length; i < l; i += 2) {
                    var regex = handlers[i]
                        , loader = handlers[i + 1];
                    if (regex.test(file))
                        return loader
                }
                return null
            }
        };
        THREE.XHRLoader = function(manager) {
            this.manager = void 0 !== manager ? manager : THREE.DefaultLoadingManager
        }
        ;
        Object.assign(THREE.XHRLoader.prototype, {
            load: function(url, onLoad, onProgress, onError) {
                void 0 !== this.path && (url = this.path + url);
                var scope = this
                    , cached = THREE.Cache.get(url);
                if (void 0 !== cached)
                    return onLoad && setTimeout(function() {
                        onLoad(cached)
                    }, 0),
                        cached;
                var request = new XMLHttpRequest;
                return request.overrideMimeType("text/plain"),
                    request.open("GET", url, !0),
                    request.addEventListener("load", function(event) {
                        var response = event.target.response;
                        THREE.Cache.add(url, response),
                            200 === this.status ? (onLoad && onLoad(response),
                                scope.manager.itemEnd(url)) : 0 === this.status ? (console.warn("THREE.XHRLoader: HTTP Status 0 received."),
                            onLoad && onLoad(response),
                                scope.manager.itemEnd(url)) : (onError && onError(event),
                                scope.manager.itemError(url))
                    }, !1),
                void 0 !== onProgress && request.addEventListener("progress", function(event) {
                    onProgress(event)
                }, !1),
                    request.addEventListener("error", function(event) {
                        onError && onError(event),
                            scope.manager.itemError(url)
                    }, !1),
                void 0 !== this.responseType && (request.responseType = this.responseType),
                void 0 !== this.withCredentials && (request.withCredentials = this.withCredentials),
                    request.send(null),
                    scope.manager.itemStart(url),
                    request
            },
            setPath: function(value) {
                return this.path = value,
                    this
            },
            setResponseType: function(value) {
                return this.responseType = value,
                    this
            },
            setWithCredentials: function(value) {
                return this.withCredentials = value,
                    this
            }
        }),
            THREE.FontLoader = function(manager) {
                this.manager = void 0 !== manager ? manager : THREE.DefaultLoadingManager
            }
            ,
            Object.assign(THREE.FontLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var scope = this
                        , loader = new THREE.XHRLoader(this.manager);
                    loader.load(url, function(text) {
                        var json;
                        try {
                            json = JSON.parse(text)
                        } catch (e) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                                json = JSON.parse(text.substring(65, text.length - 2))
                        }
                        var font = scope.parse(json);
                        onLoad && onLoad(font)
                    }, onProgress, onError)
                },
                parse: function(json) {
                    return new THREE.Font(json)
                }
            }),
            THREE.ImageLoader = function(manager) {
                this.manager = void 0 !== manager ? manager : THREE.DefaultLoadingManager
            }
            ,
            Object.assign(THREE.ImageLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                    if (image.onload = function() {
                            URL.revokeObjectURL(image.src),
                            onLoad && onLoad(image)
                        }
                            ,
                        0 === url.indexOf("data:"))
                        image.src = url;
                    else {
                        var loader = new THREE.XHRLoader(this.manager);
                        loader.setPath(this.path),
                            loader.setResponseType("blob"),
                            loader.load(url, function(blob) {
                                image.src = URL.createObjectURL(blob)
                            }, onProgress, onError)
                    }
                    return image
                },
                setCrossOrigin: function(value) {
                    return this.crossOrigin = value,
                        this
                },
                setPath: function(value) {
                    return this.path = value,
                        this
                }
            }),
            THREE.JSONLoader = function(manager) {
                "boolean" == typeof manager && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),
                    manager = void 0),
                    this.manager = void 0 !== manager ? manager : THREE.DefaultLoadingManager,
                    this.withCredentials = !1
            }
            ,
            Object.assign(THREE.JSONLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var scope = this
                        , texturePath = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : THREE.Loader.prototype.extractUrlBase(url)
                        , loader = new THREE.XHRLoader(this.manager);
                    loader.setWithCredentials(this.withCredentials),
                        loader.load(url, function(text) {
                            var json = JSON.parse(text)
                                , metadata = json.metadata;
                            if (void 0 !== metadata) {
                                var type = metadata.type;
                                if (void 0 !== type) {
                                    if ("object" === type.toLowerCase())
                                        return void console.error("THREE.JSONLoader: " + url + " should be loaded with THREE.ObjectLoader instead.");
                                    if ("scene" === type.toLowerCase())
                                        return void console.error("THREE.JSONLoader: " + url + " should be loaded with THREE.SceneLoader instead.")
                                }
                            }
                            var object = scope.parse(json, texturePath);
                            onLoad(object.geometry, object.materials)
                        }, onProgress, onError)
                },
                setTexturePath: function(value) {
                    this.texturePath = value
                },
                parse: function(json, texturePath) {
                    function parseModel(scale) {
                        function isBitSet(value, position) {
                            return value & 1 << position
                        }
                        var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;
                        if (void 0 !== json.uvs) {
                            for (i = 0; i < json.uvs.length; i++)
                                json.uvs[i].length && nUvLayers++;
                            for (i = 0; i < nUvLayers; i++)
                                geometry.faceVertexUvs[i] = []
                        }
                        for (offset = 0,
                                 zLength = vertices.length; offset < zLength; )
                            vertex = new THREE.Vector3,
                                vertex.x = vertices[offset++] * scale,
                                vertex.y = vertices[offset++] * scale,
                                vertex.z = vertices[offset++] * scale,
                                geometry.vertices.push(vertex);
                        for (offset = 0,
                                 zLength = faces.length; offset < zLength; )
                            if (type = faces[offset++],
                                    isQuad = isBitSet(type, 0),
                                    hasMaterial = isBitSet(type, 1),
                                    hasFaceVertexUv = isBitSet(type, 3),
                                    hasFaceNormal = isBitSet(type, 4),
                                    hasFaceVertexNormal = isBitSet(type, 5),
                                    hasFaceColor = isBitSet(type, 6),
                                    hasFaceVertexColor = isBitSet(type, 7),
                                    isQuad) {
                                if (faceA = new THREE.Face3,
                                        faceA.a = faces[offset],
                                        faceA.b = faces[offset + 1],
                                        faceA.c = faces[offset + 3],
                                        faceB = new THREE.Face3,
                                        faceB.a = faces[offset + 1],
                                        faceB.b = faces[offset + 2],
                                        faceB.c = faces[offset + 3],
                                        offset += 4,
                                    hasMaterial && (materialIndex = faces[offset++],
                                        faceA.materialIndex = materialIndex,
                                        faceB.materialIndex = materialIndex),
                                        fi = geometry.faces.length,
                                        hasFaceVertexUv)
                                    for (i = 0; i < nUvLayers; i++)
                                        for (uvLayer = json.uvs[i],
                                                 geometry.faceVertexUvs[i][fi] = [],
                                                 geometry.faceVertexUvs[i][fi + 1] = [],
                                                 j = 0; j < 4; j++)
                                            uvIndex = faces[offset++],
                                                u = uvLayer[2 * uvIndex],
                                                v = uvLayer[2 * uvIndex + 1],
                                                uv = new THREE.Vector2(u,v),
                                            2 !== j && geometry.faceVertexUvs[i][fi].push(uv),
                                            0 !== j && geometry.faceVertexUvs[i][fi + 1].push(uv);
                                if (hasFaceNormal && (normalIndex = 3 * faces[offset++],
                                        faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]),
                                        faceB.normal.copy(faceA.normal)),
                                        hasFaceVertexNormal)
                                    for (i = 0; i < 4; i++)
                                        normalIndex = 3 * faces[offset++],
                                            normal = new THREE.Vector3(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]),
                                        2 !== i && faceA.vertexNormals.push(normal),
                                        0 !== i && faceB.vertexNormals.push(normal);
                                if (hasFaceColor && (colorIndex = faces[offset++],
                                        hex = colors[colorIndex],
                                        faceA.color.setHex(hex),
                                        faceB.color.setHex(hex)),
                                        hasFaceVertexColor)
                                    for (i = 0; i < 4; i++)
                                        colorIndex = faces[offset++],
                                            hex = colors[colorIndex],
                                        2 !== i && faceA.vertexColors.push(new THREE.Color(hex)),
                                        0 !== i && faceB.vertexColors.push(new THREE.Color(hex));
                                geometry.faces.push(faceA),
                                    geometry.faces.push(faceB)
                            } else {
                                if (face = new THREE.Face3,
                                        face.a = faces[offset++],
                                        face.b = faces[offset++],
                                        face.c = faces[offset++],
                                    hasMaterial && (materialIndex = faces[offset++],
                                        face.materialIndex = materialIndex),
                                        fi = geometry.faces.length,
                                        hasFaceVertexUv)
                                    for (i = 0; i < nUvLayers; i++)
                                        for (uvLayer = json.uvs[i],
                                                 geometry.faceVertexUvs[i][fi] = [],
                                                 j = 0; j < 3; j++)
                                            uvIndex = faces[offset++],
                                                u = uvLayer[2 * uvIndex],
                                                v = uvLayer[2 * uvIndex + 1],
                                                uv = new THREE.Vector2(u,v),
                                                geometry.faceVertexUvs[i][fi].push(uv);
                                if (hasFaceNormal && (normalIndex = 3 * faces[offset++],
                                        face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex])),
                                        hasFaceVertexNormal)
                                    for (i = 0; i < 3; i++)
                                        normalIndex = 3 * faces[offset++],
                                            normal = new THREE.Vector3(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]),
                                            face.vertexNormals.push(normal);
                                if (hasFaceColor && (colorIndex = faces[offset++],
                                        face.color.setHex(colors[colorIndex])),
                                        hasFaceVertexColor)
                                    for (i = 0; i < 3; i++)
                                        colorIndex = faces[offset++],
                                            face.vertexColors.push(new THREE.Color(colors[colorIndex]));
                                geometry.faces.push(face)
                            }
                    }
                    function parseSkin() {
                        var influencesPerVertex = void 0 !== json.influencesPerVertex ? json.influencesPerVertex : 2;
                        if (json.skinWeights)
                            for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
                                var x = json.skinWeights[i]
                                    , y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0
                                    , z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0
                                    , w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;
                                geometry.skinWeights.push(new THREE.Vector4(x,y,z,w))
                            }
                        if (json.skinIndices)
                            for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
                                var a = json.skinIndices[i]
                                    , b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0
                                    , c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0
                                    , d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;
                                geometry.skinIndices.push(new THREE.Vector4(a,b,c,d))
                            }
                        geometry.bones = json.bones,
                        geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length) && console.warn("When skinning, number of vertices (" + geometry.vertices.length + "), skinIndices (" + geometry.skinIndices.length + "), and skinWeights (" + geometry.skinWeights.length + ") should match.")
                    }
                    function parseMorphing(scale) {
                        if (void 0 !== json.morphTargets)
                            for (var i = 0, l = json.morphTargets.length; i < l; i++) {
                                geometry.morphTargets[i] = {},
                                    geometry.morphTargets[i].name = json.morphTargets[i].name,
                                    geometry.morphTargets[i].vertices = [];
                                for (var dstVertices = geometry.morphTargets[i].vertices, srcVertices = json.morphTargets[i].vertices, v = 0, vl = srcVertices.length; v < vl; v += 3) {
                                    var vertex = new THREE.Vector3;
                                    vertex.x = srcVertices[v] * scale,
                                        vertex.y = srcVertices[v + 1] * scale,
                                        vertex.z = srcVertices[v + 2] * scale,
                                        dstVertices.push(vertex)
                                }
                            }
                        if (void 0 !== json.morphColors && json.morphColors.length > 0) {
                            console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                            for (var faces = geometry.faces, morphColors = json.morphColors[0].colors, i = 0, l = faces.length; i < l; i++)
                                faces[i].color.fromArray(morphColors, 3 * i)
                        }
                    }
                    function parseAnimations() {
                        var outputAnimations = []
                            , animations = [];
                        void 0 !== json.animation && animations.push(json.animation),
                        void 0 !== json.animations && (json.animations.length ? animations = animations.concat(json.animations) : animations.push(json.animations));
                        for (var i = 0; i < animations.length; i++) {
                            var clip = THREE.AnimationClip.parseAnimation(animations[i], geometry.bones);
                            clip && outputAnimations.push(clip)
                        }
                        if (geometry.morphTargets) {
                            var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                            outputAnimations = outputAnimations.concat(morphAnimationClips)
                        }
                        outputAnimations.length > 0 && (geometry.animations = outputAnimations)
                    }
                    var geometry = new THREE.Geometry
                        , scale = void 0 !== json.scale ? 1 / json.scale : 1;
                    if (parseModel(scale),
                            parseSkin(),
                            parseMorphing(scale),
                            parseAnimations(),
                            geometry.computeFaceNormals(),
                            geometry.computeBoundingSphere(),
                        void 0 === json.materials || 0 === json.materials.length)
                        return {
                            geometry: geometry
                        };
                    var materials = THREE.Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
                    return {
                        geometry: geometry,
                        materials: materials
                    }
                }
            }),
            THREE.LoadingManager = function(onLoad, onProgress, onError) {
                var scope = this
                    , isLoading = !1
                    , itemsLoaded = 0
                    , itemsTotal = 0;
                this.onStart = void 0,
                    this.onLoad = onLoad,
                    this.onProgress = onProgress,
                    this.onError = onError,
                    this.itemStart = function(url) {
                        itemsTotal++,
                        isLoading === !1 && void 0 !== scope.onStart && scope.onStart(url, itemsLoaded, itemsTotal),
                            isLoading = !0
                    }
                    ,
                    this.itemEnd = function(url) {
                        itemsLoaded++,
                        void 0 !== scope.onProgress && scope.onProgress(url, itemsLoaded, itemsTotal),
                        itemsLoaded === itemsTotal && (isLoading = !1,
                        void 0 !== scope.onLoad && scope.onLoad())
                    }
                    ,
                    this.itemError = function(url) {
                        void 0 !== scope.onError && scope.onError(url)
                    }
            }
            ,
            THREE.DefaultLoadingManager = new THREE.LoadingManager,
            THREE.BufferGeometryLoader = function(manager) {
                this.manager = void 0 !== manager ? manager : THREE.DefaultLoadingManager
            }
            ,
            Object.assign(THREE.BufferGeometryLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var scope = this
                        , loader = new THREE.XHRLoader(scope.manager);
                    loader.load(url, function(text) {
                        onLoad(scope.parse(JSON.parse(text)))
                    }, onProgress, onError)
                },
                parse: function(json) {
                    var geometry = new THREE.BufferGeometry
                        , index = json.data.index
                        , TYPED_ARRAYS = {
                        Int8Array: Int8Array,
                        Uint8Array: Uint8Array,
                        Uint8ClampedArray: Uint8ClampedArray,
                        Int16Array: Int16Array,
                        Uint16Array: Uint16Array,
                        Int32Array: Int32Array,
                        Uint32Array: Uint32Array,
                        Float32Array: Float32Array,
                        Float64Array: Float64Array
                    };
                    if (void 0 !== index) {
                        var typedArray = new TYPED_ARRAYS[index.type](index.array);
                        geometry.setIndex(new THREE.BufferAttribute(typedArray,1))
                    }
                    var attributes = json.data.attributes;
                    for (var key in attributes) {
                        var attribute = attributes[key]
                            , typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                        geometry.addAttribute(key, new THREE.BufferAttribute(typedArray,attribute.itemSize,attribute.normalized))
                    }
                    var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
                    if (void 0 !== groups)
                        for (var i = 0, n = groups.length; i !== n; ++i) {
                            var group = groups[i];
                            geometry.addGroup(group.start, group.count, group.materialIndex)
                        }
                    var boundingSphere = json.data.boundingSphere;
                    if (void 0 !== boundingSphere) {
                        var center = new THREE.Vector3;
                        void 0 !== boundingSphere.center && center.fromArray(boundingSphere.center),
                            geometry.boundingSphere = new THREE.Sphere(center,boundingSphere.radius)
                    }
                    return geometry
                }
            }),
            THREE.MaterialLoader = function(manager) {
                this.manager = void 0 !== manager ? manager : THREE.DefaultLoadingManager,
                    this.textures = {}
            }
            ,
            Object.assign(THREE.MaterialLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var scope = this
                        , loader = new THREE.XHRLoader(scope.manager);
                    loader.load(url, function(text) {
                        onLoad(scope.parse(JSON.parse(text)))
                    }, onProgress, onError)
                },
                setTextures: function(value) {
                    this.textures = value
                },
                getTexture: function(name) {
                    var textures = this.textures;
                    return void 0 === textures[name] && console.warn("THREE.MaterialLoader: Undefined texture", name),
                        textures[name]
                },
                parse: function(json) {
                    var material = new THREE[json.type];
                    if (void 0 !== json.uuid && (material.uuid = json.uuid),
                        void 0 !== json.name && (material.name = json.name),
                        void 0 !== json.color && material.color.setHex(json.color),
                        void 0 !== json.roughness && (material.roughness = json.roughness),
                        void 0 !== json.metalness && (material.metalness = json.metalness),
                        void 0 !== json.emissive && material.emissive.setHex(json.emissive),
                        void 0 !== json.specular && material.specular.setHex(json.specular),
                        void 0 !== json.shininess && (material.shininess = json.shininess),
                        void 0 !== json.uniforms && (material.uniforms = json.uniforms),
                        void 0 !== json.vertexShader && (material.vertexShader = json.vertexShader),
                        void 0 !== json.fragmentShader && (material.fragmentShader = json.fragmentShader),
                        void 0 !== json.vertexColors && (material.vertexColors = json.vertexColors),
                        void 0 !== json.shading && (material.shading = json.shading),
                        void 0 !== json.blending && (material.blending = json.blending),
                        void 0 !== json.side && (material.side = json.side),
                        void 0 !== json.opacity && (material.opacity = json.opacity),
                        void 0 !== json.transparent && (material.transparent = json.transparent),
                        void 0 !== json.alphaTest && (material.alphaTest = json.alphaTest),
                        void 0 !== json.depthTest && (material.depthTest = json.depthTest),
                        void 0 !== json.depthWrite && (material.depthWrite = json.depthWrite),
                        void 0 !== json.colorWrite && (material.colorWrite = json.colorWrite),
                        void 0 !== json.wireframe && (material.wireframe = json.wireframe),
                        void 0 !== json.wireframeLinewidth && (material.wireframeLinewidth = json.wireframeLinewidth),
                        void 0 !== json.size && (material.size = json.size),
                        void 0 !== json.sizeAttenuation && (material.sizeAttenuation = json.sizeAttenuation),
                        void 0 !== json.map && (material.map = this.getTexture(json.map)),
                        void 0 !== json.alphaMap && (material.alphaMap = this.getTexture(json.alphaMap),
                            material.transparent = !0),
                        void 0 !== json.bumpMap && (material.bumpMap = this.getTexture(json.bumpMap)),
                        void 0 !== json.bumpScale && (material.bumpScale = json.bumpScale),
                        void 0 !== json.normalMap && (material.normalMap = this.getTexture(json.normalMap)),
                        void 0 !== json.normalScale) {
                        var normalScale = json.normalScale;
                        Array.isArray(normalScale) === !1 && (normalScale = [normalScale, normalScale]),
                            material.normalScale = (new THREE.Vector2).fromArray(normalScale)
                    }
                    if (void 0 !== json.displacementMap && (material.displacementMap = this.getTexture(json.displacementMap)),
                        void 0 !== json.displacementScale && (material.displacementScale = json.displacementScale),
                        void 0 !== json.displacementBias && (material.displacementBias = json.displacementBias),
                        void 0 !== json.roughnessMap && (material.roughnessMap = this.getTexture(json.roughnessMap)),
                        void 0 !== json.metalnessMap && (material.metalnessMap = this.getTexture(json.metalnessMap)),
                        void 0 !== json.emissiveMap && (material.emissiveMap = this.getTexture(json.emissiveMap)),
                        void 0 !== json.emissiveIntensity && (material.emissiveIntensity = json.emissiveIntensity),
                        void 0 !== json.specularMap && (material.specularMap = this.getTexture(json.specularMap)),
                        void 0 !== json.envMap && (material.envMap = this.getTexture(json.envMap),
                            material.combine = THREE.MultiplyOperation),
                        void 0 !== json.reflectivity && (material.reflectivity = json.reflectivity),
                        void 0 !== json.lightMap && (material.lightMap = this.getTexture(json.lightMap)),
                        void 0 !== json.lightMapIntensity && (material.lightMapIntensity = json.lightMapIntensity),
                        void 0 !== json.aoMap && (material.aoMap = this.getTexture(json.aoMap)),
                        void 0 !== json.aoMapIntensity && (material.aoMapIntensity = json.aoMapIntensity),
                        void 0 !== json.materials)
                        for (var i = 0, l = json.materials.length; i < l; i++)
                            material.materials.push(this.parse(json.materials[i]));
                    return material
                }
            }),
            THREE.ObjectLoader = function(manager) {
                this.manager = void 0 !== manager ? manager : THREE.DefaultLoadingManager,
                    this.texturePath = ""
            }
            ,
            Object.assign(THREE.ObjectLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    "" === this.texturePath && (this.texturePath = url.substring(0, url.lastIndexOf("/") + 1));
                    var scope = this
                        , loader = new THREE.XHRLoader(scope.manager);
                    loader.load(url, function(text) {
                        scope.parse(JSON.parse(text), onLoad)
                    }, onProgress, onError)
                },
                setTexturePath: function(value) {
                    this.texturePath = value
                },
                setCrossOrigin: function(value) {
                    this.crossOrigin = value
                },
                parse: function(json, onLoad) {
                    var geometries = this.parseGeometries(json.geometries)
                        , images = this.parseImages(json.images, function() {
                        void 0 !== onLoad && onLoad(object)
                    })
                        , textures = this.parseTextures(json.textures, images)
                        , materials = this.parseMaterials(json.materials, textures)
                        , object = this.parseObject(json.object, geometries, materials);
                    return json.animations && (object.animations = this.parseAnimations(json.animations)),
                    void 0 !== json.images && 0 !== json.images.length || void 0 !== onLoad && onLoad(object),
                        object
                },
                parseGeometries: function(json) {
                    var geometries = {};
                    if (void 0 !== json)
                        for (var geometryLoader = new THREE.JSONLoader, bufferGeometryLoader = new THREE.BufferGeometryLoader, i = 0, l = json.length; i < l; i++) {
                            var geometry, data = json[i];
                            switch (data.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    geometry = new THREE[data.type](data.width,data.height,data.widthSegments,data.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    geometry = new THREE[data.type](data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    geometry = new THREE[data.type](data.radius,data.segments,data.thetaStart,data.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    geometry = new THREE[data.type](data.radiusTop,data.radiusBottom,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    geometry = new THREE[data.type](data.radius,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    geometry = new THREE[data.type](data.radius,data.widthSegments,data.heightSegments,data.phiStart,data.phiLength,data.thetaStart,data.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "IcosahedronGeometry":
                                case "OctahedronGeometry":
                                case "TetrahedronGeometry":
                                    geometry = new THREE[data.type](data.radius,data.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    geometry = new THREE[data.type](data.innerRadius,data.outerRadius,data.thetaSegments,data.phiSegments,data.thetaStart,data.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    geometry = new THREE[data.type](data.radius,data.tube,data.radialSegments,data.tubularSegments,data.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    geometry = new THREE[data.type](data.radius,data.tube,data.tubularSegments,data.radialSegments,data.p,data.q);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    geometry = new THREE[data.type](data.points,data.segments,data.phiStart,data.phiLength);
                                    break;
                                case "BufferGeometry":
                                    geometry = bufferGeometryLoader.parse(data);
                                    break;
                                case "Geometry":
                                    geometry = geometryLoader.parse(data.data, this.texturePath).geometry;
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                                    continue
                            }
                            geometry.uuid = data.uuid,
                            void 0 !== data.name && (geometry.name = data.name),
                                geometries[data.uuid] = geometry
                        }
                    return geometries
                },
                parseMaterials: function(json, textures) {
                    var materials = {};
                    if (void 0 !== json) {
                        var loader = new THREE.MaterialLoader;
                        loader.setTextures(textures);
                        for (var i = 0, l = json.length; i < l; i++) {
                            var material = loader.parse(json[i]);
                            materials[material.uuid] = material
                        }
                    }
                    return materials
                },
                parseAnimations: function(json) {
                    for (var animations = [], i = 0; i < json.length; i++) {
                        var clip = THREE.AnimationClip.parse(json[i]);
                        animations.push(clip)
                    }
                    return animations
                },
                parseImages: function(json, onLoad) {
                    function loadImage(url) {
                        return scope.manager.itemStart(url),
                            loader.load(url, function() {
                                scope.manager.itemEnd(url)
                            })
                    }
                    var scope = this
                        , images = {};
                    if (void 0 !== json && json.length > 0) {
                        var manager = new THREE.LoadingManager(onLoad)
                            , loader = new THREE.ImageLoader(manager);
                        loader.setCrossOrigin(this.crossOrigin);
                        for (var i = 0, l = json.length; i < l; i++) {
                            var image = json[i]
                                , path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                            images[image.uuid] = loadImage(path)
                        }
                    }
                    return images
                },
                parseTextures: function(json, images) {
                    function parseConstant(value) {
                        return "number" == typeof value ? value : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value),
                            THREE[value])
                    }
                    var textures = {};
                    if (void 0 !== json)
                        for (var i = 0, l = json.length; i < l; i++) {
                            var data = json[i];
                            void 0 === data.image && console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid),
                            void 0 === images[data.image] && console.warn("THREE.ObjectLoader: Undefined image", data.image);
                            var texture = new THREE.Texture(images[data.image]);
                            texture.needsUpdate = !0,
                                texture.uuid = data.uuid,
                            void 0 !== data.name && (texture.name = data.name),
                            void 0 !== data.mapping && (texture.mapping = parseConstant(data.mapping)),
                            void 0 !== data.offset && (texture.offset = new THREE.Vector2(data.offset[0],data.offset[1])),
                            void 0 !== data.repeat && (texture.repeat = new THREE.Vector2(data.repeat[0],data.repeat[1])),
                            void 0 !== data.minFilter && (texture.minFilter = parseConstant(data.minFilter)),
                            void 0 !== data.magFilter && (texture.magFilter = parseConstant(data.magFilter)),
                            void 0 !== data.anisotropy && (texture.anisotropy = data.anisotropy),
                            Array.isArray(data.wrap) && (texture.wrapS = parseConstant(data.wrap[0]),
                                texture.wrapT = parseConstant(data.wrap[1])),
                                textures[data.uuid] = texture
                        }
                    return textures
                },
                parseObject: function() {
                    var matrix = new THREE.Matrix4;
                    return function(data, geometries, materials) {
                        function getGeometry(name) {
                            return void 0 === geometries[name] && console.warn("THREE.ObjectLoader: Undefined geometry", name),
                                geometries[name]
                        }
                        function getMaterial(name) {
                            if (void 0 !== name)
                                return void 0 === materials[name] && console.warn("THREE.ObjectLoader: Undefined material", name),
                                    materials[name]
                        }
                        var object;
                        switch (data.type) {
                            case "Scene":
                                object = new THREE.Scene;
                                break;
                            case "PerspectiveCamera":
                                object = new THREE.PerspectiveCamera(data.fov,data.aspect,data.near,data.far),
                                void 0 !== data.focus && (object.focus = data.focus),
                                void 0 !== data.zoom && (object.zoom = data.zoom),
                                void 0 !== data.filmGauge && (object.filmGauge = data.filmGauge),
                                void 0 !== data.filmOffset && (object.filmOffset = data.filmOffset),
                                void 0 !== data.view && (object.view = Object.assign({}, data.view));
                                break;
                            case "OrthographicCamera":
                                object = new THREE.OrthographicCamera(data.left,data.right,data.top,data.bottom,data.near,data.far);
                                break;
                            case "AmbientLight":
                                object = new THREE.AmbientLight(data.color,data.intensity);
                                break;
                            case "DirectionalLight":
                                object = new THREE.DirectionalLight(data.color,data.intensity);
                                break;
                            case "PointLight":
                                object = new THREE.PointLight(data.color,data.intensity,data.distance,data.decay);
                                break;
                            case "SpotLight":
                                object = new THREE.SpotLight(data.color,data.intensity,data.distance,data.angle,data.penumbra,data.decay);
                                break;
                            case "HemisphereLight":
                                object = new THREE.HemisphereLight(data.color,data.groundColor,data.intensity);
                                break;
                            case "Mesh":
                                var geometry = getGeometry(data.geometry)
                                    , material = getMaterial(data.material);
                                object = geometry.bones && geometry.bones.length > 0 ? new THREE.SkinnedMesh(geometry,material) : new THREE.Mesh(geometry,material);
                                break;
                            case "LOD":
                                object = new THREE.LOD;
                                break;
                            case "Line":
                                object = new THREE.Line(getGeometry(data.geometry),getMaterial(data.material),data.mode);
                                break;
                            case "PointCloud":
                            case "Points":
                                object = new THREE.Points(getGeometry(data.geometry),getMaterial(data.material));
                                break;
                            case "Sprite":
                                object = new THREE.Sprite(getMaterial(data.material));
                                break;
                            case "Group":
                                object = new THREE.Group;
                                break;
                            default:
                                object = new THREE.Object3D
                        }
                        if (object.uuid = data.uuid,
                            void 0 !== data.name && (object.name = data.name),
                                void 0 !== data.matrix ? (matrix.fromArray(data.matrix),
                                    matrix.decompose(object.position, object.quaternion, object.scale)) : (void 0 !== data.position && object.position.fromArray(data.position),
                                void 0 !== data.rotation && object.rotation.fromArray(data.rotation),
                                void 0 !== data.scale && object.scale.fromArray(data.scale)),
                            void 0 !== data.castShadow && (object.castShadow = data.castShadow),
                            void 0 !== data.receiveShadow && (object.receiveShadow = data.receiveShadow),
                            void 0 !== data.visible && (object.visible = data.visible),
                            void 0 !== data.userData && (object.userData = data.userData),
                            void 0 !== data.children)
                            for (var child in data.children)
                                object.add(this.parseObject(data.children[child], geometries, materials));
                        if ("LOD" === data.type)
                            for (var levels = data.levels, l = 0; l < levels.length; l++) {
                                var level = levels[l]
                                    , child = object.getObjectByProperty("uuid", level.object);
                                void 0 !== child && object.addLevel(child, level.distance)
                            }
                        return object
                    }
                }()
            }),
            THREE.TextureLoader = function(manager) {
                this.manager = void 0 !== manager ? manager : THREE.DefaultLoadingManager
            }
            ,
            Object.assign(THREE.TextureLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var texture = new THREE.Texture
                        , loader = new THREE.ImageLoader(this.manager);
                    return loader.setCrossOrigin(this.crossOrigin),
                        loader.setPath(this.path),
                        loader.load(url, function(image) {
                            texture.image = image,
                                texture.needsUpdate = !0,
                            void 0 !== onLoad && onLoad(texture)
                        }, onProgress, onError),
                        texture
                },
                setCrossOrigin: function(value) {
                    return this.crossOrigin = value,
                        this
                },
                setPath: function(value) {
                    return this.path = value,
                        this
                }
            }),
            THREE.CubeTextureLoader = function(manager) {
                this.manager = void 0 !== manager ? manager : THREE.DefaultLoadingManager
            }
            ,
            Object.assign(THREE.CubeTextureLoader.prototype, {
                load: function(urls, onLoad, onProgress, onError) {
                    function loadTexture(i) {
                        loader.load(urls[i], function(image) {
                            texture.images[i] = image,
                                loaded++,
                            6 === loaded && (texture.needsUpdate = !0,
                            onLoad && onLoad(texture))
                        }, void 0, onError)
                    }
                    var texture = new THREE.CubeTexture
                        , loader = new THREE.ImageLoader(this.manager);
                    loader.setCrossOrigin(this.crossOrigin),
                        loader.setPath(this.path);
                    for (var loaded = 0, i = 0; i < urls.length; ++i)
                        loadTexture(i);
                    return texture
                },
                setCrossOrigin: function(value) {
                    return this.crossOrigin = value,
                        this
                },
                setPath: function(value) {
                    return this.path = value,
                        this
                }
            }),
            THREE.DataTextureLoader = THREE.BinaryTextureLoader = function(manager) {
                this.manager = void 0 !== manager ? manager : THREE.DefaultLoadingManager,
                    this._parser = null
            }
            ,
            Object.assign(THREE.BinaryTextureLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var scope = this
                        , texture = new THREE.DataTexture
                        , loader = new THREE.XHRLoader(this.manager);
                    return loader.setResponseType("arraybuffer"),
                        loader.load(url, function(buffer) {
                            var texData = scope._parser(buffer);
                            texData && (void 0 !== texData.image ? texture.image = texData.image : void 0 !== texData.data && (texture.image.width = texData.width,
                                texture.image.height = texData.height,
                                texture.image.data = texData.data),
                                texture.wrapS = void 0 !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping,
                                texture.wrapT = void 0 !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping,
                                texture.magFilter = void 0 !== texData.magFilter ? texData.magFilter : THREE.LinearFilter,
                                texture.minFilter = void 0 !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter,
                                texture.anisotropy = void 0 !== texData.anisotropy ? texData.anisotropy : 1,
                            void 0 !== texData.format && (texture.format = texData.format),
                            void 0 !== texData.type && (texture.type = texData.type),
                            void 0 !== texData.mipmaps && (texture.mipmaps = texData.mipmaps),
                            1 === texData.mipmapCount && (texture.minFilter = THREE.LinearFilter),
                                texture.needsUpdate = !0,
                            onLoad && onLoad(texture, texData))
                        }, onProgress, onError),
                        texture
                }
            }),
            THREE.CompressedTextureLoader = function(manager) {
                this.manager = void 0 !== manager ? manager : THREE.DefaultLoadingManager,
                    this._parser = null
            }
            ,
            Object.assign(THREE.CompressedTextureLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    function loadTexture(i) {
                        loader.load(url[i], function(buffer) {
                            var texDatas = scope._parser(buffer, !0);
                            images[i] = {
                                width: texDatas.width,
                                height: texDatas.height,
                                format: texDatas.format,
                                mipmaps: texDatas.mipmaps
                            },
                                loaded += 1,
                            6 === loaded && (1 === texDatas.mipmapCount && (texture.minFilter = THREE.LinearFilter),
                                texture.format = texDatas.format,
                                texture.needsUpdate = !0,
                            onLoad && onLoad(texture))
                        }, onProgress, onError)
                    }
                    var scope = this
                        , images = []
                        , texture = new THREE.CompressedTexture;
                    texture.image = images;
                    var loader = new THREE.XHRLoader(this.manager);
                    if (loader.setPath(this.path),
                            loader.setResponseType("arraybuffer"),
                            Array.isArray(url))
                        for (var loaded = 0, i = 0, il = url.length; i < il; ++i)
                            loadTexture(i);
                    else
                        loader.load(url, function(buffer) {
                            var texDatas = scope._parser(buffer, !0);
                            if (texDatas.isCubemap)
                                for (var faces = texDatas.mipmaps.length / texDatas.mipmapCount, f = 0; f < faces; f++) {
                                    images[f] = {
                                        mipmaps: []
                                    };
                                    for (var i = 0; i < texDatas.mipmapCount; i++)
                                        images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]),
                                            images[f].format = texDatas.format,
                                            images[f].width = texDatas.width,
                                            images[f].height = texDatas.height
                                }
                            else
                                texture.image.width = texDatas.width,
                                    texture.image.height = texDatas.height,
                                    texture.mipmaps = texDatas.mipmaps;
                            1 === texDatas.mipmapCount && (texture.minFilter = THREE.LinearFilter),
                                texture.format = texDatas.format,
                                texture.needsUpdate = !0,
                            onLoad && onLoad(texture)
                        }, onProgress, onError);
                    return texture
                },
                setPath: function(value) {
                    return this.path = value,
                        this
                }
            }),
            THREE.Material = function() {
                Object.defineProperty(this, "id", {
                    value: THREE.MaterialIdCount++
                }),
                    this.uuid = THREE.Math.generateUUID(),
                    this.name = "",
                    this.type = "Material",
                    this.fog = !0,
                    this.lights = !0,
                    this.blending = THREE.NormalBlending,
                    this.side = THREE.FrontSide,
                    this.shading = THREE.SmoothShading,
                    this.vertexColors = THREE.NoColors,
                    this.opacity = 1,
                    this.transparent = !1,
                    this.blendSrc = THREE.SrcAlphaFactor,
                    this.blendDst = THREE.OneMinusSrcAlphaFactor,
                    this.blendEquation = THREE.AddEquation,
                    this.blendSrcAlpha = null,
                    this.blendDstAlpha = null,
                    this.blendEquationAlpha = null,
                    this.depthFunc = THREE.LessEqualDepth,
                    this.depthTest = !0,
                    this.depthWrite = !0,
                    this.clippingPlanes = null,
                    this.clipShadows = !1,
                    this.colorWrite = !0,
                    this.precision = null,
                    this.polygonOffset = !1,
                    this.polygonOffsetFactor = 0,
                    this.polygonOffsetUnits = 0,
                    this.alphaTest = 0,
                    this.premultipliedAlpha = !1,
                    this.overdraw = 0,
                    this.visible = !0,
                    this._needsUpdate = !0
            }
            ,
            THREE.Material.prototype = {
                constructor: THREE.Material,
                get needsUpdate() {
                    return this._needsUpdate
                },
                set needsUpdate(value) {
                    value === !0 && this.update(),
                        this._needsUpdate = value
                },
                setValues: function(values) {
                    if (void 0 !== values)
                        for (var key in values) {
                            var newValue = values[key];
                            if (void 0 !== newValue) {
                                var currentValue = this[key];
                                void 0 !== currentValue ? currentValue instanceof THREE.Color ? currentValue.set(newValue) : currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ? currentValue.copy(newValue) : "overdraw" === key ? this[key] = Number(newValue) : this[key] = newValue : console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.")
                            } else
                                console.warn("THREE.Material: '" + key + "' parameter is undefined.")
                        }
                },
                toJSON: function(meta) {
                    function extractFromCache(cache) {
                        var values = [];
                        for (var key in cache) {
                            var data = cache[key];
                            delete data.metadata,
                                values.push(data)
                        }
                        return values
                    }
                    var isRoot = void 0 === meta;
                    isRoot && (meta = {
                        textures: {},
                        images: {}
                    });
                    var data = {
                        metadata: {
                            version: 4.4,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };
                    if (data.uuid = this.uuid,
                            data.type = this.type,
                        "" !== this.name && (data.name = this.name),
                        this.color instanceof THREE.Color && (data.color = this.color.getHex()),
                        void 0 !== this.roughness && (data.roughness = this.roughness),
                        void 0 !== this.metalness && (data.metalness = this.metalness),
                        this.emissive instanceof THREE.Color && (data.emissive = this.emissive.getHex()),
                        this.specular instanceof THREE.Color && (data.specular = this.specular.getHex()),
                        void 0 !== this.shininess && (data.shininess = this.shininess),
                        this.map instanceof THREE.Texture && (data.map = this.map.toJSON(meta).uuid),
                        this.alphaMap instanceof THREE.Texture && (data.alphaMap = this.alphaMap.toJSON(meta).uuid),
                        this.lightMap instanceof THREE.Texture && (data.lightMap = this.lightMap.toJSON(meta).uuid),
                        this.bumpMap instanceof THREE.Texture && (data.bumpMap = this.bumpMap.toJSON(meta).uuid,
                            data.bumpScale = this.bumpScale),
                        this.normalMap instanceof THREE.Texture && (data.normalMap = this.normalMap.toJSON(meta).uuid,
                            data.normalScale = this.normalScale.toArray()),
                        this.displacementMap instanceof THREE.Texture && (data.displacementMap = this.displacementMap.toJSON(meta).uuid,
                            data.displacementScale = this.displacementScale,
                            data.displacementBias = this.displacementBias),
                        this.roughnessMap instanceof THREE.Texture && (data.roughnessMap = this.roughnessMap.toJSON(meta).uuid),
                        this.metalnessMap instanceof THREE.Texture && (data.metalnessMap = this.metalnessMap.toJSON(meta).uuid),
                        this.emissiveMap instanceof THREE.Texture && (data.emissiveMap = this.emissiveMap.toJSON(meta).uuid),
                        this.specularMap instanceof THREE.Texture && (data.specularMap = this.specularMap.toJSON(meta).uuid),
                        this.envMap instanceof THREE.Texture && (data.envMap = this.envMap.toJSON(meta).uuid,
                            data.reflectivity = this.reflectivity),
                        void 0 !== this.size && (data.size = this.size),
                        void 0 !== this.sizeAttenuation && (data.sizeAttenuation = this.sizeAttenuation),
                        this.blending !== THREE.NormalBlending && (data.blending = this.blending),
                        this.shading !== THREE.SmoothShading && (data.shading = this.shading),
                        this.side !== THREE.FrontSide && (data.side = this.side),
                        this.vertexColors !== THREE.NoColors && (data.vertexColors = this.vertexColors),
                        this.opacity < 1 && (data.opacity = this.opacity),
                        this.transparent === !0 && (data.transparent = this.transparent),
                        this.alphaTest > 0 && (data.alphaTest = this.alphaTest),
                        this.premultipliedAlpha === !0 && (data.premultipliedAlpha = this.premultipliedAlpha),
                        this.wireframe === !0 && (data.wireframe = this.wireframe),
                        this.wireframeLinewidth > 1 && (data.wireframeLinewidth = this.wireframeLinewidth),
                            isRoot) {
                        var textures = extractFromCache(meta.textures)
                            , images = extractFromCache(meta.images);
                        textures.length > 0 && (data.textures = textures),
                        images.length > 0 && (data.images = images)
                    }
                    return data
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(source) {
                    this.name = source.name,
                        this.fog = source.fog,
                        this.lights = source.lights,
                        this.blending = source.blending,
                        this.side = source.side,
                        this.shading = source.shading,
                        this.vertexColors = source.vertexColors,
                        this.opacity = source.opacity,
                        this.transparent = source.transparent,
                        this.blendSrc = source.blendSrc,
                        this.blendDst = source.blendDst,
                        this.blendEquation = source.blendEquation,
                        this.blendSrcAlpha = source.blendSrcAlpha,
                        this.blendDstAlpha = source.blendDstAlpha,
                        this.blendEquationAlpha = source.blendEquationAlpha,
                        this.depthFunc = source.depthFunc,
                        this.depthTest = source.depthTest,
                        this.depthWrite = source.depthWrite,
                        this.colorWrite = source.colorWrite,
                        this.precision = source.precision,
                        this.polygonOffset = source.polygonOffset,
                        this.polygonOffsetFactor = source.polygonOffsetFactor,
                        this.polygonOffsetUnits = source.polygonOffsetUnits,
                        this.alphaTest = source.alphaTest,
                        this.premultipliedAlpha = source.premultipliedAlpha,
                        this.overdraw = source.overdraw,
                        this.visible = source.visible,
                        this.clipShadows = source.clipShadows;
                    var srcPlanes = source.clippingPlanes
                        , dstPlanes = null;
                    if (null !== srcPlanes) {
                        var n = srcPlanes.length;
                        dstPlanes = new Array(n);
                        for (var i = 0; i !== n; ++i)
                            dstPlanes[i] = srcPlanes[i].clone()
                    }
                    return this.clippingPlanes = dstPlanes,
                        this
                },
                update: function() {
                    this.dispatchEvent({
                        type: "update"
                    })
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            },
            Object.assign(THREE.Material.prototype, THREE.EventDispatcher.prototype),
            THREE.MaterialIdCount = 0,
            THREE.LineBasicMaterial = function(parameters) {
                THREE.Material.call(this),
                    this.type = "LineBasicMaterial",
                    this.color = new THREE.Color(16777215),
                    this.linewidth = 1,
                    this.linecap = "round",
                    this.linejoin = "round",
                    this.lights = !1,
                    this.setValues(parameters)
            }
            ,
            THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype),
            THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial,
            THREE.LineBasicMaterial.prototype.copy = function(source) {
                return THREE.Material.prototype.copy.call(this, source),
                    this.color.copy(source.color),
                    this.linewidth = source.linewidth,
                    this.linecap = source.linecap,
                    this.linejoin = source.linejoin,
                    this
            }
            ,
            THREE.LineDashedMaterial = function(parameters) {
                THREE.Material.call(this),
                    this.type = "LineDashedMaterial",
                    this.color = new THREE.Color(16777215),
                    this.linewidth = 1,
                    this.scale = 1,
                    this.dashSize = 3,
                    this.gapSize = 1,
                    this.lights = !1,
                    this.setValues(parameters)
            }
            ,
            THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype),
            THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial,
            THREE.LineDashedMaterial.prototype.copy = function(source) {
                return THREE.Material.prototype.copy.call(this, source),
                    this.color.copy(source.color),
                    this.linewidth = source.linewidth,
                    this.scale = source.scale,
                    this.dashSize = source.dashSize,
                    this.gapSize = source.gapSize,
                    this
            }
            ,
            THREE.MeshBasicMaterial = function(parameters) {
                THREE.Material.call(this),
                    this.type = "MeshBasicMaterial",
                    this.color = new THREE.Color(16777215),
                    this.map = null,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.combine = THREE.MultiplyOperation,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.lights = !1,
                    this.setValues(parameters)
            }
            ,
            THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype),
            THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial,
            THREE.MeshBasicMaterial.prototype.copy = function(source) {
                return THREE.Material.prototype.copy.call(this, source),
                    this.color.copy(source.color),
                    this.map = source.map,
                    this.aoMap = source.aoMap,
                    this.aoMapIntensity = source.aoMapIntensity,
                    this.specularMap = source.specularMap,
                    this.alphaMap = source.alphaMap,
                    this.envMap = source.envMap,
                    this.combine = source.combine,
                    this.reflectivity = source.reflectivity,
                    this.refractionRatio = source.refractionRatio,
                    this.wireframe = source.wireframe,
                    this.wireframeLinewidth = source.wireframeLinewidth,
                    this.wireframeLinecap = source.wireframeLinecap,
                    this.wireframeLinejoin = source.wireframeLinejoin,
                    this.skinning = source.skinning,
                    this.morphTargets = source.morphTargets,
                    this
            }
            ,
            THREE.MeshDepthMaterial = function(parameters) {
                THREE.Material.call(this),
                    this.type = "MeshDepthMaterial",
                    this.depthPacking = THREE.BasicDepthPacking,
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.map = null,
                    this.alphaMap = null,
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.fog = !1,
                    this.lights = !1,
                    this.setValues(parameters)
            }
            ,
            THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype),
            THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial,
            THREE.MeshDepthMaterial.prototype.copy = function(source) {
                return THREE.Material.prototype.copy.call(this, source),
                    this.depthPacking = source.depthPacking,
                    this.skinning = source.skinning,
                    this.morphTargets = source.morphTargets,
                    this.map = source.map,
                    this.alphaMap = source.alphaMap,
                    this.displacementMap = source.displacementMap,
                    this.displacementScale = source.displacementScale,
                    this.displacementBias = source.displacementBias,
                    this.wireframe = source.wireframe,
                    this.wireframeLinewidth = source.wireframeLinewidth,
                    this
            }
            ,
            THREE.MeshLambertMaterial = function(parameters) {
                THREE.Material.call(this),
                    this.type = "MeshLambertMaterial",
                    this.color = new THREE.Color(16777215),
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new THREE.Color(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.combine = THREE.MultiplyOperation,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.setValues(parameters)
            }
            ,
            THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype),
            THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial,
            THREE.MeshLambertMaterial.prototype.copy = function(source) {
                return THREE.Material.prototype.copy.call(this, source),
                    this.color.copy(source.color),
                    this.map = source.map,
                    this.lightMap = source.lightMap,
                    this.lightMapIntensity = source.lightMapIntensity,
                    this.aoMap = source.aoMap,
                    this.aoMapIntensity = source.aoMapIntensity,
                    this.emissive.copy(source.emissive),
                    this.emissiveMap = source.emissiveMap,
                    this.emissiveIntensity = source.emissiveIntensity,
                    this.specularMap = source.specularMap,
                    this.alphaMap = source.alphaMap,
                    this.envMap = source.envMap,
                    this.combine = source.combine,
                    this.reflectivity = source.reflectivity,
                    this.refractionRatio = source.refractionRatio,
                    this.wireframe = source.wireframe,
                    this.wireframeLinewidth = source.wireframeLinewidth,
                    this.wireframeLinecap = source.wireframeLinecap,
                    this.wireframeLinejoin = source.wireframeLinejoin,
                    this.skinning = source.skinning,
                    this.morphTargets = source.morphTargets,
                    this.morphNormals = source.morphNormals,
                    this
            }
            ,
            THREE.MeshNormalMaterial = function(parameters) {
                THREE.Material.call(this, parameters),
                    this.type = "MeshNormalMaterial",
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.fog = !1,
                    this.lights = !1,
                    this.morphTargets = !1,
                    this.setValues(parameters)
            }
            ,
            THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype),
            THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial,
            THREE.MeshNormalMaterial.prototype.copy = function(source) {
                return THREE.Material.prototype.copy.call(this, source),
                    this.wireframe = source.wireframe,
                    this.wireframeLinewidth = source.wireframeLinewidth,
                    this
            }
            ,
            THREE.MeshPhongMaterial = function(parameters) {
                THREE.Material.call(this),
                    this.type = "MeshPhongMaterial",
                    this.color = new THREE.Color(16777215),
                    this.specular = new THREE.Color(1118481),
                    this.shininess = 30,
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new THREE.Color(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalScale = new THREE.Vector2(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.combine = THREE.MultiplyOperation,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.setValues(parameters)
            }
            ,
            THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype),
            THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial,
            THREE.MeshPhongMaterial.prototype.copy = function(source) {
                return THREE.Material.prototype.copy.call(this, source),
                    this.color.copy(source.color),
                    this.specular.copy(source.specular),
                    this.shininess = source.shininess,
                    this.map = source.map,
                    this.lightMap = source.lightMap,
                    this.lightMapIntensity = source.lightMapIntensity,
                    this.aoMap = source.aoMap,
                    this.aoMapIntensity = source.aoMapIntensity,
                    this.emissive.copy(source.emissive),
                    this.emissiveMap = source.emissiveMap,
                    this.emissiveIntensity = source.emissiveIntensity,
                    this.bumpMap = source.bumpMap,
                    this.bumpScale = source.bumpScale,
                    this.normalMap = source.normalMap,
                    this.normalScale.copy(source.normalScale),
                    this.displacementMap = source.displacementMap,
                    this.displacementScale = source.displacementScale,
                    this.displacementBias = source.displacementBias,
                    this.specularMap = source.specularMap,
                    this.alphaMap = source.alphaMap,
                    this.envMap = source.envMap,
                    this.combine = source.combine,
                    this.reflectivity = source.reflectivity,
                    this.refractionRatio = source.refractionRatio,
                    this.wireframe = source.wireframe,
                    this.wireframeLinewidth = source.wireframeLinewidth,
                    this.wireframeLinecap = source.wireframeLinecap,
                    this.wireframeLinejoin = source.wireframeLinejoin,
                    this.skinning = source.skinning,
                    this.morphTargets = source.morphTargets,
                    this.morphNormals = source.morphNormals,
                    this
            }
            ,
            THREE.MeshStandardMaterial = function(parameters) {
                THREE.Material.call(this),
                    this.defines = {
                        STANDARD: ""
                    },
                    this.type = "MeshStandardMaterial",
                    this.color = new THREE.Color(16777215),
                    this.roughness = .5,
                    this.metalness = .5,
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new THREE.Color(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalScale = new THREE.Vector2(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.roughnessMap = null,
                    this.metalnessMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.envMapIntensity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.setValues(parameters)
            }
            ,
            THREE.MeshStandardMaterial.prototype = Object.create(THREE.Material.prototype),
            THREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial,
            THREE.MeshStandardMaterial.prototype.copy = function(source) {
                return THREE.Material.prototype.copy.call(this, source),
                    this.defines = {
                        STANDARD: ""
                    },
                    this.color.copy(source.color),
                    this.roughness = source.roughness,
                    this.metalness = source.metalness,
                    this.map = source.map,
                    this.lightMap = source.lightMap,
                    this.lightMapIntensity = source.lightMapIntensity,
                    this.aoMap = source.aoMap,
                    this.aoMapIntensity = source.aoMapIntensity,
                    this.emissive.copy(source.emissive),
                    this.emissiveMap = source.emissiveMap,
                    this.emissiveIntensity = source.emissiveIntensity,
                    this.bumpMap = source.bumpMap,
                    this.bumpScale = source.bumpScale,
                    this.normalMap = source.normalMap,
                    this.normalScale.copy(source.normalScale),
                    this.displacementMap = source.displacementMap,
                    this.displacementScale = source.displacementScale,
                    this.displacementBias = source.displacementBias,
                    this.roughnessMap = source.roughnessMap,
                    this.metalnessMap = source.metalnessMap,
                    this.alphaMap = source.alphaMap,
                    this.envMap = source.envMap,
                    this.envMapIntensity = source.envMapIntensity,
                    this.refractionRatio = source.refractionRatio,
                    this.wireframe = source.wireframe,
                    this.wireframeLinewidth = source.wireframeLinewidth,
                    this.wireframeLinecap = source.wireframeLinecap,
                    this.wireframeLinejoin = source.wireframeLinejoin,
                    this.skinning = source.skinning,
                    this.morphTargets = source.morphTargets,
                    this.morphNormals = source.morphNormals,
                    this
            }
            ,
            THREE.MeshPhysicalMaterial = function(parameters) {
                THREE.MeshStandardMaterial.call(this),
                    this.defines = {
                        PHYSICAL: ""
                    },
                    this.type = "MeshPhysicalMaterial",
                    this.reflectivity = .5,
                    this.clearCoat = 0,
                    this.clearCoatRoughness = 0,
                    this.setValues(parameters)
            }
            ,
            THREE.MeshPhysicalMaterial.prototype = Object.create(THREE.MeshStandardMaterial.prototype),
            THREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial,
            THREE.MeshPhysicalMaterial.prototype.copy = function(source) {
                return THREE.MeshStandardMaterial.prototype.copy.call(this, source),
                    this.defines = {
                        PHYSICAL: ""
                    },
                    this.reflectivity = source.reflectivity,
                    this.clearCoat = source.clearCoat,
                    this.clearCoatRoughness = source.clearCoatRoughness,
                    this
            }
            ,
            THREE.MultiMaterial = function(materials) {
                this.uuid = THREE.Math.generateUUID(),
                    this.type = "MultiMaterial",
                    this.materials = materials instanceof Array ? materials : [],
                    this.visible = !0
            }
            ,
            THREE.MultiMaterial.prototype = {
                constructor: THREE.MultiMaterial,
                toJSON: function(meta) {
                    for (var output = {
                        metadata: {
                            version: 4.2,
                            type: "material",
                            generator: "MaterialExporter"
                        },
                        uuid: this.uuid,
                        type: this.type,
                        materials: []
                    }, materials = this.materials, i = 0, l = materials.length; i < l; i++) {
                        var material = materials[i].toJSON(meta);
                        delete material.metadata,
                            output.materials.push(material)
                    }
                    return output.visible = this.visible,
                        output
                },
                clone: function() {
                    for (var material = new this.constructor, i = 0; i < this.materials.length; i++)
                        material.materials.push(this.materials[i].clone());
                    return material.visible = this.visible,
                        material
                }
            },
            THREE.PointsMaterial = function(parameters) {
                THREE.Material.call(this),
                    this.type = "PointsMaterial",
                    this.color = new THREE.Color(16777215),
                    this.map = null,
                    this.size = 1,
                    this.sizeAttenuation = !0,
                    this.lights = !1,
                    this.setValues(parameters)
            }
            ,
            THREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype),
            THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial,
            THREE.PointsMaterial.prototype.copy = function(source) {
                return THREE.Material.prototype.copy.call(this, source),
                    this.color.copy(source.color),
                    this.map = source.map,
                    this.size = source.size,
                    this.sizeAttenuation = source.sizeAttenuation,
                    this
            }
            ,
            THREE.ShaderMaterial = function(parameters) {
                THREE.Material.call(this),
                    this.type = "ShaderMaterial",
                    this.defines = {},
                    this.uniforms = {},
                    this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                    this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                    this.linewidth = 1,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.fog = !1,
                    this.lights = !1,
                    this.clipping = !1,
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.extensions = {
                        derivatives: !1,
                        fragDepth: !1,
                        drawBuffers: !1,
                        shaderTextureLOD: !1
                    },
                    this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv2: [0, 0]
                    },
                    this.index0AttributeName = void 0,
                void 0 !== parameters && (void 0 !== parameters.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
                    this.setValues(parameters))
            }
            ,
            THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype),
            THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial,
            THREE.ShaderMaterial.prototype.copy = function(source) {
                return THREE.Material.prototype.copy.call(this, source),
                    this.fragmentShader = source.fragmentShader,
                    this.vertexShader = source.vertexShader,
                    this.uniforms = THREE.UniformsUtils.clone(source.uniforms),
                    this.defines = source.defines,
                    this.wireframe = source.wireframe,
                    this.wireframeLinewidth = source.wireframeLinewidth,
                    this.lights = source.lights,
                    this.clipping = source.clipping,
                    this.skinning = source.skinning,
                    this.morphTargets = source.morphTargets,
                    this.morphNormals = source.morphNormals,
                    this.extensions = source.extensions,
                    this
            }
            ,
            THREE.ShaderMaterial.prototype.toJSON = function(meta) {
                var data = THREE.Material.prototype.toJSON.call(this, meta);
                return data.uniforms = this.uniforms,
                    data.vertexShader = this.vertexShader,
                    data.fragmentShader = this.fragmentShader,
                    data
            }
            ,
            THREE.RawShaderMaterial = function(parameters) {
                THREE.ShaderMaterial.call(this, parameters),
                    this.type = "RawShaderMaterial"
            }
            ,
            THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype),
            THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial,
            THREE.SpriteMaterial = function(parameters) {
                THREE.Material.call(this),
                    this.type = "SpriteMaterial",
                    this.color = new THREE.Color(16777215),
                    this.map = null,
                    this.rotation = 0,
                    this.fog = !1,
                    this.lights = !1,
                    this.setValues(parameters)
            }
            ,
            THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype),
            THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial,
            THREE.SpriteMaterial.prototype.copy = function(source) {
                return THREE.Material.prototype.copy.call(this, source),
                    this.color.copy(source.color),
                    this.map = source.map,
                    this.rotation = source.rotation,
                    this
            }
            ,
            THREE.ShadowMaterial = function() {
                THREE.ShaderMaterial.call(this, {
                    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.lights, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: THREE.ShaderChunk.shadow_vert,
                    fragmentShader: THREE.ShaderChunk.shadow_frag
                }),
                    this.lights = !0,
                    this.transparent = !0,
                    Object.defineProperties(this, {
                        opacity: {
                            enumerable: !0,
                            get: function() {
                                return this.uniforms.opacity.value
                            },
                            set: function(value) {
                                this.uniforms.opacity.value = value
                            }
                        }
                    })
            }
            ,
            THREE.ShadowMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype),
            THREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial,
            THREE.Texture = function(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
                Object.defineProperty(this, "id", {
                    value: THREE.TextureIdCount++
                }),
                    this.uuid = THREE.Math.generateUUID(),
                    this.name = "",
                    this.sourceFile = "",
                    this.image = void 0 !== image ? image : THREE.Texture.DEFAULT_IMAGE,
                    this.mipmaps = [],
                    this.mapping = void 0 !== mapping ? mapping : THREE.Texture.DEFAULT_MAPPING,
                    this.wrapS = void 0 !== wrapS ? wrapS : THREE.ClampToEdgeWrapping,
                    this.wrapT = void 0 !== wrapT ? wrapT : THREE.ClampToEdgeWrapping,
                    this.magFilter = void 0 !== magFilter ? magFilter : THREE.LinearFilter,
                    this.minFilter = void 0 !== minFilter ? minFilter : THREE.LinearMipMapLinearFilter,
                    this.anisotropy = void 0 !== anisotropy ? anisotropy : 1,
                    this.format = void 0 !== format ? format : THREE.RGBAFormat,
                    this.type = void 0 !== type ? type : THREE.UnsignedByteType,
                    this.offset = new THREE.Vector2(0,0),
                    this.repeat = new THREE.Vector2(1,1),
                    this.generateMipmaps = !0,
                    this.premultiplyAlpha = !1,
                    this.flipY = !0,
                    this.unpackAlignment = 4,
                    this.encoding = void 0 !== encoding ? encoding : THREE.LinearEncoding,
                    this.version = 0,
                    this.onUpdate = null
            }
            ,
            THREE.Texture.DEFAULT_IMAGE = void 0,
            THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping,
            THREE.Texture.prototype = {
                constructor: THREE.Texture,
                set needsUpdate(value) {
                    value === !0 && this.version++
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(source) {
                    return this.image = source.image,
                        this.mipmaps = source.mipmaps.slice(0),
                        this.mapping = source.mapping,
                        this.wrapS = source.wrapS,
                        this.wrapT = source.wrapT,
                        this.magFilter = source.magFilter,
                        this.minFilter = source.minFilter,
                        this.anisotropy = source.anisotropy,
                        this.format = source.format,
                        this.type = source.type,
                        this.offset.copy(source.offset),
                        this.repeat.copy(source.repeat),
                        this.generateMipmaps = source.generateMipmaps,
                        this.premultiplyAlpha = source.premultiplyAlpha,
                        this.flipY = source.flipY,
                        this.unpackAlignment = source.unpackAlignment,
                        this.encoding = source.encoding,
                        this
                },
                toJSON: function(meta) {
                    function getDataURL(image) {
                        var canvas;
                        return void 0 !== image.toDataURL ? canvas = image : (canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                            canvas.width = image.width,
                            canvas.height = image.height,
                            canvas.getContext("2d").drawImage(image, 0, 0, image.width, image.height)),
                            canvas.width > 2048 || canvas.height > 2048 ? canvas.toDataURL("image/jpeg", .6) : canvas.toDataURL("image/png")
                    }
                    if (void 0 !== meta.textures[this.uuid])
                        return meta.textures[this.uuid];
                    var output = {
                        metadata: {
                            version: 4.4,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        wrap: [this.wrapS, this.wrapT],
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy
                    };
                    if (void 0 !== this.image) {
                        var image = this.image;
                        void 0 === image.uuid && (image.uuid = THREE.Math.generateUUID()),
                        void 0 === meta.images[image.uuid] && (meta.images[image.uuid] = {
                            uuid: image.uuid,
                            url: getDataURL(image)
                        }),
                            output.image = image.uuid
                    }
                    return meta.textures[this.uuid] = output,
                        output
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(uv) {
                    if (this.mapping === THREE.UVMapping) {
                        if (uv.multiply(this.repeat),
                                uv.add(this.offset),
                            uv.x < 0 || uv.x > 1)
                            switch (this.wrapS) {
                                case THREE.RepeatWrapping:
                                    uv.x = uv.x - Math.floor(uv.x);
                                    break;
                                case THREE.ClampToEdgeWrapping:
                                    uv.x = uv.x < 0 ? 0 : 1;
                                    break;
                                case THREE.MirroredRepeatWrapping:
                                    1 === Math.abs(Math.floor(uv.x) % 2) ? uv.x = Math.ceil(uv.x) - uv.x : uv.x = uv.x - Math.floor(uv.x)
                            }
                        if (uv.y < 0 || uv.y > 1)
                            switch (this.wrapT) {
                                case THREE.RepeatWrapping:
                                    uv.y = uv.y - Math.floor(uv.y);
                                    break;
                                case THREE.ClampToEdgeWrapping:
                                    uv.y = uv.y < 0 ? 0 : 1;
                                    break;
                                case THREE.MirroredRepeatWrapping:
                                    1 === Math.abs(Math.floor(uv.y) % 2) ? uv.y = Math.ceil(uv.y) - uv.y : uv.y = uv.y - Math.floor(uv.y)
                            }
                        this.flipY && (uv.y = 1 - uv.y)
                    }
                }
            },
            Object.assign(THREE.Texture.prototype, THREE.EventDispatcher.prototype),
            THREE.TextureIdCount = 0,
            THREE.DepthTexture = function(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
                THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy),
                    this.image = {
                        width: width,
                        height: height
                    },
                    this.type = void 0 !== type ? type : THREE.UnsignedShortType,
                    this.magFilter = void 0 !== magFilter ? magFilter : THREE.NearestFilter,
                    this.minFilter = void 0 !== minFilter ? minFilter : THREE.NearestFilter,
                    this.flipY = !1,
                    this.generateMipmaps = !1
            }
            ,
            THREE.DepthTexture.prototype = Object.create(THREE.Texture.prototype),
            THREE.DepthTexture.prototype.constructor = THREE.DepthTexture,
            THREE.CanvasTexture = function(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
                THREE.Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy),
                    this.needsUpdate = !0
            }
            ,
            THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype),
            THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture,
            THREE.CubeTexture = function(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
                images = void 0 !== images ? images : [],
                    mapping = void 0 !== mapping ? mapping : THREE.CubeReflectionMapping,
                    THREE.Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding),
                    this.flipY = !1
            }
            ,
            THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype),
            THREE.CubeTexture.prototype.constructor = THREE.CubeTexture,
            Object.defineProperty(THREE.CubeTexture.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(value) {
                    this.image = value
                }
            }),
            THREE.CompressedTexture = function(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
                THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding),
                    this.image = {
                        width: width,
                        height: height
                    },
                    this.mipmaps = mipmaps,
                    this.flipY = !1,
                    this.generateMipmaps = !1
            }
        ,
        THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype),
        THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture,
        THREE.DataTexture = function(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
            THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding),
                this.image = {
                    data: data,
                    width: width,
                    height: height
                },
                this.magFilter = void 0 !== magFilter ? magFilter : THREE.NearestFilter,
                this.minFilter = void 0 !== minFilter ? minFilter : THREE.NearestFilter,
                this.flipY = !1,
                this.generateMipmaps = !1
        }
        ,
        THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype),
        THREE.DataTexture.prototype.constructor = THREE.DataTexture,
        THREE.VideoTexture = function(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            function update() {
                requestAnimationFrame(update),
                video.readyState >= video.HAVE_CURRENT_DATA && (scope.needsUpdate = !0)
            }
            THREE.Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy),
                this.generateMipmaps = !1;
            var scope = this;
            update()
        }
        ,
        THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype),
        THREE.VideoTexture.prototype.constructor = THREE.VideoTexture,
        THREE.Group = function() {
            THREE.Object3D.call(this),
                this.type = "Group"
        }
        ,
        THREE.Group.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
            constructor: THREE.Group
        }),
        THREE.Points = function(geometry, material) {
            THREE.Object3D.call(this),
                this.type = "Points",
                this.geometry = void 0 !== geometry ? geometry : new THREE.BufferGeometry,
                this.material = void 0 !== material ? material : new THREE.PointsMaterial({
                    color: 16777215 * Math.random()
                })
        }
        ,
        THREE.Points.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
            constructor: THREE.Points,
            raycast: function() {
                var inverseMatrix = new THREE.Matrix4
                    , ray = new THREE.Ray
                    , sphere = new THREE.Sphere;
                return function(raycaster, intersects) {
                    function testPoint(point, index) {
                        var rayPointDistanceSq = ray.distanceSqToPoint(point);
                        if (rayPointDistanceSq < localThresholdSq) {
                            var intersectPoint = ray.closestPointToPoint(point);
                            intersectPoint.applyMatrix4(matrixWorld);
                            var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                            if (distance < raycaster.near || distance > raycaster.far)
                                return;
                            intersects.push({
                                distance: distance,
                                distanceToRay: Math.sqrt(rayPointDistanceSq),
                                point: intersectPoint.clone(),
                                index: index,
                                face: null,
                                object: object
                            })
                        }
                    }
                    var object = this
                        , geometry = this.geometry
                        , matrixWorld = this.matrixWorld
                        , threshold = raycaster.params.Points.threshold;
                    if (null === geometry.boundingSphere && geometry.computeBoundingSphere(),
                            sphere.copy(geometry.boundingSphere),
                            sphere.applyMatrix4(matrixWorld),
                        raycaster.ray.intersectsSphere(sphere) !== !1) {
                        inverseMatrix.getInverse(matrixWorld),
                            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                            , localThresholdSq = localThreshold * localThreshold
                            , position = new THREE.Vector3;
                        if (geometry instanceof THREE.BufferGeometry) {
                            var index = geometry.index
                                , attributes = geometry.attributes
                                , positions = attributes.position.array;
                            if (null !== index)
                                for (var indices = index.array, i = 0, il = indices.length; i < il; i++) {
                                    var a = indices[i];
                                    position.fromArray(positions, 3 * a),
                                        testPoint(position, a)
                                }
                            else
                                for (var i = 0, l = positions.length / 3; i < l; i++)
                                    position.fromArray(positions, 3 * i),
                                        testPoint(position, i)
                        } else
                            for (var vertices = geometry.vertices, i = 0, l = vertices.length; i < l; i++)
                                testPoint(vertices[i], i)
                    }
                }
            }(),
            clone: function() {
                return new this.constructor(this.geometry,this.material).copy(this)
            }
        }),
        THREE.Line = function(geometry, material, mode) {
            return 1 === mode ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),
                new THREE.LineSegments(geometry,material)) : (THREE.Object3D.call(this),
                this.type = "Line",
                this.geometry = void 0 !== geometry ? geometry : new THREE.BufferGeometry,
                void (this.material = void 0 !== material ? material : new THREE.LineBasicMaterial({
                    color: 16777215 * Math.random()
                })))
        }
        ,
        THREE.Line.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
            constructor: THREE.Line,
            raycast: function() {
                var inverseMatrix = new THREE.Matrix4
                    , ray = new THREE.Ray
                    , sphere = new THREE.Sphere;
                return function(raycaster, intersects) {
                    var precision = raycaster.linePrecision
                        , precisionSq = precision * precision
                        , geometry = this.geometry
                        , matrixWorld = this.matrixWorld;
                    if (null === geometry.boundingSphere && geometry.computeBoundingSphere(),
                            sphere.copy(geometry.boundingSphere),
                            sphere.applyMatrix4(matrixWorld),
                        raycaster.ray.intersectsSphere(sphere) !== !1) {
                        inverseMatrix.getInverse(matrixWorld),
                            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                        var vStart = new THREE.Vector3
                            , vEnd = new THREE.Vector3
                            , interSegment = new THREE.Vector3
                            , interRay = new THREE.Vector3
                            , step = this instanceof THREE.LineSegments ? 2 : 1;
                        if (geometry instanceof THREE.BufferGeometry) {
                            var index = geometry.index
                                , attributes = geometry.attributes
                                , positions = attributes.position.array;
                            if (null !== index)
                                for (var indices = index.array, i = 0, l = indices.length - 1; i < l; i += step) {
                                    var a = indices[i]
                                        , b = indices[i + 1];
                                    vStart.fromArray(positions, 3 * a),
                                        vEnd.fromArray(positions, 3 * b);
                                    var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                                    if (!(distSq > precisionSq)) {
                                        interRay.applyMatrix4(this.matrixWorld);
                                        var distance = raycaster.ray.origin.distanceTo(interRay);
                                        distance < raycaster.near || distance > raycaster.far || intersects.push({
                                            distance: distance,
                                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                            index: i,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                }
                            else
                                for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                                    vStart.fromArray(positions, 3 * i),
                                        vEnd.fromArray(positions, 3 * i + 3);
                                    var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                                    if (!(distSq > precisionSq)) {
                                        interRay.applyMatrix4(this.matrixWorld);
                                        var distance = raycaster.ray.origin.distanceTo(interRay);
                                        distance < raycaster.near || distance > raycaster.far || intersects.push({
                                            distance: distance,
                                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                            index: i,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                }
                        } else if (geometry instanceof THREE.Geometry)
                            for (var vertices = geometry.vertices, nbVertices = vertices.length, i = 0; i < nbVertices - 1; i += step) {
                                var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                                if (!(distSq > precisionSq)) {
                                    interRay.applyMatrix4(this.matrixWorld);
                                    var distance = raycaster.ray.origin.distanceTo(interRay);
                                    distance < raycaster.near || distance > raycaster.far || intersects.push({
                                        distance: distance,
                                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                        index: i,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                    }
                }
            }(),
            clone: function() {
                return new this.constructor(this.geometry,this.material).copy(this)
            }
        }),
        THREE.LineSegments = function(geometry, material) {
            THREE.Line.call(this, geometry, material),
                this.type = "LineSegments"
        }
        ,
        THREE.LineSegments.prototype = Object.assign(Object.create(THREE.Line.prototype), {
            constructor: THREE.LineSegments
        }),
        THREE.Mesh = function(geometry, material) {
            THREE.Object3D.call(this),
                this.type = "Mesh",
                this.geometry = void 0 !== geometry ? geometry : new THREE.BufferGeometry,
                this.material = void 0 !== material ? material : new THREE.MeshBasicMaterial({
                    color: 16777215 * Math.random()
                }),
                this.drawMode = THREE.TrianglesDrawMode,
                this.updateMorphTargets()
        }
        ,
        THREE.Mesh.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
            constructor: THREE.Mesh,
            setDrawMode: function(value) {
                this.drawMode = value
            },
            copy: function(source) {
                return THREE.Object3D.prototype.copy.call(this, source),
                    this.drawMode = source.drawMode,
                    this
            },
            updateMorphTargets: function() {
                if (void 0 !== this.geometry.morphTargets && this.geometry.morphTargets.length > 0) {
                    this.morphTargetBase = -1,
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                    for (var m = 0, ml = this.geometry.morphTargets.length; m < ml; m++)
                        this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m
                }
            },
            getMorphTargetIndexByName: function(name) {
                return void 0 !== this.morphTargetDictionary[name] ? this.morphTargetDictionary[name] : (console.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + name + " does not exist. Returning 0."),
                    0)
            },
            raycast: function() {
                function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
                    return THREE.Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord),
                        uv1.multiplyScalar(barycoord.x),
                        uv2.multiplyScalar(barycoord.y),
                        uv3.multiplyScalar(barycoord.z),
                        uv1.add(uv2).add(uv3),
                        uv1.clone()
                }
                function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
                    var intersect, material = object.material;
                    if (intersect = material.side === THREE.BackSide ? ray.intersectTriangle(pC, pB, pA, !0, point) : ray.intersectTriangle(pA, pB, pC, material.side !== THREE.DoubleSide, point),
                        null === intersect)
                        return null;
                    intersectionPointWorld.copy(point),
                        intersectionPointWorld.applyMatrix4(object.matrixWorld);
                    var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
                    return distance < raycaster.near || distance > raycaster.far ? null : {
                        distance: distance,
                        point: intersectionPointWorld.clone(),
                        object: object
                    }
                }
                function checkBufferGeometryIntersection(object, raycaster, ray, positions, uvs, a, b, c) {
                    vA.fromArray(positions, 3 * a),
                        vB.fromArray(positions, 3 * b),
                        vC.fromArray(positions, 3 * c);
                    var intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
                    return intersection && (uvs && (uvA.fromArray(uvs, 2 * a),
                        uvB.fromArray(uvs, 2 * b),
                        uvC.fromArray(uvs, 2 * c),
                        intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC)),
                        intersection.face = new THREE.Face3(a,b,c,THREE.Triangle.normal(vA, vB, vC)),
                        intersection.faceIndex = a),
                        intersection
                }
                var inverseMatrix = new THREE.Matrix4
                    , ray = new THREE.Ray
                    , sphere = new THREE.Sphere
                    , vA = new THREE.Vector3
                    , vB = new THREE.Vector3
                    , vC = new THREE.Vector3
                    , tempA = new THREE.Vector3
                    , tempB = new THREE.Vector3
                    , tempC = new THREE.Vector3
                    , uvA = new THREE.Vector2
                    , uvB = new THREE.Vector2
                    , uvC = new THREE.Vector2
                    , barycoord = new THREE.Vector3
                    , intersectionPoint = new THREE.Vector3
                    , intersectionPointWorld = new THREE.Vector3;
                return function(raycaster, intersects) {
                    var geometry = this.geometry
                        , material = this.material
                        , matrixWorld = this.matrixWorld;
                    if (void 0 !== material && (null === geometry.boundingSphere && geometry.computeBoundingSphere(),
                            sphere.copy(geometry.boundingSphere),
                            sphere.applyMatrix4(matrixWorld),
                        raycaster.ray.intersectsSphere(sphere) !== !1 && (inverseMatrix.getInverse(matrixWorld),
                            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix),
                        null === geometry.boundingBox || ray.intersectsBox(geometry.boundingBox) !== !1))) {
                        var uvs, intersection;
                        if (geometry instanceof THREE.BufferGeometry) {
                            var a, b, c, index = geometry.index, attributes = geometry.attributes, positions = attributes.position.array;
                            if (void 0 !== attributes.uv && (uvs = attributes.uv.array),
                                null !== index)
                                for (var indices = index.array, i = 0, l = indices.length; i < l; i += 3)
                                    a = indices[i],
                                        b = indices[i + 1],
                                        c = indices[i + 2],
                                        intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c),
                                    intersection && (intersection.faceIndex = Math.floor(i / 3),
                                        intersects.push(intersection));
                            else
                                for (var i = 0, l = positions.length; i < l; i += 9)
                                    a = i / 3,
                                        b = a + 1,
                                        c = a + 2,
                                        intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c),
                                    intersection && (intersection.index = a,
                                        intersects.push(intersection))
                        } else if (geometry instanceof THREE.Geometry) {
                            var fvA, fvB, fvC, isFaceMaterial = material instanceof THREE.MultiMaterial, materials = isFaceMaterial === !0 ? material.materials : null, vertices = geometry.vertices, faces = geometry.faces, faceVertexUvs = geometry.faceVertexUvs[0];
                            faceVertexUvs.length > 0 && (uvs = faceVertexUvs);
                            for (var f = 0, fl = faces.length; f < fl; f++) {
                                var face = faces[f]
                                    , faceMaterial = isFaceMaterial === !0 ? materials[face.materialIndex] : material;
                                if (void 0 !== faceMaterial) {
                                    if (fvA = vertices[face.a],
                                            fvB = vertices[face.b],
                                            fvC = vertices[face.c],
                                        faceMaterial.morphTargets === !0) {
                                        var morphTargets = geometry.morphTargets
                                            , morphInfluences = this.morphTargetInfluences;
                                        vA.set(0, 0, 0),
                                            vB.set(0, 0, 0),
                                            vC.set(0, 0, 0);
                                        for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                                            var influence = morphInfluences[t];
                                            if (0 !== influence) {
                                                var targets = morphTargets[t].vertices;
                                                vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence),
                                                    vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence),
                                                    vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence)
                                            }
                                        }
                                        vA.add(fvA),
                                            vB.add(fvB),
                                            vC.add(fvC),
                                            fvA = vA,
                                            fvB = vB,
                                            fvC = vC
                                    }
                                    if (intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint)) {
                                        if (uvs) {
                                            var uvs_f = uvs[f];
                                            uvA.copy(uvs_f[0]),
                                                uvB.copy(uvs_f[1]),
                                                uvC.copy(uvs_f[2]),
                                                intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC)
                                        }
                                        intersection.face = face,
                                            intersection.faceIndex = f,
                                            intersects.push(intersection)
                                    }
                                }
                            }
                        }
                    }
                }
            }(),
            clone: function() {
                return new this.constructor(this.geometry,this.material).copy(this)
            }
        }),
        THREE.Bone = function(skin) {
            THREE.Object3D.call(this),
                this.type = "Bone",
                this.skin = skin
        }
        ,
        THREE.Bone.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
            constructor: THREE.Bone,
            copy: function(source) {
                return THREE.Object3D.prototype.copy.call(this, source),
                    this.skin = source.skin,
                    this
            }
        }),
        THREE.Skeleton = function(bones, boneInverses, useVertexTexture) {
            if (this.useVertexTexture = void 0 === useVertexTexture || useVertexTexture,
                    this.identityMatrix = new THREE.Matrix4,
                    bones = bones || [],
                    this.bones = bones.slice(0),
                    this.useVertexTexture) {
                var size = Math.sqrt(4 * this.bones.length);
                size = THREE.Math.nextPowerOfTwo(Math.ceil(size)),
                    size = Math.max(size, 4),
                    this.boneTextureWidth = size,
                    this.boneTextureHeight = size,
                    this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4),
                    this.boneTexture = new THREE.DataTexture(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,THREE.RGBAFormat,THREE.FloatType)
            } else
                this.boneMatrices = new Float32Array(16 * this.bones.length);
            if (void 0 === boneInverses)
                this.calculateInverses();
            else if (this.bones.length === boneInverses.length)
                this.boneInverses = boneInverses.slice(0);
            else {
                console.warn("THREE.Skeleton bonInverses is the wrong length."),
                    this.boneInverses = [];
                for (var b = 0, bl = this.bones.length; b < bl; b++)
                    this.boneInverses.push(new THREE.Matrix4)
            }
        }
        ,
        Object.assign(THREE.Skeleton.prototype, {
            calculateInverses: function() {
                this.boneInverses = [];
                for (var b = 0, bl = this.bones.length; b < bl; b++) {
                    var inverse = new THREE.Matrix4;
                    this.bones[b] && inverse.getInverse(this.bones[b].matrixWorld),
                        this.boneInverses.push(inverse)
                }
            },
            pose: function() {
                for (var bone, b = 0, bl = this.bones.length; b < bl; b++)
                    bone = this.bones[b],
                    bone && bone.matrixWorld.getInverse(this.boneInverses[b]);
                for (var b = 0, bl = this.bones.length; b < bl; b++)
                    bone = this.bones[b],
                    bone && (bone.parent instanceof THREE.Bone ? (bone.matrix.getInverse(bone.parent.matrixWorld),
                        bone.matrix.multiply(bone.matrixWorld)) : bone.matrix.copy(bone.matrixWorld),
                        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale))
            },
            update: function() {
                var offsetMatrix = new THREE.Matrix4;
                return function() {
                    for (var b = 0, bl = this.bones.length; b < bl; b++) {
                        var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
                        offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]),
                            offsetMatrix.toArray(this.boneMatrices, 16 * b)
                    }
                    this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
                }
            }(),
            clone: function() {
                return new THREE.Skeleton(this.bones,this.boneInverses,this.useVertexTexture)
            }
        }),
        THREE.SkinnedMesh = function(geometry, material, useVertexTexture) {
            THREE.Mesh.call(this, geometry, material),
                this.type = "SkinnedMesh",
                this.bindMode = "attached",
                this.bindMatrix = new THREE.Matrix4,
                this.bindMatrixInverse = new THREE.Matrix4;
            var bones = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (var bone, gbone, b = 0, bl = this.geometry.bones.length; b < bl; ++b)
                    gbone = this.geometry.bones[b],
                        bone = new THREE.Bone(this),
                        bones.push(bone),
                        bone.name = gbone.name,
                        bone.position.fromArray(gbone.pos),
                        bone.quaternion.fromArray(gbone.rotq),
                    void 0 !== gbone.scl && bone.scale.fromArray(gbone.scl);
                for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b)
                    gbone = this.geometry.bones[b],
                        gbone.parent !== -1 && null !== gbone.parent && void 0 !== bones[gbone.parent] ? bones[gbone.parent].add(bones[b]) : this.add(bones[b])
            }
            this.normalizeSkinWeights(),
                this.updateMatrixWorld(!0),
                this.bind(new THREE.Skeleton(bones,void 0,useVertexTexture), this.matrixWorld)
        }
        ,
        THREE.SkinnedMesh.prototype = Object.assign(Object.create(THREE.Mesh.prototype), {
            constructor: THREE.SkinnedMesh,
            bind: function(skeleton, bindMatrix) {
                this.skeleton = skeleton,
                void 0 === bindMatrix && (this.updateMatrixWorld(!0),
                    this.skeleton.calculateInverses(),
                    bindMatrix = this.matrixWorld),
                    this.bindMatrix.copy(bindMatrix),
                    this.bindMatrixInverse.getInverse(bindMatrix)
            },
            pose: function() {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function() {
                if (this.geometry instanceof THREE.Geometry)
                    for (var i = 0; i < this.geometry.skinWeights.length; i++) {
                        var sw = this.geometry.skinWeights[i]
                            , scale = 1 / sw.lengthManhattan();
                        scale !== 1 / 0 ? sw.multiplyScalar(scale) : sw.set(1, 0, 0, 0)
                    }
                else if (this.geometry instanceof THREE.BufferGeometry)
                    for (var vec = new THREE.Vector4, skinWeight = this.geometry.attributes.skinWeight, i = 0; i < skinWeight.count; i++) {
                        vec.x = skinWeight.getX(i),
                            vec.y = skinWeight.getY(i),
                            vec.z = skinWeight.getZ(i),
                            vec.w = skinWeight.getW(i);
                        var scale = 1 / vec.lengthManhattan();
                        scale !== 1 / 0 ? vec.multiplyScalar(scale) : vec.set(1, 0, 0, 0),
                            skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w)
                    }
            },
            updateMatrixWorld: function(force) {
                THREE.Mesh.prototype.updateMatrixWorld.call(this, !0),
                    "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode)
            },
            clone: function() {
                return new this.constructor(this.geometry,this.material,this.skeleton.useVertexTexture).copy(this)
            }
        }),
        THREE.LOD = function() {
            THREE.Object3D.call(this),
                this.type = "LOD",
                Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                })
        }
        ,
        THREE.LOD.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
            constructor: THREE.LOD,
            copy: function(source) {
                THREE.Object3D.prototype.copy.call(this, source, !1);
                for (var levels = source.levels, i = 0, l = levels.length; i < l; i++) {
                    var level = levels[i];
                    this.addLevel(level.object.clone(), level.distance)
                }
                return this
            },
            addLevel: function(object, distance) {
                void 0 === distance && (distance = 0),
                    distance = Math.abs(distance);
                for (var levels = this.levels, l = 0; l < levels.length && !(distance < levels[l].distance); l++)
                    ;
                levels.splice(l, 0, {
                    distance: distance,
                    object: object
                }),
                    this.add(object)
            },
            getObjectForDistance: function(distance) {
                for (var levels = this.levels, i = 1, l = levels.length; i < l && !(distance < levels[i].distance); i++)
                    ;
                return levels[i - 1].object
            },
            raycast: function() {
                var matrixPosition = new THREE.Vector3;
                return function(raycaster, intersects) {
                    matrixPosition.setFromMatrixPosition(this.matrixWorld);
                    var distance = raycaster.ray.origin.distanceTo(matrixPosition);
                    this.getObjectForDistance(distance).raycast(raycaster, intersects)
                }
            }(),
            update: function() {
                var v1 = new THREE.Vector3
                    , v2 = new THREE.Vector3;
                return function(camera) {
                    var levels = this.levels;
                    if (levels.length > 1) {
                        v1.setFromMatrixPosition(camera.matrixWorld),
                            v2.setFromMatrixPosition(this.matrixWorld);
                        var distance = v1.distanceTo(v2);
                        levels[0].object.visible = !0;
                        for (var i = 1, l = levels.length; i < l && distance >= levels[i].distance; i++)
                            levels[i - 1].object.visible = !1,
                                levels[i].object.visible = !0;
                        for (; i < l; i++)
                            levels[i].object.visible = !1
                    }
                }
            }(),
            toJSON: function(meta) {
                var data = THREE.Object3D.prototype.toJSON.call(this, meta);
                data.object.levels = [];
                for (var levels = this.levels, i = 0, l = levels.length; i < l; i++) {
                    var level = levels[i];
                    data.object.levels.push({
                        object: level.object.uuid,
                        distance: level.distance
                    })
                }
                return data
            }
        }),
        THREE.Sprite = function(material) {
            THREE.Object3D.call(this),
                this.type = "Sprite",
                this.material = void 0 !== material ? material : new THREE.SpriteMaterial
        }
        ,
        THREE.Sprite.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
            constructor: THREE.Sprite,
            raycast: function() {
                var matrixPosition = new THREE.Vector3;
                return function(raycaster, intersects) {
                    matrixPosition.setFromMatrixPosition(this.matrixWorld);
                    var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition)
                        , guessSizeSq = this.scale.x * this.scale.y / 4;
                    distanceSq > guessSizeSq || intersects.push({
                        distance: Math.sqrt(distanceSq),
                        point: this.position,
                        face: null,
                        object: this
                    })
                }
            }(),
            clone: function() {
                return new this.constructor(this.material).copy(this)
            }
        }),
        THREE.LensFlare = function(texture, size, distance, blending, color) {
            THREE.Object3D.call(this),
                this.lensFlares = [],
                this.positionScreen = new THREE.Vector3,
                this.customUpdateCallback = void 0,
            void 0 !== texture && this.add(texture, size, distance, blending, color)
        }
        ,
        THREE.LensFlare.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
            constructor: THREE.LensFlare,
            copy: function(source) {
                THREE.Object3D.prototype.copy.call(this, source),
                    this.positionScreen.copy(source.positionScreen),
                    this.customUpdateCallback = source.customUpdateCallback;
                for (var i = 0, l = source.lensFlares.length; i < l; i++)
                    this.lensFlares.push(source.lensFlares[i]);
                return this
            },
            add: function(texture, size, distance, blending, color, opacity) {
                void 0 === size && (size = -1),
                void 0 === distance && (distance = 0),
                void 0 === opacity && (opacity = 1),
                void 0 === color && (color = new THREE.Color(16777215)),
                void 0 === blending && (blending = THREE.NormalBlending),
                    distance = Math.min(distance, Math.max(0, distance)),
                    this.lensFlares.push({
                        texture: texture,
                        size: size,
                        distance: distance,
                        x: 0,
                        y: 0,
                        z: 0,
                        scale: 1,
                        rotation: 0,
                        opacity: opacity,
                        color: color,
                        blending: blending
                    })
            },
            updateLensFlares: function() {
                var f, flare, fl = this.lensFlares.length, vecX = 2 * -this.positionScreen.x, vecY = 2 * -this.positionScreen.y;
                for (f = 0; f < fl; f++)
                    flare = this.lensFlares[f],
                        flare.x = this.positionScreen.x + vecX * flare.distance,
                        flare.y = this.positionScreen.y + vecY * flare.distance,
                        flare.wantedRotation = flare.x * Math.PI * .25,
                        flare.rotation += .25 * (flare.wantedRotation - flare.rotation)
            }
        }),
        THREE.Scene = function() {
            THREE.Object3D.call(this),
                this.type = "Scene",
                this.background = null,
                this.fog = null,
                this.overrideMaterial = null,
                this.autoUpdate = !0
        }
        ,
        THREE.Scene.prototype = Object.create(THREE.Object3D.prototype),
        THREE.Scene.prototype.constructor = THREE.Scene,
        THREE.Scene.prototype.copy = function(source, recursive) {
            return THREE.Object3D.prototype.copy.call(this, source, recursive),
            null !== source.background && (this.background = source.background.clone()),
            null !== source.fog && (this.fog = source.fog.clone()),
            null !== source.overrideMaterial && (this.overrideMaterial = source.overrideMaterial.clone()),
                this.autoUpdate = source.autoUpdate,
                this.matrixAutoUpdate = source.matrixAutoUpdate,
                this
        }
        ,
        THREE.Fog = function(color, near, far) {
            this.name = "",
                this.color = new THREE.Color(color),
                this.near = void 0 !== near ? near : 1,
                this.far = void 0 !== far ? far : 1e3
        }
        ,
        THREE.Fog.prototype.clone = function() {
            return new THREE.Fog(this.color.getHex(),this.near,this.far)
        }
        ,
        THREE.FogExp2 = function(color, density) {
            this.name = "",
                this.color = new THREE.Color(color),
                this.density = void 0 !== density ? density : 25e-5
        }
        ,
        THREE.FogExp2.prototype.clone = function() {
            return new THREE.FogExp2(this.color.getHex(),this.density)
        }
        ,
        THREE.ShaderChunk = {},
        THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
        THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
        THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
        THREE.ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
        THREE.ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        THREE.ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n",
        THREE.ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n",
        THREE.ShaderChunk.bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
        THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
        THREE.ShaderChunk.clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n",
        THREE.ShaderChunk.clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
        THREE.ShaderChunk.clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
        THREE.ShaderChunk.clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
        THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
        THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        THREE.ShaderChunk.common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n",
        THREE.ShaderChunk.cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
        THREE.ShaderChunk.defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n",
        THREE.ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
        THREE.ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
        THREE.ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
        THREE.ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
        THREE.ShaderChunk.encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n",
        THREE.ShaderChunk.encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
        THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
        THREE.ShaderChunk.envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
        THREE.ShaderChunk.envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
        THREE.ShaderChunk.envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
        THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
        THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
        THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        THREE.ShaderChunk.lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
        THREE.ShaderChunk.lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
        THREE.ShaderChunk.lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
        THREE.ShaderChunk.lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
        THREE.ShaderChunk.lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
        THREE.ShaderChunk.lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
        THREE.ShaderChunk.lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
        THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
        THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
        THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
        THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n",
        THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
        THREE.ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
        THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
        THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n",
        THREE.ShaderChunk.metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n",
        THREE.ShaderChunk.metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
        THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
        THREE.ShaderChunk.normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n",
        THREE.ShaderChunk.normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
        THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
        THREE.ShaderChunk.packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
        THREE.ShaderChunk.premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
        THREE.ShaderChunk.project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";
        THREE.ShaderChunk.roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";
        THREE.ShaderChunk.roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
            THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
            THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
            THREE.ShaderChunk.shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
            THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
            THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n",
            THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
            THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            THREE.ShaderChunk.tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
            THREE.ShaderChunk.tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
            THREE.ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            THREE.ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
            THREE.ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
            THREE.ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
            THREE.ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n",
            THREE.ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
            THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n",
            THREE.UniformsUtils = {
                merge: function(uniforms) {
                    for (var merged = {}, u = 0; u < uniforms.length; u++) {
                        var tmp = this.clone(uniforms[u]);
                        for (var p in tmp)
                            merged[p] = tmp[p]
                    }
                    return merged
                },
                clone: function(uniforms_src) {
                    var uniforms_dst = {};
                    for (var u in uniforms_src) {
                        uniforms_dst[u] = {};
                        for (var p in uniforms_src[u]) {
                            var parameter_src = uniforms_src[u][p];
                            parameter_src instanceof THREE.Color || parameter_src instanceof THREE.Vector2 || parameter_src instanceof THREE.Vector3 || parameter_src instanceof THREE.Vector4 || parameter_src instanceof THREE.Matrix3 || parameter_src instanceof THREE.Matrix4 || parameter_src instanceof THREE.Texture ? uniforms_dst[u][p] = parameter_src.clone() : Array.isArray(parameter_src) ? uniforms_dst[u][p] = parameter_src.slice() : uniforms_dst[u][p] = parameter_src
                        }
                    }
                    return uniforms_dst
                }
            },
            THREE.UniformsLib = {
                common: {
                    diffuse: {
                        value: new THREE.Color(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    offsetRepeat: {
                        value: new THREE.Vector4(0,0,1,1)
                    },
                    specularMap: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new THREE.Vector2(1,1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new THREE.Color(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    }
                },
                points: {
                    diffuse: {
                        value: new THREE.Color(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    offsetRepeat: {
                        value: new THREE.Vector4(0,0,1,1)
                    }
                }
            },
            THREE.ShaderChunk.cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\t#include <logdepthbuf_fragment>\n}\n",
            THREE.ShaderChunk.cube_vert = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
            THREE.ShaderChunk.depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
            THREE.ShaderChunk.depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
            THREE.ShaderChunk.distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n",
            THREE.ShaderChunk.distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n",
            THREE.ShaderChunk.equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <logdepthbuf_fragment>\n}\n",
            THREE.ShaderChunk.equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
            THREE.ShaderChunk.linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            THREE.ShaderChunk.linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
            THREE.ShaderChunk.meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            THREE.ShaderChunk.meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n",
            THREE.ShaderChunk.meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            THREE.ShaderChunk.meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n",
            THREE.ShaderChunk.meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            THREE.ShaderChunk.meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n",
            THREE.ShaderChunk.meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            THREE.ShaderChunk.meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n",
            THREE.ShaderChunk.normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n",
            THREE.ShaderChunk.normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
            THREE.ShaderChunk.points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            THREE.ShaderChunk.points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n",
            THREE.ShaderChunk.shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n",
            THREE.ShaderChunk.shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n",
            THREE.ShaderLib = {
                basic: {
                    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.fog]),
                    vertexShader: THREE.ShaderChunk.meshbasic_vert,
                    fragmentShader: THREE.ShaderChunk.meshbasic_frag
                },
                lambert: {
                    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
                        emissive: {
                            value: new THREE.Color(0)
                        }
                    }]),
                    vertexShader: THREE.ShaderChunk.meshlambert_vert,
                    fragmentShader: THREE.ShaderChunk.meshlambert_frag
                },
                phong: {
                    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.bumpmap, THREE.UniformsLib.normalmap, THREE.UniformsLib.displacementmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
                        emissive: {
                            value: new THREE.Color(0)
                        },
                        specular: {
                            value: new THREE.Color(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: THREE.ShaderChunk.meshphong_vert,
                    fragmentShader: THREE.ShaderChunk.meshphong_frag
                },
                standard: {
                    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.bumpmap, THREE.UniformsLib.normalmap, THREE.UniformsLib.displacementmap, THREE.UniformsLib.roughnessmap, THREE.UniformsLib.metalnessmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
                        emissive: {
                            value: new THREE.Color(0)
                        },
                        roughness: {
                            value: .5
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: THREE.ShaderChunk.meshphysical_vert,
                    fragmentShader: THREE.ShaderChunk.meshphysical_frag
                },
                points: {
                    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.points, THREE.UniformsLib.fog]),
                    vertexShader: THREE.ShaderChunk.points_vert,
                    fragmentShader: THREE.ShaderChunk.points_frag
                },
                dashed: {
                    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: THREE.ShaderChunk.linedashed_vert,
                    fragmentShader: THREE.ShaderChunk.linedashed_frag
                },
                depth: {
                    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.displacementmap]),
                    vertexShader: THREE.ShaderChunk.depth_vert,
                    fragmentShader: THREE.ShaderChunk.depth_frag
                },
                normal: {
                    uniforms: {
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: THREE.ShaderChunk.normal_vert,
                    fragmentShader: THREE.ShaderChunk.normal_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        }
                    },
                    vertexShader: THREE.ShaderChunk.cube_vert,
                    fragmentShader: THREE.ShaderChunk.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        }
                    },
                    vertexShader: THREE.ShaderChunk.equirect_vert,
                    fragmentShader: THREE.ShaderChunk.equirect_frag
                },
                distanceRGBA: {
                    uniforms: {
                        lightPos: {
                            value: new THREE.Vector3
                        }
                    },
                    vertexShader: THREE.ShaderChunk.distanceRGBA_vert,
                    fragmentShader: THREE.ShaderChunk.distanceRGBA_frag
                }
            },
            THREE.ShaderLib.physical = {
                uniforms: THREE.UniformsUtils.merge([THREE.ShaderLib.standard.uniforms, {
                    clearCoat: {
                        value: 0
                    },
                    clearCoatRoughness: {
                        value: 0
                    }
                }]),
                vertexShader: THREE.ShaderChunk.meshphysical_vert,
                fragmentShader: THREE.ShaderChunk.meshphysical_frag
            },
            THREE.WebGLRenderer = function(parameters) {
                function getTargetPixelRatio() {
                    return null === _currentRenderTarget ? _pixelRatio : 1
                }
                function glClearColor(r, g, b, a) {
                    _premultipliedAlpha === !0 && (r *= a,
                        g *= a,
                        b *= a),
                        state.clearColor(r, g, b, a)
                }
                function setDefaultGLState() {
                    state.init(),
                        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio)),
                        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio)),
                        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha)
                }
                function resetGLState() {
                    _currentProgram = null,
                        _currentCamera = null,
                        _currentGeometryProgram = "",
                        _currentMaterialId = -1,
                        state.reset()
                }
                function onContextLost(event) {
                    event.preventDefault(),
                        resetGLState(),
                        setDefaultGLState(),
                        properties.clear()
                }
                function onMaterialDispose(event) {
                    var material = event.target;
                    material.removeEventListener("dispose", onMaterialDispose),
                        deallocateMaterial(material)
                }
                function deallocateMaterial(material) {
                    releaseMaterialProgramReference(material),
                        properties.delete(material)
                }
                function releaseMaterialProgramReference(material) {
                    var programInfo = properties.get(material).program;
                    material.program = void 0,
                    void 0 !== programInfo && programCache.releaseProgram(programInfo)
                }
                function setupVertexAttributes(material, program, geometry, startIndex) {
                    var extension;
                    if (geometry instanceof THREE.InstancedBufferGeometry && (extension = extensions.get("ANGLE_instanced_arrays"),
                        null === extension))
                        return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    void 0 === startIndex && (startIndex = 0),
                        state.initAttributes();
                    var geometryAttributes = geometry.attributes
                        , programAttributes = program.getAttributes()
                        , materialDefaultAttributeValues = material.defaultAttributeValues;
                    for (var name in programAttributes) {
                        var programAttribute = programAttributes[name];
                        if (programAttribute >= 0) {
                            var geometryAttribute = geometryAttributes[name];
                            if (void 0 !== geometryAttribute) {
                                var type = _gl.FLOAT
                                    , array = geometryAttribute.array
                                    , normalized = geometryAttribute.normalized;
                                array instanceof Float32Array ? type = _gl.FLOAT : array instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : array instanceof Uint16Array ? type = _gl.UNSIGNED_SHORT : array instanceof Int16Array ? type = _gl.SHORT : array instanceof Uint32Array ? type = _gl.UNSIGNED_INT : array instanceof Int32Array ? type = _gl.INT : array instanceof Int8Array ? type = _gl.BYTE : array instanceof Uint8Array && (type = _gl.UNSIGNED_BYTE);
                                var size = geometryAttribute.itemSize
                                    , buffer = objects.getAttributeBuffer(geometryAttribute);
                                if (geometryAttribute instanceof THREE.InterleavedBufferAttribute) {
                                    var data = geometryAttribute.data
                                        , stride = data.stride
                                        , offset = geometryAttribute.offset;
                                    data instanceof THREE.InstancedInterleavedBuffer ? (state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension),
                                    void 0 === geometry.maxInstancedCount && (geometry.maxInstancedCount = data.meshPerAttribute * data.count)) : state.enableAttribute(programAttribute),
                                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer),
                                        _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT)
                                } else
                                    geometryAttribute instanceof THREE.InstancedBufferAttribute ? (state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension),
                                    void 0 === geometry.maxInstancedCount && (geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count)) : state.enableAttribute(programAttribute),
                                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer),
                                        _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT)
                            } else if (void 0 !== materialDefaultAttributeValues) {
                                var value = materialDefaultAttributeValues[name];
                                if (void 0 !== value)
                                    switch (value.length) {
                                        case 2:
                                            _gl.vertexAttrib2fv(programAttribute, value);
                                            break;
                                        case 3:
                                            _gl.vertexAttrib3fv(programAttribute, value);
                                            break;
                                        case 4:
                                            _gl.vertexAttrib4fv(programAttribute, value);
                                            break;
                                        default:
                                            _gl.vertexAttrib1fv(programAttribute, value)
                                    }
                            }
                        }
                    }
                    state.disableUnusedAttributes()
                }
                function absNumericalSort(a, b) {
                    return Math.abs(b[0]) - Math.abs(a[0])
                }
                function painterSortStable(a, b) {
                    return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
                }
                function reversePainterSortStable(a, b) {
                    return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
                }
                function pushRenderItem(object, geometry, material, z, group) {
                    var array, index;
                    material.transparent ? (array = transparentObjects,
                        index = ++transparentObjectsLastIndex) : (array = opaqueObjects,
                        index = ++opaqueObjectsLastIndex);
                    var renderItem = array[index];
                    void 0 !== renderItem ? (renderItem.id = object.id,
                        renderItem.object = object,
                        renderItem.geometry = geometry,
                        renderItem.material = material,
                        renderItem.z = _vector3.z,
                        renderItem.group = group) : (renderItem = {
                        id: object.id,
                        object: object,
                        geometry: geometry,
                        material: material,
                        z: _vector3.z,
                        group: group
                    },
                        array.push(renderItem))
                }
                function isObjectViewable(object) {
                    var geometry = object.geometry;
                    return null === geometry.boundingSphere && geometry.computeBoundingSphere(),
                        _sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld),
                        isSphereViewable(_sphere)
                }
                function isSpriteViewable(sprite) {
                    return _sphere.center.set(0, 0, 0),
                        _sphere.radius = .7071067811865476,
                        _sphere.applyMatrix4(sprite.matrixWorld),
                        isSphereViewable(_sphere)
                }
                function isSphereViewable(sphere) {
                    if (!_frustum.intersectsSphere(sphere))
                        return !1;
                    var numPlanes = _clipping.numPlanes;
                    if (0 === numPlanes)
                        return !0;
                    var planes = _this.clippingPlanes
                        , center = sphere.center
                        , negRad = -sphere.radius
                        , i = 0;
                    do
                        if (planes[i].distanceToPoint(center) < negRad)
                            return !1;
                    while (++i !== numPlanes);return !0
                }
                function projectObject(object, camera) {
                    if (object.visible !== !1) {
                        if (object.layers.test(camera.layers))
                            if (object instanceof THREE.Light)
                                lights.push(object);
                            else if (object instanceof THREE.Sprite)
                                object.frustumCulled !== !1 && isSpriteViewable(object) !== !0 || sprites.push(object);
                            else if (object instanceof THREE.LensFlare)
                                lensFlares.push(object);
                            else if (object instanceof THREE.ImmediateRenderObject)
                                _this.sortObjects === !0 && (_vector3.setFromMatrixPosition(object.matrixWorld),
                                    _vector3.applyProjection(_projScreenMatrix)),
                                    pushRenderItem(object, null, object.material, _vector3.z, null);
                            else if ((object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) && (object instanceof THREE.SkinnedMesh && object.skeleton.update(),
                                object.frustumCulled === !1 || isObjectViewable(object) === !0)) {
                                var material = object.material;
                                if (material.visible === !0) {
                                    _this.sortObjects === !0 && (_vector3.setFromMatrixPosition(object.matrixWorld),
                                        _vector3.applyProjection(_projScreenMatrix));
                                    var geometry = objects.update(object);
                                    if (material instanceof THREE.MultiMaterial)
                                        for (var groups = geometry.groups, materials = material.materials, i = 0, l = groups.length; i < l; i++) {
                                            var group = groups[i]
                                                , groupMaterial = materials[group.materialIndex];
                                            groupMaterial.visible === !0 && pushRenderItem(object, geometry, groupMaterial, _vector3.z, group)
                                        }
                                    else
                                        pushRenderItem(object, geometry, material, _vector3.z, null)
                                }
                            }
                        for (var children = object.children, i = 0, l = children.length; i < l; i++)
                            projectObject(children[i], camera)
                    }
                }
                function renderObjects(renderList, camera, fog, overrideMaterial) {
                    for (var i = 0, l = renderList.length; i < l; i++) {
                        var renderItem = renderList[i]
                            , object = renderItem.object
                            , geometry = renderItem.geometry
                            , material = void 0 === overrideMaterial ? renderItem.material : overrideMaterial
                            , group = renderItem.group;
                        if (object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld),
                                object.normalMatrix.getNormalMatrix(object.modelViewMatrix),
                            object instanceof THREE.ImmediateRenderObject) {
                            setMaterial(material);
                            var program = setProgram(camera, fog, material, object);
                            _currentGeometryProgram = "",
                                object.render(function(object) {
                                    _this.renderBufferImmediate(object, program, material)
                                })
                        } else
                            _this.renderBufferDirect(camera, fog, geometry, material, object, group)
                    }
                }
                function initMaterial(material, fog, object) {
                    var materialProperties = properties.get(material)
                        , parameters = programCache.getParameters(material, _lights, fog, _clipping.numPlanes, object)
                        , code = programCache.getProgramCode(material, parameters)
                        , program = materialProperties.program
                        , programChange = !0;
                    if (void 0 === program)
                        material.addEventListener("dispose", onMaterialDispose);
                    else if (program.code !== code)
                        releaseMaterialProgramReference(material);
                    else {
                        if (void 0 !== parameters.shaderID)
                            return;
                        programChange = !1
                    }
                    if (programChange) {
                        if (parameters.shaderID) {
                            var shader = THREE.ShaderLib[parameters.shaderID];
                            materialProperties.__webglShader = {
                                name: material.type,
                                uniforms: THREE.UniformsUtils.clone(shader.uniforms),
                                vertexShader: shader.vertexShader,
                                fragmentShader: shader.fragmentShader
                            }
                        } else
                            materialProperties.__webglShader = {
                                name: material.type,
                                uniforms: material.uniforms,
                                vertexShader: material.vertexShader,
                                fragmentShader: material.fragmentShader
                            };
                        material.__webglShader = materialProperties.__webglShader,
                            program = programCache.acquireProgram(material, parameters, code),
                            materialProperties.program = program,
                            material.program = program
                    }
                    var attributes = program.getAttributes();
                    if (material.morphTargets) {
                        material.numSupportedMorphTargets = 0;
                        for (var i = 0; i < _this.maxMorphTargets; i++)
                            attributes["morphTarget" + i] >= 0 && material.numSupportedMorphTargets++
                    }
                    if (material.morphNormals) {
                        material.numSupportedMorphNormals = 0;
                        for (var i = 0; i < _this.maxMorphNormals; i++)
                            attributes["morphNormal" + i] >= 0 && material.numSupportedMorphNormals++
                    }
                    var uniforms = materialProperties.__webglShader.uniforms;
                    (material instanceof THREE.ShaderMaterial || material instanceof THREE.RawShaderMaterial) && material.clipping !== !0 || (materialProperties.numClippingPlanes = _clipping.numPlanes,
                        uniforms.clippingPlanes = _clipping.uniform),
                    material.lights && (materialProperties.lightsHash = _lights.hash,
                        uniforms.ambientLightColor.value = _lights.ambient,
                        uniforms.directionalLights.value = _lights.directional,
                        uniforms.spotLights.value = _lights.spot,
                        uniforms.pointLights.value = _lights.point,
                        uniforms.hemisphereLights.value = _lights.hemi,
                        uniforms.directionalShadowMap.value = _lights.directionalShadowMap,
                        uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix,
                        uniforms.spotShadowMap.value = _lights.spotShadowMap,
                        uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix,
                        uniforms.pointShadowMap.value = _lights.pointShadowMap,
                        uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix);
                    var progUniforms = materialProperties.program.getUniforms()
                        , uniformsList = THREE.WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
                    materialProperties.uniformsList = uniformsList,
                        materialProperties.dynamicUniforms = THREE.WebGLUniforms.splitDynamic(uniformsList, uniforms)
                }
                function setMaterial(material) {
                    material.side !== THREE.DoubleSide ? state.enable(_gl.CULL_FACE) : state.disable(_gl.CULL_FACE),
                        state.setFlipSided(material.side === THREE.BackSide),
                        material.transparent === !0 ? state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha) : state.setBlending(THREE.NoBlending),
                        state.setDepthFunc(material.depthFunc),
                        state.setDepthTest(material.depthTest),
                        state.setDepthWrite(material.depthWrite),
                        state.setColorWrite(material.colorWrite),
                        state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits)
                }
                function setProgram(camera, fog, material, object) {
                    _usedTextureUnits = 0;
                    var materialProperties = properties.get(material);
                    if (_clippingEnabled) {
                        if (_localClippingEnabled || camera !== _currentCamera) {
                            var useCache = camera === _currentCamera && material.id === _currentMaterialId;
                            _clipping.setState(material.clippingPlanes, material.clipShadows, camera, materialProperties, useCache)
                        }
                        void 0 !== materialProperties.numClippingPlanes && materialProperties.numClippingPlanes !== _clipping.numPlanes && (material.needsUpdate = !0)
                    }
                    void 0 === materialProperties.program && (material.needsUpdate = !0),
                    void 0 !== materialProperties.lightsHash && materialProperties.lightsHash !== _lights.hash && (material.needsUpdate = !0),
                    material.needsUpdate && (initMaterial(material, fog, object),
                        material.needsUpdate = !1);
                    var refreshProgram = !1
                        , refreshMaterial = !1
                        , refreshLights = !1
                        , program = materialProperties.program
                        , p_uniforms = program.getUniforms()
                        , m_uniforms = materialProperties.__webglShader.uniforms;
                    if (program.id !== _currentProgram && (_gl.useProgram(program.program),
                            _currentProgram = program.id,
                            refreshProgram = !0,
                            refreshMaterial = !0,
                            refreshLights = !0),
                        material.id !== _currentMaterialId && (_currentMaterialId = material.id,
                            refreshMaterial = !0),
                        refreshProgram || camera !== _currentCamera) {
                        if (p_uniforms.set(_gl, camera, "projectionMatrix"),
                            capabilities.logarithmicDepthBuffer && p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2)),
                            camera !== _currentCamera && (_currentCamera = camera,
                                refreshMaterial = !0,
                                refreshLights = !0),
                            material instanceof THREE.ShaderMaterial || material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshStandardMaterial || material.envMap) {
                            var uCamPos = p_uniforms.map.cameraPosition;
                            void 0 !== uCamPos && uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld))
                        }
                        (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshStandardMaterial || material instanceof THREE.ShaderMaterial || material.skinning) && p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse),
                            p_uniforms.set(_gl, _this, "toneMappingExposure"),
                            p_uniforms.set(_gl, _this, "toneMappingWhitePoint")
                    }
                    if (material.skinning) {
                        p_uniforms.setOptional(_gl, object, "bindMatrix"),
                            p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
                        var skeleton = object.skeleton;
                        skeleton && (capabilities.floatVertexTextures && skeleton.useVertexTexture ? (p_uniforms.set(_gl, skeleton, "boneTexture"),
                            p_uniforms.set(_gl, skeleton, "boneTextureWidth"),
                            p_uniforms.set(_gl, skeleton, "boneTextureHeight")) : p_uniforms.setOptional(_gl, skeleton, "boneMatrices"))
                    }
                    refreshMaterial && (material.lights && markUniformsLightsNeedsUpdate(m_uniforms, refreshLights),
                    fog && material.fog && refreshUniformsFog(m_uniforms, fog),
                    (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshStandardMaterial || material instanceof THREE.MeshDepthMaterial) && refreshUniformsCommon(m_uniforms, material),
                        material instanceof THREE.LineBasicMaterial ? refreshUniformsLine(m_uniforms, material) : material instanceof THREE.LineDashedMaterial ? (refreshUniformsLine(m_uniforms, material),
                            refreshUniformsDash(m_uniforms, material)) : material instanceof THREE.PointsMaterial ? refreshUniformsPoints(m_uniforms, material) : material instanceof THREE.MeshLambertMaterial ? refreshUniformsLambert(m_uniforms, material) : material instanceof THREE.MeshPhongMaterial ? refreshUniformsPhong(m_uniforms, material) : material instanceof THREE.MeshPhysicalMaterial ? refreshUniformsPhysical(m_uniforms, material) : material instanceof THREE.MeshStandardMaterial ? refreshUniformsStandard(m_uniforms, material) : material instanceof THREE.MeshDepthMaterial ? material.displacementMap && (m_uniforms.displacementMap.value = material.displacementMap,
                            m_uniforms.displacementScale.value = material.displacementScale,
                            m_uniforms.displacementBias.value = material.displacementBias) : material instanceof THREE.MeshNormalMaterial && (m_uniforms.opacity.value = material.opacity),
                        THREE.WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this)),
                        p_uniforms.set(_gl, object, "modelViewMatrix"),
                        p_uniforms.set(_gl, object, "normalMatrix"),
                        p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
                    var dynUniforms = materialProperties.dynamicUniforms;
                    return null !== dynUniforms && (THREE.WebGLUniforms.evalDynamic(dynUniforms, m_uniforms, object, camera),
                        THREE.WebGLUniforms.upload(_gl, dynUniforms, m_uniforms, _this)),
                        program
                }
                function refreshUniformsCommon(uniforms, material) {
                    uniforms.opacity.value = material.opacity,
                        uniforms.diffuse.value = material.color,
                    material.emissive && uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity),
                        uniforms.map.value = material.map,
                        uniforms.specularMap.value = material.specularMap,
                        uniforms.alphaMap.value = material.alphaMap,
                    material.aoMap && (uniforms.aoMap.value = material.aoMap,
                        uniforms.aoMapIntensity.value = material.aoMapIntensity);
                    var uvScaleMap;
                    if (material.map ? uvScaleMap = material.map : material.specularMap ? uvScaleMap = material.specularMap : material.displacementMap ? uvScaleMap = material.displacementMap : material.normalMap ? uvScaleMap = material.normalMap : material.bumpMap ? uvScaleMap = material.bumpMap : material.roughnessMap ? uvScaleMap = material.roughnessMap : material.metalnessMap ? uvScaleMap = material.metalnessMap : material.alphaMap ? uvScaleMap = material.alphaMap : material.emissiveMap && (uvScaleMap = material.emissiveMap),
                        void 0 !== uvScaleMap) {
                        uvScaleMap instanceof THREE.WebGLRenderTarget && (uvScaleMap = uvScaleMap.texture);
                        var offset = uvScaleMap.offset
                            , repeat = uvScaleMap.repeat;
                        uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y)
                    }
                    uniforms.envMap.value = material.envMap,
                        uniforms.flipEnvMap.value = material.envMap instanceof THREE.CubeTexture ? -1 : 1,
                        uniforms.reflectivity.value = material.reflectivity,
                        uniforms.refractionRatio.value = material.refractionRatio
                }
                function refreshUniformsLine(uniforms, material) {
                    uniforms.diffuse.value = material.color,
                        uniforms.opacity.value = material.opacity
                }
                function refreshUniformsDash(uniforms, material) {
                    uniforms.dashSize.value = material.dashSize,
                        uniforms.totalSize.value = material.dashSize + material.gapSize,
                        uniforms.scale.value = material.scale
                }
                function refreshUniformsPoints(uniforms, material) {
                    if (uniforms.diffuse.value = material.color,
                            uniforms.opacity.value = material.opacity,
                            uniforms.size.value = material.size * _pixelRatio,
                            uniforms.scale.value = .5 * _canvas.clientHeight,
                            uniforms.map.value = material.map,
                        null !== material.map) {
                        var offset = material.map.offset
                            , repeat = material.map.repeat;
                        uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y)
                    }
                }
                function refreshUniformsFog(uniforms, fog) {
                    uniforms.fogColor.value = fog.color,
                        fog instanceof THREE.Fog ? (uniforms.fogNear.value = fog.near,
                            uniforms.fogFar.value = fog.far) : fog instanceof THREE.FogExp2 && (uniforms.fogDensity.value = fog.density)
                }
                function refreshUniformsLambert(uniforms, material) {
                    material.lightMap && (uniforms.lightMap.value = material.lightMap,
                        uniforms.lightMapIntensity.value = material.lightMapIntensity),
                    material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap)
                }
                function refreshUniformsPhong(uniforms, material) {
                    uniforms.specular.value = material.specular,
                        uniforms.shininess.value = Math.max(material.shininess, 1e-4),
                    material.lightMap && (uniforms.lightMap.value = material.lightMap,
                        uniforms.lightMapIntensity.value = material.lightMapIntensity),
                    material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap),
                    material.bumpMap && (uniforms.bumpMap.value = material.bumpMap,
                        uniforms.bumpScale.value = material.bumpScale),
                    material.normalMap && (uniforms.normalMap.value = material.normalMap,
                        uniforms.normalScale.value.copy(material.normalScale)),
                    material.displacementMap && (uniforms.displacementMap.value = material.displacementMap,
                        uniforms.displacementScale.value = material.displacementScale,
                        uniforms.displacementBias.value = material.displacementBias)
                }
                function refreshUniformsStandard(uniforms, material) {
                    uniforms.roughness.value = material.roughness,
                        uniforms.metalness.value = material.metalness,
                    material.roughnessMap && (uniforms.roughnessMap.value = material.roughnessMap),
                    material.metalnessMap && (uniforms.metalnessMap.value = material.metalnessMap),
                    material.lightMap && (uniforms.lightMap.value = material.lightMap,
                        uniforms.lightMapIntensity.value = material.lightMapIntensity),
                    material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap),
                    material.bumpMap && (uniforms.bumpMap.value = material.bumpMap,
                        uniforms.bumpScale.value = material.bumpScale),
                    material.normalMap && (uniforms.normalMap.value = material.normalMap,
                        uniforms.normalScale.value.copy(material.normalScale)),
                    material.displacementMap && (uniforms.displacementMap.value = material.displacementMap,
                        uniforms.displacementScale.value = material.displacementScale,
                        uniforms.displacementBias.value = material.displacementBias),
                    material.envMap && (uniforms.envMapIntensity.value = material.envMapIntensity)
                }
                function refreshUniformsPhysical(uniforms, material) {
                    uniforms.clearCoat.value = material.clearCoat,
                        uniforms.clearCoatRoughness.value = material.clearCoatRoughness,
                        refreshUniformsStandard(uniforms, material)
                }
                function markUniformsLightsNeedsUpdate(uniforms, value) {
                    uniforms.ambientLightColor.needsUpdate = value,
                        uniforms.directionalLights.needsUpdate = value,
                        uniforms.pointLights.needsUpdate = value,
                        uniforms.spotLights.needsUpdate = value,
                        uniforms.hemisphereLights.needsUpdate = value
                }
                function setupShadows(lights) {
                    for (var lightShadowsLength = 0, i = 0, l = lights.length; i < l; i++) {
                        var light = lights[i];
                        light.castShadow && (_lights.shadows[lightShadowsLength++] = light)
                    }
                    _lights.shadows.length = lightShadowsLength
                }
                function setupLights(lights, camera) {
                    var l, ll, light, color, intensity, distance, shadowMap, r = 0, g = 0, b = 0, viewMatrix = camera.matrixWorldInverse, directionalLength = 0, pointLength = 0, spotLength = 0, hemiLength = 0;
                    for (l = 0,
                             ll = lights.length; l < ll; l++)
                        if (light = lights[l],
                                color = light.color,
                                intensity = light.intensity,
                                distance = light.distance,
                                shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null,
                            light instanceof THREE.AmbientLight)
                            r += color.r * intensity,
                                g += color.g * intensity,
                                b += color.b * intensity;
                        else if (light instanceof THREE.DirectionalLight) {
                            var uniforms = lightCache.get(light);
                            uniforms.color.copy(light.color).multiplyScalar(light.intensity),
                                uniforms.direction.setFromMatrixPosition(light.matrixWorld),
                                _vector3.setFromMatrixPosition(light.target.matrixWorld),
                                uniforms.direction.sub(_vector3),
                                uniforms.direction.transformDirection(viewMatrix),
                                uniforms.shadow = light.castShadow,
                            light.castShadow && (uniforms.shadowBias = light.shadow.bias,
                                uniforms.shadowRadius = light.shadow.radius,
                                uniforms.shadowMapSize = light.shadow.mapSize),
                                _lights.directionalShadowMap[directionalLength] = shadowMap,
                                _lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix,
                                _lights.directional[directionalLength++] = uniforms
                        } else if (light instanceof THREE.SpotLight) {
                            var uniforms = lightCache.get(light);
                            uniforms.position.setFromMatrixPosition(light.matrixWorld),
                                uniforms.position.applyMatrix4(viewMatrix),
                                uniforms.color.copy(color).multiplyScalar(intensity),
                                uniforms.distance = distance,
                                uniforms.direction.setFromMatrixPosition(light.matrixWorld),
                                _vector3.setFromMatrixPosition(light.target.matrixWorld),
                                uniforms.direction.sub(_vector3),
                                uniforms.direction.transformDirection(viewMatrix),
                                uniforms.coneCos = Math.cos(light.angle),
                                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra)),
                                uniforms.decay = 0 === light.distance ? 0 : light.decay,
                                uniforms.shadow = light.castShadow,
                            light.castShadow && (uniforms.shadowBias = light.shadow.bias,
                                uniforms.shadowRadius = light.shadow.radius,
                                uniforms.shadowMapSize = light.shadow.mapSize),
                                _lights.spotShadowMap[spotLength] = shadowMap,
                                _lights.spotShadowMatrix[spotLength] = light.shadow.matrix,
                                _lights.spot[spotLength++] = uniforms
                        } else if (light instanceof THREE.PointLight) {
                            var uniforms = lightCache.get(light);
                            uniforms.position.setFromMatrixPosition(light.matrixWorld),
                                uniforms.position.applyMatrix4(viewMatrix),
                                uniforms.color.copy(light.color).multiplyScalar(light.intensity),
                                uniforms.distance = light.distance,
                                uniforms.decay = 0 === light.distance ? 0 : light.decay,
                                uniforms.shadow = light.castShadow,
                            light.castShadow && (uniforms.shadowBias = light.shadow.bias,
                                uniforms.shadowRadius = light.shadow.radius,
                                uniforms.shadowMapSize = light.shadow.mapSize),
                                _lights.pointShadowMap[pointLength] = shadowMap,
                            void 0 === _lights.pointShadowMatrix[pointLength] && (_lights.pointShadowMatrix[pointLength] = new THREE.Matrix4),
                                _vector3.setFromMatrixPosition(light.matrixWorld).negate(),
                                _lights.pointShadowMatrix[pointLength].identity().setPosition(_vector3),
                                _lights.point[pointLength++] = uniforms
                        } else if (light instanceof THREE.HemisphereLight) {
                            var uniforms = lightCache.get(light);
                            uniforms.direction.setFromMatrixPosition(light.matrixWorld),
                                uniforms.direction.transformDirection(viewMatrix),
                                uniforms.direction.normalize(),
                                uniforms.skyColor.copy(light.color).multiplyScalar(intensity),
                                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity),
                                _lights.hemi[hemiLength++] = uniforms
                        }
                    _lights.ambient[0] = r,
                        _lights.ambient[1] = g,
                        _lights.ambient[2] = b,
                        _lights.directional.length = directionalLength,
                        _lights.spot.length = spotLength,
                        _lights.point.length = pointLength,
                        _lights.hemi.length = hemiLength,
                        _lights.hash = directionalLength + "," + pointLength + "," + spotLength + "," + hemiLength + "," + _lights.shadows.length
                }
                function allocTextureUnit() {
                    var textureUnit = _usedTextureUnits;
                    return textureUnit >= capabilities.maxTextures && console.warn("WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures),
                        _usedTextureUnits += 1,
                        textureUnit
                }
                function paramThreeToGL(p) {
                    var extension;
                    if (p === THREE.RepeatWrapping)
                        return _gl.REPEAT;
                    if (p === THREE.ClampToEdgeWrapping)
                        return _gl.CLAMP_TO_EDGE;
                    if (p === THREE.MirroredRepeatWrapping)
                        return _gl.MIRRORED_REPEAT;
                    if (p === THREE.NearestFilter)
                        return _gl.NEAREST;
                    if (p === THREE.NearestMipMapNearestFilter)
                        return _gl.NEAREST_MIPMAP_NEAREST;
                    if (p === THREE.NearestMipMapLinearFilter)
                        return _gl.NEAREST_MIPMAP_LINEAR;
                    if (p === THREE.LinearFilter)
                        return _gl.LINEAR;
                    if (p === THREE.LinearMipMapNearestFilter)
                        return _gl.LINEAR_MIPMAP_NEAREST;
                    if (p === THREE.LinearMipMapLinearFilter)
                        return _gl.LINEAR_MIPMAP_LINEAR;
                    if (p === THREE.UnsignedByteType)
                        return _gl.UNSIGNED_BYTE;
                    if (p === THREE.UnsignedShort4444Type)
                        return _gl.UNSIGNED_SHORT_4_4_4_4;
                    if (p === THREE.UnsignedShort5551Type)
                        return _gl.UNSIGNED_SHORT_5_5_5_1;
                    if (p === THREE.UnsignedShort565Type)
                        return _gl.UNSIGNED_SHORT_5_6_5;
                    if (p === THREE.ByteType)
                        return _gl.BYTE;
                    if (p === THREE.ShortType)
                        return _gl.SHORT;
                    if (p === THREE.UnsignedShortType)
                        return _gl.UNSIGNED_SHORT;
                    if (p === THREE.IntType)
                        return _gl.INT;
                    if (p === THREE.UnsignedIntType)
                        return _gl.UNSIGNED_INT;
                    if (p === THREE.FloatType)
                        return _gl.FLOAT;
                    if (extension = extensions.get("OES_texture_half_float"),
                        null !== extension && p === THREE.HalfFloatType)
                        return extension.HALF_FLOAT_OES;
                    if (p === THREE.AlphaFormat)
                        return _gl.ALPHA;
                    if (p === THREE.RGBFormat)
                        return _gl.RGB;
                    if (p === THREE.RGBAFormat)
                        return _gl.RGBA;
                    if (p === THREE.LuminanceFormat)
                        return _gl.LUMINANCE;
                    if (p === THREE.LuminanceAlphaFormat)
                        return _gl.LUMINANCE_ALPHA;
                    if (p === THREE.DepthFormat)
                        return _gl.DEPTH_COMPONENT;
                    if (p === THREE.AddEquation)
                        return _gl.FUNC_ADD;
                    if (p === THREE.SubtractEquation)
                        return _gl.FUNC_SUBTRACT;
                    if (p === THREE.ReverseSubtractEquation)
                        return _gl.FUNC_REVERSE_SUBTRACT;
                    if (p === THREE.ZeroFactor)
                        return _gl.ZERO;
                    if (p === THREE.OneFactor)
                        return _gl.ONE;
                    if (p === THREE.SrcColorFactor)
                        return _gl.SRC_COLOR;
                    if (p === THREE.OneMinusSrcColorFactor)
                        return _gl.ONE_MINUS_SRC_COLOR;
                    if (p === THREE.SrcAlphaFactor)
                        return _gl.SRC_ALPHA;
                    if (p === THREE.OneMinusSrcAlphaFactor)
                        return _gl.ONE_MINUS_SRC_ALPHA;
                    if (p === THREE.DstAlphaFactor)
                        return _gl.DST_ALPHA;
                    if (p === THREE.OneMinusDstAlphaFactor)
                        return _gl.ONE_MINUS_DST_ALPHA;
                    if (p === THREE.DstColorFactor)
                        return _gl.DST_COLOR;
                    if (p === THREE.OneMinusDstColorFactor)
                        return _gl.ONE_MINUS_DST_COLOR;
                    if (p === THREE.SrcAlphaSaturateFactor)
                        return _gl.SRC_ALPHA_SATURATE;
                    if (extension = extensions.get("WEBGL_compressed_texture_s3tc"),
                        null !== extension) {
                        if (p === THREE.RGB_S3TC_DXT1_Format)
                            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (p === THREE.RGBA_S3TC_DXT1_Format)
                            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (p === THREE.RGBA_S3TC_DXT3_Format)
                            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (p === THREE.RGBA_S3TC_DXT5_Format)
                            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (extension = extensions.get("WEBGL_compressed_texture_pvrtc"),
                        null !== extension) {
                        if (p === THREE.RGB_PVRTC_4BPPV1_Format)
                            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (p === THREE.RGB_PVRTC_2BPPV1_Format)
                            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (p === THREE.RGBA_PVRTC_4BPPV1_Format)
                            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (p === THREE.RGBA_PVRTC_2BPPV1_Format)
                            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (extension = extensions.get("WEBGL_compressed_texture_etc1"),
                        null !== extension && p === THREE.RGB_ETC1_Format)
                        return extension.COMPRESSED_RGB_ETC1_WEBGL;
                    if (extension = extensions.get("EXT_blend_minmax"),
                        null !== extension) {
                        if (p === THREE.MinEquation)
                            return extension.MIN_EXT;
                        if (p === THREE.MaxEquation)
                            return extension.MAX_EXT
                    }
                    return 0
                }
                console.log("THREE.WebGLRenderer", THREE.REVISION),
                    parameters = parameters || {};
                var _canvas = void 0 !== parameters.canvas ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                    , _context = void 0 !== parameters.context ? parameters.context : null
                    , _alpha = void 0 !== parameters.alpha && parameters.alpha
                    , _depth = void 0 === parameters.depth || parameters.depth
                    , _stencil = void 0 === parameters.stencil || parameters.stencil
                    , _antialias = void 0 !== parameters.antialias && parameters.antialias
                    , _premultipliedAlpha = void 0 === parameters.premultipliedAlpha || parameters.premultipliedAlpha
                    , _preserveDrawingBuffer = void 0 !== parameters.preserveDrawingBuffer && parameters.preserveDrawingBuffer
                    , lights = []
                    , opaqueObjects = []
                    , opaqueObjectsLastIndex = -1
                    , transparentObjects = []
                    , transparentObjectsLastIndex = -1
                    , morphInfluences = new Float32Array(8)
                    , sprites = []
                    , lensFlares = [];
                this.domElement = _canvas,
                    this.context = null,
                    this.autoClear = !0,
                    this.autoClearColor = !0,
                    this.autoClearDepth = !0,
                    this.autoClearStencil = !0,
                    this.sortObjects = !0,
                    this.clippingPlanes = [],
                    this.localClippingEnabled = !1,
                    this.gammaFactor = 2,
                    this.gammaInput = !1,
                    this.gammaOutput = !1,
                    this.physicallyCorrectLights = !1,
                    this.toneMapping = THREE.LinearToneMapping,
                    this.toneMappingExposure = 1,
                    this.toneMappingWhitePoint = 1,
                    this.maxMorphTargets = 8,
                    this.maxMorphNormals = 4;
                var _this = this
                    , _currentProgram = null
                    , _currentRenderTarget = null
                    , _currentFramebuffer = null
                    , _currentMaterialId = -1
                    , _currentGeometryProgram = ""
                    , _currentCamera = null
                    , _currentScissor = new THREE.Vector4
                    , _currentScissorTest = null
                    , _currentViewport = new THREE.Vector4
                    , _usedTextureUnits = 0
                    , _clearColor = new THREE.Color(0)
                    , _clearAlpha = 0
                    , _width = _canvas.width
                    , _height = _canvas.height
                    , _pixelRatio = 1
                    , _scissor = new THREE.Vector4(0,0,_width,_height)
                    , _scissorTest = !1
                    , _viewport = new THREE.Vector4(0,0,_width,_height)
                    , _frustum = new THREE.Frustum
                    , _clipping = new THREE.WebGLClipping
                    , _clippingEnabled = !1
                    , _localClippingEnabled = !1
                    , _sphere = new THREE.Sphere
                    , _projScreenMatrix = new THREE.Matrix4
                    , _vector3 = new THREE.Vector3
                    , _lights = {
                    hash: "",
                    ambient: [0, 0, 0],
                    directional: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    point: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    shadows: []
                }
                    , _infoRender = {
                    calls: 0,
                    vertices: 0,
                    faces: 0,
                    points: 0
                };
                this.info = {
                    render: _infoRender,
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    programs: null
                };
                var _gl;
                try {
                    var attributes = {
                        alpha: _alpha,
                        depth: _depth,
                        stencil: _stencil,
                        antialias: _antialias,
                        premultipliedAlpha: _premultipliedAlpha,
                        preserveDrawingBuffer: _preserveDrawingBuffer
                    };
                    if (_gl = _context || _canvas.getContext("webgl", attributes) || _canvas.getContext("experimental-webgl", attributes),
                        null === _gl)
                        throw null !== _canvas.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
                    void 0 === _gl.getShaderPrecisionFormat && (_gl.getShaderPrecisionFormat = function() {
                            return {
                                rangeMin: 1,
                                rangeMax: 1,
                                precision: 1
                            }
                        }
                    ),
                        _canvas.addEventListener("webglcontextlost", onContextLost, !1)
                } catch (error) {
                    console.error("THREE.WebGLRenderer: " + error)
                }
                var extensions = new THREE.WebGLExtensions(_gl);
                extensions.get("WEBGL_depth_texture"),
                    extensions.get("OES_texture_float"),
                    extensions.get("OES_texture_float_linear"),
                    extensions.get("OES_texture_half_float"),
                    extensions.get("OES_texture_half_float_linear"),
                    extensions.get("OES_standard_derivatives"),
                    extensions.get("ANGLE_instanced_arrays"),
                extensions.get("OES_element_index_uint") && (THREE.BufferGeometry.MaxIndex = 4294967296);
                var capabilities = new THREE.WebGLCapabilities(_gl,extensions,parameters)
                    , state = new THREE.WebGLState(_gl,extensions,paramThreeToGL)
                    , properties = new THREE.WebGLProperties
                    , textures = new THREE.WebGLTextures(_gl,extensions,state,properties,capabilities,paramThreeToGL,this.info)
                    , objects = new THREE.WebGLObjects(_gl,properties,this.info)
                    , programCache = new THREE.WebGLPrograms(this,capabilities)
                    , lightCache = new THREE.WebGLLights;
                this.info.programs = programCache.programs;
                var bufferRenderer = new THREE.WebGLBufferRenderer(_gl,extensions,_infoRender)
                    , indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer(_gl,extensions,_infoRender)
                    , backgroundCamera = new THREE.OrthographicCamera(-1,1,1,-1,0,1)
                    , backgroundCamera2 = new THREE.PerspectiveCamera
                    , backgroundPlaneMesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),new THREE.MeshBasicMaterial({
                    depthTest: !1,
                    depthWrite: !1
                }))
                    , backgroundBoxShader = THREE.ShaderLib.cube
                    , backgroundBoxMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(5,5,5),new THREE.ShaderMaterial({
                    uniforms: backgroundBoxShader.uniforms,
                    vertexShader: backgroundBoxShader.vertexShader,
                    fragmentShader: backgroundBoxShader.fragmentShader,
                    depthTest: !1,
                    depthWrite: !1,
                    side: THREE.BackSide
                }));
                objects.update(backgroundPlaneMesh),
                    objects.update(backgroundBoxMesh),
                    setDefaultGLState(),
                    this.context = _gl,
                    this.capabilities = capabilities,
                    this.extensions = extensions,
                    this.properties = properties,
                    this.state = state;
                var shadowMap = new THREE.WebGLShadowMap(this,_lights,objects);
                this.shadowMap = shadowMap;
                var spritePlugin = new THREE.SpritePlugin(this,sprites)
                    , lensFlarePlugin = new THREE.LensFlarePlugin(this,lensFlares);
                this.getContext = function() {
                    return _gl
                }
                    ,
                    this.getContextAttributes = function() {
                        return _gl.getContextAttributes()
                    }
                    ,
                    this.forceContextLoss = function() {
                        extensions.get("WEBGL_lose_context").loseContext()
                    }
                    ,
                    this.getMaxAnisotropy = function() {
                        return capabilities.getMaxAnisotropy()
                    }
                    ,
                    this.getPrecision = function() {
                        return capabilities.precision
                    }
                    ,
                    this.getPixelRatio = function() {
                        return _pixelRatio
                    }
                    ,
                    this.setPixelRatio = function(value) {
                        void 0 !== value && (_pixelRatio = value,
                            this.setSize(_viewport.z, _viewport.w, !1))
                    }
                    ,
                    this.getSize = function() {
                        return {
                            width: _width,
                            height: _height
                        }
                    }
                    ,
                    this.setSize = function(width, height, updateStyle) {
                        _width = width,
                            _height = height,
                            _canvas.width = width * _pixelRatio,
                            _canvas.height = height * _pixelRatio,
                        updateStyle !== !1 && (_canvas.style.width = width + "px",
                            _canvas.style.height = height + "px"),
                            this.setViewport(0, 0, width, height)
                    }
                    ,
                    this.setViewport = function(x, y, width, height) {
                        state.viewport(_viewport.set(x, y, width, height))
                    }
                    ,
                    this.setScissor = function(x, y, width, height) {
                        state.scissor(_scissor.set(x, y, width, height))
                    }
                    ,
                    this.setScissorTest = function(boolean) {
                        state.setScissorTest(_scissorTest = boolean)
                    }
                    ,
                    this.getClearColor = function() {
                        return _clearColor
                    }
                    ,
                    this.setClearColor = function(color, alpha) {
                        _clearColor.set(color),
                            _clearAlpha = void 0 !== alpha ? alpha : 1,
                            glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha)
                    }
                    ,
                    this.getClearAlpha = function() {
                        return _clearAlpha
                    }
                    ,
                    this.setClearAlpha = function(alpha) {
                        _clearAlpha = alpha,
                            glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha)
                    }
                    ,
                    this.clear = function(color, depth, stencil) {
                        var bits = 0;
                        (void 0 === color || color) && (bits |= _gl.COLOR_BUFFER_BIT),
                        (void 0 === depth || depth) && (bits |= _gl.DEPTH_BUFFER_BIT),
                        (void 0 === stencil || stencil) && (bits |= _gl.STENCIL_BUFFER_BIT),
                            _gl.clear(bits)
                    }
                    ,
                    this.clearColor = function() {
                        this.clear(!0, !1, !1)
                    }
                    ,
                    this.clearDepth = function() {
                        this.clear(!1, !0, !1)
                    }
                    ,
                    this.clearStencil = function() {
                        this.clear(!1, !1, !0)
                    }
                    ,
                    this.clearTarget = function(renderTarget, color, depth, stencil) {
                        this.setRenderTarget(renderTarget),
                            this.clear(color, depth, stencil)
                    }
                    ,
                    this.resetGLState = resetGLState,
                    this.dispose = function() {
                        transparentObjects = [],
                            transparentObjectsLastIndex = -1,
                            opaqueObjects = [],
                            opaqueObjectsLastIndex = -1,
                            _canvas.removeEventListener("webglcontextlost", onContextLost, !1)
                    }
                    ,
                    this.renderBufferImmediate = function(object, program, material) {
                        state.initAttributes();
                        var buffers = properties.get(object);
                        object.hasPositions && !buffers.position && (buffers.position = _gl.createBuffer()),
                        object.hasNormals && !buffers.normal && (buffers.normal = _gl.createBuffer()),
                        object.hasUvs && !buffers.uv && (buffers.uv = _gl.createBuffer()),
                        object.hasColors && !buffers.color && (buffers.color = _gl.createBuffer());
                        var attributes = program.getAttributes();
                        if (object.hasPositions && (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position),
                                _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW),
                                state.enableAttribute(attributes.position),
                                _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, !1, 0, 0)),
                                object.hasNormals) {
                            if (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal),
                                "MeshPhongMaterial" !== material.type && "MeshStandardMaterial" !== material.type && "MeshPhysicalMaterial" !== material.type && material.shading === THREE.FlatShading)
                                for (var i = 0, l = 3 * object.count; i < l; i += 9) {
                                    var array = object.normalArray
                                        , nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3
                                        , ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3
                                        , nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                                    array[i + 0] = nx,
                                        array[i + 1] = ny,
                                        array[i + 2] = nz,
                                        array[i + 3] = nx,
                                        array[i + 4] = ny,
                                        array[i + 5] = nz,
                                        array[i + 6] = nx,
                                        array[i + 7] = ny,
                                        array[i + 8] = nz
                                }
                            _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW),
                                state.enableAttribute(attributes.normal),
                                _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, !1, 0, 0)
                        }
                        object.hasUvs && material.map && (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv),
                            _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW),
                            state.enableAttribute(attributes.uv),
                            _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, !1, 0, 0)),
                        object.hasColors && material.vertexColors !== THREE.NoColors && (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color),
                            _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW),
                            state.enableAttribute(attributes.color),
                            _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, !1, 0, 0)),
                            state.disableUnusedAttributes(),
                            _gl.drawArrays(_gl.TRIANGLES, 0, object.count),
                            object.count = 0
                    }
                    ,
                    this.renderBufferDirect = function(camera, fog, geometry, material, object, group) {
                        setMaterial(material);
                        var program = setProgram(camera, fog, material, object)
                            , updateBuffers = !1
                            , geometryProgram = geometry.id + "_" + program.id + "_" + material.wireframe;
                        geometryProgram !== _currentGeometryProgram && (_currentGeometryProgram = geometryProgram,
                            updateBuffers = !0);
                        var morphTargetInfluences = object.morphTargetInfluences;
                        if (void 0 !== morphTargetInfluences) {
                            for (var activeInfluences = [], i = 0, l = morphTargetInfluences.length; i < l; i++) {
                                var influence = morphTargetInfluences[i];
                                activeInfluences.push([influence, i])
                            }
                            activeInfluences.sort(absNumericalSort),
                            activeInfluences.length > 8 && (activeInfluences.length = 8);
                            for (var morphAttributes = geometry.morphAttributes, i = 0, l = activeInfluences.length; i < l; i++) {
                                var influence = activeInfluences[i];
                                if (morphInfluences[i] = influence[0],
                                    0 !== influence[0]) {
                                    var index = influence[1];
                                    material.morphTargets === !0 && morphAttributes.position && geometry.addAttribute("morphTarget" + i, morphAttributes.position[index]),
                                    material.morphNormals === !0 && morphAttributes.normal && geometry.addAttribute("morphNormal" + i, morphAttributes.normal[index])
                                } else
                                    material.morphTargets === !0 && geometry.removeAttribute("morphTarget" + i),
                                    material.morphNormals === !0 && geometry.removeAttribute("morphNormal" + i)
                            }
                            program.getUniforms().setValue(_gl, "morphTargetInfluences", morphInfluences),
                                updateBuffers = !0
                        }
                        var index = geometry.index
                            , position = geometry.attributes.position;
                        material.wireframe === !0 && (index = objects.getWireframeAttribute(geometry));
                        var renderer;
                        null !== index ? (renderer = indexedBufferRenderer,
                            renderer.setIndex(index)) : renderer = bufferRenderer,
                        updateBuffers && (setupVertexAttributes(material, program, geometry),
                        null !== index && _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer(index)));
                        var dataStart = 0
                            , dataCount = 1 / 0;
                        null !== index ? dataCount = index.count : void 0 !== position && (dataCount = position.count);
                        var rangeStart = geometry.drawRange.start
                            , rangeCount = geometry.drawRange.count
                            , groupStart = null !== group ? group.start : 0
                            , groupCount = null !== group ? group.count : 1 / 0
                            , drawStart = Math.max(dataStart, rangeStart, groupStart)
                            , drawEnd = Math.min(dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1
                            , drawCount = Math.max(0, drawEnd - drawStart + 1);
                        if (object instanceof THREE.Mesh)
                            if (material.wireframe === !0)
                                state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio()),
                                    renderer.setMode(_gl.LINES);
                            else
                                switch (object.drawMode) {
                                    case THREE.TrianglesDrawMode:
                                        renderer.setMode(_gl.TRIANGLES);
                                        break;
                                    case THREE.TriangleStripDrawMode:
                                        renderer.setMode(_gl.TRIANGLE_STRIP);
                                        break;
                                    case THREE.TriangleFanDrawMode:
                                        renderer.setMode(_gl.TRIANGLE_FAN)
                                }
                        else if (object instanceof THREE.Line) {
                            var lineWidth = material.linewidth;
                            void 0 === lineWidth && (lineWidth = 1),
                                state.setLineWidth(lineWidth * getTargetPixelRatio()),
                                object instanceof THREE.LineSegments ? renderer.setMode(_gl.LINES) : renderer.setMode(_gl.LINE_STRIP)
                        } else
                            object instanceof THREE.Points && renderer.setMode(_gl.POINTS);
                        geometry instanceof THREE.InstancedBufferGeometry ? geometry.maxInstancedCount > 0 && renderer.renderInstances(geometry, drawStart, drawCount) : renderer.render(drawStart, drawCount)
                    }
                    ,
                    this.render = function(scene, camera, renderTarget, forceClear) {
                        if (camera instanceof THREE.Camera == !1)
                            return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        var fog = scene.fog;
                        _currentGeometryProgram = "",
                            _currentMaterialId = -1,
                            _currentCamera = null,
                        scene.autoUpdate === !0 && scene.updateMatrixWorld(),
                        null === camera.parent && camera.updateMatrixWorld(),
                            camera.matrixWorldInverse.getInverse(camera.matrixWorld),
                            _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse),
                            _frustum.setFromMatrix(_projScreenMatrix),
                            lights.length = 0,
                            opaqueObjectsLastIndex = -1,
                            transparentObjectsLastIndex = -1,
                            sprites.length = 0,
                            lensFlares.length = 0,
                            _localClippingEnabled = this.localClippingEnabled,
                            _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera),
                            projectObject(scene, camera),
                            opaqueObjects.length = opaqueObjectsLastIndex + 1,
                            transparentObjects.length = transparentObjectsLastIndex + 1,
                        _this.sortObjects === !0 && (opaqueObjects.sort(painterSortStable),
                            transparentObjects.sort(reversePainterSortStable)),
                        _clippingEnabled && _clipping.beginShadows(),
                            setupShadows(lights),
                            shadowMap.render(scene, camera),
                            setupLights(lights, camera),
                        _clippingEnabled && _clipping.endShadows(),
                            _infoRender.calls = 0,
                            _infoRender.vertices = 0,
                            _infoRender.faces = 0,
                            _infoRender.points = 0,
                        void 0 === renderTarget && (renderTarget = null),
                            this.setRenderTarget(renderTarget);
                        var background = scene.background;
                        if (null === background ? glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha) : background instanceof THREE.Color && glClearColor(background.r, background.g, background.b, 1),
                            (this.autoClear || forceClear) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil),
                                background instanceof THREE.CubeTexture ? (backgroundCamera2.projectionMatrix.copy(camera.projectionMatrix),
                                    backgroundCamera2.matrixWorld.extractRotation(camera.matrixWorld),
                                    backgroundCamera2.matrixWorldInverse.getInverse(backgroundCamera2.matrixWorld),
                                    backgroundBoxMesh.material.uniforms.tCube.value = background,
                                    backgroundBoxMesh.modelViewMatrix.multiplyMatrices(backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld),
                                    _this.renderBufferDirect(backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null)) : background instanceof THREE.Texture && (backgroundPlaneMesh.material.map = background,
                                    _this.renderBufferDirect(backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null)),
                                scene.overrideMaterial) {
                            var overrideMaterial = scene.overrideMaterial;
                            renderObjects(opaqueObjects, camera, fog, overrideMaterial),
                                renderObjects(transparentObjects, camera, fog, overrideMaterial)
                        } else
                            state.setBlending(THREE.NoBlending),
                                renderObjects(opaqueObjects, camera, fog),
                                renderObjects(transparentObjects, camera, fog);
                        spritePlugin.render(scene, camera),
                            lensFlarePlugin.render(scene, camera, _currentViewport),
                        renderTarget && textures.updateRenderTargetMipmap(renderTarget),
                            state.setDepthTest(!0),
                            state.setDepthWrite(!0),
                            state.setColorWrite(!0)
                    }
                    ,
                    this.setFaceCulling = function(cullFace, frontFaceDirection) {
                        state.setCullFace(cullFace),
                            state.setFlipSided(frontFaceDirection === THREE.FrontFaceDirectionCW)
                    }
                    ,
                    this.allocTextureUnit = allocTextureUnit,
                    this.setTexture2D = function() {
                        var warned = !1;
                        return function(texture, slot) {
                            texture instanceof THREE.WebGLRenderTarget && (warned || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),
                                warned = !0),
                                texture = texture.texture),
                                textures.setTexture2D(texture, slot)
                        }
                    }(),
                    this.setTexture = function() {
                        var warned = !1;
                        return function(texture, slot) {
                            warned || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),
                                warned = !0),
                                textures.setTexture2D(texture, slot)
                        }
                    }(),
                    this.setTextureCube = function() {
                        var warned = !1;
                        return function(texture, slot) {
                            texture instanceof THREE.WebGLRenderTargetCube && (warned || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
                                warned = !0),
                                texture = texture.texture),
                                texture instanceof THREE.CubeTexture || Array.isArray(texture.image) && 6 === texture.image.length ? textures.setTextureCube(texture, slot) : textures.setTextureCubeDynamic(texture, slot)
                        }
                    }(),
                    this.getCurrentRenderTarget = function() {
                        return _currentRenderTarget
                    }
                    ,
                    this.setRenderTarget = function(renderTarget) {
                        _currentRenderTarget = renderTarget,
                        renderTarget && void 0 === properties.get(renderTarget).__webglFramebuffer && textures.setupRenderTarget(renderTarget);
                        var framebuffer, isCube = renderTarget instanceof THREE.WebGLRenderTargetCube;
                        if (renderTarget) {
                            var renderTargetProperties = properties.get(renderTarget);
                            framebuffer = isCube ? renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace] : renderTargetProperties.__webglFramebuffer,
                                _currentScissor.copy(renderTarget.scissor),
                                _currentScissorTest = renderTarget.scissorTest,
                                _currentViewport.copy(renderTarget.viewport)
                        } else
                            framebuffer = null,
                                _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio),
                                _currentScissorTest = _scissorTest,
                                _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
                        if (_currentFramebuffer !== framebuffer && (_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer),
                                _currentFramebuffer = framebuffer),
                                state.scissor(_currentScissor),
                                state.setScissorTest(_currentScissorTest),
                                state.viewport(_currentViewport),
                                isCube) {
                            var textureProperties = properties.get(renderTarget.texture);
                            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel)
                        }
                    }
                    ,
                    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
                        if (renderTarget instanceof THREE.WebGLRenderTarget == !1)
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        var framebuffer = properties.get(renderTarget).__webglFramebuffer;
                        if (framebuffer) {
                            var restore = !1;
                            framebuffer !== _currentFramebuffer && (_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer),
                                restore = !0);
                            try {
                                var texture = renderTarget.texture;
                                if (texture.format !== THREE.RGBAFormat && paramThreeToGL(texture.format) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT))
                                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (!(texture.type === THREE.UnsignedByteType || paramThreeToGL(texture.type) === _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) || texture.type === THREE.FloatType && extensions.get("WEBGL_color_buffer_float") || texture.type === THREE.HalfFloatType && extensions.get("EXT_color_buffer_half_float")))
                                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                _gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE ? x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height && _gl.readPixels(x, y, width, height, paramThreeToGL(texture.format), paramThreeToGL(texture.type), buffer) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                restore && _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer)
                            }
                        }
                    }
            }
            ,
            THREE.WebGLRenderTarget = function(width, height, options) {
                this.uuid = THREE.Math.generateUUID(),
                    this.width = width,
                    this.height = height,
                    this.scissor = new THREE.Vector4(0,0,width,height),
                    this.scissorTest = !1,
                    this.viewport = new THREE.Vector4(0,0,width,height),
                    options = options || {},
                void 0 === options.minFilter && (options.minFilter = THREE.LinearFilter),
                    this.texture = new THREE.Texture(void 0,void 0,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding),
                    this.depthBuffer = void 0 === options.depthBuffer || options.depthBuffer,
                    this.stencilBuffer = void 0 === options.stencilBuffer || options.stencilBuffer,
                    this.depthTexture = null
            }
            ,
            Object.assign(THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {
                setSize: function(width, height) {
                    this.width === width && this.height === height || (this.width = width,
                        this.height = height,
                        this.dispose()),
                        this.viewport.set(0, 0, width, height),
                        this.scissor.set(0, 0, width, height)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(source) {
                    return this.width = source.width,
                        this.height = source.height,
                        this.viewport.copy(source.viewport),
                        this.texture = source.texture.clone(),
                        this.depthBuffer = source.depthBuffer,
                        this.stencilBuffer = source.stencilBuffer,
                        this.depthTexture = source.depthTexture,
                        this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }),
            THREE.WebGLRenderTargetCube = function(width, height, options) {
                THREE.WebGLRenderTarget.call(this, width, height, options),
                    this.activeCubeFace = 0,
                    this.activeMipMapLevel = 0
            }
            ,
            THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype),
            THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube,
            THREE.WebGLBufferRenderer = function(_gl, extensions, _infoRender) {
                function setMode(value) {
                    mode = value
                }
                function render(start, count) {
                    _gl.drawArrays(mode, start, count),
                        _infoRender.calls++,
                        _infoRender.vertices += count,
                    mode === _gl.TRIANGLES && (_infoRender.faces += count / 3)
                }
                function renderInstances(geometry) {
                    var extension = extensions.get("ANGLE_instanced_arrays");
                    if (null === extension)
                        return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    var position = geometry.attributes.position
                        , count = 0;
                    position instanceof THREE.InterleavedBufferAttribute ? (count = position.data.count,
                        extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount)) : (count = position.count,
                        extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount)),
                        _infoRender.calls++,
                        _infoRender.vertices += count * geometry.maxInstancedCount,
                    mode === _gl.TRIANGLES && (_infoRender.faces += geometry.maxInstancedCount * count / 3)
                }
                var mode;
                this.setMode = setMode,
                    this.render = render,
                    this.renderInstances = renderInstances
            }
            ,
            THREE.WebGLClipping = function() {
                function resetGlobalState() {
                    uniform.value !== globalState && (uniform.value = globalState,
                        uniform.needsUpdate = numGlobalPlanes > 0),
                        scope.numPlanes = numGlobalPlanes
                }
                function projectPlanes(planes, camera, dstOffset, skipTransform) {
                    var nPlanes = null !== planes ? planes.length : 0
                        , dstArray = null;
                    if (0 !== nPlanes) {
                        if (dstArray = uniform.value,
                            skipTransform !== !0 || null === dstArray) {
                            var flatSize = dstOffset + 4 * nPlanes
                                , viewMatrix = camera.matrixWorldInverse;
                            viewNormalMatrix.getNormalMatrix(viewMatrix),
                            (null === dstArray || dstArray.length < flatSize) && (dstArray = new Float32Array(flatSize));
                            for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i,
                                i4 += 4)
                                plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix),
                                    plane.normal.toArray(dstArray, i4),
                                    dstArray[i4 + 3] = plane.constant
                        }
                        uniform.value = dstArray,
                            uniform.needsUpdate = !0
                    }
                    return scope.numPlanes = nPlanes,
                        dstArray
                }
                var scope = this
                    , globalState = null
                    , numGlobalPlanes = 0
                    , localClippingEnabled = !1
                    , renderingShadows = !1
                    , plane = new THREE.Plane
                    , viewNormalMatrix = new THREE.Matrix3
                    , uniform = {
                    value: null,
                    needsUpdate: !1
                };
                this.uniform = uniform,
                    this.numPlanes = 0,
                    this.init = function(planes, enableLocalClipping, camera) {
                        var enabled = 0 !== planes.length || enableLocalClipping || 0 !== numGlobalPlanes || localClippingEnabled;
                        return localClippingEnabled = enableLocalClipping,
                            globalState = projectPlanes(planes, camera, 0),
                            numGlobalPlanes = planes.length,
                            enabled
                    }
                    ,
                    this.beginShadows = function() {
                        renderingShadows = !0,
                            projectPlanes(null)
                    }
                    ,
                    this.endShadows = function() {
                        renderingShadows = !1,
                            resetGlobalState()
                    }
                    ,
                    this.setState = function(planes, clipShadows, camera, cache, fromCache) {
                        if (!localClippingEnabled || null === planes || 0 === planes.length || renderingShadows && !clipShadows)
                            renderingShadows ? projectPlanes(null) : resetGlobalState();
                        else {
                            var nGlobal = renderingShadows ? 0 : numGlobalPlanes
                                , lGlobal = 4 * nGlobal
                                , dstArray = cache.clippingState || null;
                            uniform.value = dstArray,
                                dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
                            for (var i = 0; i !== lGlobal; ++i)
                                dstArray[i] = globalState[i];
                            cache.clippingState = dstArray,
                                this.numPlanes += nGlobal
                        }
                    }
            }
            ,
            THREE.WebGLIndexedBufferRenderer = function(_gl, extensions, _infoRender) {
                function setMode(value) {
                    mode = value
                }
                function setIndex(index) {
                    index.array instanceof Uint32Array && extensions.get("OES_element_index_uint") ? (type = _gl.UNSIGNED_INT,
                        size = 4) : (type = _gl.UNSIGNED_SHORT,
                        size = 2)
                }
                function render(start, count) {
                    _gl.drawElements(mode, count, type, start * size),
                        _infoRender.calls++,
                        _infoRender.vertices += count,
                    mode === _gl.TRIANGLES && (_infoRender.faces += count / 3)
                }
                function renderInstances(geometry, start, count) {
                    var extension = extensions.get("ANGLE_instanced_arrays");
                    return null === extension ? void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (extension.drawElementsInstancedANGLE(mode, count, type, start * size, geometry.maxInstancedCount),
                        _infoRender.calls++,
                        _infoRender.vertices += count * geometry.maxInstancedCount,
                        void (mode === _gl.TRIANGLES && (_infoRender.faces += geometry.maxInstancedCount * count / 3)))
                }
                var mode, type, size;
                this.setMode = setMode,
                    this.setIndex = setIndex,
                    this.render = render,
                    this.renderInstances = renderInstances
            }
            ,
            THREE.WebGLExtensions = function(gl) {
                var extensions = {};
                this.get = function(name) {
                    if (void 0 !== extensions[name])
                        return extensions[name];
                    var extension;
                    switch (name) {
                        case "WEBGL_depth_texture":
                            extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        case "WEBGL_compressed_texture_etc1":
                            extension = gl.getExtension("WEBGL_compressed_texture_etc1");
                            break;
                        default:
                            extension = gl.getExtension(name)
                    }
                    return null === extension && console.warn("THREE.WebGLRenderer: " + name + " extension not supported."),
                        extensions[name] = extension,
                        extension
                }
            }
            ,
            THREE.WebGLCapabilities = function(gl, extensions, parameters) {
                function getMaxAnisotropy() {
                    if (void 0 !== maxAnisotropy)
                        return maxAnisotropy;
                    var extension = extensions.get("EXT_texture_filter_anisotropic");
                    return maxAnisotropy = null !== extension ? gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                }
                function getMaxPrecision(precision) {
                    if ("highp" === precision) {
                        if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0)
                            return "highp";
                        precision = "mediump"
                    }
                    return "mediump" === precision && gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                }
                var maxAnisotropy;
                this.getMaxAnisotropy = getMaxAnisotropy,
                    this.getMaxPrecision = getMaxPrecision,
                    this.precision = void 0 !== parameters.precision ? parameters.precision : "highp",
                    this.logarithmicDepthBuffer = void 0 !== parameters.logarithmicDepthBuffer && parameters.logarithmicDepthBuffer,
                    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
                    this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                    this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE),
                    this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE),
                    this.maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
                    this.maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
                    this.maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS),
                    this.maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),
                    this.vertexTextures = this.maxVertexTextures > 0,
                    this.floatFragmentTextures = !!extensions.get("OES_texture_float"),
                    this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
                var _maxPrecision = getMaxPrecision(this.precision);
                _maxPrecision !== this.precision && (console.warn("THREE.WebGLRenderer:", this.precision, "not supported, using", _maxPrecision, "instead."),
                    this.precision = _maxPrecision),
                this.logarithmicDepthBuffer && (this.logarithmicDepthBuffer = !!extensions.get("EXT_frag_depth"))
            }
            ,
            THREE.WebGLGeometries = function(gl, properties, info) {
                function get(object) {
                    var geometry = object.geometry;
                    if (void 0 !== geometries[geometry.id])
                        return geometries[geometry.id];
                    geometry.addEventListener("dispose", onGeometryDispose);
                    var buffergeometry;
                    return geometry instanceof THREE.BufferGeometry ? buffergeometry = geometry : geometry instanceof THREE.Geometry && (void 0 === geometry._bufferGeometry && (geometry._bufferGeometry = (new THREE.BufferGeometry).setFromObject(object)),
                        buffergeometry = geometry._bufferGeometry),
                        geometries[geometry.id] = buffergeometry,
                        info.memory.geometries++,
                        buffergeometry
                }
                function onGeometryDispose(event) {
                    var geometry = event.target
                        , buffergeometry = geometries[geometry.id];
                    null !== buffergeometry.index && deleteAttribute(buffergeometry.index),
                        deleteAttributes(buffergeometry.attributes),
                        geometry.removeEventListener("dispose", onGeometryDispose),
                        delete geometries[geometry.id];
                    var property = properties.get(geometry);
                    property.wireframe && deleteAttribute(property.wireframe),
                        properties.delete(geometry);
                    var bufferproperty = properties.get(buffergeometry);
                    bufferproperty.wireframe && deleteAttribute(bufferproperty.wireframe),
                        properties.delete(buffergeometry),
                        info.memory.geometries--
                }
                function getAttributeBuffer(attribute) {
                    return attribute instanceof THREE.InterleavedBufferAttribute ? properties.get(attribute.data).__webglBuffer : properties.get(attribute).__webglBuffer
                }
                function deleteAttribute(attribute) {
                    var buffer = getAttributeBuffer(attribute);
                    void 0 !== buffer && (gl.deleteBuffer(buffer),
                        removeAttributeBuffer(attribute))
                }
                function deleteAttributes(attributes) {
                    for (var name in attributes)
                        deleteAttribute(attributes[name])
                }
                function removeAttributeBuffer(attribute) {
                    attribute instanceof THREE.InterleavedBufferAttribute ? properties.delete(attribute.data) : properties.delete(attribute)
                }
                var geometries = {};
                this.get = get
            }
            ,
            THREE.WebGLLights = function() {
                var lights = {};
                this.get = function(light) {
                    if (void 0 !== lights[light.id])
                        return lights[light.id];
                    var uniforms;
                    switch (light.type) {
                        case "DirectionalLight":
                            uniforms = {
                                direction: new THREE.Vector3,
                                color: new THREE.Color,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new THREE.Vector2
                            };
                            break;
                        case "SpotLight":
                            uniforms = {
                                position: new THREE.Vector3,
                                direction: new THREE.Vector3,
                                color: new THREE.Color,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new THREE.Vector2
                            };
                            break;
                        case "PointLight":
                            uniforms = {
                                position: new THREE.Vector3,
                                color: new THREE.Color,
                                distance: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new THREE.Vector2
                            };
                            break;
                        case "HemisphereLight":
                            uniforms = {
                                direction: new THREE.Vector3,
                                skyColor: new THREE.Color,
                                groundColor: new THREE.Color
                            }
                    }
                    return lights[light.id] = uniforms,
                        uniforms
                }
            }
            ,
            THREE.WebGLObjects = function(gl, properties, info) {
                function update(object) {
                    var geometry = geometries.get(object);
                    object.geometry instanceof THREE.Geometry && geometry.updateFromObject(object);
                    var index = geometry.index
                        , attributes = geometry.attributes;
                    null !== index && updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);
                    for (var name in attributes)
                        updateAttribute(attributes[name], gl.ARRAY_BUFFER);
                    var morphAttributes = geometry.morphAttributes;
                    for (var name in morphAttributes)
                        for (var array = morphAttributes[name], i = 0, l = array.length; i < l; i++)
                            updateAttribute(array[i], gl.ARRAY_BUFFER);
                    return geometry
                }
                function updateAttribute(attribute, bufferType) {
                    var data = attribute instanceof THREE.InterleavedBufferAttribute ? attribute.data : attribute
                        , attributeProperties = properties.get(data);
                    void 0 === attributeProperties.__webglBuffer ? createBuffer(attributeProperties, data, bufferType) : attributeProperties.version !== data.version && updateBuffer(attributeProperties, data, bufferType)
                }
                function createBuffer(attributeProperties, data, bufferType) {
                    attributeProperties.__webglBuffer = gl.createBuffer(),
                        gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
                    var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                    gl.bufferData(bufferType, data.array, usage),
                        attributeProperties.version = data.version
                }
                function updateBuffer(attributeProperties, data, bufferType) {
                    gl.bindBuffer(bufferType, attributeProperties.__webglBuffer),
                        data.dynamic === !1 || data.updateRange.count === -1 ? gl.bufferSubData(bufferType, 0, data.array) : 0 === data.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT, data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count)),
                            data.updateRange.count = 0),
                        attributeProperties.version = data.version
                }
                function getAttributeBuffer(attribute) {
                    return attribute instanceof THREE.InterleavedBufferAttribute ? properties.get(attribute.data).__webglBuffer : properties.get(attribute).__webglBuffer
                }
                function getWireframeAttribute(geometry) {
                    var property = properties.get(geometry);
                    if (void 0 !== property.wireframe)
                        return property.wireframe;
                    var indices = []
                        , index = geometry.index
                        , attributes = geometry.attributes
                        , position = attributes.position;
                    if (null !== index)
                        for (var edges = {}, array = index.array, i = 0, l = array.length; i < l; i += 3) {
                            var a = array[i + 0]
                                , b = array[i + 1]
                                , c = array[i + 2];
                            checkEdge(edges, a, b) && indices.push(a, b),
                            checkEdge(edges, b, c) && indices.push(b, c),
                            checkEdge(edges, c, a) && indices.push(c, a)
                        }
                    else
                        for (var array = attributes.position.array, i = 0, l = array.length / 3 - 1; i < l; i += 3) {
                            var a = i + 0
                                , b = i + 1
                                , c = i + 2;
                            indices.push(a, b, b, c, c, a)
                        }
                    var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array
                        , attribute = new THREE.BufferAttribute(new TypeArray(indices),1);
                    return updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER),
                        property.wireframe = attribute,
                        attribute
                }
                function checkEdge(edges, a, b) {
                    if (a > b) {
                        var tmp = a;
                        a = b,
                            b = tmp
                    }
                    var list = edges[a];
                    return void 0 === list ? (edges[a] = [b],
                        !0) : list.indexOf(b) === -1 && (list.push(b),
                        !0)
                }
                var geometries = new THREE.WebGLGeometries(gl,properties,info);
                this.getAttributeBuffer = getAttributeBuffer,
                    this.getWireframeAttribute = getWireframeAttribute,
                    this.update = update
            }
            ,
            THREE.WebGLProgram = function() {
                function getEncodingComponents(encoding) {
                    switch (encoding) {
                        case THREE.LinearEncoding:
                            return ["Linear", "( value )"];
                        case THREE.sRGBEncoding:
                            return ["sRGB", "( value )"];
                        case THREE.RGBEEncoding:
                            return ["RGBE", "( value )"];
                        case THREE.RGBM7Encoding:
                            return ["RGBM", "( value, 7.0 )"];
                        case THREE.RGBM16Encoding:
                            return ["RGBM", "( value, 16.0 )"];
                        case THREE.RGBDEncoding:
                            return ["RGBD", "( value, 256.0 )"];
                        case THREE.GammaEncoding:
                            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                        default:
                            throw new Error("unsupported encoding: " + encoding)
                    }
                }
                function getTexelDecodingFunction(functionName, encoding) {
                    var components = getEncodingComponents(encoding);
                    return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
                }
                function getTexelEncodingFunction(functionName, encoding) {
                    var components = getEncodingComponents(encoding);
                    return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }"
                }
                function getToneMappingFunction(functionName, toneMapping) {
                    var toneMappingName;
                    switch (toneMapping) {
                        case THREE.LinearToneMapping:
                            toneMappingName = "Linear";
                            break;
                        case THREE.ReinhardToneMapping:
                            toneMappingName = "Reinhard";
                            break;
                        case THREE.Uncharted2ToneMapping:
                            toneMappingName = "Uncharted2";
                            break;
                        case THREE.CineonToneMapping:
                            toneMappingName = "OptimizedCineon";
                            break;
                        default:
                            throw new Error("unsupported toneMapping: " + toneMapping)
                    }
                    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }"
                }
                function generateExtensions(extensions, parameters, rendererExtensions) {
                    extensions = extensions || {};
                    var chunks = [extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", extensions.drawBuffers && rendererExtensions.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
                    return chunks.filter(filterEmptyLine).join("\n")
                }
                function generateDefines(defines) {
                    var chunks = [];
                    for (var name in defines) {
                        var value = defines[name];
                        value !== !1 && chunks.push("#define " + name + " " + value)
                    }
                    return chunks.join("\n")
                }
                function fetchAttributeLocations(gl, program, identifiers) {
                    for (var attributes = {}, n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES), i = 0; i < n; i++) {
                        var info = gl.getActiveAttrib(program, i)
                            , name = info.name;
                        attributes[name] = gl.getAttribLocation(program, name)
                    }
                    return attributes
                }
                function filterEmptyLine(string) {
                    return "" !== string
                }
                function replaceLightNums(string, parameters) {
                    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights)
                }
                function parseIncludes(string) {
                    function replace(match, include) {
                        var replace = THREE.ShaderChunk[include];
                        if (void 0 === replace)
                            throw new Error("Can not resolve #include <" + include + ">");
                        return parseIncludes(replace)
                    }
                    var pattern = /#include +<([\w\d.]+)>/g;
                    return string.replace(pattern, replace)
                }
                function unrollLoops(string) {
                    function replace(match, start, end, snippet) {
                        for (var unroll = "", i = parseInt(start); i < parseInt(end); i++)
                            unroll += snippet.replace(/\[ i \]/g, "[ " + i + " ]");
                        return unroll
                    }
                    var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
                    return string.replace(pattern, replace)
                }
                var programIdCount = 0;
                return function(renderer, code, material, parameters) {
                    var gl = renderer.context
                        , extensions = material.extensions
                        , defines = material.defines
                        , vertexShader = material.__webglShader.vertexShader
                        , fragmentShader = material.__webglShader.fragmentShader
                        , shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
                    parameters.shadowMapType === THREE.PCFShadowMap ? shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF" : parameters.shadowMapType === THREE.PCFSoftShadowMap && (shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT");
                    var envMapTypeDefine = "ENVMAP_TYPE_CUBE"
                        , envMapModeDefine = "ENVMAP_MODE_REFLECTION"
                        , envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
                    if (parameters.envMap) {
                        switch (material.envMap.mapping) {
                            case THREE.CubeReflectionMapping:
                            case THREE.CubeRefractionMapping:
                                envMapTypeDefine = "ENVMAP_TYPE_CUBE";
                                break;
                            case THREE.CubeUVReflectionMapping:
                            case THREE.CubeUVRefractionMapping:
                                envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
                                break;
                            case THREE.EquirectangularReflectionMapping:
                            case THREE.EquirectangularRefractionMapping:
                                envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
                                break;
                            case THREE.SphericalReflectionMapping:
                                envMapTypeDefine = "ENVMAP_TYPE_SPHERE"
                        }
                        switch (material.envMap.mapping) {
                            case THREE.CubeRefractionMapping:
                            case THREE.EquirectangularRefractionMapping:
                                envMapModeDefine = "ENVMAP_MODE_REFRACTION"
                        }
                        switch (material.combine) {
                            case THREE.MultiplyOperation:
                                envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case THREE.MixOperation:
                                envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
                                break;
                            case THREE.AddOperation:
                                envMapBlendingDefine = "ENVMAP_BLENDING_ADD"
                        }
                    }
                    var prefixVertex, prefixFragment, gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1, customExtensions = generateExtensions(extensions, parameters, renderer.extensions), customDefines = generateDefines(defines), program = gl.createProgram();
                    material instanceof THREE.RawShaderMaterial ? (prefixVertex = [customDefines].filter(filterEmptyLine).join("\n"),
                        prefixFragment = [customDefines].filter(filterEmptyLine).join("\n")) : (prefixVertex = ["precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", "#define SHADER_NAME " + material.__webglShader.name, customDefines, parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + gammaFactorDefine, "#define MAX_BONES " + parameters.maxBones, parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && parameters.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes, parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && renderer.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine).join("\n"),
                        prefixFragment = [customExtensions, "precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", "#define SHADER_NAME " + material.__webglShader.name, customDefines, parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest : "", "#define GAMMA_FACTOR " + gammaFactorDefine, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapTypeDefine : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.envMap ? "#define " + envMapBlendingDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes, parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && renderer.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", parameters.envMap && renderer.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", parameters.toneMapping !== THREE.NoToneMapping ? "#define TONE_MAPPING" : "", parameters.toneMapping !== THREE.NoToneMapping ? THREE.ShaderChunk.tonemapping_pars_fragment : "", parameters.toneMapping !== THREE.NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "", parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? THREE.ShaderChunk.encodings_pars_fragment : "", parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "", parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "", parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "", parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "", parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : "", "\n"].filter(filterEmptyLine).join("\n")),
                        vertexShader = parseIncludes(vertexShader, parameters),
                        vertexShader = replaceLightNums(vertexShader, parameters),
                        fragmentShader = parseIncludes(fragmentShader, parameters),
                        fragmentShader = replaceLightNums(fragmentShader, parameters),
                    material instanceof THREE.ShaderMaterial == !1 && (vertexShader = unrollLoops(vertexShader),
                        fragmentShader = unrollLoops(fragmentShader));
                    var vertexGlsl = prefixVertex + vertexShader
                        , fragmentGlsl = prefixFragment + fragmentShader
                        , glVertexShader = THREE.WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl)
                        , glFragmentShader = THREE.WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
                    gl.attachShader(program, glVertexShader),
                        gl.attachShader(program, glFragmentShader),
                        void 0 !== material.index0AttributeName ? gl.bindAttribLocation(program, 0, material.index0AttributeName) : parameters.morphTargets === !0 && gl.bindAttribLocation(program, 0, "position"),
                        gl.linkProgram(program);
                    var programLog = gl.getProgramInfoLog(program)
                        , vertexLog = gl.getShaderInfoLog(glVertexShader)
                        , fragmentLog = gl.getShaderInfoLog(glFragmentShader)
                        , runnable = !0
                        , haveDiagnostics = !0;
                    gl.getProgramParameter(program, gl.LINK_STATUS) === !1 ? (runnable = !1,
                        console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS), "gl.getProgramInfoLog", programLog, vertexLog, fragmentLog)) : "" !== programLog ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog) : "" !== vertexLog && "" !== fragmentLog || (haveDiagnostics = !1),
                    haveDiagnostics && (this.diagnostics = {
                        runnable: runnable,
                        material: material,
                        programLog: programLog,
                        vertexShader: {
                            log: vertexLog,
                            prefix: prefixVertex
                        },
                        fragmentShader: {
                            log: fragmentLog,
                            prefix: prefixFragment
                        }
                    }),
                        gl.deleteShader(glVertexShader),
                        gl.deleteShader(glFragmentShader);
                    var cachedUniforms;
                    this.getUniforms = function() {
                        return void 0 === cachedUniforms && (cachedUniforms = new THREE.WebGLUniforms(gl,program,renderer)),
                            cachedUniforms
                    }
                    ;
                    var cachedAttributes;
                    return this.getAttributes = function() {
                        return void 0 === cachedAttributes && (cachedAttributes = fetchAttributeLocations(gl, program)),
                            cachedAttributes
                    }
                        ,
                        this.destroy = function() {
                            gl.deleteProgram(program),
                                this.program = void 0
                        }
                        ,
                        Object.defineProperties(this, {
                            uniforms: {
                                get: function() {
                                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."),
                                        this.getUniforms()
                                }
                            },
                            attributes: {
                                get: function() {
                                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),
                                        this.getAttributes()
                                }
                            }
                        }),
                        this.id = programIdCount++,
                        this.code = code,
                        this.usedTimes = 1,
                        this.program = program,
                        this.vertexShader = glVertexShader,
                        this.fragmentShader = glFragmentShader,
                        this
                }
            }(),
            THREE.WebGLPrograms = function(renderer, capabilities) {
                function allocateBones(object) {
                    if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture)
                        return 1024;
                    var nVertexUniforms = capabilities.maxVertexUniforms
                        , nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4)
                        , maxBones = nVertexMatrices;
                    return void 0 !== object && object instanceof THREE.SkinnedMesh && (maxBones = Math.min(object.skeleton.bones.length, maxBones),
                    maxBones < object.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + object.skeleton.bones.length + ", this GPU supports just " + maxBones + " (try OpenGL instead of ANGLE)")),
                        maxBones
                }
                function getTextureEncodingFromMap(map, gammaOverrideLinear) {
                    var encoding;
                    return map ? map instanceof THREE.Texture ? encoding = map.encoding : map instanceof THREE.WebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
                        encoding = map.texture.encoding) : encoding = THREE.LinearEncoding,
                    encoding === THREE.LinearEncoding && gammaOverrideLinear && (encoding = THREE.GammaEncoding),
                        encoding
                }
                var programs = []
                    , shaderIDs = {
                    MeshDepthMaterial: "depth",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points"
                }
                    , parameterNames = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"];
                this.getParameters = function(material, lights, fog, nClipPlanes, object) {
                    var shaderID = shaderIDs[material.type]
                        , maxBones = allocateBones(object)
                        , precision = renderer.getPrecision();
                    null !== material.precision && (precision = capabilities.getMaxPrecision(material.precision),
                    precision !== material.precision && console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead."));
                    var currentRenderTarget = renderer.getCurrentRenderTarget()
                        , parameters = {
                        shaderID: shaderID,
                        precision: precision,
                        supportsVertexTextures: capabilities.vertexTextures,
                        outputEncoding: getTextureEncodingFromMap(currentRenderTarget ? currentRenderTarget.texture : null, renderer.gammaOutput),
                        map: !!material.map,
                        mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
                        envMap: !!material.envMap,
                        envMapMode: material.envMap && material.envMap.mapping,
                        envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
                        envMapCubeUV: !!material.envMap && (material.envMap.mapping === THREE.CubeUVReflectionMapping || material.envMap.mapping === THREE.CubeUVRefractionMapping),
                        lightMap: !!material.lightMap,
                        aoMap: !!material.aoMap,
                        emissiveMap: !!material.emissiveMap,
                        emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
                        bumpMap: !!material.bumpMap,
                        normalMap: !!material.normalMap,
                        displacementMap: !!material.displacementMap,
                        roughnessMap: !!material.roughnessMap,
                        metalnessMap: !!material.metalnessMap,
                        specularMap: !!material.specularMap,
                        alphaMap: !!material.alphaMap,
                        combine: material.combine,
                        vertexColors: material.vertexColors,
                        fog: fog,
                        useFog: material.fog,
                        fogExp: fog instanceof THREE.FogExp2,
                        flatShading: material.shading === THREE.FlatShading,
                        sizeAttenuation: material.sizeAttenuation,
                        logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
                        skinning: material.skinning,
                        maxBones: maxBones,
                        useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
                        morphTargets: material.morphTargets,
                        morphNormals: material.morphNormals,
                        maxMorphTargets: renderer.maxMorphTargets,
                        maxMorphNormals: renderer.maxMorphNormals,
                        numDirLights: lights.directional.length,
                        numPointLights: lights.point.length,
                        numSpotLights: lights.spot.length,
                        numHemiLights: lights.hemi.length,
                        numClippingPlanes: nClipPlanes,
                        shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
                        shadowMapType: renderer.shadowMap.type,
                        toneMapping: renderer.toneMapping,
                        physicallyCorrectLights: renderer.physicallyCorrectLights,
                        premultipliedAlpha: material.premultipliedAlpha,
                        alphaTest: material.alphaTest,
                        doubleSided: material.side === THREE.DoubleSide,
                        flipSided: material.side === THREE.BackSide,
                        depthPacking: void 0 !== material.depthPacking && material.depthPacking
                    };
                    return parameters
                }
                    ,
                    this.getProgramCode = function(material, parameters) {
                        var array = [];
                        if (parameters.shaderID ? array.push(parameters.shaderID) : (array.push(material.fragmentShader),
                                array.push(material.vertexShader)),
                            void 0 !== material.defines)
                            for (var name in material.defines)
                                array.push(name),
                                    array.push(material.defines[name]);
                        for (var i = 0; i < parameterNames.length; i++)
                            array.push(parameters[parameterNames[i]]);
                        return array.join()
                    }
                    ,
                    this.acquireProgram = function(material, parameters, code) {
                        for (var program, p = 0, pl = programs.length; p < pl; p++) {
                            var programInfo = programs[p];
                            if (programInfo.code === code) {
                                program = programInfo,
                                    ++program.usedTimes;
                                break
                            }
                        }
                        return void 0 === program && (program = new THREE.WebGLProgram(renderer,code,material,parameters),
                            programs.push(program)),
                            program
                    }
                    ,
                    this.releaseProgram = function(program) {
                        if (0 === --program.usedTimes) {
                            var i = programs.indexOf(program);
                            programs[i] = programs[programs.length - 1],
                                programs.pop(),
                                program.destroy()
                        }
                    }
                    ,
                    this.programs = programs
            }
            ,
            THREE.WebGLProperties = function() {
                var properties = {};
                this.get = function(object) {
                    var uuid = object.uuid
                        , map = properties[uuid];
                    return void 0 === map && (map = {},
                        properties[uuid] = map),
                        map
                }
                    ,
                    this.delete = function(object) {
                        delete properties[object.uuid]
                    }
                    ,
                    this.clear = function() {
                        properties = {}
                    }
            }
            ,
            THREE.WebGLShader = function() {
                function addLineNumbers(string) {
                    for (var lines = string.split("\n"), i = 0; i < lines.length; i++)
                        lines[i] = i + 1 + ": " + lines[i];
                    return lines.join("\n")
                }
                return function(gl, type, string) {
                    var shader = gl.createShader(type);
                    return gl.shaderSource(shader, string),
                        gl.compileShader(shader),
                    gl.getShaderParameter(shader, gl.COMPILE_STATUS) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."),
                    "" !== gl.getShaderInfoLog(shader) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", type === gl.VERTEX_SHADER ? "vertex" : "fragment", gl.getShaderInfoLog(shader), addLineNumbers(string)),
                        shader
                }
            }(),
            THREE.WebGLShadowMap = function(_renderer, _lights, _objects) {
                function getDepthMaterial(object, material, isPointLight, lightPositionWorld) {
                    var geometry = object.geometry
                        , result = null
                        , materialVariants = _depthMaterials
                        , customMaterial = object.customDepthMaterial;
                    if (isPointLight && (materialVariants = _distanceMaterials,
                            customMaterial = object.customDistanceMaterial),
                            customMaterial)
                        result = customMaterial;
                    else {
                        var useMorphing = void 0 !== geometry.morphTargets && geometry.morphTargets.length > 0 && material.morphTargets
                            , useSkinning = object instanceof THREE.SkinnedMesh && material.skinning
                            , variantIndex = 0;
                        useMorphing && (variantIndex |= _MorphingFlag),
                        useSkinning && (variantIndex |= _SkinningFlag),
                            result = materialVariants[variantIndex]
                    }
                    if (_renderer.localClippingEnabled && material.clipShadows === !0 && 0 !== material.clippingPlanes.length) {
                        var keyA = result.uuid
                            , keyB = material.uuid
                            , materialsForVariant = _materialCache[keyA];
                        void 0 === materialsForVariant && (materialsForVariant = {},
                            _materialCache[keyA] = materialsForVariant);
                        var cachedMaterial = materialsForVariant[keyB];
                        void 0 === cachedMaterial && (cachedMaterial = result.clone(),
                            materialsForVariant[keyB] = cachedMaterial),
                            result = cachedMaterial
                    }
                    result.visible = material.visible,
                        result.wireframe = material.wireframe;
                    var side = material.side;
                    return scope.renderSingleSided && side == THREE.DoubleSide && (side = THREE.FrontSide),
                    scope.renderReverseSided && (side === THREE.FrontSide ? side = THREE.BackSide : side === THREE.BackSide && (side = THREE.FrontSide)),
                        result.side = side,
                        result.clipShadows = material.clipShadows,
                        result.clippingPlanes = material.clippingPlanes,
                        result.wireframeLinewidth = material.wireframeLinewidth,
                        result.linewidth = material.linewidth,
                    isPointLight && void 0 !== result.uniforms.lightPos && result.uniforms.lightPos.value.copy(lightPositionWorld),
                        result
                }
                function projectObject(object, camera, shadowCamera) {
                    if (object.visible !== !1) {
                        if (object.layers.test(camera.layers) && (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) && object.castShadow && (object.frustumCulled === !1 || _frustum.intersectsObject(object) === !0)) {
                            var material = object.material;
                            material.visible === !0 && (object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld),
                                _renderList.push(object))
                        }
                        for (var children = object.children, i = 0, l = children.length; i < l; i++)
                            projectObject(children[i], camera, shadowCamera)
                    }
                }
                var _gl = _renderer.context
                    , _state = _renderer.state
                    , _frustum = new THREE.Frustum
                    , _projScreenMatrix = new THREE.Matrix4
                    , _lightShadows = _lights.shadows
                    , _shadowMapSize = new THREE.Vector2
                    , _lookTarget = new THREE.Vector3
                    , _lightPositionWorld = new THREE.Vector3
                    , _renderList = []
                    , _MorphingFlag = 1
                    , _SkinningFlag = 2
                    , _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1
                    , _depthMaterials = new Array(_NumberOfMaterialVariants)
                    , _distanceMaterials = new Array(_NumberOfMaterialVariants)
                    , _materialCache = {}
                    , cubeDirections = [new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0), new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1), new THREE.Vector3(0,1,0), new THREE.Vector3(0,-1,0)]
                    , cubeUps = [new THREE.Vector3(0,1,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)]
                    , cube2DViewPorts = [new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4]
                    , depthMaterialTemplate = new THREE.MeshDepthMaterial;
                depthMaterialTemplate.depthPacking = THREE.RGBADepthPacking,
                    depthMaterialTemplate.clipping = !0;
                for (var distanceShader = THREE.ShaderLib.distanceRGBA, distanceUniforms = THREE.UniformsUtils.clone(distanceShader.uniforms), i = 0; i !== _NumberOfMaterialVariants; ++i) {
                    var useMorphing = 0 !== (i & _MorphingFlag)
                        , useSkinning = 0 !== (i & _SkinningFlag)
                        , depthMaterial = depthMaterialTemplate.clone();
                    depthMaterial.morphTargets = useMorphing,
                        depthMaterial.skinning = useSkinning,
                        _depthMaterials[i] = depthMaterial;
                    var distanceMaterial = new THREE.ShaderMaterial({
                        defines: {
                            USE_SHADOWMAP: ""
                        },
                        uniforms: distanceUniforms,
                        vertexShader: distanceShader.vertexShader,
                        fragmentShader: distanceShader.fragmentShader,
                        morphTargets: useMorphing,
                        skinning: useSkinning,
                        clipping: !0
                    });
                    _distanceMaterials[i] = distanceMaterial
                }
                var scope = this;
                this.enabled = !1,
                    this.autoUpdate = !0,
                    this.needsUpdate = !1,
                    this.type = THREE.PCFShadowMap,
                    this.renderReverseSided = !0,
                    this.renderSingleSided = !0,
                    this.render = function(scene, camera) {
                        if (scope.enabled !== !1 && (scope.autoUpdate !== !1 || scope.needsUpdate !== !1) && 0 !== _lightShadows.length) {
                            _state.clearColor(1, 1, 1, 1),
                                _state.disable(_gl.BLEND),
                                _state.setDepthTest(!0),
                                _state.setScissorTest(!1);
                            for (var faceCount, isPointLight, i = 0, il = _lightShadows.length; i < il; i++) {
                                var light = _lightShadows[i]
                                    , shadow = light.shadow;
                                if (void 0 !== shadow) {
                                    var shadowCamera = shadow.camera;
                                    if (_shadowMapSize.copy(shadow.mapSize),
                                        light instanceof THREE.PointLight) {
                                        faceCount = 6,
                                            isPointLight = !0;
                                        var vpWidth = _shadowMapSize.x
                                            , vpHeight = _shadowMapSize.y;
                                        cube2DViewPorts[0].set(2 * vpWidth, vpHeight, vpWidth, vpHeight),
                                            cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight),
                                            cube2DViewPorts[2].set(3 * vpWidth, vpHeight, vpWidth, vpHeight),
                                            cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight),
                                            cube2DViewPorts[4].set(3 * vpWidth, 0, vpWidth, vpHeight),
                                            cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight),
                                            _shadowMapSize.x *= 4,
                                            _shadowMapSize.y *= 2
                                    } else
                                        faceCount = 1,
                                            isPointLight = !1;
                                    if (null === shadow.map) {
                                        var pars = {
                                            minFilter: THREE.NearestFilter,
                                            magFilter: THREE.NearestFilter,
                                            format: THREE.RGBAFormat
                                        };
                                        shadow.map = new THREE.WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars),
                                            shadowCamera.updateProjectionMatrix()
                                    }
                                    shadow instanceof THREE.SpotLightShadow && shadow.update(light);
                                    var shadowMap = shadow.map
                                        , shadowMatrix = shadow.matrix;
                                    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld),
                                        shadowCamera.position.copy(_lightPositionWorld),
                                        _renderer.setRenderTarget(shadowMap),
                                        _renderer.clear();
                                    for (var face = 0; face < faceCount; face++) {
                                        if (isPointLight) {
                                            _lookTarget.copy(shadowCamera.position),
                                                _lookTarget.add(cubeDirections[face]),
                                                shadowCamera.up.copy(cubeUps[face]),
                                                shadowCamera.lookAt(_lookTarget);
                                            var vpDimensions = cube2DViewPorts[face];
                                            _state.viewport(vpDimensions)
                                        } else
                                            _lookTarget.setFromMatrixPosition(light.target.matrixWorld),
                                                shadowCamera.lookAt(_lookTarget);
                                        shadowCamera.updateMatrixWorld(),
                                            shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld),
                                            shadowMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                                            shadowMatrix.multiply(shadowCamera.projectionMatrix),
                                            shadowMatrix.multiply(shadowCamera.matrixWorldInverse),
                                            _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse),
                                            _frustum.setFromMatrix(_projScreenMatrix),
                                            _renderList.length = 0,
                                            projectObject(scene, camera, shadowCamera);
                                        for (var j = 0, jl = _renderList.length; j < jl; j++) {
                                            var object = _renderList[j]
                                                , geometry = _objects.update(object)
                                                , material = object.material;
                                            if (material instanceof THREE.MultiMaterial)
                                                for (var groups = geometry.groups, materials = material.materials, k = 0, kl = groups.length; k < kl; k++) {
                                                    var group = groups[k]
                                                        , groupMaterial = materials[group.materialIndex];
                                                    if (groupMaterial.visible === !0) {
                                                        var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
                                                        _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group)
                                                    }
                                                }
                                            else {
                                                var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
                                                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null)
                                            }
                                        }
                                    }
                                } else
                                    console.warn("THREE.WebGLShadowMap:", light, "has no shadow.")
                            }
                            var clearColor = _renderer.getClearColor()
                                , clearAlpha = _renderer.getClearAlpha();
                            _renderer.setClearColor(clearColor, clearAlpha),
                                scope.needsUpdate = !1
                        }
                    }
            }
            ,
            THREE.WebGLState = function(gl, extensions, paramThreeToGL) {
                function createTexture(type, target, count) {
                    var data = new Uint8Array(4)
                        , texture = gl.createTexture();
                    gl.bindTexture(type, texture),
                        gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST),
                        gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    for (var i = 0; i < count; i++)
                        gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                    return texture
                }
                var _this = this;
                this.buffers = {
                    color: new THREE.WebGLColorBuffer(gl,this),
                    depth: new THREE.WebGLDepthBuffer(gl,this),
                    stencil: new THREE.WebGLStencilBuffer(gl,this)
                };
                var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS)
                    , newAttributes = new Uint8Array(maxVertexAttributes)
                    , enabledAttributes = new Uint8Array(maxVertexAttributes)
                    , attributeDivisors = new Uint8Array(maxVertexAttributes)
                    , capabilities = {}
                    , compressedTextureFormats = null
                    , currentBlending = null
                    , currentBlendEquation = null
                    , currentBlendSrc = null
                    , currentBlendDst = null
                    , currentBlendEquationAlpha = null
                    , currentBlendSrcAlpha = null
                    , currentBlendDstAlpha = null
                    , currentPremultipledAlpha = !1
                    , currentFlipSided = null
                    , currentCullFace = null
                    , currentLineWidth = null
                    , currentPolygonOffsetFactor = null
                    , currentPolygonOffsetUnits = null
                    , currentScissorTest = null
                    , maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)
                    , currentTextureSlot = null
                    , currentBoundTextures = {}
                    , currentScissor = new THREE.Vector4
                    , currentViewport = new THREE.Vector4
                    , emptyTextures = {};
                emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1),
                    emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
                    this.init = function() {
                        this.clearColor(0, 0, 0, 1),
                            this.clearDepth(1),
                            this.clearStencil(0),
                            this.enable(gl.DEPTH_TEST),
                            this.setDepthFunc(THREE.LessEqualDepth),
                            this.setFlipSided(!1),
                            this.setCullFace(THREE.CullFaceBack),
                            this.enable(gl.CULL_FACE),
                            this.enable(gl.BLEND),
                            this.setBlending(THREE.NormalBlending)
                    }
                    ,
                    this.initAttributes = function() {
                        for (var i = 0, l = newAttributes.length; i < l; i++)
                            newAttributes[i] = 0
                    }
                    ,
                    this.enableAttribute = function(attribute) {
                        if (newAttributes[attribute] = 1,
                            0 === enabledAttributes[attribute] && (gl.enableVertexAttribArray(attribute),
                                enabledAttributes[attribute] = 1),
                            0 !== attributeDivisors[attribute]) {
                            var extension = extensions.get("ANGLE_instanced_arrays");
                            extension.vertexAttribDivisorANGLE(attribute, 0),
                                attributeDivisors[attribute] = 0
                        }
                    }
                    ,
                    this.enableAttributeAndDivisor = function(attribute, meshPerAttribute, extension) {
                        newAttributes[attribute] = 1,
                        0 === enabledAttributes[attribute] && (gl.enableVertexAttribArray(attribute),
                            enabledAttributes[attribute] = 1),
                        attributeDivisors[attribute] !== meshPerAttribute && (extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute),
                            attributeDivisors[attribute] = meshPerAttribute)
                    }
                    ,
                    this.disableUnusedAttributes = function() {
                        for (var i = 0, l = enabledAttributes.length; i !== l; ++i)
                            enabledAttributes[i] !== newAttributes[i] && (gl.disableVertexAttribArray(i),
                                enabledAttributes[i] = 0)
                    }
                    ,
                    this.enable = function(id) {
                        capabilities[id] !== !0 && (gl.enable(id),
                            capabilities[id] = !0)
                    }
                    ,
                    this.disable = function(id) {
                        capabilities[id] !== !1 && (gl.disable(id),
                            capabilities[id] = !1)
                    }
                    ,
                    this.getCompressedTextureFormats = function() {
                        if (null === compressedTextureFormats && (compressedTextureFormats = [],
                            extensions.get("WEBGL_compressed_texture_pvrtc") || extensions.get("WEBGL_compressed_texture_s3tc") || extensions.get("WEBGL_compressed_texture_etc1")))
                            for (var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS), i = 0; i < formats.length; i++)
                                compressedTextureFormats.push(formats[i]);
                        return compressedTextureFormats
                    }
                    ,
                    this.setBlending = function(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
                        return blending === THREE.NoBlending ? (this.disable(gl.BLEND),
                            void (currentBlending = blending)) : (this.enable(gl.BLEND),
                        blending === currentBlending && premultipliedAlpha === currentPremultipledAlpha || (blending === THREE.AdditiveBlending ? premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD),
                            gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE)) : (gl.blendEquation(gl.FUNC_ADD),
                            gl.blendFunc(gl.SRC_ALPHA, gl.ONE)) : blending === THREE.SubtractiveBlending ? premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD),
                            gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA)) : (gl.blendEquation(gl.FUNC_ADD),
                            gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR)) : blending === THREE.MultiplyBlending ? premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD),
                            gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA)) : (gl.blendEquation(gl.FUNC_ADD),
                            gl.blendFunc(gl.ZERO, gl.SRC_COLOR)) : premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD),
                            gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)) : (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD),
                            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)),
                            currentBlending = blending,
                            currentPremultipledAlpha = premultipliedAlpha),
                            void (blending === THREE.CustomBlending ? (blendEquationAlpha = blendEquationAlpha || blendEquation,
                                blendSrcAlpha = blendSrcAlpha || blendSrc,
                                blendDstAlpha = blendDstAlpha || blendDst,
                            blendEquation === currentBlendEquation && blendEquationAlpha === currentBlendEquationAlpha || (gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha)),
                                currentBlendEquation = blendEquation,
                                currentBlendEquationAlpha = blendEquationAlpha),
                            blendSrc === currentBlendSrc && blendDst === currentBlendDst && blendSrcAlpha === currentBlendSrcAlpha && blendDstAlpha === currentBlendDstAlpha || (gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha)),
                                currentBlendSrc = blendSrc,
                                currentBlendDst = blendDst,
                                currentBlendSrcAlpha = blendSrcAlpha,
                                currentBlendDstAlpha = blendDstAlpha)) : (currentBlendEquation = null,
                                currentBlendSrc = null,
                                currentBlendDst = null,
                                currentBlendEquationAlpha = null,
                                currentBlendSrcAlpha = null,
                                currentBlendDstAlpha = null)))
                    }
                    ,
                    this.setColorWrite = function(colorWrite) {
                        this.buffers.color.setMask(colorWrite)
                    }
                    ,
                    this.setDepthTest = function(depthTest) {
                        this.buffers.depth.setTest(depthTest)
                    }
                    ,
                    this.setDepthWrite = function(depthWrite) {
                        this.buffers.depth.setMask(depthWrite)
                    }
                    ,
                    this.setDepthFunc = function(depthFunc) {
                        this.buffers.depth.setFunc(depthFunc)
                    }
                    ,
                    this.setStencilTest = function(stencilTest) {
                        this.buffers.stencil.setTest(stencilTest)
                    }
                    ,
                    this.setStencilWrite = function(stencilWrite) {
                        this.buffers.stencil.setMask(stencilWrite)
                    }
                    ,
                    this.setStencilFunc = function(stencilFunc, stencilRef, stencilMask) {
                        this.buffers.stencil.setFunc(stencilFunc, stencilRef, stencilMask)
                    }
                    ,
                    this.setStencilOp = function(stencilFail, stencilZFail, stencilZPass) {
                        this.buffers.stencil.setOp(stencilFail, stencilZFail, stencilZPass)
                    }
                    ,
                    this.setFlipSided = function(flipSided) {
                        currentFlipSided !== flipSided && (flipSided ? gl.frontFace(gl.CW) : gl.frontFace(gl.CCW),
                            currentFlipSided = flipSided)
                    }
                    ,
                    this.setCullFace = function(cullFace) {
                        cullFace !== THREE.CullFaceNone ? (this.enable(gl.CULL_FACE),
                        cullFace !== currentCullFace && (cullFace === THREE.CullFaceBack ? gl.cullFace(gl.BACK) : cullFace === THREE.CullFaceFront ? gl.cullFace(gl.FRONT) : gl.cullFace(gl.FRONT_AND_BACK))) : this.disable(gl.CULL_FACE),
                            currentCullFace = cullFace
                    }
                    ,
                    this.setLineWidth = function(width) {
                        width !== currentLineWidth && (gl.lineWidth(width),
                            currentLineWidth = width)
                    }
                    ,
                    this.setPolygonOffset = function(polygonOffset, factor, units) {
                        polygonOffset ? (this.enable(gl.POLYGON_OFFSET_FILL),
                        currentPolygonOffsetFactor === factor && currentPolygonOffsetUnits === units || (gl.polygonOffset(factor, units),
                            currentPolygonOffsetFactor = factor,
                            currentPolygonOffsetUnits = units)) : this.disable(gl.POLYGON_OFFSET_FILL)
                    }
                    ,
                    this.getScissorTest = function() {
                        return currentScissorTest
                    }
                    ,
                    this.setScissorTest = function(scissorTest) {
                        currentScissorTest = scissorTest,
                            scissorTest ? this.enable(gl.SCISSOR_TEST) : this.disable(gl.SCISSOR_TEST)
                    }
                    ,
                    this.activeTexture = function(webglSlot) {
                        void 0 === webglSlot && (webglSlot = gl.TEXTURE0 + maxTextures - 1),
                        currentTextureSlot !== webglSlot && (gl.activeTexture(webglSlot),
                            currentTextureSlot = webglSlot)
                    }
                    ,
                    this.bindTexture = function(webglType, webglTexture) {
                        null === currentTextureSlot && _this.activeTexture();
                        var boundTexture = currentBoundTextures[currentTextureSlot];
                        void 0 === boundTexture && (boundTexture = {
                            type: void 0,
                            texture: void 0
                        },
                            currentBoundTextures[currentTextureSlot] = boundTexture),
                        boundTexture.type === webglType && boundTexture.texture === webglTexture || (gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]),
                            boundTexture.type = webglType,
                            boundTexture.texture = webglTexture)
                    }
                    ,
                    this.compressedTexImage2D = function() {
                        try {
                            gl.compressedTexImage2D.apply(gl, arguments)
                        } catch (error) {
                            console.error(error)
                        }
                    }
                    ,
                    this.texImage2D = function() {
                        try {
                            gl.texImage2D.apply(gl, arguments)
                        } catch (error) {
                            console.error(error)
                        }
                    }
                    ,
                    this.clearColor = function(r, g, b, a) {
                        this.buffers.color.setClear(r, g, b, a)
                    }
                    ,
                    this.clearDepth = function(depth) {
                        this.buffers.depth.setClear(depth)
                    }
                    ,
                    this.clearStencil = function(stencil) {
                        this.buffers.stencil.setClear(stencil)
                    }
                    ,
                    this.scissor = function(scissor) {
                        currentScissor.equals(scissor) === !1 && (gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w),
                            currentScissor.copy(scissor))
                    }
                    ,
                    this.viewport = function(viewport) {
                        currentViewport.equals(viewport) === !1 && (gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w),
                            currentViewport.copy(viewport))
                    }
                    ,
                    this.reset = function() {
                        for (var i = 0; i < enabledAttributes.length; i++)
                            1 === enabledAttributes[i] && (gl.disableVertexAttribArray(i),
                                enabledAttributes[i] = 0);
                        capabilities = {},
                            compressedTextureFormats = null,
                            currentTextureSlot = null,
                            currentBoundTextures = {},
                            currentBlending = null,
                            currentFlipSided = null,
                            currentCullFace = null,
                            this.buffers.color.reset(),
                            this.buffers.depth.reset(),
                            this.buffers.stencil.reset()
                    }
            }
            ,
            THREE.WebGLColorBuffer = function(gl, state) {
                var locked = !1
                    , color = new THREE.Vector4
                    , currentColorMask = null
                    , currentColorClear = new THREE.Vector4;
                this.setMask = function(colorMask) {
                    currentColorMask === colorMask || locked || (gl.colorMask(colorMask, colorMask, colorMask, colorMask),
                        currentColorMask = colorMask)
                }
                    ,
                    this.setLocked = function(lock) {
                        locked = lock
                    }
                    ,
                    this.setClear = function(r, g, b, a) {
                        color.set(r, g, b, a),
                        currentColorClear.equals(color) === !1 && (gl.clearColor(r, g, b, a),
                            currentColorClear.copy(color))
                    }
                    ,
                    this.reset = function() {
                        locked = !1,
                            currentColorMask = null,
                            currentColorClear = new THREE.Vector4
                    }
            }
            ,
            THREE.WebGLDepthBuffer = function(gl, state) {
                var locked = !1
                    , currentDepthMask = null
                    , currentDepthFunc = null
                    , currentDepthClear = null;
                this.setTest = function(depthTest) {
                    depthTest ? state.enable(gl.DEPTH_TEST) : state.disable(gl.DEPTH_TEST)
                }
                    ,
                    this.setMask = function(depthMask) {
                        currentDepthMask === depthMask || locked || (gl.depthMask(depthMask),
                            currentDepthMask = depthMask)
                    }
                    ,
                    this.setFunc = function(depthFunc) {
                        if (currentDepthFunc !== depthFunc) {
                            if (depthFunc)
                                switch (depthFunc) {
                                    case THREE.NeverDepth:
                                        gl.depthFunc(gl.NEVER);
                                        break;
                                    case THREE.AlwaysDepth:
                                        gl.depthFunc(gl.ALWAYS);
                                        break;
                                    case THREE.LessDepth:
                                        gl.depthFunc(gl.LESS);
                                        break;
                                    case THREE.LessEqualDepth:
                                        gl.depthFunc(gl.LEQUAL);
                                        break;
                                    case THREE.EqualDepth:
                                        gl.depthFunc(gl.EQUAL);
                                        break;
                                    case THREE.GreaterEqualDepth:
                                        gl.depthFunc(gl.GEQUAL);
                                        break;
                                    case THREE.GreaterDepth:
                                        gl.depthFunc(gl.GREATER);
                                        break;
                                    case THREE.NotEqualDepth:
                                        gl.depthFunc(gl.NOTEQUAL);
                                        break;
                                    default:
                                        gl.depthFunc(gl.LEQUAL)
                                }
                            else
                                gl.depthFunc(gl.LEQUAL);
                            currentDepthFunc = depthFunc
                        }
                    }
                    ,
                    this.setLocked = function(lock) {
                        locked = lock
                    }
                    ,
                    this.setClear = function(depth) {
                        currentDepthClear !== depth && (gl.clearDepth(depth),
                            currentDepthClear = depth)
                    }
                    ,
                    this.reset = function() {
                        locked = !1,
                            currentDepthMask = null,
                            currentDepthFunc = null,
                            currentDepthClear = null
                    }
            }
            ,
            THREE.WebGLStencilBuffer = function(gl, state) {
                var locked = !1
                    , currentStencilMask = null
                    , currentStencilFunc = null
                    , currentStencilRef = null
                    , currentStencilFuncMask = null
                    , currentStencilFail = null
                    , currentStencilZFail = null
                    , currentStencilZPass = null
                    , currentStencilClear = null;
                this.setTest = function(stencilTest) {
                    stencilTest ? state.enable(gl.STENCIL_TEST) : state.disable(gl.STENCIL_TEST)
                }
                    ,
                    this.setMask = function(stencilMask) {
                        currentStencilMask === stencilMask || locked || (gl.stencilMask(stencilMask),
                            currentStencilMask = stencilMask)
                    }
                    ,
                    this.setFunc = function(stencilFunc, stencilRef, stencilMask) {
                        currentStencilFunc === stencilFunc && currentStencilRef === stencilRef && currentStencilFuncMask === stencilMask || (gl.stencilFunc(stencilFunc, stencilRef, stencilMask),
                            currentStencilFunc = stencilFunc,
                            currentStencilRef = stencilRef,
                            currentStencilFuncMask = stencilMask)
                    }
                    ,
                    this.setOp = function(stencilFail, stencilZFail, stencilZPass) {
                        currentStencilFail === stencilFail && currentStencilZFail === stencilZFail && currentStencilZPass === stencilZPass || (gl.stencilOp(stencilFail, stencilZFail, stencilZPass),
                            currentStencilFail = stencilFail,
                            currentStencilZFail = stencilZFail,
                            currentStencilZPass = stencilZPass)
                    }
                    ,
                    this.setLocked = function(lock) {
                        locked = lock
                    }
                    ,
                    this.setClear = function(stencil) {
                        currentStencilClear !== stencil && (gl.clearStencil(stencil),
                            currentStencilClear = stencil)
                    }
                    ,
                    this.reset = function() {
                        locked = !1,
                            currentStencilMask = null,
                            currentStencilFunc = null,
                            currentStencilRef = null,
                            currentStencilFuncMask = null,
                            currentStencilFail = null,
                            currentStencilZFail = null,
                            currentStencilZPass = null,
                            currentStencilClear = null
                    }
            }
            ,
            THREE.WebGLTextures = function(_gl, extensions, state, properties, capabilities, paramThreeToGL, info) {
                function clampToMaxSize(image, maxSize) {
                    if (image.width > maxSize || image.height > maxSize) {
                        var scale = maxSize / Math.max(image.width, image.height)
                            , canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        canvas.width = Math.floor(image.width * scale),
                            canvas.height = Math.floor(image.height * scale);
                        var context = canvas.getContext("2d");
                        return context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height),
                            console.warn("THREE.WebGLRenderer: image is too big (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image),
                            canvas
                    }
                    return image
                }
                function isPowerOfTwo(image) {
                    return THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height)
                }
                function makePowerOfTwo(image) {
                    if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
                        var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        canvas.width = THREE.Math.nearestPowerOfTwo(image.width),
                            canvas.height = THREE.Math.nearestPowerOfTwo(image.height);
                        var context = canvas.getContext("2d");
                        return context.drawImage(image, 0, 0, canvas.width, canvas.height),
                            console.warn("THREE.WebGLRenderer: image is not power of two (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image),
                            canvas
                    }
                    return image
                }
                function textureNeedsPowerOfTwo(texture) {
                    return texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping || texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter
                }
                function filterFallback(f) {
                    return f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ? _gl.NEAREST : _gl.LINEAR
                }
                function onTextureDispose(event) {
                    var texture = event.target;
                    texture.removeEventListener("dispose", onTextureDispose),
                        deallocateTexture(texture),
                        _infoMemory.textures--
                }
                function onRenderTargetDispose(event) {
                    var renderTarget = event.target;
                    renderTarget.removeEventListener("dispose", onRenderTargetDispose),
                        deallocateRenderTarget(renderTarget),
                        _infoMemory.textures--
                }
                function deallocateTexture(texture) {
                    var textureProperties = properties.get(texture);
                    if (texture.image && textureProperties.__image__webglTextureCube)
                        _gl.deleteTexture(textureProperties.__image__webglTextureCube);
                    else {
                        if (void 0 === textureProperties.__webglInit)
                            return;
                        _gl.deleteTexture(textureProperties.__webglTexture)
                    }
                    properties.delete(texture)
                }
                function deallocateRenderTarget(renderTarget) {
                    var renderTargetProperties = properties.get(renderTarget)
                        , textureProperties = properties.get(renderTarget.texture);
                    if (renderTarget) {
                        if (void 0 !== textureProperties.__webglTexture && _gl.deleteTexture(textureProperties.__webglTexture),
                            renderTarget.depthTexture && renderTarget.depthTexture.dispose(),
                            renderTarget instanceof THREE.WebGLRenderTargetCube)
                            for (var i = 0; i < 6; i++)
                                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]),
                                renderTargetProperties.__webglDepthbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
                        else
                            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer),
                            renderTargetProperties.__webglDepthbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
                        properties.delete(renderTarget.texture),
                            properties.delete(renderTarget)
                    }
                }
                function setTexture2D(texture, slot) {
                    var textureProperties = properties.get(texture);
                    if (texture.version > 0 && textureProperties.__version !== texture.version) {
                        var image = texture.image;
                        if (void 0 === image)
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", texture);
                        else {
                            if (image.complete !== !1)
                                return void uploadTexture(textureProperties, texture, slot);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", texture)
                        }
                    }
                    state.activeTexture(_gl.TEXTURE0 + slot),
                        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture)
                }
                function setTextureCube(texture, slot) {
                    var textureProperties = properties.get(texture);
                    if (6 === texture.image.length)
                        if (texture.version > 0 && textureProperties.__version !== texture.version) {
                            textureProperties.__image__webglTextureCube || (texture.addEventListener("dispose", onTextureDispose),
                                textureProperties.__image__webglTextureCube = _gl.createTexture(),
                                _infoMemory.textures++),
                                state.activeTexture(_gl.TEXTURE0 + slot),
                                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube),
                                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                            for (var isCompressed = texture instanceof THREE.CompressedTexture, isDataTexture = texture.image[0]instanceof THREE.DataTexture, cubeImage = [], i = 0; i < 6; i++)
                                isCompressed || isDataTexture ? cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i] : cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
                            var image = cubeImage[0]
                                , isPowerOfTwoImage = isPowerOfTwo(image)
                                , glFormat = paramThreeToGL(texture.format)
                                , glType = paramThreeToGL(texture.type);
                            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
                            for (var i = 0; i < 6; i++)
                                if (isCompressed)
                                    for (var mipmap, mipmaps = cubeImage[i].mipmaps, j = 0, jl = mipmaps.length; j < jl; j++)
                                        mipmap = mipmaps[j],
                                            texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ? state.getCompressedTextureFormats().indexOf(glFormat) > -1 ? state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                                else
                                    isDataTexture ? state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                            texture.generateMipmaps && isPowerOfTwoImage && _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP),
                                textureProperties.__version = texture.version,
                            texture.onUpdate && texture.onUpdate(texture)
                        } else
                            state.activeTexture(_gl.TEXTURE0 + slot),
                                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube)
                }
                function setTextureCubeDynamic(texture, slot) {
                    state.activeTexture(_gl.TEXTURE0 + slot),
                        state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture)
                }
                function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
                    var extension;
                    if (isPowerOfTwoImage ? (_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS)),
                            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT)),
                            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter)),
                            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter))) : (_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE),
                            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE),
                        texture.wrapS === THREE.ClampToEdgeWrapping && texture.wrapT === THREE.ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", texture),
                            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter)),
                            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter)),
                        texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", texture)),
                            extension = extensions.get("EXT_texture_filter_anisotropic")) {
                        if (texture.type === THREE.FloatType && null === extensions.get("OES_texture_float_linear"))
                            return;
                        if (texture.type === THREE.HalfFloatType && null === extensions.get("OES_texture_half_float_linear"))
                            return;
                        (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) && (_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy())),
                            properties.get(texture).__currentAnisotropy = texture.anisotropy)
                    }
                }
                function uploadTexture(textureProperties, texture, slot) {
                    void 0 === textureProperties.__webglInit && (textureProperties.__webglInit = !0,
                        texture.addEventListener("dispose", onTextureDispose),
                        textureProperties.__webglTexture = _gl.createTexture(),
                        _infoMemory.textures++),
                        state.activeTexture(_gl.TEXTURE0 + slot),
                        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture),
                        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY),
                        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha),
                        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
                    var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
                    textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === !1 && (image = makePowerOfTwo(image));
                    var isPowerOfTwoImage = isPowerOfTwo(image)
                        , glFormat = paramThreeToGL(texture.format)
                        , glType = paramThreeToGL(texture.type);
                    setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
                    var mipmap, mipmaps = texture.mipmaps;
                    if (texture instanceof THREE.DepthTexture) {
                        var internalFormat = _gl.DEPTH_COMPONENT;
                        if (texture.type === THREE.FloatType) {
                            if (!_isWebGL2)
                                throw new Error("Float Depth Texture only supported in WebGL2.0");
                            internalFormat = _gl.DEPTH_COMPONENT32F
                        } else
                            _isWebGL2 && (internalFormat = _gl.DEPTH_COMPONENT16);
                        state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null)
                    } else if (texture instanceof THREE.DataTexture)
                        if (mipmaps.length > 0 && isPowerOfTwoImage) {
                            for (var i = 0, il = mipmaps.length; i < il; i++)
                                mipmap = mipmaps[i],
                                    state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                            texture.generateMipmaps = !1
                        } else
                            state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
                    else if (texture instanceof THREE.CompressedTexture)
                        for (var i = 0, il = mipmaps.length; i < il; i++)
                            mipmap = mipmaps[i],
                                texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ? state.getCompressedTextureFormats().indexOf(glFormat) > -1 ? state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    else if (mipmaps.length > 0 && isPowerOfTwoImage) {
                        for (var i = 0, il = mipmaps.length; i < il; i++)
                            mipmap = mipmaps[i],
                                state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                        texture.generateMipmaps = !1
                    } else
                        state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
                    texture.generateMipmaps && isPowerOfTwoImage && _gl.generateMipmap(_gl.TEXTURE_2D),
                        textureProperties.__version = texture.version,
                    texture.onUpdate && texture.onUpdate(texture)
                }
                function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
                    var glFormat = paramThreeToGL(renderTarget.texture.format)
                        , glType = paramThreeToGL(renderTarget.texture.type);
                    state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null),
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer),
                        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0),
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null)
                }
                function setupRenderBufferStorage(renderbuffer, renderTarget) {
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer),
                        renderTarget.depthBuffer && !renderTarget.stencilBuffer ? (_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height),
                            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)) : renderTarget.depthBuffer && renderTarget.stencilBuffer ? (_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height),
                            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)) : _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height),
                        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null)
                }
                function setupDepthTexture(framebuffer, renderTarget) {
                    var isCube = renderTarget instanceof THREE.WebGLRenderTargetCube;
                    if (isCube)
                        throw new Error("Depth Texture with cube render targets is not supported!");
                    if (_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer),
                            !(renderTarget.depthTexture instanceof THREE.DepthTexture))
                        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    properties.get(renderTarget.depthTexture).__webglTexture && renderTarget.depthTexture.image.width === renderTarget.width && renderTarget.depthTexture.image.height === renderTarget.height || (renderTarget.depthTexture.image.width = renderTarget.width,
                        renderTarget.depthTexture.image.height = renderTarget.height,
                        renderTarget.depthTexture.needsUpdate = !0),
                        setTexture2D(renderTarget.depthTexture, 0);
                    var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
                    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0)
                }
                function setupDepthRenderbuffer(renderTarget) {
                    var renderTargetProperties = properties.get(renderTarget)
                        , isCube = renderTarget instanceof THREE.WebGLRenderTargetCube;
                    if (renderTarget.depthTexture) {
                        if (isCube)
                            throw new Error("target.depthTexture not supported in Cube render targets");
                        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget)
                    } else if (isCube) {
                        renderTargetProperties.__webglDepthbuffer = [];
                        for (var i = 0; i < 6; i++)
                            _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]),
                                renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer(),
                                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget)
                    } else
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer),
                            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer(),
                            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null)
                }
                function setupRenderTarget(renderTarget) {
                    var renderTargetProperties = properties.get(renderTarget)
                        , textureProperties = properties.get(renderTarget.texture);
                    renderTarget.addEventListener("dispose", onRenderTargetDispose),
                        textureProperties.__webglTexture = _gl.createTexture(),
                        _infoMemory.textures++;
                    var isCube = renderTarget instanceof THREE.WebGLRenderTargetCube
                        , isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
                    if (isCube) {
                        renderTargetProperties.__webglFramebuffer = [];
                        for (var i = 0; i < 6; i++)
                            renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer()
                    } else
                        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
                    if (isCube) {
                        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture),
                            setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
                        for (var i = 0; i < 6; i++)
                            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                        renderTarget.texture.generateMipmaps && isTargetPowerOfTwo && _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP),
                            state.bindTexture(_gl.TEXTURE_CUBE_MAP, null)
                    } else
                        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture),
                            setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo),
                            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D),
                        renderTarget.texture.generateMipmaps && isTargetPowerOfTwo && _gl.generateMipmap(_gl.TEXTURE_2D),
                            state.bindTexture(_gl.TEXTURE_2D, null);
                    renderTarget.depthBuffer && setupDepthRenderbuffer(renderTarget)
                }
                function updateRenderTargetMipmap(renderTarget) {
                    var texture = renderTarget.texture;
                    if (texture.generateMipmaps && isPowerOfTwo(renderTarget) && texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
                        var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D
                            , webglTexture = properties.get(texture).__webglTexture;
                        state.bindTexture(target, webglTexture),
                            _gl.generateMipmap(target),
                            state.bindTexture(target, null)
                    }
                }
                var _infoMemory = info.memory
                    , _isWebGL2 = "undefined" != typeof WebGL2RenderingContext && _gl instanceof WebGL2RenderingContext;
                this.setTexture2D = setTexture2D,
                    this.setTextureCube = setTextureCube,
                    this.setTextureCubeDynamic = setTextureCubeDynamic,
                    this.setupRenderTarget = setupRenderTarget,
                    this.updateRenderTargetMipmap = updateRenderTargetMipmap
            }
            ,
            THREE.WebGLUniforms = function() {
                var emptyTexture = new THREE.Texture
                    , emptyCubeTexture = new THREE.CubeTexture
                    , UniformContainer = function() {
                    this.seq = [],
                        this.map = {}
                }
                    , arrayCacheF32 = []
                    , arrayCacheI32 = []
                    , flatten = function(array, nBlocks, blockSize) {
                    var firstElem = array[0];
                    if (firstElem <= 0 || firstElem > 0)
                        return array;
                    var n = nBlocks * blockSize
                        , r = arrayCacheF32[n];
                    if (void 0 === r && (r = new Float32Array(n),
                            arrayCacheF32[n] = r),
                        0 !== nBlocks) {
                        firstElem.toArray(r, 0);
                        for (var i = 1, offset = 0; i !== nBlocks; ++i)
                            offset += blockSize,
                                array[i].toArray(r, offset)
                    }
                    return r
                }
                    , allocTexUnits = function(renderer, n) {
                    var r = arrayCacheI32[n];
                    void 0 === r && (r = new Int32Array(n),
                        arrayCacheI32[n] = r);
                    for (var i = 0; i !== n; ++i)
                        r[i] = renderer.allocTextureUnit();
                    return r
                }
                    , setValue1f = function(gl, v) {
                    gl.uniform1f(this.addr, v)
                }
                    , setValue1i = function(gl, v) {
                    gl.uniform1i(this.addr, v)
                }
                    , setValue2fv = function(gl, v) {
                    void 0 === v.x ? gl.uniform2fv(this.addr, v) : gl.uniform2f(this.addr, v.x, v.y)
                }
                    , setValue3fv = function(gl, v) {
                    void 0 !== v.x ? gl.uniform3f(this.addr, v.x, v.y, v.z) : void 0 !== v.r ? gl.uniform3f(this.addr, v.r, v.g, v.b) : gl.uniform3fv(this.addr, v)
                }
                    , setValue4fv = function(gl, v) {
                    void 0 === v.x ? gl.uniform4fv(this.addr, v) : gl.uniform4f(this.addr, v.x, v.y, v.z, v.w)
                }
                    , setValue2fm = function(gl, v) {
                    gl.uniformMatrix2fv(this.addr, !1, v.elements || v)
                }
                    , setValue3fm = function(gl, v) {
                    gl.uniformMatrix3fv(this.addr, !1, v.elements || v)
                }
                    , setValue4fm = function(gl, v) {
                    gl.uniformMatrix4fv(this.addr, !1, v.elements || v)
                }
                    , setValueT1 = function(gl, v, renderer) {
                    var unit = renderer.allocTextureUnit();
                    gl.uniform1i(this.addr, unit),
                        renderer.setTexture2D(v || emptyTexture, unit)
                }
                    , setValueT6 = function(gl, v, renderer) {
                    var unit = renderer.allocTextureUnit();
                    gl.uniform1i(this.addr, unit),
                        renderer.setTextureCube(v || emptyCubeTexture, unit)
                }
                    , setValue2iv = function(gl, v) {
                    gl.uniform2iv(this.addr, v)
                }
                    , setValue3iv = function(gl, v) {
                    gl.uniform3iv(this.addr, v)
                }
                    , setValue4iv = function(gl, v) {
                    gl.uniform4iv(this.addr, v)
                }
                    , getSingularSetter = function(type) {
                    switch (type) {
                        case 5126:
                            return setValue1f;
                        case 35664:
                            return setValue2fv;
                        case 35665:
                            return setValue3fv;
                        case 35666:
                            return setValue4fv;
                        case 35674:
                            return setValue2fm;
                        case 35675:
                            return setValue3fm;
                        case 35676:
                            return setValue4fm;
                        case 35678:
                            return setValueT1;
                        case 35680:
                            return setValueT6;
                        case 5124:
                        case 35670:
                            return setValue1i;
                        case 35667:
                        case 35671:
                            return setValue2iv;
                        case 35668:
                        case 35672:
                            return setValue3iv;
                        case 35669:
                        case 35673:
                            return setValue4iv
                    }
                }
                    , setValue1fv = function(gl, v) {
                    gl.uniform1fv(this.addr, v)
                }
                    , setValue1iv = function(gl, v) {
                    gl.uniform1iv(this.addr, v)
                }
                    , setValueV2a = function(gl, v) {
                    gl.uniform2fv(this.addr, flatten(v, this.size, 2))
                }
                    , setValueV3a = function(gl, v) {
                    gl.uniform3fv(this.addr, flatten(v, this.size, 3))
                }
                    , setValueV4a = function(gl, v) {
                    gl.uniform4fv(this.addr, flatten(v, this.size, 4))
                }
                    , setValueM2a = function(gl, v) {
                    gl.uniformMatrix2fv(this.addr, !1, flatten(v, this.size, 4))
                }
                    , setValueM3a = function(gl, v) {
                    gl.uniformMatrix3fv(this.addr, !1, flatten(v, this.size, 9))
                }
                    , setValueM4a = function(gl, v) {
                    gl.uniformMatrix4fv(this.addr, !1, flatten(v, this.size, 16))
                }
                    , setValueT1a = function(gl, v, renderer) {
                    var n = v.length
                        , units = allocTexUnits(renderer, n);
                    gl.uniform1iv(this.addr, units);
                    for (var i = 0; i !== n; ++i)
                        renderer.setTexture2D(v[i] || emptyTexture, units[i])
                }
                    , setValueT6a = function(gl, v, renderer) {
                    var n = v.length
                        , units = allocTexUnits(renderer, n);
                    gl.uniform1iv(this.addr, units);
                    for (var i = 0; i !== n; ++i)
                        renderer.setTextureCube(v[i] || emptyCubeTexture, units[i])
                }
                    , getPureArraySetter = function(type) {
                    switch (type) {
                        case 5126:
                            return setValue1fv;
                        case 35664:
                            return setValueV2a;
                        case 35665:
                            return setValueV3a;
                        case 35666:
                            return setValueV4a;
                        case 35674:
                            return setValueM2a;
                        case 35675:
                            return setValueM3a;
                        case 35676:
                            return setValueM4a;
                        case 35678:
                            return setValueT1a;
                        case 35680:
                            return setValueT6a;
                        case 5124:
                        case 35670:
                            return setValue1iv;
                        case 35667:
                        case 35671:
                            return setValue2iv;
                        case 35668:
                        case 35672:
                            return setValue3iv;
                        case 35669:
                        case 35673:
                            return setValue4iv
                    }
                }
                    , SingleUniform = function(id, activeInfo, addr) {
                    this.id = id,
                        this.addr = addr,
                        this.setValue = getSingularSetter(activeInfo.type)
                }
                    , PureArrayUniform = function(id, activeInfo, addr) {
                    this.id = id,
                        this.addr = addr,
                        this.size = activeInfo.size,
                        this.setValue = getPureArraySetter(activeInfo.type)
                }
                    , StructuredUniform = function(id) {
                    this.id = id,
                        UniformContainer.call(this)
                };
                StructuredUniform.prototype.setValue = function(gl, value) {
                    for (var seq = this.seq, i = 0, n = seq.length; i !== n; ++i) {
                        var u = seq[i];
                        u.setValue(gl, value[u.id])
                    }
                }
                ;
                var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g
                    , addUniform = function(container, uniformObject) {
                    container.seq.push(uniformObject),
                        container.map[uniformObject.id] = uniformObject
                }
                    , parseUniform = function(activeInfo, addr, container) {
                    var path = activeInfo.name
                        , pathLength = path.length;
                    for (RePathPart.lastIndex = 0; ; ) {
                        var match = RePathPart.exec(path)
                            , matchEnd = RePathPart.lastIndex
                            , id = match[1]
                            , idIsIndex = "]" === match[2]
                            , subscript = match[3];
                        if (idIsIndex && (id |= 0),
                            void 0 === subscript || "[" === subscript && matchEnd + 2 === pathLength) {
                            addUniform(container, void 0 === subscript ? new SingleUniform(id,activeInfo,addr) : new PureArrayUniform(id,activeInfo,addr));
                            break
                        }
                        var map = container.map
                            , next = map[id];
                        void 0 === next && (next = new StructuredUniform(id),
                            addUniform(container, next)),
                            container = next
                    }
                }
                    , WebGLUniforms = function(gl, program, renderer) {
                    UniformContainer.call(this),
                        this.renderer = renderer;
                    for (var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), i = 0; i !== n; ++i) {
                        var info = gl.getActiveUniform(program, i)
                            , path = info.name
                            , addr = gl.getUniformLocation(program, path);
                        parseUniform(info, addr, this)
                    }
                };
                return WebGLUniforms.prototype.setValue = function(gl, name, value) {
                    var u = this.map[name];
                    void 0 !== u && u.setValue(gl, value, this.renderer)
                }
                    ,
                    WebGLUniforms.prototype.set = function(gl, object, name) {
                        var u = this.map[name];
                        void 0 !== u && u.setValue(gl, object[name], this.renderer)
                    }
                    ,
                    WebGLUniforms.prototype.setOptional = function(gl, object, name) {
                        var v = object[name];
                        void 0 !== v && this.setValue(gl, name, v)
                    }
                    ,
                    WebGLUniforms.upload = function(gl, seq, values, renderer) {
                        for (var i = 0, n = seq.length; i !== n; ++i) {
                            var u = seq[i]
                                , v = values[u.id];
                            v.needsUpdate !== !1 && u.setValue(gl, v.value, renderer)
                        }
                    }
                    ,
                    WebGLUniforms.seqWithValue = function(seq, values) {
                        for (var r = [], i = 0, n = seq.length; i !== n; ++i) {
                            var u = seq[i];
                            u.id in values && r.push(u)
                        }
                        return r
                    }
                    ,
                    WebGLUniforms.splitDynamic = function(seq, values) {
                        for (var r = null, n = seq.length, w = 0, i = 0; i !== n; ++i) {
                            var u = seq[i]
                                , v = values[u.id];
                            v && v.dynamic === !0 ? (null === r && (r = []),
                                r.push(u)) : (w < i && (seq[w] = u),
                                ++w)
                        }
                        return w < n && (seq.length = w),
                            r
                    }
                    ,
                    WebGLUniforms.evalDynamic = function(seq, values, object, camera) {
                        for (var i = 0, n = seq.length; i !== n; ++i) {
                            var v = values[seq[i].id]
                                , f = v.onUpdateCallback;
                            void 0 !== f && f.call(v, object, camera)
                        }
                    }
                    ,
                    WebGLUniforms
            }(),
            THREE.LensFlarePlugin = function(renderer, flares) {
                function init() {
                    var vertices = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1])
                        , faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    vertexBuffer = gl.createBuffer(),
                        elementBuffer = gl.createBuffer(),
                        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer),
                        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW),
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer),
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW),
                        tempTexture = gl.createTexture(),
                        occlusionTexture = gl.createTexture(),
                        state.bindTexture(gl.TEXTURE_2D, tempTexture),
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST),
                        state.bindTexture(gl.TEXTURE_2D, occlusionTexture),
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST),
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST),
                        shader = {
                            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                            fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
                        },
                        program = createProgram(shader),
                        attributes = {
                            vertex: gl.getAttribLocation(program, "position"),
                            uv: gl.getAttribLocation(program, "uv")
                        },
                        uniforms = {
                            renderType: gl.getUniformLocation(program, "renderType"),
                            map: gl.getUniformLocation(program, "map"),
                            occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
                            opacity: gl.getUniformLocation(program, "opacity"),
                            color: gl.getUniformLocation(program, "color"),
                            scale: gl.getUniformLocation(program, "scale"),
                            rotation: gl.getUniformLocation(program, "rotation"),
                            screenPosition: gl.getUniformLocation(program, "screenPosition")
                        }
                }
                function createProgram(shader) {
                    var program = gl.createProgram()
                        , fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)
                        , vertexShader = gl.createShader(gl.VERTEX_SHADER)
                        , prefix = "precision " + renderer.getPrecision() + " float;\n";
                    return gl.shaderSource(fragmentShader, prefix + shader.fragmentShader),
                        gl.shaderSource(vertexShader, prefix + shader.vertexShader),
                        gl.compileShader(fragmentShader),
                        gl.compileShader(vertexShader),
                        gl.attachShader(program, fragmentShader),
                        gl.attachShader(program, vertexShader),
                        gl.linkProgram(program),
                        program
                }
                var vertexBuffer, elementBuffer, shader, program, attributes, uniforms, tempTexture, occlusionTexture, gl = renderer.context, state = renderer.state;
                this.render = function(scene, camera, viewport) {
                    if (0 !== flares.length) {
                        var tempPosition = new THREE.Vector3
                            , invAspect = viewport.w / viewport.z
                            , halfViewportWidth = .5 * viewport.z
                            , halfViewportHeight = .5 * viewport.w
                            , size = 16 / viewport.w
                            , scale = new THREE.Vector2(size * invAspect,size)
                            , screenPosition = new THREE.Vector3(1,1,0)
                            , screenPositionPixels = new THREE.Vector2(1,1)
                            , validArea = new THREE.Box2;
                        validArea.min.set(0, 0),
                            validArea.max.set(viewport.z - 16, viewport.w - 16),
                        void 0 === program && init(),
                            gl.useProgram(program),
                            state.initAttributes(),
                            state.enableAttribute(attributes.vertex),
                            state.enableAttribute(attributes.uv),
                            state.disableUnusedAttributes(),
                            gl.uniform1i(uniforms.occlusionMap, 0),
                            gl.uniform1i(uniforms.map, 1),
                            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer),
                            gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, !1, 16, 0),
                            gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, !1, 16, 8),
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer),
                            state.disable(gl.CULL_FACE),
                            state.setDepthWrite(!1);
                        for (var i = 0, l = flares.length; i < l; i++) {
                            size = 16 / viewport.w,
                                scale.set(size * invAspect, size);
                            var flare = flares[i];
                            if (tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]),
                                    tempPosition.applyMatrix4(camera.matrixWorldInverse),
                                    tempPosition.applyProjection(camera.projectionMatrix),
                                    screenPosition.copy(tempPosition),
                                    screenPositionPixels.x = viewport.x + screenPosition.x * halfViewportWidth + halfViewportWidth - 8,
                                    screenPositionPixels.y = viewport.y + screenPosition.y * halfViewportHeight + halfViewportHeight - 8,
                                validArea.containsPoint(screenPositionPixels) === !0) {
                                state.activeTexture(gl.TEXTURE0),
                                    state.bindTexture(gl.TEXTURE_2D, null),
                                    state.activeTexture(gl.TEXTURE1),
                                    state.bindTexture(gl.TEXTURE_2D, tempTexture),
                                    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0),
                                    gl.uniform1i(uniforms.renderType, 0),
                                    gl.uniform2f(uniforms.scale, scale.x, scale.y),
                                    gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z),
                                    state.disable(gl.BLEND),
                                    state.enable(gl.DEPTH_TEST),
                                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0),
                                    state.activeTexture(gl.TEXTURE0),
                                    state.bindTexture(gl.TEXTURE_2D, occlusionTexture),
                                    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0),
                                    gl.uniform1i(uniforms.renderType, 1),
                                    state.disable(gl.DEPTH_TEST),
                                    state.activeTexture(gl.TEXTURE1),
                                    state.bindTexture(gl.TEXTURE_2D, tempTexture),
                                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0),
                                    flare.positionScreen.copy(screenPosition),
                                    flare.customUpdateCallback ? flare.customUpdateCallback(flare) : flare.updateLensFlares(),
                                    gl.uniform1i(uniforms.renderType, 2),
                                    state.enable(gl.BLEND);
                                for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
                                    var sprite = flare.lensFlares[j];
                                    sprite.opacity > .001 && sprite.scale > .001 && (screenPosition.x = sprite.x,
                                        screenPosition.y = sprite.y,
                                        screenPosition.z = sprite.z,
                                        size = sprite.size * sprite.scale / viewport.w,
                                        scale.x = size * invAspect,
                                        scale.y = size,
                                        gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z),
                                        gl.uniform2f(uniforms.scale, scale.x, scale.y),
                                        gl.uniform1f(uniforms.rotation, sprite.rotation),
                                        gl.uniform1f(uniforms.opacity, sprite.opacity),
                                        gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b),
                                        state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst),
                                        renderer.setTexture2D(sprite.texture, 1),
                                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0))
                                }
                            }
                        }
                        state.enable(gl.CULL_FACE),
                            state.enable(gl.DEPTH_TEST),
                            state.setDepthWrite(!0),
                            renderer.resetGLState()
                    }
                }
            }
            ,
            THREE.SpritePlugin = function(renderer, sprites) {
                function init() {
                    var vertices = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1])
                        , faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    vertexBuffer = gl.createBuffer(),
                        elementBuffer = gl.createBuffer(),
                        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer),
                        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW),
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer),
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW),
                        program = createProgram(),
                        attributes = {
                            position: gl.getAttribLocation(program, "position"),
                            uv: gl.getAttribLocation(program, "uv")
                        },
                        uniforms = {
                            uvOffset: gl.getUniformLocation(program, "uvOffset"),
                            uvScale: gl.getUniformLocation(program, "uvScale"),
                            rotation: gl.getUniformLocation(program, "rotation"),
                            scale: gl.getUniformLocation(program, "scale"),
                            color: gl.getUniformLocation(program, "color"),
                            map: gl.getUniformLocation(program, "map"),
                            opacity: gl.getUniformLocation(program, "opacity"),
                            modelViewMatrix: gl.getUniformLocation(program, "modelViewMatrix"),
                            projectionMatrix: gl.getUniformLocation(program, "projectionMatrix"),
                            fogType: gl.getUniformLocation(program, "fogType"),
                            fogDensity: gl.getUniformLocation(program, "fogDensity"),
                            fogNear: gl.getUniformLocation(program, "fogNear"),
                            fogFar: gl.getUniformLocation(program, "fogFar"),
                            fogColor: gl.getUniformLocation(program, "fogColor"),
                            alphaTest: gl.getUniformLocation(program, "alphaTest")
                        };
                    var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    canvas.width = 8,
                        canvas.height = 8;
                    var context = canvas.getContext("2d");
                    context.fillStyle = "white",
                        context.fillRect(0, 0, 8, 8),
                        texture = new THREE.Texture(canvas),
                        texture.needsUpdate = !0
                }
                function createProgram() {
                    var program = gl.createProgram()
                        , vertexShader = gl.createShader(gl.VERTEX_SHADER)
                        , fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                    return gl.shaderSource(vertexShader, ["precision " + renderer.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")),
                        gl.shaderSource(fragmentShader, ["precision " + renderer.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")),
                        gl.compileShader(vertexShader),
                        gl.compileShader(fragmentShader),
                        gl.attachShader(program, vertexShader),
                        gl.attachShader(program, fragmentShader),
                        gl.linkProgram(program),
                        program
                }
                function painterSortStable(a, b) {
                    return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id
                }
                var vertexBuffer, elementBuffer, program, attributes, uniforms, texture, gl = renderer.context, state = renderer.state, spritePosition = new THREE.Vector3, spriteRotation = new THREE.Quaternion, spriteScale = new THREE.Vector3;
                this.render = function(scene, camera) {
                    if (0 !== sprites.length) {
                        void 0 === program && init(),
                            gl.useProgram(program),
                            state.initAttributes(),
                            state.enableAttribute(attributes.position),
                            state.enableAttribute(attributes.uv),
                            state.disableUnusedAttributes(),
                            state.disable(gl.CULL_FACE),
                            state.enable(gl.BLEND),
                            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer),
                            gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, !1, 16, 0),
                            gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, !1, 16, 8),
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer),
                            gl.uniformMatrix4fv(uniforms.projectionMatrix, !1, camera.projectionMatrix.elements),
                            state.activeTexture(gl.TEXTURE0),
                            gl.uniform1i(uniforms.map, 0);
                        var oldFogType = 0
                            , sceneFogType = 0
                            , fog = scene.fog;
                        fog ? (gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b),
                            fog instanceof THREE.Fog ? (gl.uniform1f(uniforms.fogNear, fog.near),
                                gl.uniform1f(uniforms.fogFar, fog.far),
                                gl.uniform1i(uniforms.fogType, 1),
                                oldFogType = 1,
                                sceneFogType = 1) : fog instanceof THREE.FogExp2 && (gl.uniform1f(uniforms.fogDensity, fog.density),
                                gl.uniform1i(uniforms.fogType, 2),
                                oldFogType = 2,
                                sceneFogType = 2)) : (gl.uniform1i(uniforms.fogType, 0),
                            oldFogType = 0,
                            sceneFogType = 0);
                        for (var i = 0, l = sprites.length; i < l; i++) {
                            var sprite = sprites[i];
                            sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld),
                                sprite.z = -sprite.modelViewMatrix.elements[14]
                        }
                        sprites.sort(painterSortStable);
                        for (var scale = [], i = 0, l = sprites.length; i < l; i++) {
                            var sprite = sprites[i]
                                , material = sprite.material;
                            gl.uniform1f(uniforms.alphaTest, material.alphaTest),
                                gl.uniformMatrix4fv(uniforms.modelViewMatrix, !1, sprite.modelViewMatrix.elements),
                                sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale),
                                scale[0] = spriteScale.x,
                                scale[1] = spriteScale.y;
                            var fogType = 0;
                            scene.fog && material.fog && (fogType = sceneFogType),
                            oldFogType !== fogType && (gl.uniform1i(uniforms.fogType, fogType),
                                oldFogType = fogType),
                                null !== material.map ? (gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y),
                                    gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y)) : (gl.uniform2f(uniforms.uvOffset, 0, 0),
                                    gl.uniform2f(uniforms.uvScale, 1, 1)),
                                gl.uniform1f(uniforms.opacity, material.opacity),
                                gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b),
                                gl.uniform1f(uniforms.rotation, material.rotation),
                                gl.uniform2fv(uniforms.scale, scale),
                                state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst),
                                state.setDepthTest(material.depthTest),
                                state.setDepthWrite(material.depthWrite),
                                material.map ? renderer.setTexture2D(material.map, 0) : renderer.setTexture2D(texture, 0),
                                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0)
                        }
                        state.enable(gl.CULL_FACE),
                            renderer.resetGLState()
                    }
                }
            }
            ,
            Object.assign(THREE, {
                Face4: function(a, b, c, d, normal, color, materialIndex) {
                    return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
                        new THREE.Face3(a,b,c,normal,color,materialIndex)
                },
                LineStrip: 0,
                LinePieces: 1,
                MeshFaceMaterial: THREE.MultiMaterial,
                PointCloud: function(geometry, material) {
                    return console.warn("THREE.PointCloud has been renamed to THREE.Points."),
                        new THREE.Points(geometry,material)
                },
                Particle: THREE.Sprite,
                ParticleSystem: function(geometry, material) {
                    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
                        new THREE.Points(geometry,material)
                },
                PointCloudMaterial: function(parameters) {
                    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
                        new THREE.PointsMaterial(parameters)
                },
                ParticleBasicMaterial: function(parameters) {
                    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
                        new THREE.PointsMaterial(parameters)
                },
                ParticleSystemMaterial: function(parameters) {
                    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
                        new THREE.PointsMaterial(parameters)
                },
                Vertex: function(x, y, z) {
                    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
                        new THREE.Vector3(x,y,z)
                }
            }),
            Object.assign(THREE.Box2.prototype, {
                empty: function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
                        this.isEmpty()
                },
                isIntersectionBox: function(box) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
                        this.intersectsBox(box)
                }
            }),
            Object.assign(THREE.Box3.prototype, {
                empty: function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
                        this.isEmpty()
                },
                isIntersectionBox: function(box) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
                        this.intersectsBox(box)
                },
                isIntersectionSphere: function(sphere) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
                        this.intersectsSphere(sphere)
                }
            }),
            Object.assign(THREE.Matrix3.prototype, {
                multiplyVector3: function(vector) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
                        vector.applyMatrix3(this)
                },
                multiplyVector3Array: function(a) {
                    return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."),
                        this.applyToVector3Array(a)
                }
            }),
            Object.assign(THREE.Matrix4.prototype, {
                extractPosition: function(m) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
                        this.copyPosition(m)
                },
                setRotationFromQuaternion: function(q) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
                        this.makeRotationFromQuaternion(q)
                },
                multiplyVector3: function(vector) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."),
                        vector.applyProjection(this)
                },
                multiplyVector4: function(vector) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                        vector.applyMatrix4(this)
                },
                multiplyVector3Array: function(a) {
                    return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."),
                        this.applyToVector3Array(a)
                },
                rotateAxis: function(v) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
                        v.transformDirection(this)
                },
                crossVector: function(vector) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                        vector.applyMatrix4(this)
                },
                translate: function(v) {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function(angle) {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function(angle) {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function(angle) {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function(axis, angle) {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                }
            }),
            Object.assign(THREE.Plane.prototype, {
                isIntersectionLine: function(line) {
                    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
                        this.intersectsLine(line)
                }
            }),
            Object.assign(THREE.Quaternion.prototype, {
                multiplyVector3: function(vector) {
                    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
                        vector.applyQuaternion(this)
                }
            }),
            Object.assign(THREE.Ray.prototype, {
                isIntersectionBox: function(box) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
                        this.intersectsBox(box)
                },
                isIntersectionPlane: function(plane) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
                        this.intersectsPlane(plane)
                },
                isIntersectionSphere: function(sphere) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
                        this.intersectsSphere(sphere)
                }
            }),
            Object.assign(THREE.Vector3.prototype, {
                setEulerFromRotationMatrix: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(m) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
                        this.setFromMatrixPosition(m)
                },
                getScaleFromMatrix: function(m) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
                        this.setFromMatrixScale(m)
                },
                getColumnFromMatrix: function(index, matrix) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
                        this.setFromMatrixColumn(matrix, index)
                }
            }),
            Object.assign(THREE.Object3D.prototype, {
                getChildByName: function(name) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
                        this.getObjectByName(name)
                },
                renderDepth: function(value) {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function(distance, axis) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
                        this.translateOnAxis(axis, distance)
                }
            }),
            Object.defineProperties(THREE.Object3D.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                            this.rotation.order
                    },
                    set: function(value) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                            this.rotation.order = value
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function(value) {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }),
            Object.defineProperties(THREE.LOD.prototype, {
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                            this.levels
                    }
                }
            }),
            THREE.PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
                void 0 !== filmGauge && (this.filmGauge = filmGauge),
                    this.setFocalLength(focalLength)
            }
            ,
            Object.defineProperties(THREE.Light.prototype, {
                onlyShadow: {
                    set: function(value) {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                            this.shadow.camera.fov = value
                    }
                },
                shadowCameraLeft: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                            this.shadow.camera.left = value
                    }
                },
                shadowCameraRight: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                            this.shadow.camera.right = value
                    }
                },
                shadowCameraTop: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                            this.shadow.camera.top = value
                    }
                },
                shadowCameraBottom: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                            this.shadow.camera.bottom = value
                    }
                },
                shadowCameraNear: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                            this.shadow.camera.near = value
                    }
                },
                shadowCameraFar: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                            this.shadow.camera.far = value
                    }
                },
                shadowCameraVisible: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                            this.shadow.bias = value
                    }
                },
                shadowDarkness: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                            this.shadow.mapSize.width = value
                    }
                },
                shadowMapHeight: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                            this.shadow.mapSize.height = value
                    }
                }
            }),
            Object.defineProperties(THREE.BufferAttribute.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."),
                            this.array.length
                    }
                }
            }),
            Object.assign(THREE.BufferGeometry.prototype, {
                addIndex: function(index) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
                        this.setIndex(index)
                },
                addDrawCall: function(start, count, indexOffset) {
                    void 0 !== indexOffset && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
                        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
                        this.addGroup(start, count)
                },
                clearDrawCalls: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
                        this.clearGroups()
                },
                computeTangents: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            }),
            Object.defineProperties(THREE.BufferGeometry.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                            this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                            this.groups
                    }
                }
            }),
            Object.defineProperties(THREE.Material.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                    },
                    set: function(value) {
                        console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE." + this.type + ": .wrapRGB has been removed."),
                            new THREE.Color
                    }
                }
            }),
            Object.defineProperties(THREE.MeshPhongMaterial.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                            !1
                    },
                    set: function(value) {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }),
            Object.defineProperties(THREE.ShaderMaterial.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                            this.extensions.derivatives
                    },
                    set: function(value) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                            this.extensions.derivatives = value
                    }
                }
            }),
            THREE.EventDispatcher.prototype = Object.assign(Object.create({
                constructor: THREE.EventDispatcher,
                apply: function(target) {
                    console.warn("THREE.EventDispatcher: .apply is deprecated, just inherit or Object.assign the prototype to mix-in."),
                        Object.assign(target, this)
                }
            }), THREE.EventDispatcher.prototype),
            Object.assign(THREE.WebGLRenderer.prototype, {
                supportsFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
                        this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
                        this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
                        this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
                        this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
                        this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
                        this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
                        this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(boolean) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
                        this.setScissorTest(boolean)
                },
                initMaterial: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                }
            }),
            Object.defineProperties(THREE.WebGLRenderer.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                            this.shadowMap.enabled = value
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                            this.shadowMap.type = value
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        return this.shadowMap.cullFace
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."),
                            this.shadowMap.cullFace = value
                    }
                }
            }),
            Object.defineProperties(THREE.WebGLShadowMap.prototype, {
                cullFace: {
                    get: function() {
                        return this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack
                    },
                    set: function(cullFace) {
                        var value = cullFace !== THREE.CullFaceBack;
                        console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "."),
                            this.renderReverseSided = value
                    }
                }
            }),
            Object.defineProperties(THREE.WebGLRenderTarget.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                            this.texture.wrapS
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                            this.texture.wrapS = value
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                            this.texture.wrapT
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                            this.texture.wrapT = value
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                            this.texture.magFilter
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                            this.texture.magFilter = value
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                            this.texture.minFilter
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                            this.texture.minFilter = value
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                            this.texture.anisotropy
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                            this.texture.anisotropy = value
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                            this.texture.offset
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                            this.texture.offset = value
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                            this.texture.repeat
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                            this.texture.repeat = value
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                            this.texture.format
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                            this.texture.format = value
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                            this.texture.type
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                            this.texture.type = value
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                            this.texture.generateMipmaps
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                            this.texture.generateMipmaps = value
                    }
                }
            }),
            Object.assign(THREE.Audio.prototype, {
                load: function(file) {
                    console.warn("THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.");
                    var scope = this
                        , audioLoader = new THREE.AudioLoader;
                    return audioLoader.load(file, function(buffer) {
                        scope.setBuffer(buffer)
                    }),
                        this
                }
            }),
        Object.assign(THREE.AudioAnalyser.prototype, {
            getData: function(file) {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
                    this.getFrequencyData()
            }
        }),
        THREE.GeometryUtils = {
            merge: function(geometry1, geometry2, materialIndexOffset) {
                console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                var matrix;
                geometry2 instanceof THREE.Mesh && (geometry2.matrixAutoUpdate && geometry2.updateMatrix(),
                    matrix = geometry2.matrix,
                    geometry2 = geometry2.geometry),
                    geometry1.merge(geometry2, matrix, materialIndexOffset)
            },
            center: function(geometry) {
                return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
                    geometry.center()
            }
        },
        THREE.ImageUtils = {
            crossOrigin: void 0,
            loadTexture: function(url, mapping, onLoad, onError) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var loader = new THREE.TextureLoader;
                loader.setCrossOrigin(this.crossOrigin);
                var texture = loader.load(url, onLoad, void 0, onError);
                return mapping && (texture.mapping = mapping),
                    texture
            },
            loadTextureCube: function(urls, mapping, onLoad, onError) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var loader = new THREE.CubeTextureLoader;
                loader.setCrossOrigin(this.crossOrigin);
                var texture = loader.load(urls, onLoad, void 0, onError);
                return mapping && (texture.mapping = mapping),
                    texture
            },
            loadCompressedTexture: function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            },
            loadCompressedTextureCube: function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            }
        },
        THREE.Projector = function() {
            console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."),
                this.projectVector = function(vector, camera) {
                    console.warn("THREE.Projector: .projectVector() is now vector.project()."),
                        vector.project(camera)
                }
                ,
                this.unprojectVector = function(vector, camera) {
                    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),
                        vector.unproject(camera)
                }
                ,
                this.pickingRay = function(vector, camera) {
                    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                }
        }
        ,
        THREE.CanvasRenderer = function() {
            console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"),
                this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                this.clear = function() {}
                ,
                this.render = function() {}
                ,
                this.setClearColor = function() {}
                ,
                this.setSize = function() {}
        }
        ,
        THREE.CurveUtils = {
            tangentQuadraticBezier: function(t, p0, p1, p2) {
                return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1)
            },
            tangentCubicBezier: function(t, p0, p1, p2, p3) {
                return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3
            },
            tangentSpline: function(t, p0, p1, p2, p3) {
                var h00 = 6 * t * t - 6 * t
                    , h10 = 3 * t * t - 4 * t + 1
                    , h01 = -6 * t * t + 6 * t
                    , h11 = 3 * t * t - 2 * t;
                return h00 + h10 + h01 + h11
            },
            interpolate: function(p0, p1, p2, p3, t) {
                var v0 = .5 * (p2 - p0)
                    , v1 = .5 * (p3 - p1)
                    , t2 = t * t
                    , t3 = t * t2;
                return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1
            }
        },
        THREE.SceneUtils = {
            createMultiMaterialObject: function(geometry, materials) {
                for (var group = new THREE.Group, i = 0, l = materials.length; i < l; i++)
                    group.add(new THREE.Mesh(geometry,materials[i]));
                return group
            },
            detach: function(child, parent, scene) {
                child.applyMatrix(parent.matrixWorld),
                    parent.remove(child),
                    scene.add(child)
            },
            attach: function(child, scene, parent) {
                var matrixWorldInverse = new THREE.Matrix4;
                matrixWorldInverse.getInverse(parent.matrixWorld),
                    child.applyMatrix(matrixWorldInverse),
                    scene.remove(child),
                    parent.add(child)
            }
        },
        THREE.ShapeUtils = {
            area: function(contour) {
                for (var n = contour.length, a = 0, p = n - 1, q = 0; q < n; p = q++)
                    a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
                return .5 * a
            },
            triangulate: function() {
                function snip(contour, u, v, w, n, verts) {
                    var p, ax, ay, bx, by, cx, cy, px, py;
                    if (ax = contour[verts[u]].x,
                            ay = contour[verts[u]].y,
                            bx = contour[verts[v]].x,
                            by = contour[verts[v]].y,
                            cx = contour[verts[w]].x,
                            cy = contour[verts[w]].y,
                        Number.EPSILON > (bx - ax) * (cy - ay) - (by - ay) * (cx - ax))
                        return !1;
                    var aX, aY, bX, bY, cX, cY, apx, apy, bpx, bpy, cpx, cpy, cCROSSap, bCROSScp, aCROSSbp;
                    for (aX = cx - bx,
                             aY = cy - by,
                             bX = ax - cx,
                             bY = ay - cy,
                             cX = bx - ax,
                             cY = by - ay,
                             p = 0; p < n; p++)
                        if (px = contour[verts[p]].x,
                                py = contour[verts[p]].y,
                            !(px === ax && py === ay || px === bx && py === by || px === cx && py === cy) && (apx = px - ax,
                                apy = py - ay,
                                bpx = px - bx,
                                bpy = py - by,
                                cpx = px - cx,
                                cpy = py - cy,
                                aCROSSbp = aX * bpy - aY * bpx,
                                cCROSSap = cX * apy - cY * apx,
                                bCROSScp = bX * cpy - bY * cpx,
                            aCROSSbp >= -Number.EPSILON && bCROSScp >= -Number.EPSILON && cCROSSap >= -Number.EPSILON))
                            return !1;
                    return !0
                }
                return function(contour, indices) {
                    var n = contour.length;
                    if (n < 3)
                        return null;
                    var u, v, w, result = [], verts = [], vertIndices = [];
                    if (THREE.ShapeUtils.area(contour) > 0)
                        for (v = 0; v < n; v++)
                            verts[v] = v;
                    else
                        for (v = 0; v < n; v++)
                            verts[v] = n - 1 - v;
                    var nv = n
                        , count = 2 * nv;
                    for (v = nv - 1; nv > 2; ) {
                        if (count-- <= 0)
                            return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"),
                                indices ? vertIndices : result;
                        if (u = v,
                            nv <= u && (u = 0),
                                v = u + 1,
                            nv <= v && (v = 0),
                                w = v + 1,
                            nv <= w && (w = 0),
                                snip(contour, u, v, w, nv, verts)) {
                            var a, b, c, s, t;
                            for (a = verts[u],
                                     b = verts[v],
                                     c = verts[w],
                                     result.push([contour[a], contour[b], contour[c]]),
                                     vertIndices.push([verts[u], verts[v], verts[w]]),
                                     s = v,
                                     t = v + 1; t < nv; s++,
                                     t++)
                                verts[s] = verts[t];
                            nv--,
                                count = 2 * nv
                        }
                    }
                    return indices ? vertIndices : result
                }
            }(),
            triangulateShape: function(contour, holes) {
                function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
                    return inSegPt1.x !== inSegPt2.x ? inSegPt1.x < inSegPt2.x ? inSegPt1.x <= inOtherPt.x && inOtherPt.x <= inSegPt2.x : inSegPt2.x <= inOtherPt.x && inOtherPt.x <= inSegPt1.x : inSegPt1.y < inSegPt2.y ? inSegPt1.y <= inOtherPt.y && inOtherPt.y <= inSegPt2.y : inSegPt2.y <= inOtherPt.y && inOtherPt.y <= inSegPt1.y
                }
                function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
                    var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x
                        , seg1dy = inSeg1Pt2.y - inSeg1Pt1.y
                        , seg2dx = inSeg2Pt2.x - inSeg2Pt1.x
                        , seg2dy = inSeg2Pt2.y - inSeg2Pt1.y
                        , seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x
                        , seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y
                        , limit = seg1dy * seg2dx - seg1dx * seg2dy
                        , perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
                    if (Math.abs(limit) > Number.EPSILON) {
                        var perpSeg2;
                        if (limit > 0) {
                            if (perpSeg1 < 0 || perpSeg1 > limit)
                                return [];
                            if (perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy,
                                perpSeg2 < 0 || perpSeg2 > limit)
                                return []
                        } else {
                            if (perpSeg1 > 0 || perpSeg1 < limit)
                                return [];
                            if (perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy,
                                perpSeg2 > 0 || perpSeg2 < limit)
                                return []
                        }
                        if (0 === perpSeg2)
                            return !inExcludeAdjacentSegs || 0 !== perpSeg1 && perpSeg1 !== limit ? [inSeg1Pt1] : [];
                        if (perpSeg2 === limit)
                            return !inExcludeAdjacentSegs || 0 !== perpSeg1 && perpSeg1 !== limit ? [inSeg1Pt2] : [];
                        if (0 === perpSeg1)
                            return [inSeg2Pt1];
                        if (perpSeg1 === limit)
                            return [inSeg2Pt2];
                        var factorSeg1 = perpSeg2 / limit;
                        return [{
                            x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                            y: inSeg1Pt1.y + factorSeg1 * seg1dy
                        }]
                    }
                    if (0 !== perpSeg1 || seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy)
                        return [];
                    var seg1Pt = 0 === seg1dx && 0 === seg1dy
                        , seg2Pt = 0 === seg2dx && 0 === seg2dy;
                    if (seg1Pt && seg2Pt)
                        return inSeg1Pt1.x !== inSeg2Pt1.x || inSeg1Pt1.y !== inSeg2Pt1.y ? [] : [inSeg1Pt1];
                    if (seg1Pt)
                        return point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1) ? [inSeg1Pt1] : [];
                    if (seg2Pt)
                        return point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1) ? [inSeg2Pt1] : [];
                    var seg1min, seg1max, seg1minVal, seg1maxVal, seg2min, seg2max, seg2minVal, seg2maxVal;
                    return 0 !== seg1dx ? (inSeg1Pt1.x < inSeg1Pt2.x ? (seg1min = inSeg1Pt1,
                        seg1minVal = inSeg1Pt1.x,
                        seg1max = inSeg1Pt2,
                        seg1maxVal = inSeg1Pt2.x) : (seg1min = inSeg1Pt2,
                        seg1minVal = inSeg1Pt2.x,
                        seg1max = inSeg1Pt1,
                        seg1maxVal = inSeg1Pt1.x),
                        inSeg2Pt1.x < inSeg2Pt2.x ? (seg2min = inSeg2Pt1,
                            seg2minVal = inSeg2Pt1.x,
                            seg2max = inSeg2Pt2,
                            seg2maxVal = inSeg2Pt2.x) : (seg2min = inSeg2Pt2,
                            seg2minVal = inSeg2Pt2.x,
                            seg2max = inSeg2Pt1,
                            seg2maxVal = inSeg2Pt1.x)) : (inSeg1Pt1.y < inSeg1Pt2.y ? (seg1min = inSeg1Pt1,
                        seg1minVal = inSeg1Pt1.y,
                        seg1max = inSeg1Pt2,
                        seg1maxVal = inSeg1Pt2.y) : (seg1min = inSeg1Pt2,
                        seg1minVal = inSeg1Pt2.y,
                        seg1max = inSeg1Pt1,
                        seg1maxVal = inSeg1Pt1.y),
                        inSeg2Pt1.y < inSeg2Pt2.y ? (seg2min = inSeg2Pt1,
                            seg2minVal = inSeg2Pt1.y,
                            seg2max = inSeg2Pt2,
                            seg2maxVal = inSeg2Pt2.y) : (seg2min = inSeg2Pt2,
                            seg2minVal = inSeg2Pt2.y,
                            seg2max = inSeg2Pt1,
                            seg2maxVal = inSeg2Pt1.y)),
                        seg1minVal <= seg2minVal ? seg1maxVal < seg2minVal ? [] : seg1maxVal === seg2minVal ? inExcludeAdjacentSegs ? [] : [seg2min] : seg1maxVal <= seg2maxVal ? [seg2min, seg1max] : [seg2min, seg2max] : seg1minVal > seg2maxVal ? [] : seg1minVal === seg2maxVal ? inExcludeAdjacentSegs ? [] : [seg1min] : seg1maxVal <= seg2maxVal ? [seg1min, seg1max] : [seg1min, seg2max]
                }
                function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
                    var legFromPtX = inLegFromPt.x - inVertex.x
                        , legFromPtY = inLegFromPt.y - inVertex.y
                        , legToPtX = inLegToPt.x - inVertex.x
                        , legToPtY = inLegToPt.y - inVertex.y
                        , otherPtX = inOtherPt.x - inVertex.x
                        , otherPtY = inOtherPt.y - inVertex.y
                        , from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX
                        , from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
                    if (Math.abs(from2toAngle) > Number.EPSILON) {
                        var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                        return from2toAngle > 0 ? from2otherAngle >= 0 && other2toAngle >= 0 : from2otherAngle >= 0 || other2toAngle >= 0
                    }
                    return from2otherAngle > 0
                }
                function removeHoles(contour, holes) {
                    function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
                        var lastShapeIdx = shape.length - 1
                            , prevShapeIdx = inShapeIdx - 1;
                        prevShapeIdx < 0 && (prevShapeIdx = lastShapeIdx);
                        var nextShapeIdx = inShapeIdx + 1;
                        nextShapeIdx > lastShapeIdx && (nextShapeIdx = 0);
                        var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
                        if (!insideAngle)
                            return !1;
                        var lastHoleIdx = hole.length - 1
                            , prevHoleIdx = inHoleIdx - 1;
                        prevHoleIdx < 0 && (prevHoleIdx = lastHoleIdx);
                        var nextHoleIdx = inHoleIdx + 1;
                        return nextHoleIdx > lastHoleIdx && (nextHoleIdx = 0),
                            insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]),
                            !!insideAngle
                    }
                    function intersectsShapeEdge(inShapePt, inHolePt) {
                        var sIdx, nextIdx, intersection;
                        for (sIdx = 0; sIdx < shape.length; sIdx++)
                            if (nextIdx = sIdx + 1,
                                    nextIdx %= shape.length,
                                    intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], !0),
                                intersection.length > 0)
                                return !0;
                        return !1
                    }
                    function intersectsHoleEdge(inShapePt, inHolePt) {
                        var ihIdx, chkHole, hIdx, nextIdx, intersection;
                        for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++)
                            for (chkHole = holes[indepHoles[ihIdx]],
                                     hIdx = 0; hIdx < chkHole.length; hIdx++)
                                if (nextIdx = hIdx + 1,
                                        nextIdx %= chkHole.length,
                                        intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], !0),
                                    intersection.length > 0)
                                    return !0;
                        return !1
                    }
                    for (var hole, holeIndex, shapeIndex, shapePt, holePt, holeIdx, cutKey, tmpShape1, tmpShape2, tmpHole1, tmpHole2, shape = contour.concat(), indepHoles = [], failedCuts = [], h = 0, hl = holes.length; h < hl; h++)
                        indepHoles.push(h);
                    for (var minShapeIndex = 0, counter = 2 * indepHoles.length; indepHoles.length > 0; ) {
                        if (counter--,
                            counter < 0) {
                            console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
                            break
                        }
                        for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
                            shapePt = shape[shapeIndex],
                                holeIndex = -1;
                            for (var h = 0; h < indepHoles.length; h++)
                                if (holeIdx = indepHoles[h],
                                        cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx,
                                    void 0 === failedCuts[cutKey]) {
                                    hole = holes[holeIdx];
                                    for (var h2 = 0; h2 < hole.length; h2++)
                                        if (holePt = hole[h2],
                                            isCutLineInsideAngles(shapeIndex, h2) && !intersectsShapeEdge(shapePt, holePt) && !intersectsHoleEdge(shapePt, holePt)) {
                                            holeIndex = h2,
                                                indepHoles.splice(h, 1),
                                                tmpShape1 = shape.slice(0, shapeIndex + 1),
                                                tmpShape2 = shape.slice(shapeIndex),
                                                tmpHole1 = hole.slice(holeIndex),
                                                tmpHole2 = hole.slice(0, holeIndex + 1),
                                                shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2),
                                                minShapeIndex = shapeIndex;
                                            break
                                        }
                                    if (holeIndex >= 0)
                                        break;
                                    failedCuts[cutKey] = !0
                                }
                            if (holeIndex >= 0)
                                break
                        }
                    }
                    return shape
                }
                for (var i, il, f, face, key, index, allPointsMap = {}, allpoints = contour.concat(), h = 0, hl = holes.length; h < hl; h++)
                    Array.prototype.push.apply(allpoints, holes[h]);
                for (i = 0,
                         il = allpoints.length; i < il; i++)
                    key = allpoints[i].x + ":" + allpoints[i].y,
                    void 0 !== allPointsMap[key] && console.warn("THREE.Shape: Duplicate point", key),
                        allPointsMap[key] = i;
                var shapeWithoutHoles = removeHoles(contour, holes)
                    , triangles = THREE.ShapeUtils.triangulate(shapeWithoutHoles, !1);
                for (i = 0,
                         il = triangles.length; i < il; i++)
                    for (face = triangles[i],
                             f = 0; f < 3; f++)
                        key = face[f].x + ":" + face[f].y,
                            index = allPointsMap[key],
                        void 0 !== index && (face[f] = index);
                return triangles.concat()
            },
            isClockWise: function(pts) {
                return THREE.ShapeUtils.area(pts) < 0
            },
            b2: function() {
                function b2p0(t, p) {
                    var k = 1 - t;
                    return k * k * p
                }
                function b2p1(t, p) {
                    return 2 * (1 - t) * t * p
                }
                function b2p2(t, p) {
                    return t * t * p
                }
                return function(t, p0, p1, p2) {
                    return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2)
                }
            }(),
            b3: function() {
                function b3p0(t, p) {
                    var k = 1 - t;
                    return k * k * k * p
                }
                function b3p1(t, p) {
                    var k = 1 - t;
                    return 3 * k * k * t * p
                }
                function b3p2(t, p) {
                    var k = 1 - t;
                    return 3 * k * t * t * p
                }
                function b3p3(t, p) {
                    return t * t * t * p
                }
                return function(t, p0, p1, p2, p3) {
                    return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3)
                }
            }()
        },
        THREE.Curve = function() {}
        ,
        THREE.Curve.prototype = {
            constructor: THREE.Curve,
            getPoint: function(t) {
                return console.warn("THREE.Curve: Warning, getPoint() not implemented!"),
                    null
            },
            getPointAt: function(u) {
                var t = this.getUtoTmapping(u);
                return this.getPoint(t)
            },
            getPoints: function(divisions) {
                divisions || (divisions = 5);
                var d, pts = [];
                for (d = 0; d <= divisions; d++)
                    pts.push(this.getPoint(d / divisions));
                return pts
            },
            getSpacedPoints: function(divisions) {
                divisions || (divisions = 5);
                var d, pts = [];
                for (d = 0; d <= divisions; d++)
                    pts.push(this.getPointAt(d / divisions));
                return pts
            },
            getLength: function() {
                var lengths = this.getLengths();
                return lengths[lengths.length - 1]
            },
            getLengths: function(divisions) {
                if (divisions || (divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200),
                    this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate)
                    return this.cacheArcLengths;
                this.needsUpdate = !1;
                var current, p, cache = [], last = this.getPoint(0), sum = 0;
                for (cache.push(0),
                         p = 1; p <= divisions; p++)
                    current = this.getPoint(p / divisions),
                        sum += current.distanceTo(last),
                        cache.push(sum),
                        last = current;
                return this.cacheArcLengths = cache,
                    cache
            },
            updateArcLengths: function() {
                this.needsUpdate = !0,
                    this.getLengths()
            },
            getUtoTmapping: function(u, distance) {
                var targetArcLength, arcLengths = this.getLengths(), i = 0, il = arcLengths.length;
                targetArcLength = distance ? distance : u * arcLengths[il - 1];
                for (var comparison, low = 0, high = il - 1; low <= high; )
                    if (i = Math.floor(low + (high - low) / 2),
                            comparison = arcLengths[i] - targetArcLength,
                        comparison < 0)
                        low = i + 1;
                    else {
                        if (!(comparison > 0)) {
                            high = i;
                            break
                        }
                        high = i - 1
                    }
                if (i = high,
                    arcLengths[i] === targetArcLength) {
                    var t = i / (il - 1);
                    return t
                }
                var lengthBefore = arcLengths[i]
                    , lengthAfter = arcLengths[i + 1]
                    , segmentLength = lengthAfter - lengthBefore
                    , segmentFraction = (targetArcLength - lengthBefore) / segmentLength
                    , t = (i + segmentFraction) / (il - 1);
                return t
            },
            getTangent: function(t) {
                var delta = 1e-4
                    , t1 = t - delta
                    , t2 = t + delta;
                t1 < 0 && (t1 = 0),
                t2 > 1 && (t2 = 1);
                var pt1 = this.getPoint(t1)
                    , pt2 = this.getPoint(t2)
                    , vec = pt2.clone().sub(pt1);
                return vec.normalize()
            },
            getTangentAt: function(u) {
                var t = this.getUtoTmapping(u);
                return this.getTangent(t)
            }
        },
        THREE.Curve.create = function(constructor, getPointFunc) {
            return constructor.prototype = Object.create(THREE.Curve.prototype),
                constructor.prototype.constructor = constructor,
                constructor.prototype.getPoint = getPointFunc,
                constructor
        }
        ,
        THREE.CurvePath = function() {
            this.curves = [],
                this.autoClose = !1
        }
        ,
        THREE.CurvePath.prototype = Object.assign(Object.create(THREE.Curve.prototype), {
            constructor: THREE.CurvePath,
            add: function(curve) {
                this.curves.push(curve)
            },
            closePath: function() {
                var startPoint = this.curves[0].getPoint(0)
                    , endPoint = this.curves[this.curves.length - 1].getPoint(1);
                startPoint.equals(endPoint) || this.curves.push(new THREE.LineCurve(endPoint,startPoint))
            },
            getPoint: function(t) {
                for (var d = t * this.getLength(), curveLengths = this.getCurveLengths(), i = 0; i < curveLengths.length; ) {
                    if (curveLengths[i] >= d) {
                        var diff = curveLengths[i] - d
                            , curve = this.curves[i]
                            , u = 1 - diff / curve.getLength();
                        return curve.getPointAt(u)
                    }
                    i++
                }
                return null
            },
            getLength: function() {
                var lens = this.getCurveLengths();
                return lens[lens.length - 1]
            },
            updateArcLengths: function() {
                this.needsUpdate = !0,
                    this.cacheLengths = null,
                    this.getLengths()
            },
            getCurveLengths: function() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                    return this.cacheLengths;
                for (var lengths = [], sums = 0, i = 0, l = this.curves.length; i < l; i++)
                    sums += this.curves[i].getLength(),
                        lengths.push(sums);
                return this.cacheLengths = lengths,
                    lengths
            },
            createPointsGeometry: function(divisions) {
                var pts = this.getPoints(divisions);
                return this.createGeometry(pts)
            },
            createSpacedPointsGeometry: function(divisions) {
                var pts = this.getSpacedPoints(divisions);
                return this.createGeometry(pts)
            },
            createGeometry: function(points) {
                for (var geometry = new THREE.Geometry, i = 0, l = points.length; i < l; i++) {
                    var point = points[i];
                    geometry.vertices.push(new THREE.Vector3(point.x,point.y,point.z || 0))
                }
                return geometry
            }
        }),
        THREE.Font = function(data) {
            this.data = data
        }
        ,
        Object.assign(THREE.Font.prototype, {
            generateShapes: function(text, size, divisions) {
                function createPaths(text) {
                    for (var chars = String(text).split(""), scale = size / data.resolution, offset = 0, paths = [], i = 0; i < chars.length; i++) {
                        var ret = createPath(chars[i], scale, offset);
                        offset += ret.offset,
                            paths.push(ret.path)
                    }
                    return paths
                }
                function createPath(c, scale, offset) {
                    var glyph = data.glyphs[c] || data.glyphs["?"];
                    if (glyph) {
                        var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste, path = new THREE.Path, pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;
                        if (glyph.o)
                            for (var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" ")), i = 0, l = outline.length; i < l; ) {
                                var action = outline[i++];
                                switch (action) {
                                    case "m":
                                        x = outline[i++] * scale + offset,
                                            y = outline[i++] * scale,
                                            path.moveTo(x, y);
                                        break;
                                    case "l":
                                        x = outline[i++] * scale + offset,
                                            y = outline[i++] * scale,
                                            path.lineTo(x, y);
                                        break;
                                    case "q":
                                        if (cpx = outline[i++] * scale + offset,
                                                cpy = outline[i++] * scale,
                                                cpx1 = outline[i++] * scale + offset,
                                                cpy1 = outline[i++] * scale,
                                                path.quadraticCurveTo(cpx1, cpy1, cpx, cpy),
                                                laste = pts[pts.length - 1]) {
                                            cpx0 = laste.x,
                                                cpy0 = laste.y;
                                            for (var i2 = 1; i2 <= divisions; i2++) {
                                                var t = i2 / divisions;
                                                b2(t, cpx0, cpx1, cpx),
                                                    b2(t, cpy0, cpy1, cpy)
                                            }
                                        }
                                        break;
                                    case "b":
                                        if (cpx = outline[i++] * scale + offset,
                                                cpy = outline[i++] * scale,
                                                cpx1 = outline[i++] * scale + offset,
                                                cpy1 = outline[i++] * scale,
                                                cpx2 = outline[i++] * scale + offset,
                                                cpy2 = outline[i++] * scale,
                                                path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy),
                                                laste = pts[pts.length - 1]) {
                                            cpx0 = laste.x,
                                                cpy0 = laste.y;
                                            for (var i2 = 1; i2 <= divisions; i2++) {
                                                var t = i2 / divisions;
                                                b3(t, cpx0, cpx1, cpx2, cpx),
                                                    b3(t, cpy0, cpy1, cpy2, cpy)
                                            }
                                        }
                                }
                            }
                        return {
                            offset: glyph.ha * scale,
                            path: path
                        }
                    }
                }
                void 0 === size && (size = 100),
                void 0 === divisions && (divisions = 4);
                for (var data = this.data, paths = createPaths(text), shapes = [], p = 0, pl = paths.length; p < pl; p++)
                    Array.prototype.push.apply(shapes, paths[p].toShapes());
                return shapes
            }
        }),
        THREE.Path = function(points) {
            THREE.CurvePath.call(this),
                this.actions = [],
            points && this.fromPoints(points)
        }
        ,
        THREE.Path.prototype = Object.assign(Object.create(THREE.CurvePath.prototype), {
            constructor: THREE.Path,
            fromPoints: function(vectors) {
                this.moveTo(vectors[0].x, vectors[0].y);
                for (var i = 1, l = vectors.length; i < l; i++)
                    this.lineTo(vectors[i].x, vectors[i].y)
            },
            moveTo: function(x, y) {
                this.actions.push({
                    action: "moveTo",
                    args: [x, y]
                })
            },
            lineTo: function(x, y) {
                var lastargs = this.actions[this.actions.length - 1].args
                    , x0 = lastargs[lastargs.length - 2]
                    , y0 = lastargs[lastargs.length - 1]
                    , curve = new THREE.LineCurve(new THREE.Vector2(x0,y0),new THREE.Vector2(x,y));
                this.curves.push(curve),
                    this.actions.push({
                        action: "lineTo",
                        args: [x, y]
                    })
            },
            quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
                var lastargs = this.actions[this.actions.length - 1].args
                    , x0 = lastargs[lastargs.length - 2]
                    , y0 = lastargs[lastargs.length - 1]
                    , curve = new THREE.QuadraticBezierCurve(new THREE.Vector2(x0,y0),new THREE.Vector2(aCPx,aCPy),new THREE.Vector2(aX,aY));
                this.curves.push(curve),
                    this.actions.push({
                        action: "quadraticCurveTo",
                        args: [aCPx, aCPy, aX, aY]
                    })
            },
            bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
                var lastargs = this.actions[this.actions.length - 1].args
                    , x0 = lastargs[lastargs.length - 2]
                    , y0 = lastargs[lastargs.length - 1]
                    , curve = new THREE.CubicBezierCurve(new THREE.Vector2(x0,y0),new THREE.Vector2(aCP1x,aCP1y),new THREE.Vector2(aCP2x,aCP2y),new THREE.Vector2(aX,aY));
                this.curves.push(curve),
                    this.actions.push({
                        action: "bezierCurveTo",
                        args: [aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]
                    })
            },
            splineThru: function(pts) {
                var args = Array.prototype.slice.call(arguments)
                    , lastargs = this.actions[this.actions.length - 1].args
                    , x0 = lastargs[lastargs.length - 2]
                    , y0 = lastargs[lastargs.length - 1]
                    , npts = [new THREE.Vector2(x0,y0)];
                Array.prototype.push.apply(npts, pts);
                var curve = new THREE.SplineCurve(npts);
                this.curves.push(curve);
                var lastPoint = pts[pts.length - 1];
                args.push(lastPoint.x),
                    args.push(lastPoint.y),
                    this.actions.push({
                        action: "splineThru",
                        args: args
                    })
            },
            arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                var lastargs = this.actions[this.actions.length - 1].args
                    , x0 = lastargs[lastargs.length - 2]
                    , y0 = lastargs[lastargs.length - 1];
                this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise)
            },
            absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise)
            },
            ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
                var lastargs = this.actions[this.actions.length - 1].args
                    , x0 = lastargs[lastargs.length - 2]
                    , y0 = lastargs[lastargs.length - 1];
                this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation)
            },
            absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
                var args = [aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation || 0]
                    , curve = new THREE.EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);
                this.curves.push(curve);
                var lastPoint = curve.getPoint(1);
                args.push(lastPoint.x),
                    args.push(lastPoint.y),
                    this.actions.push({
                        action: "ellipse",
                        args: args
                    })
            },
            getSpacedPoints: function(divisions) {
                divisions || (divisions = 40);
                for (var points = [], i = 0; i < divisions; i++)
                    points.push(this.getPoint(i / divisions));
                return this.autoClose && points.push(points[0]),
                    points
            },
            getPoints: function(divisions) {
                divisions = divisions || 12;
                for (var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0, laste, tx, ty, b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3, points = [], i = 0, l = this.actions.length; i < l; i++) {
                    var item = this.actions[i]
                        , action = item.action
                        , args = item.args;
                    switch (action) {
                        case "moveTo":
                            points.push(new THREE.Vector2(args[0],args[1]));
                            break;
                        case "lineTo":
                            points.push(new THREE.Vector2(args[0],args[1]));
                            break;
                        case "quadraticCurveTo":
                            cpx = args[2],
                                cpy = args[3],
                                cpx1 = args[0],
                                cpy1 = args[1],
                                points.length > 0 ? (laste = points[points.length - 1],
                                    cpx0 = laste.x,
                                    cpy0 = laste.y) : (laste = this.actions[i - 1].args,
                                    cpx0 = laste[laste.length - 2],
                                    cpy0 = laste[laste.length - 1]);
                            for (var j = 1; j <= divisions; j++) {
                                var t = j / divisions;
                                tx = b2(t, cpx0, cpx1, cpx),
                                    ty = b2(t, cpy0, cpy1, cpy),
                                    points.push(new THREE.Vector2(tx,ty))
                            }
                            break;
                        case "bezierCurveTo":
                            cpx = args[4],
                                cpy = args[5],
                                cpx1 = args[0],
                                cpy1 = args[1],
                                cpx2 = args[2],
                                cpy2 = args[3],
                                points.length > 0 ? (laste = points[points.length - 1],
                                    cpx0 = laste.x,
                                    cpy0 = laste.y) : (laste = this.actions[i - 1].args,
                                    cpx0 = laste[laste.length - 2],
                                    cpy0 = laste[laste.length - 1]);
                            for (var j = 1; j <= divisions; j++) {
                                var t = j / divisions;
                                tx = b3(t, cpx0, cpx1, cpx2, cpx),
                                    ty = b3(t, cpy0, cpy1, cpy2, cpy),
                                    points.push(new THREE.Vector2(tx,ty))
                            }
                            break;
                        case "splineThru":
                            laste = this.actions[i - 1].args;
                            var last = new THREE.Vector2(laste[laste.length - 2],laste[laste.length - 1])
                                , spts = [last]
                                , n = divisions * args[0].length;
                            spts = spts.concat(args[0]);
                            for (var spline = new THREE.SplineCurve(spts), j = 1; j <= n; j++)
                                points.push(spline.getPointAt(j / n));
                            break;
                        case "arc":
                            for (var angle, aX = args[0], aY = args[1], aRadius = args[2], aStartAngle = args[3], aEndAngle = args[4], aClockwise = !!args[5], deltaAngle = aEndAngle - aStartAngle, tdivisions = 2 * divisions, j = 1; j <= tdivisions; j++) {
                                var t = j / tdivisions;
                                aClockwise || (t = 1 - t),
                                    angle = aStartAngle + t * deltaAngle,
                                    tx = aX + aRadius * Math.cos(angle),
                                    ty = aY + aRadius * Math.sin(angle),
                                    points.push(new THREE.Vector2(tx,ty))
                            }
                            break;
                        case "ellipse":
                            var angle, cos, sin, aX = args[0], aY = args[1], xRadius = args[2], yRadius = args[3], aStartAngle = args[4], aEndAngle = args[5], aClockwise = !!args[6], aRotation = args[7], deltaAngle = aEndAngle - aStartAngle, tdivisions = 2 * divisions;
                            0 !== aRotation && (cos = Math.cos(aRotation),
                                sin = Math.sin(aRotation));
                            for (var j = 1; j <= tdivisions; j++) {
                                var t = j / tdivisions;
                                if (aClockwise || (t = 1 - t),
                                        angle = aStartAngle + t * deltaAngle,
                                        tx = aX + xRadius * Math.cos(angle),
                                        ty = aY + yRadius * Math.sin(angle),
                                    0 !== aRotation) {
                                    var x = tx
                                        , y = ty;
                                    tx = (x - aX) * cos - (y - aY) * sin + aX,
                                        ty = (x - aX) * sin + (y - aY) * cos + aY
                                }
                                points.push(new THREE.Vector2(tx,ty))
                            }
                    }
                }
                var lastPoint = points[points.length - 1];
                return Math.abs(lastPoint.x - points[0].x) < Number.EPSILON && Math.abs(lastPoint.y - points[0].y) < Number.EPSILON && points.splice(points.length - 1, 1),
                this.autoClose && points.push(points[0]),
                    points
            },
            toShapes: function(isCCW, noHoles) {
                function extractSubpaths(inActions) {
                    for (var subPaths = [], lastPath = new THREE.Path, i = 0, l = inActions.length; i < l; i++) {
                        var item = inActions[i]
                            , args = item.args
                            , action = item.action;
                        "moveTo" === action && 0 !== lastPath.actions.length && (subPaths.push(lastPath),
                            lastPath = new THREE.Path),
                            lastPath[action].apply(lastPath, args)
                    }
                    return 0 !== lastPath.actions.length && subPaths.push(lastPath),
                        subPaths
                }
                function toShapesNoHoles(inSubpaths) {
                    for (var shapes = [], i = 0, l = inSubpaths.length; i < l; i++) {
                        var tmpPath = inSubpaths[i]
                            , tmpShape = new THREE.Shape;
                        tmpShape.actions = tmpPath.actions,
                            tmpShape.curves = tmpPath.curves,
                            shapes.push(tmpShape)
                    }
                    return shapes
                }
                function isPointInsidePolygon(inPt, inPolygon) {
                    for (var polyLen = inPolygon.length, inside = !1, p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                        var edgeLowPt = inPolygon[p]
                            , edgeHighPt = inPolygon[q]
                            , edgeDx = edgeHighPt.x - edgeLowPt.x
                            , edgeDy = edgeHighPt.y - edgeLowPt.y;
                        if (Math.abs(edgeDy) > Number.EPSILON) {
                            if (edgeDy < 0 && (edgeLowPt = inPolygon[q],
                                    edgeDx = -edgeDx,
                                    edgeHighPt = inPolygon[p],
                                    edgeDy = -edgeDy),
                                inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                                continue;
                            if (inPt.y === edgeLowPt.y) {
                                if (inPt.x === edgeLowPt.x)
                                    return !0
                            } else {
                                var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                                if (0 === perpEdge)
                                    return !0;
                                if (perpEdge < 0)
                                    continue;
                                inside = !inside
                            }
                        } else {
                            if (inPt.y !== edgeLowPt.y)
                                continue;
                            if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                                return !0
                        }
                    }
                    return inside
                }
                var isClockWise = THREE.ShapeUtils.isClockWise
                    , subPaths = extractSubpaths(this.actions);
                if (0 === subPaths.length)
                    return [];
                if (noHoles === !0)
                    return toShapesNoHoles(subPaths);
                var solid, tmpPath, tmpShape, shapes = [];
                if (1 === subPaths.length)
                    return tmpPath = subPaths[0],
                        tmpShape = new THREE.Shape,
                        tmpShape.actions = tmpPath.actions,
                        tmpShape.curves = tmpPath.curves,
                        shapes.push(tmpShape),
                        shapes;
                var holesFirst = !isClockWise(subPaths[0].getPoints());
                holesFirst = isCCW ? !holesFirst : holesFirst;
                var tmpPoints, betterShapeHoles = [], newShapes = [], newShapeHoles = [], mainIdx = 0;
                newShapes[mainIdx] = void 0,
                    newShapeHoles[mainIdx] = [];
                for (var i = 0, l = subPaths.length; i < l; i++)
                    tmpPath = subPaths[i],
                        tmpPoints = tmpPath.getPoints(),
                        solid = isClockWise(tmpPoints),
                        solid = isCCW ? !solid : solid,
                        solid ? (!holesFirst && newShapes[mainIdx] && mainIdx++,
                            newShapes[mainIdx] = {
                                s: new THREE.Shape,
                                p: tmpPoints
                            },
                            newShapes[mainIdx].s.actions = tmpPath.actions,
                            newShapes[mainIdx].s.curves = tmpPath.curves,
                        holesFirst && mainIdx++,
                            newShapeHoles[mainIdx] = []) : newShapeHoles[mainIdx].push({
                            h: tmpPath,
                            p: tmpPoints[0]
                        });
                if (!newShapes[0])
                    return toShapesNoHoles(subPaths);
                if (newShapes.length > 1) {
                    for (var ambiguous = !1, toChange = [], sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++)
                        betterShapeHoles[sIdx] = [];
                    for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++)
                        for (var sho = newShapeHoles[sIdx], hIdx = 0; hIdx < sho.length; hIdx++) {
                            for (var ho = sho[hIdx], hole_unassigned = !0, s2Idx = 0; s2Idx < newShapes.length; s2Idx++)
                                isPointInsidePolygon(ho.p, newShapes[s2Idx].p) && (sIdx !== s2Idx && toChange.push({
                                    froms: sIdx,
                                    tos: s2Idx,
                                    hole: hIdx
                                }),
                                    hole_unassigned ? (hole_unassigned = !1,
                                        betterShapeHoles[s2Idx].push(ho)) : ambiguous = !0);
                            hole_unassigned && betterShapeHoles[sIdx].push(ho)
                        }
                    toChange.length > 0 && (ambiguous || (newShapeHoles = betterShapeHoles))
                }
                for (var tmpHoles, i = 0, il = newShapes.length; i < il; i++) {
                    tmpShape = newShapes[i].s,
                        shapes.push(tmpShape),
                        tmpHoles = newShapeHoles[i];
                    for (var j = 0, jl = tmpHoles.length; j < jl; j++)
                        tmpShape.holes.push(tmpHoles[j].h)
                }
                return shapes
            }
        }),
        THREE.Shape = function() {
            THREE.Path.apply(this, arguments),
                this.holes = []
        }
        ,
        THREE.Shape.prototype = Object.assign(Object.create(THREE.Path.prototype), {
            constructor: THREE.Shape,
            extrude: function(options) {
                return new THREE.ExtrudeGeometry(this,options)
            },
            makeGeometry: function(options) {
                return new THREE.ShapeGeometry(this,options)
            },
            getPointsHoles: function(divisions) {
                for (var holesPts = [], i = 0, l = this.holes.length; i < l; i++)
                    holesPts[i] = this.holes[i].getPoints(divisions);
                return holesPts
            },
            extractAllPoints: function(divisions) {
                return {
                    shape: this.getPoints(divisions),
                    holes: this.getPointsHoles(divisions)
                }
            },
            extractPoints: function(divisions) {
                return this.extractAllPoints(divisions)
            }
        }),
        THREE.LineCurve = function(v1, v2) {
            this.v1 = v1,
                this.v2 = v2
        }
        ,
        THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype),
        THREE.LineCurve.prototype.constructor = THREE.LineCurve,
        THREE.LineCurve.prototype.getPoint = function(t) {
            var point = this.v2.clone().sub(this.v1);
            return point.multiplyScalar(t).add(this.v1),
                point
        }
        ,
        THREE.LineCurve.prototype.getPointAt = function(u) {
            return this.getPoint(u)
        }
        ,
        THREE.LineCurve.prototype.getTangent = function(t) {
            var tangent = this.v2.clone().sub(this.v1);
            return tangent.normalize()
        }
        ,
        THREE.QuadraticBezierCurve = function(v0, v1, v2) {
            this.v0 = v0,
                this.v1 = v1,
                this.v2 = v2
        }
        ,
        THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype),
        THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve,
        THREE.QuadraticBezierCurve.prototype.getPoint = function(t) {
            var b2 = THREE.ShapeUtils.b2;
            return new THREE.Vector2(b2(t, this.v0.x, this.v1.x, this.v2.x),b2(t, this.v0.y, this.v1.y, this.v2.y))
        }
        ,
        THREE.QuadraticBezierCurve.prototype.getTangent = function(t) {
            var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;
            return new THREE.Vector2(tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x),tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y)).normalize()
        }
        ,
        THREE.CubicBezierCurve = function(v0, v1, v2, v3) {
            this.v0 = v0,
                this.v1 = v1,
                this.v2 = v2,
                this.v3 = v3
        }
        ,
        THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype),
        THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve,
        THREE.CubicBezierCurve.prototype.getPoint = function(t) {
            var b3 = THREE.ShapeUtils.b3;
            return new THREE.Vector2(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y))
        }
        ,
        THREE.CubicBezierCurve.prototype.getTangent = function(t) {
            var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;
            return new THREE.Vector2(tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize()
        }
        ,
        THREE.SplineCurve = function(points) {
            this.points = void 0 == points ? [] : points
        }
        ,
        THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype),
        THREE.SplineCurve.prototype.constructor = THREE.SplineCurve,
        THREE.SplineCurve.prototype.getPoint = function(t) {
            var points = this.points
                , point = (points.length - 1) * t
                , intPoint = Math.floor(point)
                , weight = point - intPoint
                , point0 = points[0 === intPoint ? intPoint : intPoint - 1]
                , point1 = points[intPoint]
                , point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1]
                , point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2]
                , interpolate = THREE.CurveUtils.interpolate;
            return new THREE.Vector2(interpolate(point0.x, point1.x, point2.x, point3.x, weight),interpolate(point0.y, point1.y, point2.y, point3.y, weight))
        }
        ,
        THREE.EllipseCurve = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            this.aX = aX,
                this.aY = aY,
                this.xRadius = xRadius,
                this.yRadius = yRadius,
                this.aStartAngle = aStartAngle,
                this.aEndAngle = aEndAngle,
                this.aClockwise = aClockwise,
                this.aRotation = aRotation || 0
        }
        ,
        THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype),
        THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve,
        THREE.EllipseCurve.prototype.getPoint = function(t) {
            var deltaAngle = this.aEndAngle - this.aStartAngle;
            deltaAngle < 0 && (deltaAngle += 2 * Math.PI),
            deltaAngle > 2 * Math.PI && (deltaAngle -= 2 * Math.PI);
            var angle;
            angle = this.aClockwise === !0 ? this.aEndAngle + (1 - t) * (2 * Math.PI - deltaAngle) : this.aStartAngle + t * deltaAngle;
            var x = this.aX + this.xRadius * Math.cos(angle)
                , y = this.aY + this.yRadius * Math.sin(angle);
            if (0 !== this.aRotation) {
                var cos = Math.cos(this.aRotation)
                    , sin = Math.sin(this.aRotation)
                    , tx = x
                    , ty = y;
                x = (tx - this.aX) * cos - (ty - this.aY) * sin + this.aX,
                    y = (tx - this.aX) * sin + (ty - this.aY) * cos + this.aY
            }
            return new THREE.Vector2(x,y)
        }
        ,
        THREE.ArcCurve = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            THREE.EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise)
        }
        ,
        THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype),
        THREE.ArcCurve.prototype.constructor = THREE.ArcCurve,
        THREE.LineCurve3 = THREE.Curve.create(function(v1, v2) {
            this.v1 = v1,
                this.v2 = v2
        }, function(t) {
            var vector = new THREE.Vector3;
            return vector.subVectors(this.v2, this.v1),
                vector.multiplyScalar(t),
                vector.add(this.v1),
                vector
        }),
        THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(v0, v1, v2) {
            this.v0 = v0,
                this.v1 = v1,
                this.v2 = v2
        }, function(t) {
            var b2 = THREE.ShapeUtils.b2;
            return new THREE.Vector3(b2(t, this.v0.x, this.v1.x, this.v2.x),b2(t, this.v0.y, this.v1.y, this.v2.y),b2(t, this.v0.z, this.v1.z, this.v2.z))
        }),
        THREE.CubicBezierCurve3 = THREE.Curve.create(function(v0, v1, v2, v3) {
            this.v0 = v0,
                this.v1 = v1,
                this.v2 = v2,
                this.v3 = v3
        }, function(t) {
            var b3 = THREE.ShapeUtils.b3;
            return new THREE.Vector3(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y),b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z))
        }),
        THREE.SplineCurve3 = THREE.Curve.create(function(points) {
            console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"),
                this.points = void 0 == points ? [] : points
        }, function(t) {
            var points = this.points
                , point = (points.length - 1) * t
                , intPoint = Math.floor(point)
                , weight = point - intPoint
                , point0 = points[0 == intPoint ? intPoint : intPoint - 1]
                , point1 = points[intPoint]
                , point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1]
                , point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2]
                , interpolate = THREE.CurveUtils.interpolate;
            return new THREE.Vector3(interpolate(point0.x, point1.x, point2.x, point3.x, weight),interpolate(point0.y, point1.y, point2.y, point3.y, weight),interpolate(point0.z, point1.z, point2.z, point3.z, weight))
        }),
        THREE.CatmullRomCurve3 = function() {
            function CubicPoly() {}
            var tmp = new THREE.Vector3
                , px = new CubicPoly
                , py = new CubicPoly
                , pz = new CubicPoly;
            return CubicPoly.prototype.init = function(x0, x1, t0, t1) {
                this.c0 = x0,
                    this.c1 = t0,
                    this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1,
                    this.c3 = 2 * x0 - 2 * x1 + t0 + t1
            }
                ,
                CubicPoly.prototype.initNonuniformCatmullRom = function(x0, x1, x2, x3, dt0, dt1, dt2) {
                    var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1
                        , t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
                    t1 *= dt1,
                        t2 *= dt1,
                        this.init(x1, x2, t1, t2)
                }
                ,
                CubicPoly.prototype.initCatmullRom = function(x0, x1, x2, x3, tension) {
                    this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1))
                }
                ,
                CubicPoly.prototype.calc = function(t) {
                    var t2 = t * t
                        , t3 = t2 * t;
                    return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3
                }
                ,
                THREE.Curve.create(function(p) {
                    this.points = p || [],
                        this.closed = !1
                }, function(t) {
                    var point, intPoint, weight, l, points = this.points;
                    l = points.length,
                    l < 2 && console.log("duh, you need at least 2 points"),
                        point = (l - (this.closed ? 0 : 1)) * t,
                        intPoint = Math.floor(point),
                        weight = point - intPoint,
                        this.closed ? intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length : 0 === weight && intPoint === l - 1 && (intPoint = l - 2,
                            weight = 1);
                    var p0, p1, p2, p3;
                    if (this.closed || intPoint > 0 ? p0 = points[(intPoint - 1) % l] : (tmp.subVectors(points[0], points[1]).add(points[0]),
                            p0 = tmp),
                            p1 = points[intPoint % l],
                            p2 = points[(intPoint + 1) % l],
                            this.closed || intPoint + 2 < l ? p3 = points[(intPoint + 2) % l] : (tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]),
                                p3 = tmp),
                        void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
                        var pow = "chordal" === this.type ? .5 : .25
                            , dt0 = Math.pow(p0.distanceToSquared(p1), pow)
                            , dt1 = Math.pow(p1.distanceToSquared(p2), pow)
                            , dt2 = Math.pow(p2.distanceToSquared(p3), pow);
                        dt1 < 1e-4 && (dt1 = 1),
                        dt0 < 1e-4 && (dt0 = dt1),
                        dt2 < 1e-4 && (dt2 = dt1),
                            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2),
                            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2),
                            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2)
                    } else if ("catmullrom" === this.type) {
                        var tension = void 0 !== this.tension ? this.tension : .5;
                        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension),
                            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension),
                            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension)
                    }
                    var v = new THREE.Vector3(px.calc(weight),py.calc(weight),pz.calc(weight));
                    return v
                })
        }(),
        THREE.ClosedSplineCurve3 = function(points) {
            console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3."),
                THREE.CatmullRomCurve3.call(this, points),
                this.type = "catmullrom",
                this.closed = !0
        }
        ,
        THREE.ClosedSplineCurve3.prototype = Object.create(THREE.CatmullRomCurve3.prototype),
        THREE.BoxGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
            THREE.Geometry.call(this),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: width,
                    height: height,
                    depth: depth,
                    widthSegments: widthSegments,
                    heightSegments: heightSegments,
                    depthSegments: depthSegments
                },
                this.fromBufferGeometry(new THREE.BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments)),
                this.mergeVertices()
        }
        ,
        THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype),
        THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry,
        THREE.CubeGeometry = THREE.BoxGeometry,
        THREE.BoxBufferGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
            function calculateVertexCount(w, h, d) {
                var vertices = 0;
                return vertices += (w + 1) * (h + 1) * 2,
                    vertices += (w + 1) * (d + 1) * 2,
                    vertices += (d + 1) * (h + 1) * 2
            }
            function calculateIndexCount(w, h, d) {
                var index = 0;
                return index += w * h * 2,
                    index += w * d * 2,
                    index += d * h * 2,
                6 * index
            }
            function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
                for (var segmentWidth = width / gridX, segmentHeight = height / gridY, widthHalf = width / 2, heightHalf = height / 2, depthHalf = depth / 2, gridX1 = gridX + 1, gridY1 = gridY + 1, vertexCounter = 0, groupCount = 0, vector = new THREE.Vector3, iy = 0; iy < gridY1; iy++)
                    for (var y = iy * segmentHeight - heightHalf, ix = 0; ix < gridX1; ix++) {
                        var x = ix * segmentWidth - widthHalf;
                        vector[u] = x * udir,
                            vector[v] = y * vdir,
                            vector[w] = depthHalf,
                            vertices[vertexBufferOffset] = vector.x,
                            vertices[vertexBufferOffset + 1] = vector.y,
                            vertices[vertexBufferOffset + 2] = vector.z,
                            vector[u] = 0,
                            vector[v] = 0,
                            vector[w] = depth > 0 ? 1 : -1,
                            normals[vertexBufferOffset] = vector.x,
                            normals[vertexBufferOffset + 1] = vector.y,
                            normals[vertexBufferOffset + 2] = vector.z,
                            uvs[uvBufferOffset] = ix / gridX,
                            uvs[uvBufferOffset + 1] = 1 - iy / gridY,
                            vertexBufferOffset += 3,
                            uvBufferOffset += 2,
                            vertexCounter += 1
                    }
                for (iy = 0; iy < gridY; iy++)
                    for (ix = 0; ix < gridX; ix++) {
                        var a = numberOfVertices + ix + gridX1 * iy
                            , b = numberOfVertices + ix + gridX1 * (iy + 1)
                            , c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1)
                            , d = numberOfVertices + (ix + 1) + gridX1 * iy;
                        indices[indexBufferOffset] = a,
                            indices[indexBufferOffset + 1] = b,
                            indices[indexBufferOffset + 2] = d,
                            indices[indexBufferOffset + 3] = b,
                            indices[indexBufferOffset + 4] = c,
                            indices[indexBufferOffset + 5] = d,
                            indexBufferOffset += 6,
                            groupCount += 6
                    }
                scope.addGroup(groupStart, groupCount, materialIndex),
                    groupStart += groupCount,
                    numberOfVertices += vertexCounter
            }
            THREE.BufferGeometry.call(this),
                this.type = "BoxBufferGeometry",
                this.parameters = {
                    width: width,
                    height: height,
                    depth: depth,
                    widthSegments: widthSegments,
                    heightSegments: heightSegments,
                    depthSegments: depthSegments
                };
            var scope = this;
            widthSegments = Math.floor(widthSegments) || 1,
                heightSegments = Math.floor(heightSegments) || 1,
                depthSegments = Math.floor(depthSegments) || 1;
            var vertexCount = calculateVertexCount(widthSegments, heightSegments, depthSegments)
                , indexCount = calculateIndexCount(widthSegments, heightSegments, depthSegments)
                , indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount)
                , vertices = new Float32Array(3 * vertexCount)
                , normals = new Float32Array(3 * vertexCount)
                , uvs = new Float32Array(2 * vertexCount)
                , vertexBufferOffset = 0
                , uvBufferOffset = 0
                , indexBufferOffset = 0
                , numberOfVertices = 0
                , groupStart = 0;
            buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0),
                buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1),
                buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2),
                buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3),
                buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4),
                buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5),
                this.setIndex(new THREE.BufferAttribute(indices,1)),
                this.addAttribute("position", new THREE.BufferAttribute(vertices,3)),
                this.addAttribute("normal", new THREE.BufferAttribute(normals,3)),
                this.addAttribute("uv", new THREE.BufferAttribute(uvs,2))
        }
        ,
        THREE.BoxBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
        THREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry,
        THREE.CircleGeometry = function(radius, segments, thetaStart, thetaLength) {
            THREE.Geometry.call(this),
                this.type = "CircleGeometry",
                this.parameters = {
                    radius: radius,
                    segments: segments,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                },
                this.fromBufferGeometry(new THREE.CircleBufferGeometry(radius,segments,thetaStart,thetaLength))
        }
        ,
        THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype),
        THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry,
        THREE.CircleBufferGeometry = function(radius, segments, thetaStart, thetaLength) {
            THREE.BufferGeometry.call(this),
                this.type = "CircleBufferGeometry",
                this.parameters = {
                    radius: radius,
                    segments: segments,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                },
                radius = radius || 50,
                segments = void 0 !== segments ? Math.max(3, segments) : 8,
                thetaStart = void 0 !== thetaStart ? thetaStart : 0,
                thetaLength = void 0 !== thetaLength ? thetaLength : 2 * Math.PI;
            var vertices = segments + 2
                , positions = new Float32Array(3 * vertices)
                , normals = new Float32Array(3 * vertices)
                , uvs = new Float32Array(2 * vertices);
            normals[2] = 1,
                uvs[0] = .5,
                uvs[1] = .5;
            for (var s = 0, i = 3, ii = 2; s <= segments; s++,
                i += 3,
                ii += 2) {
                var segment = thetaStart + s / segments * thetaLength;
                positions[i] = radius * Math.cos(segment),
                    positions[i + 1] = radius * Math.sin(segment),
                    normals[i + 2] = 1,
                    uvs[ii] = (positions[i] / radius + 1) / 2,
                    uvs[ii + 1] = (positions[i + 1] / radius + 1) / 2
            }
            for (var indices = [], i = 1; i <= segments; i++)
                indices.push(i, i + 1, 0);
            this.setIndex(new THREE.BufferAttribute(new Uint16Array(indices),1)),
                this.addAttribute("position", new THREE.BufferAttribute(positions,3)),
                this.addAttribute("normal", new THREE.BufferAttribute(normals,3)),
                this.addAttribute("uv", new THREE.BufferAttribute(uvs,2)),
                this.boundingSphere = new THREE.Sphere(new THREE.Vector3,radius)
        }
        ,
        THREE.CircleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
        THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry,
        THREE.CylinderBufferGeometry = function(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            function calculateVertexCount() {
                var count = (radialSegments + 1) * (heightSegments + 1);
                return openEnded === !1 && (count += (radialSegments + 1) * nbCap + radialSegments * nbCap),
                    count
            }
            function calculateIndexCount() {
                var count = radialSegments * heightSegments * 2 * 3;
                return openEnded === !1 && (count += radialSegments * nbCap * 3),
                    count
            }
            function generateTorso() {
                var x, y, normal = new THREE.Vector3, vertex = new THREE.Vector3, groupCount = 0, tanTheta = (radiusBottom - radiusTop) / height;
                for (y = 0; y <= heightSegments; y++) {
                    var indexRow = []
                        , v = y / heightSegments
                        , radius = v * (radiusBottom - radiusTop) + radiusTop;
                    for (x = 0; x <= radialSegments; x++) {
                        var u = x / radialSegments;
                        vertex.x = radius * Math.sin(u * thetaLength + thetaStart),
                            vertex.y = -v * height + halfHeight,
                            vertex.z = radius * Math.cos(u * thetaLength + thetaStart),
                            vertices.setXYZ(index, vertex.x, vertex.y, vertex.z),
                            normal.copy(vertex),
                        (0 === radiusTop && 0 === y || 0 === radiusBottom && y === heightSegments) && (normal.x = Math.sin(u * thetaLength + thetaStart),
                            normal.z = Math.cos(u * thetaLength + thetaStart)),
                            normal.setY(Math.sqrt(normal.x * normal.x + normal.z * normal.z) * tanTheta).normalize(),
                            normals.setXYZ(index, normal.x, normal.y, normal.z),
                            uvs.setXY(index, u, 1 - v),
                            indexRow.push(index),
                            index++
                    }
                    indexArray.push(indexRow)
                }
                for (x = 0; x < radialSegments; x++)
                    for (y = 0; y < heightSegments; y++) {
                        var i1 = indexArray[y][x]
                            , i2 = indexArray[y + 1][x]
                            , i3 = indexArray[y + 1][x + 1]
                            , i4 = indexArray[y][x + 1];
                        indices.setX(indexOffset, i1),
                            indexOffset++,
                            indices.setX(indexOffset, i2),
                            indexOffset++,
                            indices.setX(indexOffset, i4),
                            indexOffset++,
                            indices.setX(indexOffset, i2),
                            indexOffset++,
                            indices.setX(indexOffset, i3),
                            indexOffset++,
                            indices.setX(indexOffset, i4),
                            indexOffset++,
                            groupCount += 6
                    }
                scope.addGroup(groupStart, groupCount, 0),
                    groupStart += groupCount
            }
            function generateCap(top) {
                var x, centerIndexStart, centerIndexEnd, uv = new THREE.Vector2, vertex = new THREE.Vector3, groupCount = 0, radius = top === !0 ? radiusTop : radiusBottom, sign = top === !0 ? 1 : -1;
                for (centerIndexStart = index,
                         x = 1; x <= radialSegments; x++)
                    vertices.setXYZ(index, 0, halfHeight * sign, 0),
                        normals.setXYZ(index, 0, sign, 0),
                        uv.x = .5,
                        uv.y = .5,
                        uvs.setXY(index, uv.x, uv.y),
                        index++;
                for (centerIndexEnd = index,
                         x = 0; x <= radialSegments; x++) {
                    var u = x / radialSegments
                        , theta = u * thetaLength + thetaStart
                        , cosTheta = Math.cos(theta)
                        , sinTheta = Math.sin(theta);
                    vertex.x = radius * sinTheta,
                        vertex.y = halfHeight * sign,
                        vertex.z = radius * cosTheta,
                        vertices.setXYZ(index, vertex.x, vertex.y, vertex.z),
                        normals.setXYZ(index, 0, sign, 0),
                        uv.x = .5 * cosTheta + .5,
                        uv.y = .5 * sinTheta * sign + .5,
                        uvs.setXY(index, uv.x, uv.y),
                        index++
                }
                for (x = 0; x < radialSegments; x++) {
                    var c = centerIndexStart + x
                        , i = centerIndexEnd + x;
                    top === !0 ? (indices.setX(indexOffset, i),
                        indexOffset++,
                        indices.setX(indexOffset, i + 1),
                        indexOffset++,
                        indices.setX(indexOffset, c),
                        indexOffset++) : (indices.setX(indexOffset, i + 1),
                        indexOffset++,
                        indices.setX(indexOffset, i),
                        indexOffset++,
                        indices.setX(indexOffset, c),
                        indexOffset++),
                        groupCount += 3
                }
                scope.addGroup(groupStart, groupCount, top === !0 ? 1 : 2),
                    groupStart += groupCount
            }
            THREE.BufferGeometry.call(this),
                this.type = "CylinderBufferGeometry",
                this.parameters = {
                    radiusTop: radiusTop,
                    radiusBottom: radiusBottom,
                    height: height,
                    radialSegments: radialSegments,
                    heightSegments: heightSegments,
                    openEnded: openEnded,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                };
            var scope = this;
            radiusTop = void 0 !== radiusTop ? radiusTop : 20,
                radiusBottom = void 0 !== radiusBottom ? radiusBottom : 20,
                height = void 0 !== height ? height : 100,
                radialSegments = Math.floor(radialSegments) || 8,
                heightSegments = Math.floor(heightSegments) || 1,
                openEnded = void 0 !== openEnded && openEnded,
                thetaStart = void 0 !== thetaStart ? thetaStart : 0,
                thetaLength = void 0 !== thetaLength ? thetaLength : 2 * Math.PI;
            var nbCap = 0;
            openEnded === !1 && (radiusTop > 0 && nbCap++,
            radiusBottom > 0 && nbCap++);
            var vertexCount = calculateVertexCount()
                , indexCount = calculateIndexCount()
                , indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount),1)
                , vertices = new THREE.BufferAttribute(new Float32Array(3 * vertexCount),3)
                , normals = new THREE.BufferAttribute(new Float32Array(3 * vertexCount),3)
                , uvs = new THREE.BufferAttribute(new Float32Array(2 * vertexCount),2)
                , index = 0
                , indexOffset = 0
                , indexArray = []
                , halfHeight = height / 2
                , groupStart = 0;
            generateTorso(),
            openEnded === !1 && (radiusTop > 0 && generateCap(!0),
            radiusBottom > 0 && generateCap(!1)),
                this.setIndex(indices),
                this.addAttribute("position", vertices),
                this.addAttribute("normal", normals),
                this.addAttribute("uv", uvs)
        }
        ,
        THREE.CylinderBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
        THREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry,
        THREE.CylinderGeometry = function(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            THREE.Geometry.call(this),
                this.type = "CylinderGeometry",
                this.parameters = {
                    radiusTop: radiusTop,
                    radiusBottom: radiusBottom,
                    height: height,
                    radialSegments: radialSegments,
                    heightSegments: heightSegments,
                    openEnded: openEnded,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                },
                this.fromBufferGeometry(new THREE.CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength)),
                this.mergeVertices()
        }
        ,
        THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype),
        THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry,
        THREE.ConeBufferGeometry = function(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            THREE.CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength),
                this.type = "ConeBufferGeometry",
                this.parameters = {
                    radius: radius,
                    height: height,
                    radialSegments: radialSegments,
                    heightSegments: heightSegments,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                }
        }
        ,
        THREE.ConeBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
        THREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry,
        THREE.ConeGeometry = function(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            THREE.CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength),
                this.type = "ConeGeometry",
                this.parameters = {
                    radius: radius,
                    height: height,
                    radialSegments: radialSegments,
                    heightSegments: heightSegments,
                    openEnded: openEnded,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                }
        }
        ,
        THREE.ConeGeometry.prototype = Object.create(THREE.CylinderGeometry.prototype),
        THREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry,
        THREE.EdgesGeometry = function(geometry, thresholdAngle) {
            function sortFunction(a, b) {
                return a - b
            }
            THREE.BufferGeometry.call(this),
                thresholdAngle = void 0 !== thresholdAngle ? thresholdAngle : 1;
            var geometry2, thresholdDot = Math.cos(THREE.Math.DEG2RAD * thresholdAngle), edge = [0, 0], hash = {}, keys = ["a", "b", "c"];
            geometry instanceof THREE.BufferGeometry ? (geometry2 = new THREE.Geometry,
                geometry2.fromBufferGeometry(geometry)) : geometry2 = geometry.clone(),
                geometry2.mergeVertices(),
                geometry2.computeFaceNormals();
            for (var vertices = geometry2.vertices, faces = geometry2.faces, i = 0, l = faces.length; i < l; i++)
                for (var face = faces[i], j = 0; j < 3; j++) {
                    edge[0] = face[keys[j]],
                        edge[1] = face[keys[(j + 1) % 3]],
                        edge.sort(sortFunction);
                    var key = edge.toString();
                    void 0 === hash[key] ? hash[key] = {
                        vert1: edge[0],
                        vert2: edge[1],
                        face1: i,
                        face2: void 0
                    } : hash[key].face2 = i
                }
            var coords = [];
            for (var key in hash) {
                var h = hash[key];
                if (void 0 === h.face2 || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
                    var vertex = vertices[h.vert1];
                    coords.push(vertex.x),
                        coords.push(vertex.y),
                        coords.push(vertex.z),
                        vertex = vertices[h.vert2],
                        coords.push(vertex.x),
                        coords.push(vertex.y),
                        coords.push(vertex.z)
                }
            }
            this.addAttribute("position", new THREE.BufferAttribute(new Float32Array(coords),3))
        }
        ,
        THREE.EdgesGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
        THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry,
        THREE.ExtrudeGeometry = function(shapes, options) {
            return "undefined" == typeof shapes ? void (shapes = []) : (THREE.Geometry.call(this),
                this.type = "ExtrudeGeometry",
                shapes = Array.isArray(shapes) ? shapes : [shapes],
                this.addShapeList(shapes, options),
                void this.computeFaceNormals())
        }
        ,
        THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype),
        THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry,
        THREE.ExtrudeGeometry.prototype.addShapeList = function(shapes, options) {
            for (var sl = shapes.length, s = 0; s < sl; s++) {
                var shape = shapes[s];
                this.addShape(shape, options)
            }
        }
        ,
        THREE.ExtrudeGeometry.prototype.addShape = function(shape, options) {
            function scalePt2(pt, vec, size) {
                return vec || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                    vec.clone().multiplyScalar(size).add(pt)
            }
            function getBevelVec(inPt, inPrev, inNext) {
                var v_trans_x, v_trans_y, shrink_by = 1, v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y, v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y, v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y, collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
                if (Math.abs(collinear0) > Number.EPSILON) {
                    var v_prev_len = Math.sqrt(v_prev_lensq)
                        , v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y)
                        , ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len
                        , ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len
                        , ptNextShift_x = inNext.x - v_next_y / v_next_len
                        , ptNextShift_y = inNext.y + v_next_x / v_next_len
                        , sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x,
                        v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                    var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                    if (v_trans_lensq <= 2)
                        return new THREE.Vector2(v_trans_x,v_trans_y);
                    shrink_by = Math.sqrt(v_trans_lensq / 2)
                } else {
                    var direction_eq = !1;
                    v_prev_x > Number.EPSILON ? v_next_x > Number.EPSILON && (direction_eq = !0) : v_prev_x < -Number.EPSILON ? v_next_x < -Number.EPSILON && (direction_eq = !0) : Math.sign(v_prev_y) === Math.sign(v_next_y) && (direction_eq = !0),
                        direction_eq ? (v_trans_x = -v_prev_y,
                            v_trans_y = v_prev_x,
                            shrink_by = Math.sqrt(v_prev_lensq)) : (v_trans_x = v_prev_x,
                            v_trans_y = v_prev_y,
                            shrink_by = Math.sqrt(v_prev_lensq / 2))
                }
                return new THREE.Vector2(v_trans_x / shrink_by,v_trans_y / shrink_by)
            }
            function buildLidFaces() {
                if (bevelEnabled) {
                    var layer = 0
                        , offset = vlen * layer;
                    for (i = 0; i < flen; i++)
                        face = faces[i],
                            f3(face[2] + offset, face[1] + offset, face[0] + offset);
                    for (layer = steps + 2 * bevelSegments,
                             offset = vlen * layer,
                             i = 0; i < flen; i++)
                        face = faces[i],
                            f3(face[0] + offset, face[1] + offset, face[2] + offset)
                } else {
                    for (i = 0; i < flen; i++)
                        face = faces[i],
                            f3(face[2], face[1], face[0]);
                    for (i = 0; i < flen; i++)
                        face = faces[i],
                            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps)
                }
            }
            function buildSideFaces() {
                var layeroffset = 0;
                for (sidewalls(contour, layeroffset),
                         layeroffset += contour.length,
                         h = 0,
                         hl = holes.length; h < hl; h++)
                    ahole = holes[h],
                        sidewalls(ahole, layeroffset),
                        layeroffset += ahole.length
            }
            function sidewalls(contour, layeroffset) {
                var j, k;
                for (i = contour.length; --i >= 0; ) {
                    j = i,
                        k = i - 1,
                    k < 0 && (k = contour.length - 1);
                    var s = 0
                        , sl = steps + 2 * bevelSegments;
                    for (s = 0; s < sl; s++) {
                        var slen1 = vlen * s
                            , slen2 = vlen * (s + 1)
                            , a = layeroffset + j + slen1
                            , b = layeroffset + k + slen1
                            , c = layeroffset + k + slen2
                            , d = layeroffset + j + slen2;
                        f4(a, b, c, d, contour, s, sl, j, k)
                    }
                }
            }
            function v(x, y, z) {
                scope.vertices.push(new THREE.Vector3(x,y,z))
            }
            function f3(a, b, c) {
                a += shapesOffset,
                    b += shapesOffset,
                    c += shapesOffset,
                    scope.faces.push(new THREE.Face3(a,b,c,null,null,0));
                var uvs = uvgen.generateTopUV(scope, a, b, c);
                scope.faceVertexUvs[0].push(uvs)
            }
            function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
                a += shapesOffset,
                    b += shapesOffset,
                    c += shapesOffset,
                    d += shapesOffset,
                    scope.faces.push(new THREE.Face3(a,b,d,null,null,1)),
                    scope.faces.push(new THREE.Face3(b,c,d,null,null,1));
                var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
                scope.faceVertexUvs[0].push([uvs[0], uvs[1], uvs[3]]),
                    scope.faceVertexUvs[0].push([uvs[1], uvs[2], uvs[3]])
            }
            var extrudePts, splineTube, binormal, normal, position2, amount = void 0 !== options.amount ? options.amount : 100, bevelThickness = void 0 !== options.bevelThickness ? options.bevelThickness : 6, bevelSize = void 0 !== options.bevelSize ? options.bevelSize : bevelThickness - 2, bevelSegments = void 0 !== options.bevelSegments ? options.bevelSegments : 3, bevelEnabled = void 0 === options.bevelEnabled || options.bevelEnabled, curveSegments = void 0 !== options.curveSegments ? options.curveSegments : 12, steps = void 0 !== options.steps ? options.steps : 1, extrudePath = options.extrudePath, extrudeByPath = !1, uvgen = void 0 !== options.UVGenerator ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
            extrudePath && (extrudePts = extrudePath.getSpacedPoints(steps),
                extrudeByPath = !0,
                bevelEnabled = !1,
                splineTube = void 0 !== options.frames ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath,steps,!1),
                binormal = new THREE.Vector3,
                normal = new THREE.Vector3,
                position2 = new THREE.Vector3),
            bevelEnabled || (bevelSegments = 0,
                bevelThickness = 0,
                bevelSize = 0);
            var ahole, h, hl, scope = this, shapesOffset = this.vertices.length, shapePoints = shape.extractPoints(curveSegments), vertices = shapePoints.shape, holes = shapePoints.holes, reverse = !THREE.ShapeUtils.isClockWise(vertices);
            if (reverse) {
                for (vertices = vertices.reverse(),
                         h = 0,
                         hl = holes.length; h < hl; h++)
                    ahole = holes[h],
                    THREE.ShapeUtils.isClockWise(ahole) && (holes[h] = ahole.reverse());
                reverse = !1
            }
            var faces = THREE.ShapeUtils.triangulateShape(vertices, holes)
                , contour = vertices;
            for (h = 0,
                     hl = holes.length; h < hl; h++)
                ahole = holes[h],
                    vertices = vertices.concat(ahole);
            for (var b, bs, t, z, vert, face, vlen = vertices.length, flen = faces.length, contourMovements = [], i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++,
                j++,
                k++)
                j === il && (j = 0),
                k === il && (k = 0),
                    contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
            var oneHoleMovements, holesMovements = [], verticesMovements = contourMovements.concat();
            for (h = 0,
                     hl = holes.length; h < hl; h++) {
                for (ahole = holes[h],
                         oneHoleMovements = [],
                         i = 0,
                         il = ahole.length,
                         j = il - 1,
                         k = i + 1; i < il; i++,
                         j++,
                         k++)
                    j === il && (j = 0),
                    k === il && (k = 0),
                        oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
                holesMovements.push(oneHoleMovements),
                    verticesMovements = verticesMovements.concat(oneHoleMovements)
            }
            for (b = 0; b < bevelSegments; b++) {
                for (t = b / bevelSegments,
                         z = bevelThickness * (1 - t),
                         bs = bevelSize * Math.sin(t * Math.PI / 2),
                         i = 0,
                         il = contour.length; i < il; i++)
                    vert = scalePt2(contour[i], contourMovements[i], bs),
                        v(vert.x, vert.y, -z);
                for (h = 0,
                         hl = holes.length; h < hl; h++)
                    for (ahole = holes[h],
                             oneHoleMovements = holesMovements[h],
                             i = 0,
                             il = ahole.length; i < il; i++)
                        vert = scalePt2(ahole[i], oneHoleMovements[i], bs),
                            v(vert.x, vert.y, -z)
            }
            for (bs = bevelSize,
                     i = 0; i < vlen; i++)
                vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i],
                    extrudeByPath ? (normal.copy(splineTube.normals[0]).multiplyScalar(vert.x),
                        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y),
                        position2.copy(extrudePts[0]).add(normal).add(binormal),
                        v(position2.x, position2.y, position2.z)) : v(vert.x, vert.y, 0);
            var s;
            for (s = 1; s <= steps; s++)
                for (i = 0; i < vlen; i++)
                    vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i],
                        extrudeByPath ? (normal.copy(splineTube.normals[s]).multiplyScalar(vert.x),
                            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y),
                            position2.copy(extrudePts[s]).add(normal).add(binormal),
                            v(position2.x, position2.y, position2.z)) : v(vert.x, vert.y, amount / steps * s);
            for (b = bevelSegments - 1; b >= 0; b--) {
                for (t = b / bevelSegments,
                         z = bevelThickness * (1 - t),
                         bs = bevelSize * Math.sin(t * Math.PI / 2),
                         i = 0,
                         il = contour.length; i < il; i++)
                    vert = scalePt2(contour[i], contourMovements[i], bs),
                        v(vert.x, vert.y, amount + z);
                for (h = 0,
                         hl = holes.length; h < hl; h++)
                    for (ahole = holes[h],
                             oneHoleMovements = holesMovements[h],
                             i = 0,
                             il = ahole.length; i < il; i++)
                        vert = scalePt2(ahole[i], oneHoleMovements[i], bs),
                            extrudeByPath ? v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z) : v(vert.x, vert.y, amount + z)
            }
            buildLidFaces(),
                buildSideFaces()
        }
        ,
        THREE.ExtrudeGeometry.WorldUVGenerator = {
            generateTopUV: function(geometry, indexA, indexB, indexC) {
                var vertices = geometry.vertices
                    , a = vertices[indexA]
                    , b = vertices[indexB]
                    , c = vertices[indexC];
                return [new THREE.Vector2(a.x,a.y), new THREE.Vector2(b.x,b.y), new THREE.Vector2(c.x,c.y)]
            },
            generateSideWallUV: function(geometry, indexA, indexB, indexC, indexD) {
                var vertices = geometry.vertices
                    , a = vertices[indexA]
                    , b = vertices[indexB]
                    , c = vertices[indexC]
                    , d = vertices[indexD];
                return Math.abs(a.y - b.y) < .01 ? [new THREE.Vector2(a.x,1 - a.z), new THREE.Vector2(b.x,1 - b.z), new THREE.Vector2(c.x,1 - c.z), new THREE.Vector2(d.x,1 - d.z)] : [new THREE.Vector2(a.y,1 - a.z), new THREE.Vector2(b.y,1 - b.z), new THREE.Vector2(c.y,1 - c.z), new THREE.Vector2(d.y,1 - d.z)]
            }
        },
        THREE.ShapeGeometry = function(shapes, options) {
            THREE.Geometry.call(this),
                this.type = "ShapeGeometry",
            Array.isArray(shapes) === !1 && (shapes = [shapes]),
                this.addShapeList(shapes, options),
                this.computeFaceNormals()
        }
        ,
        THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype),
        THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry,
        THREE.ShapeGeometry.prototype.addShapeList = function(shapes, options) {
            for (var i = 0, l = shapes.length; i < l; i++)
                this.addShape(shapes[i], options);
            return this
        }
        ,
        THREE.ShapeGeometry.prototype.addShape = function(shape, options) {
            void 0 === options && (options = {});
            var i, l, hole, curveSegments = void 0 !== options.curveSegments ? options.curveSegments : 12, material = options.material, uvgen = void 0 === options.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator, shapesOffset = this.vertices.length, shapePoints = shape.extractPoints(curveSegments), vertices = shapePoints.shape, holes = shapePoints.holes, reverse = !THREE.ShapeUtils.isClockWise(vertices);
            if (reverse) {
                for (vertices = vertices.reverse(),
                         i = 0,
                         l = holes.length; i < l; i++)
                    hole = holes[i],
                    THREE.ShapeUtils.isClockWise(hole) && (holes[i] = hole.reverse());
                reverse = !1
            }
            var faces = THREE.ShapeUtils.triangulateShape(vertices, holes);
            for (i = 0,
                     l = holes.length; i < l; i++)
                hole = holes[i],
                    vertices = vertices.concat(hole);
            var vert, face, vlen = vertices.length, flen = faces.length;
            for (i = 0; i < vlen; i++)
                vert = vertices[i],
                    this.vertices.push(new THREE.Vector3(vert.x,vert.y,0));
            for (i = 0; i < flen; i++) {
                face = faces[i];
                var a = face[0] + shapesOffset
                    , b = face[1] + shapesOffset
                    , c = face[2] + shapesOffset;
                this.faces.push(new THREE.Face3(a,b,c,null,null,material)),
                    this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c))
            }
        }
        ,
        THREE.LatheBufferGeometry = function(points, segments, phiStart, phiLength) {
            THREE.BufferGeometry.call(this),
                this.type = "LatheBufferGeometry",
                this.parameters = {
                    points: points,
                    segments: segments,
                    phiStart: phiStart,
                    phiLength: phiLength
                },
                segments = Math.floor(segments) || 12,
                phiStart = phiStart || 0,
                phiLength = phiLength || 2 * Math.PI,
                phiLength = THREE.Math.clamp(phiLength, 0, 2 * Math.PI);
            var base, i, j, vertexCount = (segments + 1) * points.length, indexCount = segments * points.length * 2 * 3, indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount),1), vertices = new THREE.BufferAttribute(new Float32Array(3 * vertexCount),3), uvs = new THREE.BufferAttribute(new Float32Array(2 * vertexCount),2), index = 0, indexOffset = 0, inverseSegments = (1 / (points.length - 1),
            1 / segments), vertex = new THREE.Vector3, uv = new THREE.Vector2;
            for (i = 0; i <= segments; i++) {
                var phi = phiStart + i * inverseSegments * phiLength
                    , sin = Math.sin(phi)
                    , cos = Math.cos(phi);
                for (j = 0; j <= points.length - 1; j++)
                    vertex.x = points[j].x * sin,
                        vertex.y = points[j].y,
                        vertex.z = points[j].x * cos,
                        vertices.setXYZ(index, vertex.x, vertex.y, vertex.z),
                        uv.x = i / segments,
                        uv.y = j / (points.length - 1),
                        uvs.setXY(index, uv.x, uv.y),
                        index++
            }
            for (i = 0; i < segments; i++)
                for (j = 0; j < points.length - 1; j++) {
                    base = j + i * points.length;
                    var a = base
                        , b = base + points.length
                        , c = base + points.length + 1
                        , d = base + 1;
                    indices.setX(indexOffset, a),
                        indexOffset++,
                        indices.setX(indexOffset, b),
                        indexOffset++,
                        indices.setX(indexOffset, d),
                        indexOffset++,
                        indices.setX(indexOffset, b),
                        indexOffset++,
                        indices.setX(indexOffset, c),
                        indexOffset++,
                        indices.setX(indexOffset, d),
                        indexOffset++
                }
            if (this.setIndex(indices),
                    this.addAttribute("position", vertices),
                    this.addAttribute("uv", uvs),
                    this.computeVertexNormals(),
                phiLength === 2 * Math.PI) {
                var normals = this.attributes.normal.array
                    , n1 = new THREE.Vector3
                    , n2 = new THREE.Vector3
                    , n = new THREE.Vector3;
                for (base = segments * points.length * 3,
                         i = 0,
                         j = 0; i < points.length; i++,
                         j += 3)
                    n1.x = normals[j + 0],
                        n1.y = normals[j + 1],
                        n1.z = normals[j + 2],
                        n2.x = normals[base + j + 0],
                        n2.y = normals[base + j + 1],
                        n2.z = normals[base + j + 2],
                        n.addVectors(n1, n2).normalize(),
                        normals[j + 0] = normals[base + j + 0] = n.x,
                        normals[j + 1] = normals[base + j + 1] = n.y,
                        normals[j + 2] = normals[base + j + 2] = n.z
            }
        }
        ,
        THREE.LatheBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
        THREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry,
        THREE.LatheGeometry = function(points, segments, phiStart, phiLength) {
            THREE.Geometry.call(this),
                this.type = "LatheGeometry",
                this.parameters = {
                    points: points,
                    segments: segments,
                    phiStart: phiStart,
                    phiLength: phiLength
                },
                this.fromBufferGeometry(new THREE.LatheBufferGeometry(points,segments,phiStart,phiLength)),
                this.mergeVertices()
        }
        ,
        THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype),
        THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry,
        THREE.PlaneGeometry = function(width, height, widthSegments, heightSegments) {
            THREE.Geometry.call(this),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: width,
                    height: height,
                    widthSegments: widthSegments,
                    heightSegments: heightSegments
                },
                this.fromBufferGeometry(new THREE.PlaneBufferGeometry(width,height,widthSegments,heightSegments))
        }
        ;
        THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry,
            THREE.PlaneBufferGeometry = function(width, height, widthSegments, heightSegments) {
                THREE.BufferGeometry.call(this),
                    this.type = "PlaneBufferGeometry",
                    this.parameters = {
                        width: width,
                        height: height,
                        widthSegments: widthSegments,
                        heightSegments: heightSegments
                    };
                for (var width_half = width / 2, height_half = height / 2, gridX = Math.floor(widthSegments) || 1, gridY = Math.floor(heightSegments) || 1, gridX1 = gridX + 1, gridY1 = gridY + 1, segment_width = width / gridX, segment_height = height / gridY, vertices = new Float32Array(gridX1 * gridY1 * 3), normals = new Float32Array(gridX1 * gridY1 * 3), uvs = new Float32Array(gridX1 * gridY1 * 2), offset = 0, offset2 = 0, iy = 0; iy < gridY1; iy++)
                    for (var y = iy * segment_height - height_half, ix = 0; ix < gridX1; ix++) {
                        var x = ix * segment_width - width_half;
                        vertices[offset] = x,
                            vertices[offset + 1] = -y,
                            normals[offset + 2] = 1,
                            uvs[offset2] = ix / gridX,
                            uvs[offset2 + 1] = 1 - iy / gridY,
                            offset += 3,
                            offset2 += 2
                    }
                offset = 0;
                for (var indices = new (vertices.length / 3 > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6), iy = 0; iy < gridY; iy++)
                    for (var ix = 0; ix < gridX; ix++) {
                        var a = ix + gridX1 * iy
                            , b = ix + gridX1 * (iy + 1)
                            , c = ix + 1 + gridX1 * (iy + 1)
                            , d = ix + 1 + gridX1 * iy;
                        indices[offset] = a,
                            indices[offset + 1] = b,
                            indices[offset + 2] = d,
                            indices[offset + 3] = b,
                            indices[offset + 4] = c,
                            indices[offset + 5] = d,
                            offset += 6
                    }
                this.setIndex(new THREE.BufferAttribute(indices,1)),
                    this.addAttribute("position", new THREE.BufferAttribute(vertices,3)),
                    this.addAttribute("normal", new THREE.BufferAttribute(normals,3)),
                    this.addAttribute("uv", new THREE.BufferAttribute(uvs,2))
            }
            ,
            THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
            THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry,
            THREE.RingBufferGeometry = function(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
                THREE.BufferGeometry.call(this),
                    this.type = "RingBufferGeometry",
                    this.parameters = {
                        innerRadius: innerRadius,
                        outerRadius: outerRadius,
                        thetaSegments: thetaSegments,
                        phiSegments: phiSegments,
                        thetaStart: thetaStart,
                        thetaLength: thetaLength
                    },
                    innerRadius = innerRadius || 20,
                    outerRadius = outerRadius || 50,
                    thetaStart = void 0 !== thetaStart ? thetaStart : 0,
                    thetaLength = void 0 !== thetaLength ? thetaLength : 2 * Math.PI,
                    thetaSegments = void 0 !== thetaSegments ? Math.max(3, thetaSegments) : 8,
                    phiSegments = void 0 !== phiSegments ? Math.max(1, phiSegments) : 1;
                var segment, j, i, vertexCount = (thetaSegments + 1) * (phiSegments + 1), indexCount = thetaSegments * phiSegments * 2 * 3, indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount),1), vertices = new THREE.BufferAttribute(new Float32Array(3 * vertexCount),3), normals = new THREE.BufferAttribute(new Float32Array(3 * vertexCount),3), uvs = new THREE.BufferAttribute(new Float32Array(2 * vertexCount),2), index = 0, indexOffset = 0, radius = innerRadius, radiusStep = (outerRadius - innerRadius) / phiSegments, vertex = new THREE.Vector3, uv = new THREE.Vector2;
                for (j = 0; j <= phiSegments; j++) {
                    for (i = 0; i <= thetaSegments; i++)
                        segment = thetaStart + i / thetaSegments * thetaLength,
                            vertex.x = radius * Math.cos(segment),
                            vertex.y = radius * Math.sin(segment),
                            vertices.setXYZ(index, vertex.x, vertex.y, vertex.z),
                            normals.setXYZ(index, 0, 0, 1),
                            uv.x = (vertex.x / outerRadius + 1) / 2,
                            uv.y = (vertex.y / outerRadius + 1) / 2,
                            uvs.setXY(index, uv.x, uv.y),
                            index++;
                    radius += radiusStep
                }
                for (j = 0; j < phiSegments; j++) {
                    var thetaSegmentLevel = j * (thetaSegments + 1);
                    for (i = 0; i < thetaSegments; i++) {
                        segment = i + thetaSegmentLevel;
                        var a = segment
                            , b = segment + thetaSegments + 1
                            , c = segment + thetaSegments + 2
                            , d = segment + 1;
                        indices.setX(indexOffset, a),
                            indexOffset++,
                            indices.setX(indexOffset, b),
                            indexOffset++,
                            indices.setX(indexOffset, c),
                            indexOffset++,
                            indices.setX(indexOffset, a),
                            indexOffset++,
                            indices.setX(indexOffset, c),
                            indexOffset++,
                            indices.setX(indexOffset, d),
                            indexOffset++
                    }
                }
                this.setIndex(indices),
                    this.addAttribute("position", vertices),
                    this.addAttribute("normal", normals),
                    this.addAttribute("uv", uvs)
            }
            ,
            THREE.RingBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
            THREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry,
            THREE.RingGeometry = function(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
                THREE.Geometry.call(this),
                    this.type = "RingGeometry",
                    this.parameters = {
                        innerRadius: innerRadius,
                        outerRadius: outerRadius,
                        thetaSegments: thetaSegments,
                        phiSegments: phiSegments,
                        thetaStart: thetaStart,
                        thetaLength: thetaLength
                    },
                    this.fromBufferGeometry(new THREE.RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength))
            }
            ,
            THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype),
            THREE.RingGeometry.prototype.constructor = THREE.RingGeometry,
            THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
                THREE.Geometry.call(this),
                    this.type = "SphereGeometry",
                    this.parameters = {
                        radius: radius,
                        widthSegments: widthSegments,
                        heightSegments: heightSegments,
                        phiStart: phiStart,
                        phiLength: phiLength,
                        thetaStart: thetaStart,
                        thetaLength: thetaLength
                    },
                    this.fromBufferGeometry(new THREE.SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength))
            }
            ,
            THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype),
            THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry,
            THREE.SphereBufferGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
                THREE.BufferGeometry.call(this),
                    this.type = "SphereBufferGeometry",
                    this.parameters = {
                        radius: radius,
                        widthSegments: widthSegments,
                        heightSegments: heightSegments,
                        phiStart: phiStart,
                        phiLength: phiLength,
                        thetaStart: thetaStart,
                        thetaLength: thetaLength
                    },
                    radius = radius || 50,
                    widthSegments = Math.max(3, Math.floor(widthSegments) || 8),
                    heightSegments = Math.max(2, Math.floor(heightSegments) || 6),
                    phiStart = void 0 !== phiStart ? phiStart : 0,
                    phiLength = void 0 !== phiLength ? phiLength : 2 * Math.PI,
                    thetaStart = void 0 !== thetaStart ? thetaStart : 0,
                    thetaLength = void 0 !== thetaLength ? thetaLength : Math.PI;
                for (var thetaEnd = thetaStart + thetaLength, vertexCount = (widthSegments + 1) * (heightSegments + 1), positions = new THREE.BufferAttribute(new Float32Array(3 * vertexCount),3), normals = new THREE.BufferAttribute(new Float32Array(3 * vertexCount),3), uvs = new THREE.BufferAttribute(new Float32Array(2 * vertexCount),2), index = 0, vertices = [], normal = new THREE.Vector3, y = 0; y <= heightSegments; y++) {
                    for (var verticesRow = [], v = y / heightSegments, x = 0; x <= widthSegments; x++) {
                        var u = x / widthSegments
                            , px = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength)
                            , py = radius * Math.cos(thetaStart + v * thetaLength)
                            , pz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                        normal.set(px, py, pz).normalize(),
                            positions.setXYZ(index, px, py, pz),
                            normals.setXYZ(index, normal.x, normal.y, normal.z),
                            uvs.setXY(index, u, 1 - v),
                            verticesRow.push(index),
                            index++
                    }
                    vertices.push(verticesRow)
                }
                for (var indices = [], y = 0; y < heightSegments; y++)
                    for (var x = 0; x < widthSegments; x++) {
                        var v1 = vertices[y][x + 1]
                            , v2 = vertices[y][x]
                            , v3 = vertices[y + 1][x]
                            , v4 = vertices[y + 1][x + 1];
                        (0 !== y || thetaStart > 0) && indices.push(v1, v2, v4),
                        (y !== heightSegments - 1 || thetaEnd < Math.PI) && indices.push(v2, v3, v4)
                    }
                this.setIndex(new (positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute)(indices,1)),
                    this.addAttribute("position", positions),
                    this.addAttribute("normal", normals),
                    this.addAttribute("uv", uvs),
                    this.boundingSphere = new THREE.Sphere(new THREE.Vector3,radius)
            }
            ,
            THREE.SphereBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
            THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry,
            THREE.TextGeometry = function(text, parameters) {
                parameters = parameters || {};
                var font = parameters.font;
                if (font instanceof THREE.Font == !1)
                    return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
                        new THREE.Geometry;
                var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
                parameters.amount = void 0 !== parameters.height ? parameters.height : 50,
                void 0 === parameters.bevelThickness && (parameters.bevelThickness = 10),
                void 0 === parameters.bevelSize && (parameters.bevelSize = 8),
                void 0 === parameters.bevelEnabled && (parameters.bevelEnabled = !1),
                    THREE.ExtrudeGeometry.call(this, shapes, parameters),
                    this.type = "TextGeometry"
            }
            ,
            THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype),
            THREE.TextGeometry.prototype.constructor = THREE.TextGeometry,
            THREE.TorusBufferGeometry = function(radius, tube, radialSegments, tubularSegments, arc) {
                THREE.BufferGeometry.call(this),
                    this.type = "TorusBufferGeometry",
                    this.parameters = {
                        radius: radius,
                        tube: tube,
                        radialSegments: radialSegments,
                        tubularSegments: tubularSegments,
                        arc: arc
                    },
                    radius = radius || 100,
                    tube = tube || 40,
                    radialSegments = Math.floor(radialSegments) || 8,
                    tubularSegments = Math.floor(tubularSegments) || 6,
                    arc = arc || 2 * Math.PI;
                var j, i, vertexCount = (radialSegments + 1) * (tubularSegments + 1), indexCount = radialSegments * tubularSegments * 2 * 3, indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), vertices = new Float32Array(3 * vertexCount), normals = new Float32Array(3 * vertexCount), uvs = new Float32Array(2 * vertexCount), vertexBufferOffset = 0, uvBufferOffset = 0, indexBufferOffset = 0, center = new THREE.Vector3, vertex = new THREE.Vector3, normal = new THREE.Vector3;
                for (j = 0; j <= radialSegments; j++)
                    for (i = 0; i <= tubularSegments; i++) {
                        var u = i / tubularSegments * arc
                            , v = j / radialSegments * Math.PI * 2;
                        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u),
                            vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u),
                            vertex.z = tube * Math.sin(v),
                            vertices[vertexBufferOffset] = vertex.x,
                            vertices[vertexBufferOffset + 1] = vertex.y,
                            vertices[vertexBufferOffset + 2] = vertex.z,
                            center.x = radius * Math.cos(u),
                            center.y = radius * Math.sin(u),
                            normal.subVectors(vertex, center).normalize(),
                            normals[vertexBufferOffset] = normal.x,
                            normals[vertexBufferOffset + 1] = normal.y,
                            normals[vertexBufferOffset + 2] = normal.z,
                            uvs[uvBufferOffset] = i / tubularSegments,
                            uvs[uvBufferOffset + 1] = j / radialSegments,
                            vertexBufferOffset += 3,
                            uvBufferOffset += 2
                    }
                for (j = 1; j <= radialSegments; j++)
                    for (i = 1; i <= tubularSegments; i++) {
                        var a = (tubularSegments + 1) * j + i - 1
                            , b = (tubularSegments + 1) * (j - 1) + i - 1
                            , c = (tubularSegments + 1) * (j - 1) + i
                            , d = (tubularSegments + 1) * j + i;
                        indices[indexBufferOffset] = a,
                            indices[indexBufferOffset + 1] = b,
                            indices[indexBufferOffset + 2] = d,
                            indices[indexBufferOffset + 3] = b,
                            indices[indexBufferOffset + 4] = c,
                            indices[indexBufferOffset + 5] = d,
                            indexBufferOffset += 6
                    }
                this.setIndex(new THREE.BufferAttribute(indices,1)),
                    this.addAttribute("position", new THREE.BufferAttribute(vertices,3)),
                    this.addAttribute("normal", new THREE.BufferAttribute(normals,3)),
                    this.addAttribute("uv", new THREE.BufferAttribute(uvs,2))
            }
            ,
            THREE.TorusBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
            THREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry,
            THREE.TorusGeometry = function(radius, tube, radialSegments, tubularSegments, arc) {
                THREE.Geometry.call(this),
                    this.type = "TorusGeometry",
                    this.parameters = {
                        radius: radius,
                        tube: tube,
                        radialSegments: radialSegments,
                        tubularSegments: tubularSegments,
                        arc: arc
                    },
                    this.fromBufferGeometry(new THREE.TorusBufferGeometry(radius,tube,radialSegments,tubularSegments,arc))
            }
            ,
            THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype),
            THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry,
            THREE.TorusKnotBufferGeometry = function(radius, tube, tubularSegments, radialSegments, p, q) {
                function calculatePositionOnCurve(u, p, q, radius, position) {
                    var cu = Math.cos(u)
                        , su = Math.sin(u)
                        , quOverP = q / p * u
                        , cs = Math.cos(quOverP);
                    position.x = radius * (2 + cs) * .5 * cu,
                        position.y = radius * (2 + cs) * su * .5,
                        position.z = radius * Math.sin(quOverP) * .5
                }
                THREE.BufferGeometry.call(this),
                    this.type = "TorusKnotBufferGeometry",
                    this.parameters = {
                        radius: radius,
                        tube: tube,
                        tubularSegments: tubularSegments,
                        radialSegments: radialSegments,
                        p: p,
                        q: q
                    },
                    radius = radius || 100,
                    tube = tube || 40,
                    tubularSegments = Math.floor(tubularSegments) || 64,
                    radialSegments = Math.floor(radialSegments) || 8,
                    p = p || 2,
                    q = q || 3;
                var i, j, vertexCount = (radialSegments + 1) * (tubularSegments + 1), indexCount = radialSegments * tubularSegments * 2 * 3, indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount),1), vertices = new THREE.BufferAttribute(new Float32Array(3 * vertexCount),3), normals = new THREE.BufferAttribute(new Float32Array(3 * vertexCount),3), uvs = new THREE.BufferAttribute(new Float32Array(2 * vertexCount),2), index = 0, indexOffset = 0, vertex = new THREE.Vector3, normal = new THREE.Vector3, uv = new THREE.Vector2, P1 = new THREE.Vector3, P2 = new THREE.Vector3, B = new THREE.Vector3, T = new THREE.Vector3, N = new THREE.Vector3;
                for (i = 0; i <= tubularSegments; ++i) {
                    var u = i / tubularSegments * p * Math.PI * 2;
                    for (calculatePositionOnCurve(u, p, q, radius, P1),
                             calculatePositionOnCurve(u + .01, p, q, radius, P2),
                             T.subVectors(P2, P1),
                             N.addVectors(P2, P1),
                             B.crossVectors(T, N),
                             N.crossVectors(B, T),
                             B.normalize(),
                             N.normalize(),
                             j = 0; j <= radialSegments; ++j) {
                        var v = j / radialSegments * Math.PI * 2
                            , cx = -tube * Math.cos(v)
                            , cy = tube * Math.sin(v);
                        vertex.x = P1.x + (cx * N.x + cy * B.x),
                            vertex.y = P1.y + (cx * N.y + cy * B.y),
                            vertex.z = P1.z + (cx * N.z + cy * B.z),
                            vertices.setXYZ(index, vertex.x, vertex.y, vertex.z),
                            normal.subVectors(vertex, P1).normalize(),
                            normals.setXYZ(index, normal.x, normal.y, normal.z),
                            uv.x = i / tubularSegments,
                            uv.y = j / radialSegments,
                            uvs.setXY(index, uv.x, uv.y),
                            index++
                    }
                }
                for (j = 1; j <= tubularSegments; j++)
                    for (i = 1; i <= radialSegments; i++) {
                        var a = (radialSegments + 1) * (j - 1) + (i - 1)
                            , b = (radialSegments + 1) * j + (i - 1)
                            , c = (radialSegments + 1) * j + i
                            , d = (radialSegments + 1) * (j - 1) + i;
                        indices.setX(indexOffset, a),
                            indexOffset++,
                            indices.setX(indexOffset, b),
                            indexOffset++,
                            indices.setX(indexOffset, d),
                            indexOffset++,
                            indices.setX(indexOffset, b),
                            indexOffset++,
                            indices.setX(indexOffset, c),
                            indexOffset++,
                            indices.setX(indexOffset, d),
                            indexOffset++
                    }
                this.setIndex(indices),
                    this.addAttribute("position", vertices),
                    this.addAttribute("normal", normals),
                    this.addAttribute("uv", uvs)
            }
            ,
            THREE.TorusKnotBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
            THREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry,
            THREE.TorusKnotGeometry = function(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
                THREE.Geometry.call(this),
                    this.type = "TorusKnotGeometry",
                    this.parameters = {
                        radius: radius,
                        tube: tube,
                        tubularSegments: tubularSegments,
                        radialSegments: radialSegments,
                        p: p,
                        q: q
                    },
                void 0 !== heightScale && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
                    this.fromBufferGeometry(new THREE.TorusKnotBufferGeometry(radius,tube,tubularSegments,radialSegments,p,q)),
                    this.mergeVertices()
            }
            ,
            THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype),
            THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry,
            THREE.TubeGeometry = function(path, segments, radius, radialSegments, closed, taper) {
                function vert(x, y, z) {
                    return scope.vertices.push(new THREE.Vector3(x,y,z)) - 1
                }
                THREE.Geometry.call(this),
                    this.type = "TubeGeometry",
                    this.parameters = {
                        path: path,
                        segments: segments,
                        radius: radius,
                        radialSegments: radialSegments,
                        closed: closed,
                        taper: taper
                    },
                    segments = segments || 64,
                    radius = radius || 1,
                    radialSegments = radialSegments || 8,
                    closed = closed || !1,
                    taper = taper || THREE.TubeGeometry.NoTaper;
                var tangent, normal, binormal, u, v, r, cx, cy, pos, i, j, ip, jp, a, b, c, d, uva, uvb, uvc, uvd, grid = [], scope = this, numpoints = segments + 1, pos2 = new THREE.Vector3, frames = new THREE.TubeGeometry.FrenetFrames(path,segments,closed), tangents = frames.tangents, normals = frames.normals, binormals = frames.binormals;
                for (this.tangents = tangents,
                         this.normals = normals,
                         this.binormals = binormals,
                         i = 0; i < numpoints; i++)
                    for (grid[i] = [],
                             u = i / (numpoints - 1),
                             pos = path.getPointAt(u),
                             tangent = tangents[i],
                             normal = normals[i],
                             binormal = binormals[i],
                             r = radius * taper(u),
                             j = 0; j < radialSegments; j++)
                        v = j / radialSegments * 2 * Math.PI,
                            cx = -r * Math.cos(v),
                            cy = r * Math.sin(v),
                            pos2.copy(pos),
                            pos2.x += cx * normal.x + cy * binormal.x,
                            pos2.y += cx * normal.y + cy * binormal.y,
                            pos2.z += cx * normal.z + cy * binormal.z,
                            grid[i][j] = vert(pos2.x, pos2.y, pos2.z);
                for (i = 0; i < segments; i++)
                    for (j = 0; j < radialSegments; j++)
                        ip = closed ? (i + 1) % segments : i + 1,
                            jp = (j + 1) % radialSegments,
                            a = grid[i][j],
                            b = grid[ip][j],
                            c = grid[ip][jp],
                            d = grid[i][jp],
                            uva = new THREE.Vector2(i / segments,j / radialSegments),
                            uvb = new THREE.Vector2((i + 1) / segments,j / radialSegments),
                            uvc = new THREE.Vector2((i + 1) / segments,(j + 1) / radialSegments),
                            uvd = new THREE.Vector2(i / segments,(j + 1) / radialSegments),
                            this.faces.push(new THREE.Face3(a,b,d)),
                            this.faceVertexUvs[0].push([uva, uvb, uvd]),
                            this.faces.push(new THREE.Face3(b,c,d)),
                            this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
                this.computeFaceNormals(),
                    this.computeVertexNormals()
            }
            ,
            THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype),
            THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry,
            THREE.TubeGeometry.NoTaper = function(u) {
                return 1
            }
            ,
            THREE.TubeGeometry.SinusoidalTaper = function(u) {
                return Math.sin(Math.PI * u)
            }
            ,
            THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {
                function initialNormal3() {
                    normals[0] = new THREE.Vector3,
                        binormals[0] = new THREE.Vector3,
                        smallest = Number.MAX_VALUE,
                        tx = Math.abs(tangents[0].x),
                        ty = Math.abs(tangents[0].y),
                        tz = Math.abs(tangents[0].z),
                    tx <= smallest && (smallest = tx,
                        normal.set(1, 0, 0)),
                    ty <= smallest && (smallest = ty,
                        normal.set(0, 1, 0)),
                    tz <= smallest && normal.set(0, 0, 1),
                        vec.crossVectors(tangents[0], normal).normalize(),
                        normals[0].crossVectors(tangents[0], vec),
                        binormals[0].crossVectors(tangents[0], normals[0])
                }
                var theta, smallest, tx, ty, tz, i, u, normal = new THREE.Vector3, tangents = [], normals = [], binormals = [], vec = new THREE.Vector3, mat = new THREE.Matrix4, numpoints = segments + 1;
                for (this.tangents = tangents,
                         this.normals = normals,
                         this.binormals = binormals,
                         i = 0; i < numpoints; i++)
                    u = i / (numpoints - 1),
                        tangents[i] = path.getTangentAt(u),
                        tangents[i].normalize();
                for (initialNormal3(),
                         i = 1; i < numpoints; i++)
                    normals[i] = normals[i - 1].clone(),
                        binormals[i] = binormals[i - 1].clone(),
                        vec.crossVectors(tangents[i - 1], tangents[i]),
                    vec.length() > Number.EPSILON && (vec.normalize(),
                        theta = Math.acos(THREE.Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)),
                        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta))),
                        binormals[i].crossVectors(tangents[i], normals[i]);
                if (closed)
                    for (theta = Math.acos(THREE.Math.clamp(normals[0].dot(normals[numpoints - 1]), -1, 1)),
                             theta /= numpoints - 1,
                         tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0 && (theta = -theta),
                             i = 1; i < numpoints; i++)
                        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i)),
                            binormals[i].crossVectors(tangents[i], normals[i])
            }
            ,
            THREE.PolyhedronGeometry = function(vertices, indices, radius, detail) {
                function prepare(vector) {
                    var vertex = vector.normalize().clone();
                    vertex.index = that.vertices.push(vertex) - 1;
                    var u = azimuth(vector) / 2 / Math.PI + .5
                        , v = inclination(vector) / Math.PI + .5;
                    return vertex.uv = new THREE.Vector2(u,1 - v),
                        vertex
                }
                function make(v1, v2, v3) {
                    var face = new THREE.Face3(v1.index,v2.index,v3.index,[v1.clone(), v2.clone(), v3.clone()]);
                    that.faces.push(face),
                        centroid.copy(v1).add(v2).add(v3).divideScalar(3);
                    var azi = azimuth(centroid);
                    that.faceVertexUvs[0].push([correctUV(v1.uv, v1, azi), correctUV(v2.uv, v2, azi), correctUV(v3.uv, v3, azi)])
                }
                function subdivide(face, detail) {
                    for (var cols = Math.pow(2, detail), a = prepare(that.vertices[face.a]), b = prepare(that.vertices[face.b]), c = prepare(that.vertices[face.c]), v = [], i = 0; i <= cols; i++) {
                        v[i] = [];
                        for (var aj = prepare(a.clone().lerp(c, i / cols)), bj = prepare(b.clone().lerp(c, i / cols)), rows = cols - i, j = 0; j <= rows; j++)
                            0 === j && i === cols ? v[i][j] = aj : v[i][j] = prepare(aj.clone().lerp(bj, j / rows))
                    }
                    for (var i = 0; i < cols; i++)
                        for (var j = 0; j < 2 * (cols - i) - 1; j++) {
                            var k = Math.floor(j / 2);
                            j % 2 === 0 ? make(v[i][k + 1], v[i + 1][k], v[i][k]) : make(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k])
                        }
                }
                function azimuth(vector) {
                    return Math.atan2(vector.z, -vector.x)
                }
                function inclination(vector) {
                    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z))
                }
                function correctUV(uv, vector, azimuth) {
                    return azimuth < 0 && 1 === uv.x && (uv = new THREE.Vector2(uv.x - 1,uv.y)),
                    0 === vector.x && 0 === vector.z && (uv = new THREE.Vector2(azimuth / 2 / Math.PI + .5,uv.y)),
                        uv.clone()
                }
                THREE.Geometry.call(this),
                    this.type = "PolyhedronGeometry",
                    this.parameters = {
                        vertices: vertices,
                        indices: indices,
                        radius: radius,
                        detail: detail
                    },
                    radius = radius || 1,
                    detail = detail || 0;
                for (var that = this, i = 0, l = vertices.length; i < l; i += 3)
                    prepare(new THREE.Vector3(vertices[i],vertices[i + 1],vertices[i + 2]));
                for (var p = this.vertices, faces = [], i = 0, j = 0, l = indices.length; i < l; i += 3,
                    j++) {
                    var v1 = p[indices[i]]
                        , v2 = p[indices[i + 1]]
                        , v3 = p[indices[i + 2]];
                    faces[j] = new THREE.Face3(v1.index,v2.index,v3.index,[v1.clone(), v2.clone(), v3.clone()])
                }
                for (var centroid = new THREE.Vector3, i = 0, l = faces.length; i < l; i++)
                    subdivide(faces[i], detail);
                for (var i = 0, l = this.faceVertexUvs[0].length; i < l; i++) {
                    var uvs = this.faceVertexUvs[0][i]
                        , x0 = uvs[0].x
                        , x1 = uvs[1].x
                        , x2 = uvs[2].x
                        , max = Math.max(x0, x1, x2)
                        , min = Math.min(x0, x1, x2);
                    max > .9 && min < .1 && (x0 < .2 && (uvs[0].x += 1),
                    x1 < .2 && (uvs[1].x += 1),
                    x2 < .2 && (uvs[2].x += 1))
                }
                for (var i = 0, l = this.vertices.length; i < l; i++)
                    this.vertices[i].multiplyScalar(radius);
                this.mergeVertices(),
                    this.computeFaceNormals(),
                    this.boundingSphere = new THREE.Sphere(new THREE.Vector3,radius)
            }
            ,
            THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype),
            THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry,
            THREE.DodecahedronGeometry = function(radius, detail) {
                var t = (1 + Math.sqrt(5)) / 2
                    , r = 1 / t
                    , vertices = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r]
                    , indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
                THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail),
                    this.type = "DodecahedronGeometry",
                    this.parameters = {
                        radius: radius,
                        detail: detail
                    }
            }
            ,
            THREE.DodecahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype),
            THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry,
            THREE.IcosahedronGeometry = function(radius, detail) {
                var t = (1 + Math.sqrt(5)) / 2
                    , vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1]
                    , indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
                THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail),
                    this.type = "IcosahedronGeometry",
                    this.parameters = {
                        radius: radius,
                        detail: detail
                    }
            }
            ,
            THREE.IcosahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype),
            THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry,
            THREE.OctahedronGeometry = function(radius, detail) {
                var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
                    , indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
                THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail),
                    this.type = "OctahedronGeometry",
                    this.parameters = {
                        radius: radius,
                        detail: detail
                    }
            }
            ,
            THREE.OctahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype),
            THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry,
            THREE.TetrahedronGeometry = function(radius, detail) {
                var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
                    , indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
                THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail),
                    this.type = "TetrahedronGeometry",
                    this.parameters = {
                        radius: radius,
                        detail: detail
                    }
            }
            ,
            THREE.TetrahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype),
            THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry,
            THREE.ParametricGeometry = function(func, slices, stacks) {
                THREE.Geometry.call(this),
                    this.type = "ParametricGeometry",
                    this.parameters = {
                        func: func,
                        slices: slices,
                        stacks: stacks
                    };
                var i, j, p, u, v, verts = this.vertices, faces = this.faces, uvs = this.faceVertexUvs[0], sliceCount = slices + 1;
                for (i = 0; i <= stacks; i++)
                    for (v = i / stacks,
                             j = 0; j <= slices; j++)
                        u = j / slices,
                            p = func(u, v),
                            verts.push(p);
                var a, b, c, d, uva, uvb, uvc, uvd;
                for (i = 0; i < stacks; i++)
                    for (j = 0; j < slices; j++)
                        a = i * sliceCount + j,
                            b = i * sliceCount + j + 1,
                            c = (i + 1) * sliceCount + j + 1,
                            d = (i + 1) * sliceCount + j,
                            uva = new THREE.Vector2(j / slices,i / stacks),
                            uvb = new THREE.Vector2((j + 1) / slices,i / stacks),
                            uvc = new THREE.Vector2((j + 1) / slices,(i + 1) / stacks),
                            uvd = new THREE.Vector2(j / slices,(i + 1) / stacks),
                            faces.push(new THREE.Face3(a,b,d)),
                            uvs.push([uva, uvb, uvd]),
                            faces.push(new THREE.Face3(b,c,d)),
                            uvs.push([uvb.clone(), uvc, uvd.clone()]);
                this.computeFaceNormals(),
                    this.computeVertexNormals()
            }
            ,
            THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype),
            THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry,
            THREE.WireframeGeometry = function(geometry) {
                function sortFunction(a, b) {
                    return a - b
                }
                THREE.BufferGeometry.call(this);
                var edge = [0, 0]
                    , hash = {}
                    , keys = ["a", "b", "c"];
                if (geometry instanceof THREE.Geometry) {
                    for (var vertices = geometry.vertices, faces = geometry.faces, numEdges = 0, edges = new Uint32Array(6 * faces.length), i = 0, l = faces.length; i < l; i++)
                        for (var face = faces[i], j = 0; j < 3; j++) {
                            edge[0] = face[keys[j]],
                                edge[1] = face[keys[(j + 1) % 3]],
                                edge.sort(sortFunction);
                            var key = edge.toString();
                            void 0 === hash[key] && (edges[2 * numEdges] = edge[0],
                                edges[2 * numEdges + 1] = edge[1],
                                hash[key] = !0,
                                numEdges++)
                        }
                    for (var coords = new Float32Array(2 * numEdges * 3), i = 0, l = numEdges; i < l; i++)
                        for (var j = 0; j < 2; j++) {
                            var vertex = vertices[edges[2 * i + j]]
                                , index = 6 * i + 3 * j;
                            coords[index + 0] = vertex.x,
                                coords[index + 1] = vertex.y,
                                coords[index + 2] = vertex.z
                        }
                    this.addAttribute("position", new THREE.BufferAttribute(coords,3))
                } else if (geometry instanceof THREE.BufferGeometry)
                    if (null !== geometry.index) {
                        var indices = geometry.index.array
                            , vertices = geometry.attributes.position
                            , groups = geometry.groups
                            , numEdges = 0;
                        0 === groups.length && geometry.addGroup(0, indices.length);
                        for (var edges = new Uint32Array(2 * indices.length), o = 0, ol = groups.length; o < ol; ++o)
                            for (var group = groups[o], start = group.start, count = group.count, i = start, il = start + count; i < il; i += 3)
                                for (var j = 0; j < 3; j++) {
                                    edge[0] = indices[i + j],
                                        edge[1] = indices[i + (j + 1) % 3],
                                        edge.sort(sortFunction);
                                    var key = edge.toString();
                                    void 0 === hash[key] && (edges[2 * numEdges] = edge[0],
                                        edges[2 * numEdges + 1] = edge[1],
                                        hash[key] = !0,
                                        numEdges++)
                                }
                        for (var coords = new Float32Array(2 * numEdges * 3), i = 0, l = numEdges; i < l; i++)
                            for (var j = 0; j < 2; j++) {
                                var index = 6 * i + 3 * j
                                    , index2 = edges[2 * i + j];
                                coords[index + 0] = vertices.getX(index2),
                                    coords[index + 1] = vertices.getY(index2),
                                    coords[index + 2] = vertices.getZ(index2)
                            }
                        this.addAttribute("position", new THREE.BufferAttribute(coords,3))
                    } else {
                        for (var vertices = geometry.attributes.position.array, numEdges = vertices.length / 3, numTris = numEdges / 3, coords = new Float32Array(2 * numEdges * 3), i = 0, l = numTris; i < l; i++)
                            for (var j = 0; j < 3; j++) {
                                var index = 18 * i + 6 * j
                                    , index1 = 9 * i + 3 * j;
                                coords[index + 0] = vertices[index1],
                                    coords[index + 1] = vertices[index1 + 1],
                                    coords[index + 2] = vertices[index1 + 2];
                                var index2 = 9 * i + 3 * ((j + 1) % 3);
                                coords[index + 3] = vertices[index2],
                                    coords[index + 4] = vertices[index2 + 1],
                                    coords[index + 5] = vertices[index2 + 2]
                            }
                        this.addAttribute("position", new THREE.BufferAttribute(coords,3))
                    }
            }
            ,
            THREE.WireframeGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
            THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry,
            THREE.AxisHelper = function(size) {
                size = size || 1;
                var vertices = new Float32Array([0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size])
                    , colors = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1])
                    , geometry = new THREE.BufferGeometry;
                geometry.addAttribute("position", new THREE.BufferAttribute(vertices,3)),
                    geometry.addAttribute("color", new THREE.BufferAttribute(colors,3));
                var material = new THREE.LineBasicMaterial({
                    vertexColors: THREE.VertexColors
                });
                THREE.LineSegments.call(this, geometry, material)
            }
            ,
            THREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype),
            THREE.AxisHelper.prototype.constructor = THREE.AxisHelper,
            THREE.ArrowHelper = function() {
                var lineGeometry = new THREE.BufferGeometry;
                lineGeometry.addAttribute("position", new THREE.Float32Attribute([0, 0, 0, 0, 1, 0],3));
                var coneGeometry = new THREE.CylinderBufferGeometry(0,.5,1,5,1);
                return coneGeometry.translate(0, -.5, 0),
                    function(dir, origin, length, color, headLength, headWidth) {
                        THREE.Object3D.call(this),
                        void 0 === color && (color = 16776960),
                        void 0 === length && (length = 1),
                        void 0 === headLength && (headLength = .2 * length),
                        void 0 === headWidth && (headWidth = .2 * headLength),
                            this.position.copy(origin),
                            this.line = new THREE.Line(lineGeometry,new THREE.LineBasicMaterial({
                                color: color
                            })),
                            this.line.matrixAutoUpdate = !1,
                            this.add(this.line),
                            this.cone = new THREE.Mesh(coneGeometry,new THREE.MeshBasicMaterial({
                                color: color
                            })),
                            this.cone.matrixAutoUpdate = !1,
                            this.add(this.cone),
                            this.setDirection(dir),
                            this.setLength(length, headLength, headWidth)
                    }
            }(),
            THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype),
            THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper,
            THREE.ArrowHelper.prototype.setDirection = function() {
                var radians, axis = new THREE.Vector3;
                return function(dir) {
                    dir.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : dir.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (axis.set(dir.z, 0, -dir.x).normalize(),
                        radians = Math.acos(dir.y),
                        this.quaternion.setFromAxisAngle(axis, radians))
                }
            }(),
            THREE.ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
                void 0 === headLength && (headLength = .2 * length),
                void 0 === headWidth && (headWidth = .2 * headLength),
                    this.line.scale.set(1, Math.max(0, length - headLength), 1),
                    this.line.updateMatrix(),
                    this.cone.scale.set(headWidth, headLength, headWidth),
                    this.cone.position.y = length,
                    this.cone.updateMatrix()
            }
            ,
            THREE.ArrowHelper.prototype.setColor = function(color) {
                this.line.material.color.copy(color),
                    this.cone.material.color.copy(color)
            }
            ,
            THREE.BoxHelper = function(object, color) {
                void 0 === color && (color = 16776960);
                var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                    , positions = new Float32Array(24)
                    , geometry = new THREE.BufferGeometry;
                geometry.setIndex(new THREE.BufferAttribute(indices,1)),
                    geometry.addAttribute("position", new THREE.BufferAttribute(positions,3)),
                    THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({
                        color: color
                    })),
                void 0 !== object && this.update(object)
            }
            ,
            THREE.BoxHelper.prototype = Object.create(THREE.LineSegments.prototype),
            THREE.BoxHelper.prototype.constructor = THREE.BoxHelper,
            THREE.BoxHelper.prototype.update = function() {
                var box = new THREE.Box3;
                return function(object) {
                    if (object instanceof THREE.Box3 ? box.copy(object) : box.setFromObject(object),
                            !box.isEmpty()) {
                        var min = box.min
                            , max = box.max
                            , position = this.geometry.attributes.position
                            , array = position.array;
                        array[0] = max.x,
                            array[1] = max.y,
                            array[2] = max.z,
                            array[3] = min.x,
                            array[4] = max.y,
                            array[5] = max.z,
                            array[6] = min.x,
                            array[7] = min.y,
                            array[8] = max.z,
                            array[9] = max.x,
                            array[10] = min.y,
                            array[11] = max.z,
                            array[12] = max.x,
                            array[13] = max.y,
                            array[14] = min.z,
                            array[15] = min.x,
                            array[16] = max.y,
                            array[17] = min.z,
                            array[18] = min.x,
                            array[19] = min.y,
                            array[20] = min.z,
                            array[21] = max.x,
                            array[22] = min.y,
                            array[23] = min.z,
                            position.needsUpdate = !0,
                            this.geometry.computeBoundingSphere()
                    }
                }
            }(),
            THREE.BoundingBoxHelper = function(object, hex) {
                var color = void 0 !== hex ? hex : 8947848;
                this.object = object,
                    this.box = new THREE.Box3,
                    THREE.Mesh.call(this, new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({
                        color: color,
                        wireframe: !0
                    }))
            }
            ,
            THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype),
            THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper,
            THREE.BoundingBoxHelper.prototype.update = function() {
                this.box.setFromObject(this.object),
                    this.box.size(this.scale),
                    this.box.center(this.position)
            }
            ,
            THREE.CameraHelper = function(camera) {
                function addLine(a, b, hex) {
                    addPoint(a, hex),
                        addPoint(b, hex)
                }
                function addPoint(id, hex) {
                    geometry.vertices.push(new THREE.Vector3),
                        geometry.colors.push(new THREE.Color(hex)),
                    void 0 === pointMap[id] && (pointMap[id] = []),
                        pointMap[id].push(geometry.vertices.length - 1)
                }
                var geometry = new THREE.Geometry
                    , material = new THREE.LineBasicMaterial({
                    color: 16777215,
                    vertexColors: THREE.FaceColors
                })
                    , pointMap = {}
                    , hexFrustum = 16755200
                    , hexCone = 16711680
                    , hexUp = 43775
                    , hexTarget = 16777215
                    , hexCross = 3355443;
                addLine("n1", "n2", hexFrustum),
                    addLine("n2", "n4", hexFrustum),
                    addLine("n4", "n3", hexFrustum),
                    addLine("n3", "n1", hexFrustum),
                    addLine("f1", "f2", hexFrustum),
                    addLine("f2", "f4", hexFrustum),
                    addLine("f4", "f3", hexFrustum),
                    addLine("f3", "f1", hexFrustum),
                    addLine("n1", "f1", hexFrustum),
                    addLine("n2", "f2", hexFrustum),
                    addLine("n3", "f3", hexFrustum),
                    addLine("n4", "f4", hexFrustum),
                    addLine("p", "n1", hexCone),
                    addLine("p", "n2", hexCone),
                    addLine("p", "n3", hexCone),
                    addLine("p", "n4", hexCone),
                    addLine("u1", "u2", hexUp),
                    addLine("u2", "u3", hexUp),
                    addLine("u3", "u1", hexUp),
                    addLine("c", "t", hexTarget),
                    addLine("p", "c", hexCross),
                    addLine("cn1", "cn2", hexCross),
                    addLine("cn3", "cn4", hexCross),
                    addLine("cf1", "cf2", hexCross),
                    addLine("cf3", "cf4", hexCross),
                    THREE.LineSegments.call(this, geometry, material),
                    this.camera = camera,
                this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                    this.matrix = camera.matrixWorld,
                    this.matrixAutoUpdate = !1,
                    this.pointMap = pointMap,
                    this.update()
            }
            ,
            THREE.CameraHelper.prototype = Object.create(THREE.LineSegments.prototype),
            THREE.CameraHelper.prototype.constructor = THREE.CameraHelper,
            THREE.CameraHelper.prototype.update = function() {
                function setPoint(point, x, y, z) {
                    vector.set(x, y, z).unproject(camera);
                    var points = pointMap[point];
                    if (void 0 !== points)
                        for (var i = 0, il = points.length; i < il; i++)
                            geometry.vertices[points[i]].copy(vector)
                }
                var geometry, pointMap, vector = new THREE.Vector3, camera = new THREE.Camera;
                return function() {
                    geometry = this.geometry,
                        pointMap = this.pointMap;
                    var w = 1
                        , h = 1;
                    camera.projectionMatrix.copy(this.camera.projectionMatrix),
                        setPoint("c", 0, 0, -1),
                        setPoint("t", 0, 0, 1),
                        setPoint("n1", -w, -h, -1),
                        setPoint("n2", w, -h, -1),
                        setPoint("n3", -w, h, -1),
                        setPoint("n4", w, h, -1),
                        setPoint("f1", -w, -h, 1),
                        setPoint("f2", w, -h, 1),
                        setPoint("f3", -w, h, 1),
                        setPoint("f4", w, h, 1),
                        setPoint("u1", .7 * w, 1.1 * h, -1),
                        setPoint("u2", .7 * -w, 1.1 * h, -1),
                        setPoint("u3", 0, 2 * h, -1),
                        setPoint("cf1", -w, 0, 1),
                        setPoint("cf2", w, 0, 1),
                        setPoint("cf3", 0, -h, 1),
                        setPoint("cf4", 0, h, 1),
                        setPoint("cn1", -w, 0, -1),
                        setPoint("cn2", w, 0, -1),
                        setPoint("cn3", 0, -h, -1),
                        setPoint("cn4", 0, h, -1),
                        geometry.verticesNeedUpdate = !0
                }
            }(),
            THREE.DirectionalLightHelper = function(light, size) {
                THREE.Object3D.call(this),
                    this.light = light,
                    this.light.updateMatrixWorld(),
                    this.matrix = light.matrixWorld,
                    this.matrixAutoUpdate = !1,
                void 0 === size && (size = 1);
                var geometry = new THREE.BufferGeometry;
                geometry.addAttribute("position", new THREE.Float32Attribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0],3));
                var material = new THREE.LineBasicMaterial({
                    fog: !1
                });
                this.add(new THREE.Line(geometry,material)),
                    geometry = new THREE.BufferGeometry,
                    geometry.addAttribute("position", new THREE.Float32Attribute([0, 0, 0, 0, 0, 1],3)),
                    this.add(new THREE.Line(geometry,material)),
                    this.update()
            }
            ,
            THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype),
            THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper,
            THREE.DirectionalLightHelper.prototype.dispose = function() {
                var lightPlane = this.children[0]
                    , targetLine = this.children[1];
                lightPlane.geometry.dispose(),
                    lightPlane.material.dispose(),
                    targetLine.geometry.dispose(),
                    targetLine.material.dispose()
            }
            ,
            THREE.DirectionalLightHelper.prototype.update = function() {
                var v1 = new THREE.Vector3
                    , v2 = new THREE.Vector3
                    , v3 = new THREE.Vector3;
                return function() {
                    v1.setFromMatrixPosition(this.light.matrixWorld),
                        v2.setFromMatrixPosition(this.light.target.matrixWorld),
                        v3.subVectors(v2, v1);
                    var lightPlane = this.children[0]
                        , targetLine = this.children[1];
                    lightPlane.lookAt(v3),
                        lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity),
                        targetLine.lookAt(v3),
                        targetLine.scale.z = v3.length()
                }
            }(),
            THREE.EdgesHelper = function(object, hex, thresholdAngle) {
                var color = void 0 !== hex ? hex : 16777215;
                THREE.LineSegments.call(this, new THREE.EdgesGeometry(object.geometry,thresholdAngle), new THREE.LineBasicMaterial({
                    color: color
                })),
                    this.matrix = object.matrixWorld,
                    this.matrixAutoUpdate = !1
            }
            ,
            THREE.EdgesHelper.prototype = Object.create(THREE.LineSegments.prototype),
            THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper,
            THREE.FaceNormalsHelper = function(object, size, hex, linewidth) {
                this.object = object,
                    this.size = void 0 !== size ? size : 1;
                var color = void 0 !== hex ? hex : 16776960
                    , width = void 0 !== linewidth ? linewidth : 1
                    , nNormals = 0
                    , objGeometry = this.object.geometry;
                objGeometry instanceof THREE.Geometry ? nNormals = objGeometry.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var geometry = new THREE.BufferGeometry
                    , positions = new THREE.Float32Attribute(2 * nNormals * 3,3);
                geometry.addAttribute("position", positions),
                    THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({
                        color: color,
                        linewidth: width
                    })),
                    this.matrixAutoUpdate = !1,
                    this.update()
            }
            ,
            THREE.FaceNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype),
            THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper,
            THREE.FaceNormalsHelper.prototype.update = function() {
                var v1 = new THREE.Vector3
                    , v2 = new THREE.Vector3
                    , normalMatrix = new THREE.Matrix3;
                return function() {
                    this.object.updateMatrixWorld(!0),
                        normalMatrix.getNormalMatrix(this.object.matrixWorld);
                    for (var matrixWorld = this.object.matrixWorld, position = this.geometry.attributes.position, objGeometry = this.object.geometry, vertices = objGeometry.vertices, faces = objGeometry.faces, idx = 0, i = 0, l = faces.length; i < l; i++) {
                        var face = faces[i]
                            , normal = face.normal;
                        v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld),
                            v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1),
                            position.setXYZ(idx, v1.x, v1.y, v1.z),
                            idx += 1,
                            position.setXYZ(idx, v2.x, v2.y, v2.z),
                            idx += 1
                    }
                    return position.needsUpdate = !0,
                        this
                }
            }(),
            THREE.GridHelper = function(size, step, color1, color2) {
                color1 = new THREE.Color(void 0 !== color1 ? color1 : 4473924),
                    color2 = new THREE.Color(void 0 !== color2 ? color2 : 8947848);
                for (var vertices = [], colors = [], i = -size, j = 0; i <= size; i += step) {
                    vertices.push(-size, 0, i, size, 0, i),
                        vertices.push(i, 0, -size, i, 0, size);
                    var color = 0 === i ? color1 : color2;
                    color.toArray(colors, j),
                        j += 3,
                        color.toArray(colors, j),
                        j += 3,
                        color.toArray(colors, j),
                        j += 3,
                        color.toArray(colors, j),
                        j += 3
                }
                var geometry = new THREE.BufferGeometry;
                geometry.addAttribute("position", new THREE.Float32Attribute(vertices,3)),
                    geometry.addAttribute("color", new THREE.Float32Attribute(colors,3));
                var material = new THREE.LineBasicMaterial({
                    vertexColors: THREE.VertexColors
                });
                THREE.LineSegments.call(this, geometry, material)
            }
            ,
            THREE.GridHelper.prototype = Object.create(THREE.LineSegments.prototype),
            THREE.GridHelper.prototype.constructor = THREE.GridHelper,
            THREE.GridHelper.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }
            ,
            THREE.HemisphereLightHelper = function(light, sphereSize) {
                THREE.Object3D.call(this),
                    this.light = light,
                    this.light.updateMatrixWorld(),
                    this.matrix = light.matrixWorld,
                    this.matrixAutoUpdate = !1,
                    this.colors = [new THREE.Color, new THREE.Color];
                var geometry = new THREE.SphereGeometry(sphereSize,4,2);
                geometry.rotateX(-Math.PI / 2);
                for (var i = 0, il = 8; i < il; i++)
                    geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
                var material = new THREE.MeshBasicMaterial({
                    vertexColors: THREE.FaceColors,
                    wireframe: !0
                });
                this.lightSphere = new THREE.Mesh(geometry,material),
                    this.add(this.lightSphere),
                    this.update()
            }
            ,
            THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype),
            THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper,
            THREE.HemisphereLightHelper.prototype.dispose = function() {
                this.lightSphere.geometry.dispose(),
                    this.lightSphere.material.dispose()
            }
            ,
            THREE.HemisphereLightHelper.prototype.update = function() {
                var vector = new THREE.Vector3;
                return function() {
                    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity),
                        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity),
                        this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate()),
                        this.lightSphere.geometry.colorsNeedUpdate = !0
                }
            }(),
            THREE.PointLightHelper = function(light, sphereSize) {
                this.light = light,
                    this.light.updateMatrixWorld();
                var geometry = new THREE.SphereBufferGeometry(sphereSize,4,2)
                    , material = new THREE.MeshBasicMaterial({
                    wireframe: !0,
                    fog: !1
                });
                material.color.copy(this.light.color).multiplyScalar(this.light.intensity),
                    THREE.Mesh.call(this, geometry, material),
                    this.matrix = this.light.matrixWorld,
                    this.matrixAutoUpdate = !1
            }
        ,
        THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype),
        THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper,
        THREE.PointLightHelper.prototype.dispose = function() {
            this.geometry.dispose(),
                this.material.dispose()
        }
        ,
        THREE.PointLightHelper.prototype.update = function() {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
        }
        ,
        THREE.SkeletonHelper = function(object) {
            this.bones = this.getBoneList(object);
            for (var geometry = new THREE.Geometry, i = 0; i < this.bones.length; i++) {
                var bone = this.bones[i];
                bone.parent instanceof THREE.Bone && (geometry.vertices.push(new THREE.Vector3),
                    geometry.vertices.push(new THREE.Vector3),
                    geometry.colors.push(new THREE.Color(0,0,1)),
                    geometry.colors.push(new THREE.Color(0,1,0)))
            }
            geometry.dynamic = !0;
            var material = new THREE.LineBasicMaterial({
                vertexColors: THREE.VertexColors,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            });
            THREE.LineSegments.call(this, geometry, material),
                this.root = object,
                this.matrix = object.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.update()
        }
        ,
        THREE.SkeletonHelper.prototype = Object.create(THREE.LineSegments.prototype),
        THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper,
        THREE.SkeletonHelper.prototype.getBoneList = function(object) {
            var boneList = [];
            object instanceof THREE.Bone && boneList.push(object);
            for (var i = 0; i < object.children.length; i++)
                boneList.push.apply(boneList, this.getBoneList(object.children[i]));
            return boneList
        }
        ,
        THREE.SkeletonHelper.prototype.update = function() {
            for (var geometry = this.geometry, matrixWorldInv = (new THREE.Matrix4).getInverse(this.root.matrixWorld), boneMatrix = new THREE.Matrix4, j = 0, i = 0; i < this.bones.length; i++) {
                var bone = this.bones[i];
                bone.parent instanceof THREE.Bone && (boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld),
                    geometry.vertices[j].setFromMatrixPosition(boneMatrix),
                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld),
                    geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix),
                    j += 2)
            }
            geometry.verticesNeedUpdate = !0,
                geometry.computeBoundingSphere()
        }
        ,
        THREE.SpotLightHelper = function(light) {
            THREE.Object3D.call(this),
                this.light = light,
                this.light.updateMatrixWorld(),
                this.matrix = light.matrixWorld,
                this.matrixAutoUpdate = !1;
            for (var geometry = new THREE.BufferGeometry, positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, j = 1, l = 32; i < l; i++,
                j++) {
                var p1 = i / l * Math.PI * 2
                    , p2 = j / l * Math.PI * 2;
                positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1)
            }
            geometry.addAttribute("position", new THREE.Float32Attribute(positions,3));
            var material = new THREE.LineBasicMaterial({
                fog: !1
            });
            this.cone = new THREE.LineSegments(geometry,material),
                this.add(this.cone),
                this.update()
        }
        ,
        THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype),
        THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper,
        THREE.SpotLightHelper.prototype.dispose = function() {
            this.cone.geometry.dispose(),
                this.cone.material.dispose()
        }
        ,
        THREE.SpotLightHelper.prototype.update = function() {
            var vector = new THREE.Vector3
                , vector2 = new THREE.Vector3;
            return function() {
                var coneLength = this.light.distance ? this.light.distance : 1e3
                    , coneWidth = coneLength * Math.tan(this.light.angle);
                this.cone.scale.set(coneWidth, coneWidth, coneLength),
                    vector.setFromMatrixPosition(this.light.matrixWorld),
                    vector2.setFromMatrixPosition(this.light.target.matrixWorld),
                    this.cone.lookAt(vector2.sub(vector)),
                    this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
            }
        }(),
        THREE.VertexNormalsHelper = function(object, size, hex, linewidth) {
            this.object = object,
                this.size = void 0 !== size ? size : 1;
            var color = void 0 !== hex ? hex : 16711680
                , width = void 0 !== linewidth ? linewidth : 1
                , nNormals = 0
                , objGeometry = this.object.geometry;
            objGeometry instanceof THREE.Geometry ? nNormals = 3 * objGeometry.faces.length : objGeometry instanceof THREE.BufferGeometry && (nNormals = objGeometry.attributes.normal.count);
            var geometry = new THREE.BufferGeometry
                , positions = new THREE.Float32Attribute(2 * nNormals * 3,3);
            geometry.addAttribute("position", positions),
                THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({
                    color: color,
                    linewidth: width
                })),
                this.matrixAutoUpdate = !1,
                this.update()
        }
        ,
        THREE.VertexNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype),
        THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper,
        THREE.VertexNormalsHelper.prototype.update = function() {
            var v1 = new THREE.Vector3
                , v2 = new THREE.Vector3
                , normalMatrix = new THREE.Matrix3;
            return function() {
                var keys = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0),
                    normalMatrix.getNormalMatrix(this.object.matrixWorld);
                var matrixWorld = this.object.matrixWorld
                    , position = this.geometry.attributes.position
                    , objGeometry = this.object.geometry;
                if (objGeometry instanceof THREE.Geometry)
                    for (var vertices = objGeometry.vertices, faces = objGeometry.faces, idx = 0, i = 0, l = faces.length; i < l; i++)
                        for (var face = faces[i], j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                            var vertex = vertices[face[keys[j]]]
                                , normal = face.vertexNormals[j];
                            v1.copy(vertex).applyMatrix4(matrixWorld),
                                v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1),
                                position.setXYZ(idx, v1.x, v1.y, v1.z),
                                idx += 1,
                                position.setXYZ(idx, v2.x, v2.y, v2.z),
                                idx += 1
                        }
                else if (objGeometry instanceof THREE.BufferGeometry)
                    for (var objPos = objGeometry.attributes.position, objNorm = objGeometry.attributes.normal, idx = 0, j = 0, jl = objPos.count; j < jl; j++)
                        v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld),
                            v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j)),
                            v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1),
                            position.setXYZ(idx, v1.x, v1.y, v1.z),
                            idx += 1,
                            position.setXYZ(idx, v2.x, v2.y, v2.z),
                            idx += 1;
                return position.needsUpdate = !0,
                    this
            }
        }(),
        THREE.WireframeHelper = function(object, hex) {
            var color = void 0 !== hex ? hex : 16777215;
            THREE.LineSegments.call(this, new THREE.WireframeGeometry(object.geometry), new THREE.LineBasicMaterial({
                color: color
            })),
                this.matrix = object.matrixWorld,
                this.matrixAutoUpdate = !1
        }
        ,
        THREE.WireframeHelper.prototype = Object.create(THREE.LineSegments.prototype),
        THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper,
        THREE.ImmediateRenderObject = function(material) {
            THREE.Object3D.call(this),
                this.material = material,
                this.render = function(renderCallback) {}
        }
        ,
        THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype),
        THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject,
        THREE.MorphBlendMesh = function(geometry, material) {
            THREE.Mesh.call(this, geometry, material),
                this.animationsMap = {},
                this.animationsList = [];
            var numFrames = this.geometry.morphTargets.length
                , name = "__default"
                , startFrame = 0
                , endFrame = numFrames - 1
                , fps = numFrames / 1;
            this.createAnimation(name, startFrame, endFrame, fps),
                this.setAnimationWeight(name, 1)
        }
        ,
        THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype),
        THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh,
        THREE.MorphBlendMesh.prototype.createAnimation = function(name, start, end, fps) {
            var animation = {
                start: start,
                end: end,
                length: end - start + 1,
                fps: fps,
                duration: (end - start) / fps,
                lastFrame: 0,
                currentFrame: 0,
                active: !1,
                time: 0,
                direction: 1,
                weight: 1,
                directionBackwards: !1,
                mirroredLoop: !1
            };
            this.animationsMap[name] = animation,
                this.animationsList.push(animation)
        }
        ,
        THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(fps) {
            for (var firstAnimation, pattern = /([a-z]+)_?(\d+)/i, frameRanges = {}, geometry = this.geometry, i = 0, il = geometry.morphTargets.length; i < il; i++) {
                var morph = geometry.morphTargets[i]
                    , chunks = morph.name.match(pattern);
                if (chunks && chunks.length > 1) {
                    var name = chunks[1];
                    frameRanges[name] || (frameRanges[name] = {
                        start: 1 / 0,
                        end: -(1 / 0)
                    });
                    var range = frameRanges[name];
                    i < range.start && (range.start = i),
                    i > range.end && (range.end = i),
                    firstAnimation || (firstAnimation = name)
                }
            }
            for (var name in frameRanges) {
                var range = frameRanges[name];
                this.createAnimation(name, range.start, range.end, fps)
            }
            this.firstAnimation = firstAnimation
        }
        ,
        THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(name) {
            var animation = this.animationsMap[name];
            animation && (animation.direction = 1,
                animation.directionBackwards = !1)
        }
        ,
        THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(name) {
            var animation = this.animationsMap[name];
            animation && (animation.direction = -1,
                animation.directionBackwards = !0)
        }
        ,
        THREE.MorphBlendMesh.prototype.setAnimationFPS = function(name, fps) {
            var animation = this.animationsMap[name];
            animation && (animation.fps = fps,
                animation.duration = (animation.end - animation.start) / animation.fps)
        }
        ,
        THREE.MorphBlendMesh.prototype.setAnimationDuration = function(name, duration) {
            var animation = this.animationsMap[name];
            animation && (animation.duration = duration,
                animation.fps = (animation.end - animation.start) / animation.duration)
        }
        ,
        THREE.MorphBlendMesh.prototype.setAnimationWeight = function(name, weight) {
            var animation = this.animationsMap[name];
            animation && (animation.weight = weight)
        }
        ,
        THREE.MorphBlendMesh.prototype.setAnimationTime = function(name, time) {
            var animation = this.animationsMap[name];
            animation && (animation.time = time)
        }
        ,
        THREE.MorphBlendMesh.prototype.getAnimationTime = function(name) {
            var time = 0
                , animation = this.animationsMap[name];
            return animation && (time = animation.time),
                time
        }
        ,
        THREE.MorphBlendMesh.prototype.getAnimationDuration = function(name) {
            var duration = -1
                , animation = this.animationsMap[name];
            return animation && (duration = animation.duration),
                duration
        }
        ,
        THREE.MorphBlendMesh.prototype.playAnimation = function(name) {
            var animation = this.animationsMap[name];
            animation ? (animation.time = 0,
                animation.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()")
        }
        ,
        THREE.MorphBlendMesh.prototype.stopAnimation = function(name) {
            var animation = this.animationsMap[name];
            animation && (animation.active = !1)
        }
        ,
        THREE.MorphBlendMesh.prototype.update = function(delta) {
            for (var i = 0, il = this.animationsList.length; i < il; i++) {
                var animation = this.animationsList[i];
                if (animation.active) {
                    var frameTime = animation.duration / animation.length;
                    animation.time += animation.direction * delta,
                        animation.mirroredLoop ? (animation.time > animation.duration || animation.time < 0) && (animation.direction *= -1,
                        animation.time > animation.duration && (animation.time = animation.duration,
                            animation.directionBackwards = !0),
                        animation.time < 0 && (animation.time = 0,
                            animation.directionBackwards = !1)) : (animation.time = animation.time % animation.duration,
                        animation.time < 0 && (animation.time += animation.duration));
                    var keyframe = animation.start + THREE.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1)
                        , weight = animation.weight;
                    keyframe !== animation.currentFrame && (this.morphTargetInfluences[animation.lastFrame] = 0,
                        this.morphTargetInfluences[animation.currentFrame] = 1 * weight,
                        this.morphTargetInfluences[keyframe] = 0,
                        animation.lastFrame = animation.currentFrame,
                        animation.currentFrame = keyframe);
                    var mix = animation.time % frameTime / frameTime;
                    animation.directionBackwards && (mix = 1 - mix),
                        animation.currentFrame !== animation.lastFrame ? (this.morphTargetInfluences[animation.currentFrame] = mix * weight,
                            this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight) : this.morphTargetInfluences[animation.currentFrame] = weight
                }
            }
        }
    }
        , {}],
    2: [function(require, module, exports) {
        module.exports = {
            default: require("core-js/library/fn/get-iterator"),
            __esModule: !0
        }
    }
        , {
            "core-js/library/fn/get-iterator": 8
        }],
    3: [function(require, module, exports) {
        module.exports = {
            default: require("core-js/library/fn/json/stringify"),
            __esModule: !0
        }
    }
        , {
            "core-js/library/fn/json/stringify": 9
        }],
    4: [function(require, module, exports) {
        module.exports = {
            default: require("core-js/library/fn/symbol"),
            __esModule: !0
        }
    }
        , {
            "core-js/library/fn/symbol": 10
        }],
    5: [function(require, module, exports) {
        module.exports = {
            default: require("core-js/library/fn/symbol/iterator"),
            __esModule: !0
        }
    }
        , {
            "core-js/library/fn/symbol/iterator": 11
        }],
    6: [function(require, module, exports) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        exports.__esModule = !0;
        var _iterator = require("../core-js/symbol/iterator")
            , _iterator2 = _interopRequireDefault(_iterator)
            , _symbol = require("../core-js/symbol")
            , _symbol2 = _interopRequireDefault(_symbol)
            , _typeof = "function" == typeof _symbol2.default && "symbol" == typeof _iterator2.default ? function(obj) {
                return typeof obj
            }
                : function(obj) {
                return obj && "function" == typeof _symbol2.default && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj
            }
            ;
        exports.default = "function" == typeof _symbol2.default && "symbol" === _typeof(_iterator2.default) ? function(obj) {
            return "undefined" == typeof obj ? "undefined" : _typeof(obj)
        }
            : function(obj) {
            return obj && "function" == typeof _symbol2.default && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : "undefined" == typeof obj ? "undefined" : _typeof(obj)
        }
    }
        , {
            "../core-js/symbol": 4,
            "../core-js/symbol/iterator": 5
        }],
    7: [function(require, module, exports) {
        (function() {
                function base64MimeType(encoded) {
                    var result = null;
                    if ("string" != typeof encoded)
                        return result;
                    var mime = encoded.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/);
                    return mime && mime.length && (result = mime[1]),
                        result
                }
                "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = base64MimeType),
                    exports.base64MimeType = base64MimeType) : "function" == typeof define && define.amd ? define([], function() {
                    return base64MimeType
                }) : this.base64MimeType = base64MimeType
            }
        ).call(this)
    }
        , {}],
    8: [function(require, module, exports) {
        require("../modules/web.dom.iterable"),
            require("../modules/es6.string.iterator"),
            module.exports = require("../modules/core.get-iterator")
    }
        , {
            "../modules/core.get-iterator": 70,
            "../modules/es6.string.iterator": 73,
            "../modules/web.dom.iterable": 77
        }],
    9: [function(require, module, exports) {
        var core = require("../../modules/_core")
            , $JSON = core.JSON || (core.JSON = {
                stringify: JSON.stringify
            });
        module.exports = function(it) {
            return $JSON.stringify.apply($JSON, arguments)
        }
    }
        , {
            "../../modules/_core": 18
        }],
    10: [function(require, module, exports) {
        require("../../modules/es6.symbol"),
            require("../../modules/es6.object.to-string"),
            require("../../modules/es7.symbol.async-iterator"),
            require("../../modules/es7.symbol.observable"),
            module.exports = require("../../modules/_core").Symbol
    }
        , {
            "../../modules/_core": 18,
            "../../modules/es6.object.to-string": 72,
            "../../modules/es6.symbol": 74,
            "../../modules/es7.symbol.async-iterator": 75,
            "../../modules/es7.symbol.observable": 76
        }],
    11: [function(require, module, exports) {
        require("../../modules/es6.string.iterator"),
            require("../../modules/web.dom.iterable"),
            module.exports = require("../../modules/_wks-ext").f("iterator")
    }
        , {
            "../../modules/_wks-ext": 67,
            "../../modules/es6.string.iterator": 73,
            "../../modules/web.dom.iterable": 77
        }],
    12: [function(require, module, exports) {
        module.exports = function(it) {
            if ("function" != typeof it)
                throw TypeError(it + " is not a function!");
            return it
        }
    }
        , {}],
    13: [function(require, module, exports) {
        module.exports = function() {}
    }
        , {}],
    14: [function(require, module, exports) {
        var isObject = require("./_is-object");
        module.exports = function(it) {
            if (!isObject(it))
                throw TypeError(it + " is not an object!");
            return it
        }
    }
        , {
            "./_is-object": 34
        }],
    15: [function(require, module, exports) {
        var toIObject = require("./_to-iobject")
            , toLength = require("./_to-length")
            , toIndex = require("./_to-index");
        module.exports = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
                var value, O = toIObject($this), length = toLength(O.length), index = toIndex(fromIndex, length);
                if (IS_INCLUDES && el != el) {
                    for (; length > index; )
                        if (value = O[index++],
                            value != value)
                            return !0
                } else
                    for (; length > index; index++)
                        if ((IS_INCLUDES || index in O) && O[index] === el)
                            return IS_INCLUDES || index || 0;
                return !IS_INCLUDES && -1
            }
        }
    }
        , {
            "./_to-index": 59,
            "./_to-iobject": 61,
            "./_to-length": 62
        }],
    16: [function(require, module, exports) {
        var cof = require("./_cof")
            , TAG = require("./_wks")("toStringTag")
            , ARG = "Arguments" == cof(function() {
                return arguments
            }())
            , tryGet = function(it, key) {
            try {
                return it[key]
            } catch (e) {}
        };
        module.exports = function(it) {
            var O, T, B;
            return void 0 === it ? "Undefined" : null === it ? "Null" : "string" == typeof (T = tryGet(O = Object(it), TAG)) ? T : ARG ? cof(O) : "Object" == (B = cof(O)) && "function" == typeof O.callee ? "Arguments" : B
        }
    }
        , {
            "./_cof": 17,
            "./_wks": 68
        }],
    17: [function(require, module, exports) {
        var toString = {}.toString;
        module.exports = function(it) {
            return toString.call(it).slice(8, -1)
        }
    }
        , {}],
    18: [function(require, module, exports) {
        var core = module.exports = {
            version: "2.4.0"
        };
        "number" == typeof __e && (__e = core)
    }
        , {}],
    19: [function(require, module, exports) {
        var aFunction = require("./_a-function");
        module.exports = function(fn, that, length) {
            if (aFunction(fn),
                void 0 === that)
                return fn;
            switch (length) {
                case 1:
                    return function(a) {
                        return fn.call(that, a)
                    }
                        ;
                case 2:
                    return function(a, b) {
                        return fn.call(that, a, b)
                    }
                        ;
                case 3:
                    return function(a, b, c) {
                        return fn.call(that, a, b, c)
                    }
            }
            return function() {
                return fn.apply(that, arguments)
            }
        }
    }
        , {
            "./_a-function": 12
        }],
    20: [function(require, module, exports) {
        module.exports = function(it) {
            if (void 0 == it)
                throw TypeError("Can't call method on  " + it);
            return it
        }
    }
        , {}],
    21: [function(require, module, exports) {
        module.exports = !require("./_fails")(function() {
            return 7 != Object.defineProperty({}, "a", {
                    get: function() {
                        return 7
                    }
                }).a
        })
    }
        , {
            "./_fails": 26
        }],
    22: [function(require, module, exports) {
        var isObject = require("./_is-object")
            , document = require("./_global").document
            , is = isObject(document) && isObject(document.createElement);
        module.exports = function(it) {
            return is ? document.createElement(it) : {}
        }
    }
        , {
            "./_global": 27,
            "./_is-object": 34
        }],
    23: [function(require, module, exports) {
        module.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
    }
        , {}],
    24: [function(require, module, exports) {
        var getKeys = require("./_object-keys")
            , gOPS = require("./_object-gops")
            , pIE = require("./_object-pie");
        module.exports = function(it) {
            var result = getKeys(it)
                , getSymbols = gOPS.f;
            if (getSymbols)
                for (var key, symbols = getSymbols(it), isEnum = pIE.f, i = 0; symbols.length > i; )
                    isEnum.call(it, key = symbols[i++]) && result.push(key);
            return result
        }
    }
        , {
            "./_object-gops": 48,
            "./_object-keys": 51,
            "./_object-pie": 52
        }],
    25: [function(require, module, exports) {
        var global = require("./_global")
            , core = require("./_core")
            , ctx = require("./_ctx")
            , hide = require("./_hide")
            , PROTOTYPE = "prototype"
            , $export = function(type, name, source) {
            var key, own, out, IS_FORCED = type & $export.F, IS_GLOBAL = type & $export.G, IS_STATIC = type & $export.S, IS_PROTO = type & $export.P, IS_BIND = type & $export.B, IS_WRAP = type & $export.W, exports = IS_GLOBAL ? core : core[name] || (core[name] = {}), expProto = exports[PROTOTYPE], target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
            IS_GLOBAL && (source = name);
            for (key in source)
                own = !IS_FORCED && target && void 0 !== target[key],
                own && key in exports || (out = own ? target[key] : source[key],
                    exports[key] = IS_GLOBAL && "function" != typeof target[key] ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function(C) {
                        var F = function(a, b, c) {
                            if (this instanceof C) {
                                switch (arguments.length) {
                                    case 0:
                                        return new C;
                                    case 1:
                                        return new C(a);
                                    case 2:
                                        return new C(a,b)
                                }
                                return new C(a,b,c)
                            }
                            return C.apply(this, arguments)
                        };
                        return F[PROTOTYPE] = C[PROTOTYPE],
                            F
                    }(out) : IS_PROTO && "function" == typeof out ? ctx(Function.call, out) : out,
                IS_PROTO && ((exports.virtual || (exports.virtual = {}))[key] = out,
                type & $export.R && expProto && !expProto[key] && hide(expProto, key, out)))
        };
        $export.F = 1,
            $export.G = 2,
            $export.S = 4,
            $export.P = 8,
            $export.B = 16,
            $export.W = 32,
            $export.U = 64,
            $export.R = 128,
            module.exports = $export
    }
        , {
            "./_core": 18,
            "./_ctx": 19,
            "./_global": 27,
            "./_hide": 29
        }],
    26: [function(require, module, exports) {
        module.exports = function(exec) {
            try {
                return !!exec()
            } catch (e) {
                return !0
            }
        }
    }
        , {}],
    27: [function(require, module, exports) {
        var global = module.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = global)
    }
        , {}],
    28: [function(require, module, exports) {
        var hasOwnProperty = {}.hasOwnProperty;
        module.exports = function(it, key) {
            return hasOwnProperty.call(it, key)
        }
    }
        , {}],
    29: [function(require, module, exports) {
        var dP = require("./_object-dp")
            , createDesc = require("./_property-desc");
        module.exports = require("./_descriptors") ? function(object, key, value) {
            return dP.f(object, key, createDesc(1, value))
        }
            : function(object, key, value) {
            return object[key] = value,
                object
        }
    }
        , {
            "./_descriptors": 21,
            "./_object-dp": 43,
            "./_property-desc": 53
        }],
    30: [function(require, module, exports) {
        module.exports = require("./_global").document && document.documentElement
    }
        , {
            "./_global": 27
        }],
    31: [function(require, module, exports) {
        module.exports = !require("./_descriptors") && !require("./_fails")(function() {
                return 7 != Object.defineProperty(require("./_dom-create")("div"), "a", {
                        get: function() {
                            return 7
                        }
                    }).a
            })
    }
        , {
            "./_descriptors": 21,
            "./_dom-create": 22,
            "./_fails": 26
        }],
    32: [function(require, module, exports) {
        var cof = require("./_cof");
        module.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
            return "String" == cof(it) ? it.split("") : Object(it)
        }
    }
        , {
            "./_cof": 17
        }],
    33: [function(require, module, exports) {
        var cof = require("./_cof");
        module.exports = Array.isArray || function(arg) {
                return "Array" == cof(arg)
            }
    }
        , {
            "./_cof": 17
        }],
    34: [function(require, module, exports) {
        module.exports = function(it) {
            return "object" == typeof it ? null !== it : "function" == typeof it
        }
    }
        , {}],
    35: [function(require, module, exports) {
        "use strict";
        var create = require("./_object-create")
            , descriptor = require("./_property-desc")
            , setToStringTag = require("./_set-to-string-tag")
            , IteratorPrototype = {};
        require("./_hide")(IteratorPrototype, require("./_wks")("iterator"), function() {
            return this
        }),
            module.exports = function(Constructor, NAME, next) {
                Constructor.prototype = create(IteratorPrototype, {
                    next: descriptor(1, next)
                }),
                    setToStringTag(Constructor, NAME + " Iterator")
            }
    }
        , {
            "./_hide": 29,
            "./_object-create": 42,
            "./_property-desc": 53,
            "./_set-to-string-tag": 55,
            "./_wks": 68
        }],
    36: [function(require, module, exports) {
        "use strict";
        var LIBRARY = require("./_library")
            , $export = require("./_export")
            , redefine = require("./_redefine")
            , hide = require("./_hide")
            , has = require("./_has")
            , Iterators = require("./_iterators")
            , $iterCreate = require("./_iter-create")
            , setToStringTag = require("./_set-to-string-tag")
            , getPrototypeOf = require("./_object-gpo")
            , ITERATOR = require("./_wks")("iterator")
            , BUGGY = !([].keys && "next"in [].keys())
            , FF_ITERATOR = "@@iterator"
            , KEYS = "keys"
            , VALUES = "values"
            , returnThis = function() {
            return this
        };
        module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
            $iterCreate(Constructor, NAME, next);
            var methods, key, IteratorPrototype, getMethod = function(kind) {
                if (!BUGGY && kind in proto)
                    return proto[kind];
                switch (kind) {
                    case KEYS:
                        return function() {
                            return new Constructor(this,kind)
                        }
                            ;
                    case VALUES:
                        return function() {
                            return new Constructor(this,kind)
                        }
                }
                return function() {
                    return new Constructor(this,kind)
                }
            }, TAG = NAME + " Iterator", DEF_VALUES = DEFAULT == VALUES, VALUES_BUG = !1, proto = Base.prototype, $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT], $default = $native || getMethod(DEFAULT), $entries = DEFAULT ? DEF_VALUES ? getMethod("entries") : $default : void 0, $anyNative = "Array" == NAME ? proto.entries || $native : $native;
            if ($anyNative && (IteratorPrototype = getPrototypeOf($anyNative.call(new Base)),
                IteratorPrototype !== Object.prototype && (setToStringTag(IteratorPrototype, TAG, !0),
                LIBRARY || has(IteratorPrototype, ITERATOR) || hide(IteratorPrototype, ITERATOR, returnThis))),
                DEF_VALUES && $native && $native.name !== VALUES && (VALUES_BUG = !0,
                        $default = function() {
                            return $native.call(this)
                        }
                ),
                LIBRARY && !FORCED || !BUGGY && !VALUES_BUG && proto[ITERATOR] || hide(proto, ITERATOR, $default),
                    Iterators[NAME] = $default,
                    Iterators[TAG] = returnThis,
                    DEFAULT)
                if (methods = {
                        values: DEF_VALUES ? $default : getMethod(VALUES),
                        keys: IS_SET ? $default : getMethod(KEYS),
                        entries: $entries
                    },
                        FORCED)
                    for (key in methods)
                        key in proto || redefine(proto, key, methods[key]);
                else
                    $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
            return methods
        }
    }
        , {
            "./_export": 25,
            "./_has": 28,
            "./_hide": 29,
            "./_iter-create": 35,
            "./_iterators": 38,
            "./_library": 40,
            "./_object-gpo": 49,
            "./_redefine": 54,
            "./_set-to-string-tag": 55,
            "./_wks": 68
        }],
    37: [function(require, module, exports) {
        module.exports = function(done, value) {
            return {
                value: value,
                done: !!done
            }
        }
    }
        , {}],
    38: [function(require, module, exports) {
        module.exports = {}
    }
        , {}],
    39: [function(require, module, exports) {
        var getKeys = require("./_object-keys")
            , toIObject = require("./_to-iobject");
        module.exports = function(object, el) {
            for (var key, O = toIObject(object), keys = getKeys(O), length = keys.length, index = 0; length > index; )
                if (O[key = keys[index++]] === el)
                    return key
        }
    }
        , {
            "./_object-keys": 51,
            "./_to-iobject": 61
        }],
    40: [function(require, module, exports) {
        module.exports = !0
    }
        , {}],
    41: [function(require, module, exports) {
        var META = require("./_uid")("meta")
            , isObject = require("./_is-object")
            , has = require("./_has")
            , setDesc = require("./_object-dp").f
            , id = 0
            , isExtensible = Object.isExtensible || function() {
                return !0
            }
            , FREEZE = !require("./_fails")(function() {
            return isExtensible(Object.preventExtensions({}))
        })
            , setMeta = function(it) {
            setDesc(it, META, {
                value: {
                    i: "O" + ++id,
                    w: {}
                }
            })
        }
            , fastKey = function(it, create) {
            if (!isObject(it))
                return "symbol" == typeof it ? it : ("string" == typeof it ? "S" : "P") + it;
            if (!has(it, META)) {
                if (!isExtensible(it))
                    return "F";
                if (!create)
                    return "E";
                setMeta(it)
            }
            return it[META].i
        }
            , getWeak = function(it, create) {
            if (!has(it, META)) {
                if (!isExtensible(it))
                    return !0;
                if (!create)
                    return !1;
                setMeta(it)
            }
            return it[META].w
        }
            , onFreeze = function(it) {
            return FREEZE && meta.NEED && isExtensible(it) && !has(it, META) && setMeta(it),
                it
        }
            , meta = module.exports = {
            KEY: META,
            NEED: !1,
            fastKey: fastKey,
            getWeak: getWeak,
            onFreeze: onFreeze
        }
    }
        , {
            "./_fails": 26,
            "./_has": 28,
            "./_is-object": 34,
            "./_object-dp": 43,
            "./_uid": 65
        }],
    42: [function(require, module, exports) {
        var anObject = require("./_an-object")
            , dPs = require("./_object-dps")
            , enumBugKeys = require("./_enum-bug-keys")
            , IE_PROTO = require("./_shared-key")("IE_PROTO")
            , Empty = function() {}
            , PROTOTYPE = "prototype"
            , createDict = function() {
            var iframeDocument, iframe = require("./_dom-create")("iframe"), i = enumBugKeys.length, lt = "<", gt = ">";
            for (iframe.style.display = "none",
                     require("./_html").appendChild(iframe),
                     iframe.src = "javascript:",
                     iframeDocument = iframe.contentWindow.document,
                     iframeDocument.open(),
                     iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt),
                     iframeDocument.close(),
                     createDict = iframeDocument.F; i--; )
                delete createDict[PROTOTYPE][enumBugKeys[i]];
            return createDict()
        };
        module.exports = Object.create || function(O, Properties) {
                var result;
                return null !== O ? (Empty[PROTOTYPE] = anObject(O),
                    result = new Empty,
                    Empty[PROTOTYPE] = null,
                    result[IE_PROTO] = O) : result = createDict(),
                    void 0 === Properties ? result : dPs(result, Properties)
            }
    }
        , {
            "./_an-object": 14,
            "./_dom-create": 22,
            "./_enum-bug-keys": 23,
            "./_html": 30,
            "./_object-dps": 44,
            "./_shared-key": 56
        }],
    43: [function(require, module, exports) {
        var anObject = require("./_an-object")
            , IE8_DOM_DEFINE = require("./_ie8-dom-define")
            , toPrimitive = require("./_to-primitive")
            , dP = Object.defineProperty;
        exports.f = require("./_descriptors") ? Object.defineProperty : function(O, P, Attributes) {
            if (anObject(O),
                    P = toPrimitive(P, !0),
                    anObject(Attributes),
                    IE8_DOM_DEFINE)
                try {
                    return dP(O, P, Attributes)
                } catch (e) {}
            if ("get"in Attributes || "set"in Attributes)
                throw TypeError("Accessors not supported!");
            return "value"in Attributes && (O[P] = Attributes.value),
                O
        }
    }
        , {
            "./_an-object": 14,
            "./_descriptors": 21,
            "./_ie8-dom-define": 31,
            "./_to-primitive": 64
        }],
    44: [function(require, module, exports) {
        var dP = require("./_object-dp")
            , anObject = require("./_an-object")
            , getKeys = require("./_object-keys");
        module.exports = require("./_descriptors") ? Object.defineProperties : function(O, Properties) {
            anObject(O);
            for (var P, keys = getKeys(Properties), length = keys.length, i = 0; length > i; )
                dP.f(O, P = keys[i++], Properties[P]);
            return O
        }
    }
        , {
            "./_an-object": 14,
            "./_descriptors": 21,
            "./_object-dp": 43,
            "./_object-keys": 51
        }],
    45: [function(require, module, exports) {
        var pIE = require("./_object-pie")
            , createDesc = require("./_property-desc")
            , toIObject = require("./_to-iobject")
            , toPrimitive = require("./_to-primitive")
            , has = require("./_has")
            , IE8_DOM_DEFINE = require("./_ie8-dom-define")
            , gOPD = Object.getOwnPropertyDescriptor;
        exports.f = require("./_descriptors") ? gOPD : function(O, P) {
            if (O = toIObject(O),
                    P = toPrimitive(P, !0),
                    IE8_DOM_DEFINE)
                try {
                    return gOPD(O, P)
                } catch (e) {}
            if (has(O, P))
                return createDesc(!pIE.f.call(O, P), O[P])
        }
    }
        , {
            "./_descriptors": 21,
            "./_has": 28,
            "./_ie8-dom-define": 31,
            "./_object-pie": 52,
            "./_property-desc": 53,
            "./_to-iobject": 61,
            "./_to-primitive": 64
        }],
    46: [function(require, module, exports) {
        var toIObject = require("./_to-iobject")
            , gOPN = require("./_object-gopn").f
            , toString = {}.toString
            , windowNames = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []
            , getWindowNames = function(it) {
            try {
                return gOPN(it)
            } catch (e) {
                return windowNames.slice()
            }
        };
        module.exports.f = function(it) {
            return windowNames && "[object Window]" == toString.call(it) ? getWindowNames(it) : gOPN(toIObject(it))
        }
    }
        , {
            "./_object-gopn": 47,
            "./_to-iobject": 61
        }],
    47: [function(require, module, exports) {
        var $keys = require("./_object-keys-internal")
            , hiddenKeys = require("./_enum-bug-keys").concat("length", "prototype");
        exports.f = Object.getOwnPropertyNames || function(O) {
                return $keys(O, hiddenKeys)
            }
    }
        , {
            "./_enum-bug-keys": 23,
            "./_object-keys-internal": 50
        }],
    48: [function(require, module, exports) {
        exports.f = Object.getOwnPropertySymbols
    }
        , {}],
    49: [function(require, module, exports) {
        var has = require("./_has")
            , toObject = require("./_to-object")
            , IE_PROTO = require("./_shared-key")("IE_PROTO")
            , ObjectProto = Object.prototype;
        module.exports = Object.getPrototypeOf || function(O) {
                return O = toObject(O),
                    has(O, IE_PROTO) ? O[IE_PROTO] : "function" == typeof O.constructor && O instanceof O.constructor ? O.constructor.prototype : O instanceof Object ? ObjectProto : null
            }
    }
        , {
            "./_has": 28,
            "./_shared-key": 56,
            "./_to-object": 63
        }],
    50: [function(require, module, exports) {
        var has = require("./_has")
            , toIObject = require("./_to-iobject")
            , arrayIndexOf = require("./_array-includes")(!1)
            , IE_PROTO = require("./_shared-key")("IE_PROTO");
        module.exports = function(object, names) {
            var key, O = toIObject(object), i = 0, result = [];
            for (key in O)
                key != IE_PROTO && has(O, key) && result.push(key);
            for (; names.length > i; )
                has(O, key = names[i++]) && (~arrayIndexOf(result, key) || result.push(key));
            return result
        }
    }
        , {
            "./_array-includes": 15,
            "./_has": 28,
            "./_shared-key": 56,
            "./_to-iobject": 61
        }],
    51: [function(require, module, exports) {
        var $keys = require("./_object-keys-internal")
            , enumBugKeys = require("./_enum-bug-keys");
        module.exports = Object.keys || function(O) {
                return $keys(O, enumBugKeys)
            }
    }
        , {
            "./_enum-bug-keys": 23,
            "./_object-keys-internal": 50
        }],
    52: [function(require, module, exports) {
        exports.f = {}.propertyIsEnumerable
    }
        , {}],
    53: [function(require, module, exports) {
        module.exports = function(bitmap, value) {
            return {
                enumerable: !(1 & bitmap),
                configurable: !(2 & bitmap),
                writable: !(4 & bitmap),
                value: value
            }
        }
    }
        , {}],
    54: [function(require, module, exports) {
        module.exports = require("./_hide")
    }
        , {
            "./_hide": 29
        }],
    55: [function(require, module, exports) {
        var def = require("./_object-dp").f
            , has = require("./_has")
            , TAG = require("./_wks")("toStringTag");
        module.exports = function(it, tag, stat) {
            it && !has(it = stat ? it : it.prototype, TAG) && def(it, TAG, {
                configurable: !0,
                value: tag
            })
        }
    }
        , {
            "./_has": 28,
            "./_object-dp": 43,
            "./_wks": 68
        }],
    56: [function(require, module, exports) {
        var shared = require("./_shared")("keys")
            , uid = require("./_uid");
        module.exports = function(key) {
            return shared[key] || (shared[key] = uid(key))
        }
    }
        , {
            "./_shared": 57,
            "./_uid": 65
        }],
    57: [function(require, module, exports) {
        var global = require("./_global")
            , SHARED = "__core-js_shared__"
            , store = global[SHARED] || (global[SHARED] = {});
        module.exports = function(key) {
            return store[key] || (store[key] = {})
        }
    }
        , {
            "./_global": 27
        }],
    58: [function(require, module, exports) {
        var toInteger = require("./_to-integer")
            , defined = require("./_defined");
        module.exports = function(TO_STRING) {
            return function(that, pos) {
                var a, b, s = String(defined(that)), i = toInteger(pos), l = s.length;
                return i < 0 || i >= l ? TO_STRING ? "" : void 0 : (a = s.charCodeAt(i),
                    a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536)
            }
        }
    }
        , {
            "./_defined": 20,
            "./_to-integer": 60
        }],
    59: [function(require, module, exports) {
        var toInteger = require("./_to-integer")
            , max = Math.max
            , min = Math.min;
        module.exports = function(index, length) {
            return index = toInteger(index),
                index < 0 ? max(index + length, 0) : min(index, length)
        }
    }
        , {
            "./_to-integer": 60
        }],
    60: [function(require, module, exports) {
        var ceil = Math.ceil
            , floor = Math.floor;
        module.exports = function(it) {
            return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it)
        }
    }
        , {}],
    61: [function(require, module, exports) {
        var IObject = require("./_iobject")
            , defined = require("./_defined");
        module.exports = function(it) {
            return IObject(defined(it))
        }
    }
        , {
            "./_defined": 20,
            "./_iobject": 32
        }],
    62: [function(require, module, exports) {
        var toInteger = require("./_to-integer")
            , min = Math.min;
        module.exports = function(it) {
            return it > 0 ? min(toInteger(it), 9007199254740991) : 0
        }
    }
        , {
            "./_to-integer": 60
        }],
    63: [function(require, module, exports) {
        var defined = require("./_defined");
        module.exports = function(it) {
            return Object(defined(it))
        }
    }
        , {
            "./_defined": 20
        }],
    64: [function(require, module, exports) {
        var isObject = require("./_is-object");
        module.exports = function(it, S) {
            if (!isObject(it))
                return it;
            var fn, val;
            if (S && "function" == typeof (fn = it.toString) && !isObject(val = fn.call(it)))
                return val;
            if ("function" == typeof (fn = it.valueOf) && !isObject(val = fn.call(it)))
                return val;
            if (!S && "function" == typeof (fn = it.toString) && !isObject(val = fn.call(it)))
                return val;
            throw TypeError("Can't convert object to primitive value")
        }
    }
        , {
            "./_is-object": 34
        }],
    65: [function(require, module, exports) {
        var id = 0
            , px = Math.random();
        module.exports = function(key) {
            return "Symbol(".concat(void 0 === key ? "" : key, ")_", (++id + px).toString(36))
        }
    }
        , {}],
    66: [function(require, module, exports) {
        var global = require("./_global")
            , core = require("./_core")
            , LIBRARY = require("./_library")
            , wksExt = require("./_wks-ext")
            , defineProperty = require("./_object-dp").f;
        module.exports = function(name) {
            var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
            "_" == name.charAt(0) || name in $Symbol || defineProperty($Symbol, name, {
                value: wksExt.f(name)
            })
        }
    }
        , {
            "./_core": 18,
            "./_global": 27,
            "./_library": 40,
            "./_object-dp": 43,
            "./_wks-ext": 67
        }],
    67: [function(require, module, exports) {
        exports.f = require("./_wks")
    }
        , {
            "./_wks": 68
        }],
    68: [function(require, module, exports) {
        var store = require("./_shared")("wks")
            , uid = require("./_uid")
            , Symbol = require("./_global").Symbol
            , USE_SYMBOL = "function" == typeof Symbol
            , $exports = module.exports = function(name) {
                return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)("Symbol." + name))
            }
            ;
        $exports.store = store
    }
        , {
            "./_global": 27,
            "./_shared": 57,
            "./_uid": 65
        }],
    69: [function(require, module, exports) {
        var classof = require("./_classof")
            , ITERATOR = require("./_wks")("iterator")
            , Iterators = require("./_iterators");
        module.exports = require("./_core").getIteratorMethod = function(it) {
            if (void 0 != it)
                return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)]
        }
    }
        , {
            "./_classof": 16,
            "./_core": 18,
            "./_iterators": 38,
            "./_wks": 68
        }],
    70: [function(require, module, exports) {
        var anObject = require("./_an-object")
            , get = require("./core.get-iterator-method");
        module.exports = require("./_core").getIterator = function(it) {
            var iterFn = get(it);
            if ("function" != typeof iterFn)
                throw TypeError(it + " is not iterable!");
            return anObject(iterFn.call(it))
        }
    }
        , {
            "./_an-object": 14,
            "./_core": 18,
            "./core.get-iterator-method": 69
        }],
    71: [function(require, module, exports) {
        "use strict";
        var addToUnscopables = require("./_add-to-unscopables")
            , step = require("./_iter-step")
            , Iterators = require("./_iterators")
            , toIObject = require("./_to-iobject");
        module.exports = require("./_iter-define")(Array, "Array", function(iterated, kind) {
            this._t = toIObject(iterated),
                this._i = 0,
                this._k = kind
        }, function() {
            var O = this._t
                , kind = this._k
                , index = this._i++;
            return !O || index >= O.length ? (this._t = void 0,
                step(1)) : "keys" == kind ? step(0, index) : "values" == kind ? step(0, O[index]) : step(0, [index, O[index]])
        }, "values"),
            Iterators.Arguments = Iterators.Array,
            addToUnscopables("keys"),
            addToUnscopables("values"),
            addToUnscopables("entries")
    }
        , {
            "./_add-to-unscopables": 13,
            "./_iter-define": 36,
            "./_iter-step": 37,
            "./_iterators": 38,
            "./_to-iobject": 61
        }],
    72: [function(require, module, exports) {}
        , {}],
    73: [function(require, module, exports) {
        "use strict";
        var $at = require("./_string-at")(!0);
        require("./_iter-define")(String, "String", function(iterated) {
            this._t = String(iterated),
                this._i = 0
        }, function() {
            var point, O = this._t, index = this._i;
            return index >= O.length ? {
                value: void 0,
                done: !0
            } : (point = $at(O, index),
                this._i += point.length,
                {
                    value: point,
                    done: !1
                })
        })
    }
        , {
            "./_iter-define": 36,
            "./_string-at": 58
        }],
    74: [function(require, module, exports) {
        "use strict";
        var global = require("./_global")
            , has = require("./_has")
            , DESCRIPTORS = require("./_descriptors")
            , $export = require("./_export")
            , redefine = require("./_redefine")
            , META = require("./_meta").KEY
            , $fails = require("./_fails")
            , shared = require("./_shared")
            , setToStringTag = require("./_set-to-string-tag")
            , uid = require("./_uid")
            , wks = require("./_wks")
            , wksExt = require("./_wks-ext")
            , wksDefine = require("./_wks-define")
            , keyOf = require("./_keyof")
            , enumKeys = require("./_enum-keys")
            , isArray = require("./_is-array")
            , anObject = require("./_an-object")
            , toIObject = require("./_to-iobject")
            , toPrimitive = require("./_to-primitive")
            , createDesc = require("./_property-desc")
            , _create = require("./_object-create")
            , gOPNExt = require("./_object-gopn-ext")
            , $GOPD = require("./_object-gopd")
            , $DP = require("./_object-dp")
            , $keys = require("./_object-keys")
            , gOPD = $GOPD.f
            , dP = $DP.f
            , gOPN = gOPNExt.f
            , $Symbol = global.Symbol
            , $JSON = global.JSON
            , _stringify = $JSON && $JSON.stringify
            , PROTOTYPE = "prototype"
            , HIDDEN = wks("_hidden")
            , TO_PRIMITIVE = wks("toPrimitive")
            , isEnum = {}.propertyIsEnumerable
            , SymbolRegistry = shared("symbol-registry")
            , AllSymbols = shared("symbols")
            , OPSymbols = shared("op-symbols")
            , ObjectProto = Object[PROTOTYPE]
            , USE_NATIVE = "function" == typeof $Symbol
            , QObject = global.QObject
            , setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild
            , setSymbolDesc = DESCRIPTORS && $fails(function() {
            return 7 != _create(dP({}, "a", {
                    get: function() {
                        return dP(this, "a", {
                            value: 7
                        }).a
                    }
                })).a
        }) ? function(it, key, D) {
            var protoDesc = gOPD(ObjectProto, key);
            protoDesc && delete ObjectProto[key],
                dP(it, key, D),
            protoDesc && it !== ObjectProto && dP(ObjectProto, key, protoDesc)
        }
            : dP
            , wrap = function(tag) {
            var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
            return sym._k = tag,
                sym
        }
            , isSymbol = USE_NATIVE && "symbol" == typeof $Symbol.iterator ? function(it) {
            return "symbol" == typeof it
        }
            : function(it) {
            return it instanceof $Symbol
        }
            , $defineProperty = function(it, key, D) {
            return it === ObjectProto && $defineProperty(OPSymbols, key, D),
                anObject(it),
                key = toPrimitive(key, !0),
                anObject(D),
                has(AllSymbols, key) ? (D.enumerable ? (has(it, HIDDEN) && it[HIDDEN][key] && (it[HIDDEN][key] = !1),
                    D = _create(D, {
                        enumerable: createDesc(0, !1)
                    })) : (has(it, HIDDEN) || dP(it, HIDDEN, createDesc(1, {})),
                    it[HIDDEN][key] = !0),
                    setSymbolDesc(it, key, D)) : dP(it, key, D)
        }
            , $defineProperties = function(it, P) {
            anObject(it);
            for (var key, keys = enumKeys(P = toIObject(P)), i = 0, l = keys.length; l > i; )
                $defineProperty(it, key = keys[i++], P[key]);
            return it
        }
            , $create = function(it, P) {
            return void 0 === P ? _create(it) : $defineProperties(_create(it), P)
        }
            , $propertyIsEnumerable = function(key) {
            var E = isEnum.call(this, key = toPrimitive(key, !0));
            return !(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) && (!(E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]) || E)
        }
            , $getOwnPropertyDescriptor = function(it, key) {
            if (it = toIObject(it),
                    key = toPrimitive(key, !0),
                it !== ObjectProto || !has(AllSymbols, key) || has(OPSymbols, key)) {
                var D = gOPD(it, key);
                return !D || !has(AllSymbols, key) || has(it, HIDDEN) && it[HIDDEN][key] || (D.enumerable = !0),
                    D
            }
        }
            , $getOwnPropertyNames = function(it) {
            for (var key, names = gOPN(toIObject(it)), result = [], i = 0; names.length > i; )
                has(AllSymbols, key = names[i++]) || key == HIDDEN || key == META || result.push(key);
            return result
        }
            , $getOwnPropertySymbols = function(it) {
            for (var key, IS_OP = it === ObjectProto, names = gOPN(IS_OP ? OPSymbols : toIObject(it)), result = [], i = 0; names.length > i; )
                !has(AllSymbols, key = names[i++]) || IS_OP && !has(ObjectProto, key) || result.push(AllSymbols[key]);
            return result
        };
        USE_NATIVE || ($Symbol = function() {
                if (this instanceof $Symbol)
                    throw TypeError("Symbol is not a constructor!");
                var tag = uid(arguments.length > 0 ? arguments[0] : void 0)
                    , $set = function(value) {
                    this === ObjectProto && $set.call(OPSymbols, value),
                    has(this, HIDDEN) && has(this[HIDDEN], tag) && (this[HIDDEN][tag] = !1),
                        setSymbolDesc(this, tag, createDesc(1, value))
                };
                return DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
                    configurable: !0,
                    set: $set
                }),
                    wrap(tag)
            }
                ,
                redefine($Symbol[PROTOTYPE], "toString", function() {
                    return this._k
                }),
                $GOPD.f = $getOwnPropertyDescriptor,
                $DP.f = $defineProperty,
                require("./_object-gopn").f = gOPNExt.f = $getOwnPropertyNames,
                require("./_object-pie").f = $propertyIsEnumerable,
                require("./_object-gops").f = $getOwnPropertySymbols,
            DESCRIPTORS && !require("./_library") && redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, !0),
                wksExt.f = function(name) {
                    return wrap(wks(name))
                }
        ),
            $export($export.G + $export.W + $export.F * !USE_NATIVE, {
                Symbol: $Symbol
            });
        for (var symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), i = 0; symbols.length > i; )
            wks(symbols[i++]);
        for (var symbols = $keys(wks.store), i = 0; symbols.length > i; )
            wksDefine(symbols[i++]);
        $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
            for: function(key) {
                return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key)
            },
            keyFor: function(key) {
                if (isSymbol(key))
                    return keyOf(SymbolRegistry, key);
                throw TypeError(key + " is not a symbol!")
            },
            useSetter: function() {
                setter = !0
            },
            useSimple: function() {
                setter = !1
            }
        }),
            $export($export.S + $export.F * !USE_NATIVE, "Object", {
                create: $create,
                defineProperty: $defineProperty,
                defineProperties: $defineProperties,
                getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
                getOwnPropertyNames: $getOwnPropertyNames,
                getOwnPropertySymbols: $getOwnPropertySymbols
            }),
        $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
                var S = $Symbol();
                return "[null]" != _stringify([S]) || "{}" != _stringify({
                        a: S
                    }) || "{}" != _stringify(Object(S))
            })), "JSON", {
            stringify: function(it) {
                if (void 0 !== it && !isSymbol(it)) {
                    for (var replacer, $replacer, args = [it], i = 1; arguments.length > i; )
                        args.push(arguments[i++]);
                    return replacer = args[1],
                    "function" == typeof replacer && ($replacer = replacer),
                    !$replacer && isArray(replacer) || (replacer = function(key, value) {
                            if ($replacer && (value = $replacer.call(this, key, value)),
                                    !isSymbol(value))
                                return value
                        }
                    ),
                        args[1] = replacer,
                        _stringify.apply($JSON, args)
                }
            }
        }),
        $Symbol[PROTOTYPE][TO_PRIMITIVE] || require("./_hide")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf),
            setToStringTag($Symbol, "Symbol"),
            setToStringTag(Math, "Math", !0),
            setToStringTag(global.JSON, "JSON", !0)
    }
        , {
            "./_an-object": 14,
            "./_descriptors": 21,
            "./_enum-keys": 24,
            "./_export": 25,
            "./_fails": 26,
            "./_global": 27,
            "./_has": 28,
            "./_hide": 29,
            "./_is-array": 33,
            "./_keyof": 39,
            "./_library": 40,
            "./_meta": 41,
            "./_object-create": 42,
            "./_object-dp": 43,
            "./_object-gopd": 45,
            "./_object-gopn": 47,
            "./_object-gopn-ext": 46,
            "./_object-gops": 48,
            "./_object-keys": 51,
            "./_object-pie": 52,
            "./_property-desc": 53,
            "./_redefine": 54,
            "./_set-to-string-tag": 55,
            "./_shared": 57,
            "./_to-iobject": 61,
            "./_to-primitive": 64,
            "./_uid": 65,
            "./_wks": 68,
            "./_wks-define": 66,
            "./_wks-ext": 67
        }],
    75: [function(require, module, exports) {
        require("./_wks-define")("asyncIterator")
    }
        , {
            "./_wks-define": 66
        }],
    76: [function(require, module, exports) {
        require("./_wks-define")("observable")
    }
        , {
            "./_wks-define": 66
        }],
    77: [function(require, module, exports) {
        require("./es6.array.iterator");
        for (var global = require("./_global"), hide = require("./_hide"), Iterators = require("./_iterators"), TO_STRING_TAG = require("./_wks")("toStringTag"), collections = ["NodeList", "DOMTokenList", "MediaList", "StyleSheetList", "CSSRuleList"], i = 0; i < 5; i++) {
            var NAME = collections[i]
                , Collection = global[NAME]
                , proto = Collection && Collection.prototype;
            proto && !proto[TO_STRING_TAG] && hide(proto, TO_STRING_TAG, NAME),
                Iterators[NAME] = Iterators.Array
        }
    }
        , {
            "./_global": 27,
            "./_hide": 29,
            "./_iterators": 38,
            "./_wks": 68,
            "./es6.array.iterator": 71
        }],
    78: [function(require, module, exports) {
        (function(process, global) {
                !function(global, factory) {
                    "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.ES6Promise = factory()
                }(this, function() {
                    "use strict";
                    function objectOrFunction(x) {
                        return "function" == typeof x || "object" == typeof x && null !== x
                    }
                    function isFunction(x) {
                        return "function" == typeof x
                    }
                    function setScheduler(scheduleFn) {
                        customSchedulerFn = scheduleFn
                    }
                    function setAsap(asapFn) {
                        asap = asapFn
                    }
                    function useNextTick() {
                        return function() {
                            return process.nextTick(flush)
                        }
                    }
                    function useVertxTimer() {
                        return "undefined" != typeof vertxNext ? function() {
                            vertxNext(flush)
                        }
                            : useSetTimeout()
                    }
                    function useMutationObserver() {
                        var iterations = 0
                            , observer = new BrowserMutationObserver(flush)
                            , node = document.createTextNode("");
                        return observer.observe(node, {
                            characterData: !0
                        }),
                            function() {
                                node.data = iterations = ++iterations % 2
                            }
                    }
                    function useMessageChannel() {
                        var channel = new MessageChannel;
                        return channel.port1.onmessage = flush,
                            function() {
                                return channel.port2.postMessage(0)
                            }
                    }
                    function useSetTimeout() {
                        var globalSetTimeout = setTimeout;
                        return function() {
                            return globalSetTimeout(flush, 1)
                        }
                    }
                    function flush() {
                        for (var i = 0; i < len; i += 2) {
                            var callback = queue[i]
                                , arg = queue[i + 1];
                            callback(arg),
                                queue[i] = void 0,
                                queue[i + 1] = void 0
                        }
                        len = 0
                    }
                    function attemptVertx() {
                        try {
                            var r = require
                                , vertx = r("vertx");
                            return vertxNext = vertx.runOnLoop || vertx.runOnContext,
                                useVertxTimer()
                        } catch (e) {
                            return useSetTimeout()
                        }
                    }
                    function then(onFulfillment, onRejection) {
                        var _arguments = arguments
                            , parent = this
                            , child = new this.constructor(noop);
                        void 0 === child[PROMISE_ID] && makePromise(child);
                        var _state = parent._state;
                        return _state ? !function() {
                            var callback = _arguments[_state - 1];
                            asap(function() {
                                return invokeCallback(_state, child, callback, parent._result)
                            })
                        }() : subscribe(parent, child, onFulfillment, onRejection),
                            child
                    }
                    function resolve(object) {
                        var Constructor = this;
                        if (object && "object" == typeof object && object.constructor === Constructor)
                            return object;
                        var promise = new Constructor(noop);
                        return _resolve(promise, object),
                            promise
                    }
                    function noop() {}
                    function selfFulfillment() {
                        return new TypeError("You cannot resolve a promise with itself")
                    }
                    function cannotReturnOwn() {
                        return new TypeError("A promises callback cannot return that same promise.")
                    }
                    function getThen(promise) {
                        try {
                            return promise.then
                        } catch (error) {
                            return GET_THEN_ERROR.error = error,
                                GET_THEN_ERROR
                        }
                    }
                    function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
                        try {
                            then.call(value, fulfillmentHandler, rejectionHandler)
                        } catch (e) {
                            return e
                        }
                    }
                    function handleForeignThenable(promise, thenable, then) {
                        asap(function(promise) {
                            var sealed = !1
                                , error = tryThen(then, thenable, function(value) {
                                sealed || (sealed = !0,
                                    thenable !== value ? _resolve(promise, value) : fulfill(promise, value))
                            }, function(reason) {
                                sealed || (sealed = !0,
                                    _reject(promise, reason))
                            }, "Settle: " + (promise._label || " unknown promise"));
                            !sealed && error && (sealed = !0,
                                _reject(promise, error))
                        }, promise)
                    }
                    function handleOwnThenable(promise, thenable) {
                        thenable._state === FULFILLED ? fulfill(promise, thenable._result) : thenable._state === REJECTED ? _reject(promise, thenable._result) : subscribe(thenable, void 0, function(value) {
                            return _resolve(promise, value)
                        }, function(reason) {
                            return _reject(promise, reason)
                        })
                    }
                    function handleMaybeThenable(promise, maybeThenable, then$$) {
                        maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve ? handleOwnThenable(promise, maybeThenable) : then$$ === GET_THEN_ERROR ? _reject(promise, GET_THEN_ERROR.error) : void 0 === then$$ ? fulfill(promise, maybeThenable) : isFunction(then$$) ? handleForeignThenable(promise, maybeThenable, then$$) : fulfill(promise, maybeThenable)
                    }
                    function _resolve(promise, value) {
                        promise === value ? _reject(promise, selfFulfillment()) : objectOrFunction(value) ? handleMaybeThenable(promise, value, getThen(value)) : fulfill(promise, value)
                    }
                    function publishRejection(promise) {
                        promise._onerror && promise._onerror(promise._result),
                            publish(promise)
                    }
                    function fulfill(promise, value) {
                        promise._state === PENDING && (promise._result = value,
                            promise._state = FULFILLED,
                        0 !== promise._subscribers.length && asap(publish, promise))
                    }
                    function _reject(promise, reason) {
                        promise._state === PENDING && (promise._state = REJECTED,
                            promise._result = reason,
                            asap(publishRejection, promise))
                    }
                    function subscribe(parent, child, onFulfillment, onRejection) {
                        var _subscribers = parent._subscribers
                            , length = _subscribers.length;
                        parent._onerror = null,
                            _subscribers[length] = child,
                            _subscribers[length + FULFILLED] = onFulfillment,
                            _subscribers[length + REJECTED] = onRejection,
                        0 === length && parent._state && asap(publish, parent)
                    }
                    function publish(promise) {
                        var subscribers = promise._subscribers
                            , settled = promise._state;
                        if (0 !== subscribers.length) {
                            for (var child = void 0, callback = void 0, detail = promise._result, i = 0; i < subscribers.length; i += 3)
                                child = subscribers[i],
                                    callback = subscribers[i + settled],
                                    child ? invokeCallback(settled, child, callback, detail) : callback(detail);
                            promise._subscribers.length = 0
                        }
                    }
                    function ErrorObject() {
                        this.error = null
                    }
                    function tryCatch(callback, detail) {
                        try {
                            return callback(detail)
                        } catch (e) {
                            return TRY_CATCH_ERROR.error = e,
                                TRY_CATCH_ERROR
                        }
                    }
                    function invokeCallback(settled, promise, callback, detail) {
                        var hasCallback = isFunction(callback)
                            , value = void 0
                            , error = void 0
                            , succeeded = void 0
                            , failed = void 0;
                        if (hasCallback) {
                            if (value = tryCatch(callback, detail),
                                    value === TRY_CATCH_ERROR ? (failed = !0,
                                        error = value.error,
                                        value = null) : succeeded = !0,
                                promise === value)
                                return void _reject(promise, cannotReturnOwn())
                        } else
                            value = detail,
                                succeeded = !0;
                        promise._state !== PENDING || (hasCallback && succeeded ? _resolve(promise, value) : failed ? _reject(promise, error) : settled === FULFILLED ? fulfill(promise, value) : settled === REJECTED && _reject(promise, value))
                    }
                    function initializePromise(promise, resolver) {
                        try {
                            resolver(function(value) {
                                _resolve(promise, value)
                            }, function(reason) {
                                _reject(promise, reason)
                            })
                        } catch (e) {
                            _reject(promise, e)
                        }
                    }
                    function nextId() {
                        return id++
                    }
                    function makePromise(promise) {
                        promise[PROMISE_ID] = id++,
                            promise._state = void 0,
                            promise._result = void 0,
                            promise._subscribers = []
                    }
                    function Enumerator(Constructor, input) {
                        this._instanceConstructor = Constructor,
                            this.promise = new Constructor(noop),
                        this.promise[PROMISE_ID] || makePromise(this.promise),
                            isArray(input) ? (this._input = input,
                                this.length = input.length,
                                this._remaining = input.length,
                                this._result = new Array(this.length),
                                0 === this.length ? fulfill(this.promise, this._result) : (this.length = this.length || 0,
                                    this._enumerate(),
                                0 === this._remaining && fulfill(this.promise, this._result))) : _reject(this.promise, validationError())
                    }
                    function validationError() {
                        return new Error("Array Methods must be provided an Array")
                    }
                    function all(entries) {
                        return new Enumerator(this,entries).promise
                    }
                    function race(entries) {
                        var Constructor = this;
                        return new Constructor(isArray(entries) ? function(resolve, reject) {
                                for (var length = entries.length, i = 0; i < length; i++)
                                    Constructor.resolve(entries[i]).then(resolve, reject)
                            }
                                : function(_, reject) {
                                return reject(new TypeError("You must pass an array to race."))
                            }
                        )
                    }
                    function reject(reason) {
                        var Constructor = this
                            , promise = new Constructor(noop);
                        return _reject(promise, reason),
                            promise
                    }
                    function needsResolver() {
                        throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")
                    }
                    function needsNew() {
                        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")
                    }
                    function Promise(resolver) {
                        this[PROMISE_ID] = nextId(),
                            this._result = this._state = void 0,
                            this._subscribers = [],
                        noop !== resolver && ("function" != typeof resolver && needsResolver(),
                            this instanceof Promise ? initializePromise(this, resolver) : needsNew())
                    }
                    function polyfill() {
                        var local = void 0;
                        if ("undefined" != typeof global)
                            local = global;
                        else if ("undefined" != typeof self)
                            local = self;
                        else
                            try {
                                local = Function("return this")()
                            } catch (e) {
                                throw new Error("polyfill failed because global object is unavailable in this environment")
                            }
                        var P = local.Promise;
                        if (P) {
                            var promiseToString = null;
                            try {
                                promiseToString = Object.prototype.toString.call(P.resolve())
                            } catch (e) {}
                            if ("[object Promise]" === promiseToString && !P.cast)
                                return
                        }
                        local.Promise = Promise
                    }
                    var _isArray = void 0;
                    _isArray = Array.isArray ? Array.isArray : function(x) {
                        return "[object Array]" === Object.prototype.toString.call(x)
                    }
                    ;
                    var isArray = _isArray
                        , len = 0
                        , vertxNext = void 0
                        , customSchedulerFn = void 0
                        , asap = function(callback, arg) {
                        queue[len] = callback,
                            queue[len + 1] = arg,
                            len += 2,
                        2 === len && (customSchedulerFn ? customSchedulerFn(flush) : scheduleFlush())
                    }
                        , browserWindow = "undefined" != typeof window ? window : void 0
                        , browserGlobal = browserWindow || {}
                        , BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver
                        , isNode = "undefined" == typeof self && "undefined" != typeof process && "[object process]" === {}.toString.call(process)
                        , isWorker = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel
                        , queue = new Array(1e3)
                        , scheduleFlush = void 0;
                    scheduleFlush = isNode ? useNextTick() : BrowserMutationObserver ? useMutationObserver() : isWorker ? useMessageChannel() : void 0 === browserWindow && "function" == typeof require ? attemptVertx() : useSetTimeout();
                    var PROMISE_ID = Math.random().toString(36).substring(16)
                        , PENDING = void 0
                        , FULFILLED = 1
                        , REJECTED = 2
                        , GET_THEN_ERROR = new ErrorObject
                        , TRY_CATCH_ERROR = new ErrorObject
                        , id = 0;
                    return Enumerator.prototype._enumerate = function() {
                        for (var length = this.length, _input = this._input, i = 0; this._state === PENDING && i < length; i++)
                            this._eachEntry(_input[i], i)
                    }
                        ,
                        Enumerator.prototype._eachEntry = function(entry, i) {
                            var c = this._instanceConstructor
                                , resolve$$ = c.resolve;
                            if (resolve$$ === resolve) {
                                var _then = getThen(entry);
                                if (_then === then && entry._state !== PENDING)
                                    this._settledAt(entry._state, i, entry._result);
                                else if ("function" != typeof _then)
                                    this._remaining--,
                                        this._result[i] = entry;
                                else if (c === Promise) {
                                    var promise = new c(noop);
                                    handleMaybeThenable(promise, entry, _then),
                                        this._willSettleAt(promise, i)
                                } else
                                    this._willSettleAt(new c(function(resolve$$) {
                                            return resolve$$(entry)
                                        }
                                    ), i)
                            } else
                                this._willSettleAt(resolve$$(entry), i)
                        }
                        ,
                        Enumerator.prototype._settledAt = function(state, i, value) {
                            var promise = this.promise;
                            promise._state === PENDING && (this._remaining--,
                                state === REJECTED ? _reject(promise, value) : this._result[i] = value),
                            0 === this._remaining && fulfill(promise, this._result)
                        }
                        ,
                        Enumerator.prototype._willSettleAt = function(promise, i) {
                            var enumerator = this;
                            subscribe(promise, void 0, function(value) {
                                return enumerator._settledAt(FULFILLED, i, value)
                            }, function(reason) {
                                return enumerator._settledAt(REJECTED, i, reason)
                            })
                        }
                        ,
                        Promise.all = all,
                        Promise.race = race,
                        Promise.resolve = resolve,
                        Promise.reject = reject,
                        Promise._setScheduler = setScheduler,
                        Promise._setAsap = setAsap,
                        Promise._asap = asap,
                        Promise.prototype = {
                            constructor: Promise,
                            then: then,
                            catch: function(onRejection) {
                                return this.then(null, onRejection)
                            }
                        },
                        Promise.polyfill = polyfill,
                        Promise.Promise = Promise,
                        Promise
                })
            }
        ).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }
        , {
            _process: 97
        }],
    79: [function(require, module, exports) {
        function EventEmitter() {
            this._events = this._events || {},
                this._maxListeners = this._maxListeners || void 0
        }
        function isFunction(arg) {
            return "function" == typeof arg
        }
        function isNumber(arg) {
            return "number" == typeof arg
        }
        function isObject(arg) {
            return "object" == typeof arg && null !== arg
        }
        function isUndefined(arg) {
            return void 0 === arg
        }
        module.exports = EventEmitter,
            EventEmitter.EventEmitter = EventEmitter,
            EventEmitter.prototype._events = void 0,
            EventEmitter.prototype._maxListeners = void 0,
            EventEmitter.defaultMaxListeners = 10,
            EventEmitter.prototype.setMaxListeners = function(n) {
                if (!isNumber(n) || n < 0 || isNaN(n))
                    throw TypeError("n must be a positive number");
                return this._maxListeners = n,
                    this
            }
            ,
            EventEmitter.prototype.emit = function(type) {
                var er, handler, len, args, i, listeners;
                if (this._events || (this._events = {}),
                    "error" === type && (!this._events.error || isObject(this._events.error) && !this._events.error.length)) {
                    if (er = arguments[1],
                        er instanceof Error)
                        throw er;
                    var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
                    throw err.context = er,
                        err
                }
                if (handler = this._events[type],
                        isUndefined(handler))
                    return !1;
                if (isFunction(handler))
                    switch (arguments.length) {
                        case 1:
                            handler.call(this);
                            break;
                        case 2:
                            handler.call(this, arguments[1]);
                            break;
                        case 3:
                            handler.call(this, arguments[1], arguments[2]);
                            break;
                        default:
                            args = Array.prototype.slice.call(arguments, 1),
                                handler.apply(this, args)
                    }
                else if (isObject(handler))
                    for (args = Array.prototype.slice.call(arguments, 1),
                             listeners = handler.slice(),
                             len = listeners.length,
                             i = 0; i < len; i++)
                        listeners[i].apply(this, args);
                return !0
            }
            ,
            EventEmitter.prototype.addListener = function(type, listener) {
                var m;
                if (!isFunction(listener))
                    throw TypeError("listener must be a function");
                return this._events || (this._events = {}),
                this._events.newListener && this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener),
                    this._events[type] ? isObject(this._events[type]) ? this._events[type].push(listener) : this._events[type] = [this._events[type], listener] : this._events[type] = listener,
                isObject(this._events[type]) && !this._events[type].warned && (m = isUndefined(this._maxListeners) ? EventEmitter.defaultMaxListeners : this._maxListeners,
                m && m > 0 && this._events[type].length > m && (this._events[type].warned = !0,
                    console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[type].length),
                "function" == typeof console.trace && console.trace())),
                    this
            }
            ,
            EventEmitter.prototype.on = EventEmitter.prototype.addListener,
            EventEmitter.prototype.once = function(type, listener) {
                function g() {
                    this.removeListener(type, g),
                    fired || (fired = !0,
                        listener.apply(this, arguments))
                }
                if (!isFunction(listener))
                    throw TypeError("listener must be a function");
                var fired = !1;
                return g.listener = listener,
                    this.on(type, g),
                    this
            }
            ,
            EventEmitter.prototype.removeListener = function(type, listener) {
                var list, position, length, i;
                if (!isFunction(listener))
                    throw TypeError("listener must be a function");
                if (!this._events || !this._events[type])
                    return this;
                if (list = this._events[type],
                        length = list.length,
                        position = -1,
                    list === listener || isFunction(list.listener) && list.listener === listener)
                    delete this._events[type],
                    this._events.removeListener && this.emit("removeListener", type, listener);
                else if (isObject(list)) {
                    for (i = length; i-- > 0; )
                        if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                            position = i;
                            break
                        }
                    if (position < 0)
                        return this;
                    1 === list.length ? (list.length = 0,
                        delete this._events[type]) : list.splice(position, 1),
                    this._events.removeListener && this.emit("removeListener", type, listener)
                }
                return this
            }
            ,
            EventEmitter.prototype.removeAllListeners = function(type) {
                var key, listeners;
                if (!this._events)
                    return this;
                if (!this._events.removeListener)
                    return 0 === arguments.length ? this._events = {} : this._events[type] && delete this._events[type],
                        this;
                if (0 === arguments.length) {
                    for (key in this._events)
                        "removeListener" !== key && this.removeAllListeners(key);
                    return this.removeAllListeners("removeListener"),
                        this._events = {},
                        this
                }
                if (listeners = this._events[type],
                        isFunction(listeners))
                    this.removeListener(type, listeners);
                else if (listeners)
                    for (; listeners.length; )
                        this.removeListener(type, listeners[listeners.length - 1]);
                return delete this._events[type],
                    this
            }
            ,
            EventEmitter.prototype.listeners = function(type) {
                var ret;
                return ret = this._events && this._events[type] ? isFunction(this._events[type]) ? [this._events[type]] : this._events[type].slice() : []
            }
            ,
            EventEmitter.prototype.listenerCount = function(type) {
                if (this._events) {
                    var evlistener = this._events[type];
                    if (isFunction(evlistener))
                        return 1;
                    if (evlistener)
                        return evlistener.length
                }
                return 0
            }
            ,
            EventEmitter.listenerCount = function(emitter, type) {
                return emitter.listenerCount(type)
            }
    }
        , {}],
    80: [function(require, module, exports) {
        (function(global) {
                var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
                (_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
                    "use strict";
                    _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(Animation, SimpleTimeline, TweenLite) {
                        var _slice = function(a) {
                            var i, b = [], l = a.length;
                            for (i = 0; i !== l; b.push(a[i++]))
                                ;
                            return b
                        }
                            , _applyCycle = function(vars, targets, i) {
                            var p, val, alt = vars.cycle;
                            for (p in alt)
                                val = alt[p],
                                    vars[p] = "function" == typeof val ? val(i, targets[i]) : val[i % val.length];
                            delete vars.cycle
                        }
                            , TweenMax = function(target, duration, vars) {
                            TweenLite.call(this, target, duration, vars),
                                this._cycle = 0,
                                this._yoyo = this.vars.yoyo === !0,
                                this._repeat = this.vars.repeat || 0,
                                this._repeatDelay = this.vars.repeatDelay || 0,
                                this._dirty = !0,
                                this.render = TweenMax.prototype.render
                        }
                            , _tinyNum = 1e-10
                            , TweenLiteInternals = TweenLite._internals
                            , _isSelector = TweenLiteInternals.isSelector
                            , _isArray = TweenLiteInternals.isArray
                            , p = TweenMax.prototype = TweenLite.to({}, .1, {})
                            , _blankArray = [];
                        TweenMax.version = "1.19.0",
                            p.constructor = TweenMax,
                            p.kill()._gc = !1,
                            TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf,
                            TweenMax.getTweensOf = TweenLite.getTweensOf,
                            TweenMax.lagSmoothing = TweenLite.lagSmoothing,
                            TweenMax.ticker = TweenLite.ticker,
                            TweenMax.render = TweenLite.render,
                            p.invalidate = function() {
                                return this._yoyo = this.vars.yoyo === !0,
                                    this._repeat = this.vars.repeat || 0,
                                    this._repeatDelay = this.vars.repeatDelay || 0,
                                    this._uncache(!0),
                                    TweenLite.prototype.invalidate.call(this)
                            }
                            ,
                            p.updateTo = function(vars, resetDuration) {
                                var p, curRatio = this.ratio, immediate = this.vars.immediateRender || vars.immediateRender;
                                resetDuration && this._startTime < this._timeline._time && (this._startTime = this._timeline._time,
                                    this._uncache(!1),
                                    this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
                                for (p in vars)
                                    this.vars[p] = vars[p];
                                if (this._initted || immediate)
                                    if (resetDuration)
                                        this._initted = !1,
                                        immediate && this.render(0, !0, !0);
                                    else if (this._gc && this._enabled(!0, !1),
                                        this._notifyPluginsOfEnabled && this._firstPT && TweenLite._onPluginEvent("_onDisable", this),
                                        this._time / this._duration > .998) {
                                        var prevTime = this._totalTime;
                                        this.render(0, !0, !1),
                                            this._initted = !1,
                                            this.render(prevTime, !0, !1)
                                    } else if (this._initted = !1,
                                            this._init(),
                                        this._time > 0 || immediate)
                                        for (var endValue, inv = 1 / (1 - curRatio), pt = this._firstPT; pt; )
                                            endValue = pt.s + pt.c,
                                                pt.c *= inv,
                                                pt.s = endValue - pt.c,
                                                pt = pt._next;
                                return this
                            }
                            ,
                            p.render = function(time, suppressEvents, force) {
                                this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                                var isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime, totalDur = this._dirty ? this.totalDuration() : this._totalDuration, prevTime = this._time, prevTotalTime = this._totalTime, prevCycle = this._cycle, duration = this._duration, prevRawPrevTime = this._rawPrevTime;
                                if (time >= totalDur - 1e-7 ? (this._totalTime = totalDur,
                                        this._cycle = this._repeat,
                                        this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0,
                                            this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = duration,
                                            this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1),
                                    this._reversed || (isComplete = !0,
                                        callback = "onComplete",
                                        force = force || this._timeline.autoRemoveChildren),
                                    0 === duration && (this._initted || !this.vars.lazy || force) && (this._startTime === this._timeline._duration && (time = 0),
                                    (prevRawPrevTime < 0 || time <= 0 && time >= -1e-7 || prevRawPrevTime === _tinyNum && "isPause" !== this.data) && prevRawPrevTime !== time && (force = !0,
                                    prevRawPrevTime > _tinyNum && (callback = "onReverseComplete")),
                                        this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum)) : time < 1e-7 ? (this._totalTime = this._time = this._cycle = 0,
                                        this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0,
                                    (0 !== prevTotalTime || 0 === duration && prevRawPrevTime > 0) && (callback = "onReverseComplete",
                                        isComplete = this._reversed),
                                    time < 0 && (this._active = !1,
                                    0 === duration && (this._initted || !this.vars.lazy || force) && (prevRawPrevTime >= 0 && (force = !0),
                                        this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum)),
                                    this._initted || (force = !0)) : (this._totalTime = this._time = time,
                                    0 !== this._repeat && (cycleDuration = duration + this._repeatDelay,
                                        this._cycle = this._totalTime / cycleDuration >> 0,
                                    0 !== this._cycle && this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time && this._cycle--,
                                        this._time = this._totalTime - this._cycle * cycleDuration,
                                    this._yoyo && 0 !== (1 & this._cycle) && (this._time = duration - this._time),
                                        this._time > duration ? this._time = duration : this._time < 0 && (this._time = 0)),
                                        this._easeType ? (r = this._time / duration,
                                            type = this._easeType,
                                            pow = this._easePower,
                                        (1 === type || 3 === type && r >= .5) && (r = 1 - r),
                                        3 === type && (r *= 2),
                                            1 === pow ? r *= r : 2 === pow ? r *= r * r : 3 === pow ? r *= r * r * r : 4 === pow && (r *= r * r * r * r),
                                            1 === type ? this.ratio = 1 - r : 2 === type ? this.ratio = r : this._time / duration < .5 ? this.ratio = r / 2 : this.ratio = 1 - r / 2) : this.ratio = this._ease.getRatio(this._time / duration)),
                                    prevTime === this._time && !force && prevCycle === this._cycle)
                                    return void (prevTotalTime !== this._totalTime && this._onUpdate && (suppressEvents || this._callback("onUpdate")));
                                if (!this._initted) {
                                    if (this._init(),
                                        !this._initted || this._gc)
                                        return;
                                    if (!force && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
                                        return this._time = prevTime,
                                            this._totalTime = prevTotalTime,
                                            this._rawPrevTime = prevRawPrevTime,
                                            this._cycle = prevCycle,
                                            TweenLiteInternals.lazyTweens.push(this),
                                            void (this._lazy = [time, suppressEvents]);
                                    this._time && !isComplete ? this.ratio = this._ease.getRatio(this._time / duration) : isComplete && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                                }
                                for (this._lazy !== !1 && (this._lazy = !1),
                                     this._active || !this._paused && this._time !== prevTime && time >= 0 && (this._active = !0),
                                     0 === prevTotalTime && (2 === this._initted && time > 0 && this._init(),
                                     this._startAt && (time >= 0 ? this._startAt.render(time, suppressEvents, force) : callback || (callback = "_dummyGS")),
                                     this.vars.onStart && (0 === this._totalTime && 0 !== duration || suppressEvents || this._callback("onStart"))),
                                         pt = this._firstPT; pt; )
                                    pt.f ? pt.t[pt.p](pt.c * this.ratio + pt.s) : pt.t[pt.p] = pt.c * this.ratio + pt.s,
                                        pt = pt._next;
                                this._onUpdate && (time < 0 && this._startAt && this._startTime && this._startAt.render(time, suppressEvents, force),
                                suppressEvents || (this._totalTime !== prevTotalTime || callback) && this._callback("onUpdate")),
                                this._cycle !== prevCycle && (suppressEvents || this._gc || this.vars.onRepeat && this._callback("onRepeat")),
                                callback && (this._gc && !force || (time < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(time, suppressEvents, force),
                                isComplete && (this._timeline.autoRemoveChildren && this._enabled(!1, !1),
                                    this._active = !1),
                                !suppressEvents && this.vars[callback] && this._callback(callback),
                                0 === duration && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum && (this._rawPrevTime = 0)))
                            }
                            ,
                            TweenMax.to = function(target, duration, vars) {
                                return new TweenMax(target,duration,vars)
                            }
                            ,
                            TweenMax.from = function(target, duration, vars) {
                                return vars.runBackwards = !0,
                                    vars.immediateRender = 0 != vars.immediateRender,
                                    new TweenMax(target,duration,vars)
                            }
                            ,
                            TweenMax.fromTo = function(target, duration, fromVars, toVars) {
                                return toVars.startAt = fromVars,
                                    toVars.immediateRender = 0 != toVars.immediateRender && 0 != fromVars.immediateRender,
                                    new TweenMax(target,duration,toVars)
                            }
                            ,
                            TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
                                stagger = stagger || 0;
                                var l, copy, i, p, delay = 0, a = [], finalComplete = function() {
                                    vars.onComplete && vars.onComplete.apply(vars.onCompleteScope || this, arguments),
                                        onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray)
                                }, cycle = vars.cycle, fromCycle = vars.startAt && vars.startAt.cycle;
                                for (_isArray(targets) || ("string" == typeof targets && (targets = TweenLite.selector(targets) || targets),
                                _isSelector(targets) && (targets = _slice(targets))),
                                         targets = targets || [],
                                     stagger < 0 && (targets = _slice(targets),
                                         targets.reverse(),
                                         stagger *= -1),
                                         l = targets.length - 1,
                                         i = 0; i <= l; i++) {
                                    copy = {};
                                    for (p in vars)
                                        copy[p] = vars[p];
                                    if (cycle && (_applyCycle(copy, targets, i),
                                        null != copy.duration && (duration = copy.duration,
                                            delete copy.duration)),
                                            fromCycle) {
                                        fromCycle = copy.startAt = {};
                                        for (p in vars.startAt)
                                            fromCycle[p] = vars.startAt[p];
                                        _applyCycle(copy.startAt, targets, i)
                                    }
                                    copy.delay = delay + (copy.delay || 0),
                                    i === l && onCompleteAll && (copy.onComplete = finalComplete),
                                        a[i] = new TweenMax(targets[i],duration,copy),
                                        delay += stagger
                                }
                                return a
                            }
                            ,
                            TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
                                return vars.runBackwards = !0,
                                    vars.immediateRender = 0 != vars.immediateRender,
                                    TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)
                            }
                            ,
                            TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
                                return toVars.startAt = fromVars,
                                    toVars.immediateRender = 0 != toVars.immediateRender && 0 != fromVars.immediateRender,
                                    TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)
                            }
                            ,
                            TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
                                return new TweenMax(callback,0,{
                                    delay: delay,
                                    onComplete: callback,
                                    onCompleteParams: params,
                                    callbackScope: scope,
                                    onReverseComplete: callback,
                                    onReverseCompleteParams: params,
                                    immediateRender: !1,
                                    useFrames: useFrames,
                                    overwrite: 0
                                })
                            }
                            ,
                            TweenMax.set = function(target, vars) {
                                return new TweenMax(target,0,vars)
                            }
                            ,
                            TweenMax.isTweening = function(target) {
                                return TweenLite.getTweensOf(target, !0).length > 0
                            }
                        ;
                        var _getChildrenOf = function(timeline, includeTimelines) {
                                for (var a = [], cnt = 0, tween = timeline._first; tween; )
                                    tween instanceof TweenLite ? a[cnt++] = tween : (includeTimelines && (a[cnt++] = tween),
                                        a = a.concat(_getChildrenOf(tween, includeTimelines)),
                                        cnt = a.length),
                                        tween = tween._next;
                                return a
                            }
                            , getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
                                return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat(_getChildrenOf(Animation._rootFramesTimeline, includeTimelines))
                            }
                            ;
                        TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
                            null == tweens && (tweens = !0),
                            null == delayedCalls && (delayedCalls = !0);
                            var isDC, tween, i, a = getAllTweens(0 != timelines), l = a.length, allTrue = tweens && delayedCalls && timelines;
                            for (i = 0; i < l; i++)
                                tween = a[i],
                                (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) && (complete ? tween.totalTime(tween._reversed ? 0 : tween.totalDuration()) : tween._enabled(!1, !1))
                        }
                            ,
                            TweenMax.killChildTweensOf = function(parent, complete) {
                                if (null != parent) {
                                    var a, curParent, p, i, l, tl = TweenLiteInternals.tweenLookup;
                                    if ("string" == typeof parent && (parent = TweenLite.selector(parent) || parent),
                                        _isSelector(parent) && (parent = _slice(parent)),
                                            _isArray(parent))
                                        for (i = parent.length; --i > -1; )
                                            TweenMax.killChildTweensOf(parent[i], complete);
                                    else {
                                        a = [];
                                        for (p in tl)
                                            for (curParent = tl[p].target.parentNode; curParent; )
                                                curParent === parent && (a = a.concat(tl[p].tweens)),
                                                    curParent = curParent.parentNode;
                                        for (l = a.length,
                                                 i = 0; i < l; i++)
                                            complete && a[i].totalTime(a[i].totalDuration()),
                                                a[i]._enabled(!1, !1)
                                    }
                                }
                            }
                        ;
                        var _changePause = function(pause, tweens, delayedCalls, timelines) {
                            tweens = tweens !== !1,
                                delayedCalls = delayedCalls !== !1,
                                timelines = timelines !== !1;
                            for (var isDC, tween, a = getAllTweens(timelines), allTrue = tweens && delayedCalls && timelines, i = a.length; --i > -1; )
                                tween = a[i],
                                (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) && tween.paused(pause)
                        };
                        return TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
                            _changePause(!0, tweens, delayedCalls, timelines)
                        }
                            ,
                            TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
                                _changePause(!1, tweens, delayedCalls, timelines)
                            }
                            ,
                            TweenMax.globalTimeScale = function(value) {
                                var tl = Animation._rootTimeline
                                    , t = TweenLite.ticker.time;
                                return arguments.length ? (value = value || _tinyNum,
                                    tl._startTime = t - (t - tl._startTime) * tl._timeScale / value,
                                    tl = Animation._rootFramesTimeline,
                                    t = TweenLite.ticker.frame,
                                    tl._startTime = t - (t - tl._startTime) * tl._timeScale / value,
                                    tl._timeScale = Animation._rootTimeline._timeScale = value,
                                    value) : tl._timeScale
                            }
                            ,
                            p.progress = function(value, suppressEvents) {
                                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents) : this._time / this.duration()
                            }
                            ,
                            p.totalProgress = function(value, suppressEvents) {
                                return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this._totalTime / this.totalDuration()
                            }
                            ,
                            p.time = function(value, suppressEvents) {
                                return arguments.length ? (this._dirty && this.totalDuration(),
                                value > this._duration && (value = this._duration),
                                    this._yoyo && 0 !== (1 & this._cycle) ? value = this._duration - value + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (value += this._cycle * (this._duration + this._repeatDelay)),
                                    this.totalTime(value, suppressEvents)) : this._time
                            }
                            ,
                            p.duration = function(value) {
                                return arguments.length ? Animation.prototype.duration.call(this, value) : this._duration
                            }
                            ,
                            p.totalDuration = function(value) {
                                return arguments.length ? this._repeat === -1 ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat,
                                    this._dirty = !1),
                                    this._totalDuration)
                            }
                            ,
                            p.repeat = function(value) {
                                return arguments.length ? (this._repeat = value,
                                    this._uncache(!0)) : this._repeat
                            }
                            ,
                            p.repeatDelay = function(value) {
                                return arguments.length ? (this._repeatDelay = value,
                                    this._uncache(!0)) : this._repeatDelay
                            }
                            ,
                            p.yoyo = function(value) {
                                return arguments.length ? (this._yoyo = value,
                                    this) : this._yoyo
                            }
                            ,
                            TweenMax
                    }, !0),
                        _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(Animation, SimpleTimeline, TweenLite) {
                            var TimelineLite = function(vars) {
                                SimpleTimeline.call(this, vars),
                                    this._labels = {},
                                    this.autoRemoveChildren = this.vars.autoRemoveChildren === !0,
                                    this.smoothChildTiming = this.vars.smoothChildTiming === !0,
                                    this._sortChildren = !0,
                                    this._onUpdate = this.vars.onUpdate;
                                var val, p, v = this.vars;
                                for (p in v)
                                    val = v[p],
                                    _isArray(val) && val.join("").indexOf("{self}") !== -1 && (v[p] = this._swapSelfInParams(val));
                                _isArray(v.tweens) && this.add(v.tweens, 0, v.align, v.stagger)
                            }
                                , _tinyNum = 1e-10
                                , TweenLiteInternals = TweenLite._internals
                                , _internals = TimelineLite._internals = {}
                                , _isSelector = TweenLiteInternals.isSelector
                                , _isArray = TweenLiteInternals.isArray
                                , _lazyTweens = TweenLiteInternals.lazyTweens
                                , _lazyRender = TweenLiteInternals.lazyRender
                                , _globals = _gsScope._gsDefine.globals
                                , _copy = function(vars) {
                                var p, copy = {};
                                for (p in vars)
                                    copy[p] = vars[p];
                                return copy
                            }
                                , _applyCycle = function(vars, targets, i) {
                                var p, val, alt = vars.cycle;
                                for (p in alt)
                                    val = alt[p],
                                        vars[p] = "function" == typeof val ? val.call(targets[i], i) : val[i % val.length];
                                delete vars.cycle
                            }
                                , _pauseCallback = _internals.pauseCallback = function() {}
                                , _slice = function(a) {
                                var i, b = [], l = a.length;
                                for (i = 0; i !== l; b.push(a[i++]))
                                    ;
                                return b
                            }
                                , p = TimelineLite.prototype = new SimpleTimeline;
                            return TimelineLite.version = "1.19.0",
                                p.constructor = TimelineLite,
                                p.kill()._gc = p._forcingPlayhead = p._hasPause = !1,
                                p.to = function(target, duration, vars, position) {
                                    var Engine = vars.repeat && _globals.TweenMax || TweenLite;
                                    return duration ? this.add(new Engine(target,duration,vars), position) : this.set(target, vars, position)
                                }
                                ,
                                p.from = function(target, duration, vars, position) {
                                    return this.add((vars.repeat && _globals.TweenMax || TweenLite).from(target, duration, vars), position)
                                }
                                ,
                                p.fromTo = function(target, duration, fromVars, toVars, position) {
                                    var Engine = toVars.repeat && _globals.TweenMax || TweenLite;
                                    return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position)
                                }
                                ,
                                p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
                                    var copy, i, tl = new TimelineLite({
                                        onComplete: onCompleteAll,
                                        onCompleteParams: onCompleteAllParams,
                                        callbackScope: onCompleteAllScope,
                                        smoothChildTiming: this.smoothChildTiming
                                    }), cycle = vars.cycle;
                                    for ("string" == typeof targets && (targets = TweenLite.selector(targets) || targets),
                                             targets = targets || [],
                                         _isSelector(targets) && (targets = _slice(targets)),
                                             stagger = stagger || 0,
                                         stagger < 0 && (targets = _slice(targets),
                                             targets.reverse(),
                                             stagger *= -1),
                                             i = 0; i < targets.length; i++)
                                        copy = _copy(vars),
                                        copy.startAt && (copy.startAt = _copy(copy.startAt),
                                        copy.startAt.cycle && _applyCycle(copy.startAt, targets, i)),
                                        cycle && (_applyCycle(copy, targets, i),
                                        null != copy.duration && (duration = copy.duration,
                                            delete copy.duration)),
                                            tl.to(targets[i], duration, copy, i * stagger);
                                    return this.add(tl, position)
                                }
                                ,
                                p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
                                    return vars.immediateRender = 0 != vars.immediateRender,
                                        vars.runBackwards = !0,
                                        this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope)
                                }
                                ,
                                p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
                                    return toVars.startAt = fromVars,
                                        toVars.immediateRender = 0 != toVars.immediateRender && 0 != fromVars.immediateRender,
                                        this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope)
                                }
                                ,
                                p.call = function(callback, params, scope, position) {
                                    return this.add(TweenLite.delayedCall(0, callback, params, scope), position)
                                }
                                ,
                                p.set = function(target, vars, position) {
                                    return position = this._parseTimeOrLabel(position, 0, !0),
                                    null == vars.immediateRender && (vars.immediateRender = position === this._time && !this._paused),
                                        this.add(new TweenLite(target,0,vars), position)
                                }
                                ,
                                TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
                                    vars = vars || {},
                                    null == vars.smoothChildTiming && (vars.smoothChildTiming = !0);
                                    var tween, next, tl = new TimelineLite(vars), root = tl._timeline;
                                    for (null == ignoreDelayedCalls && (ignoreDelayedCalls = !0),
                                             root._remove(tl, !0),
                                             tl._startTime = 0,
                                             tl._rawPrevTime = tl._time = tl._totalTime = root._time,
                                             tween = root._first; tween; )
                                        next = tween._next,
                                        ignoreDelayedCalls && tween instanceof TweenLite && tween.target === tween.vars.onComplete || tl.add(tween, tween._startTime - tween._delay),
                                            tween = next;
                                    return root.add(tl, 0),
                                        tl
                                }
                                ,
                                p.add = function(value, position, align, stagger) {
                                    var curTime, l, i, child, tl, beforeRawTime;
                                    if ("number" != typeof position && (position = this._parseTimeOrLabel(position, 0, !0, value)),
                                            !(value instanceof Animation)) {
                                        if (value instanceof Array || value && value.push && _isArray(value)) {
                                            for (align = align || "normal",
                                                     stagger = stagger || 0,
                                                     curTime = position,
                                                     l = value.length,
                                                     i = 0; i < l; i++)
                                                _isArray(child = value[i]) && (child = new TimelineLite({
                                                    tweens: child
                                                })),
                                                    this.add(child, curTime),
                                                "string" != typeof child && "function" != typeof child && ("sequence" === align ? curTime = child._startTime + child.totalDuration() / child._timeScale : "start" === align && (child._startTime -= child.delay())),
                                                    curTime += stagger;
                                            return this._uncache(!0)
                                        }
                                        if ("string" == typeof value)
                                            return this.addLabel(value, position);
                                        if ("function" != typeof value)
                                            throw "Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.";
                                        value = TweenLite.delayedCall(0, value)
                                    }
                                    if (SimpleTimeline.prototype.add.call(this, value, position),
                                        (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                                        for (tl = this,
                                                 beforeRawTime = tl.rawTime() > value._startTime; tl._timeline; )
                                            beforeRawTime && tl._timeline.smoothChildTiming ? tl.totalTime(tl._totalTime, !0) : tl._gc && tl._enabled(!0, !1),
                                                tl = tl._timeline;
                                    return this
                                }
                                ,
                                p.remove = function(value) {
                                    if (value instanceof Animation) {
                                        this._remove(value, !1);
                                        var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline;
                                        return value._startTime = (value._paused ? value._pauseTime : tl._time) - (value._reversed ? value.totalDuration() - value._totalTime : value._totalTime) / value._timeScale,
                                            this
                                    }
                                    if (value instanceof Array || value && value.push && _isArray(value)) {
                                        for (var i = value.length; --i > -1; )
                                            this.remove(value[i]);
                                        return this
                                    }
                                    return "string" == typeof value ? this.removeLabel(value) : this.kill(null, value)
                                }
                                ,
                                p._remove = function(tween, skipDisable) {
                                    SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
                                    var last = this._last;
                                    return last ? this._time > last._startTime + last._totalDuration / last._timeScale && (this._time = this.duration(),
                                        this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0,
                                        this
                                }
                                ,
                                p.append = function(value, offsetOrLabel) {
                                    return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, !0, value))
                                }
                                ,
                                p.insert = p.insertMultiple = function(value, position, align, stagger) {
                                    return this.add(value, position || 0, align, stagger)
                                }
                                ,
                                p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
                                    return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, !0, tweens), align, stagger)
                                }
                                ,
                                p.addLabel = function(label, position) {
                                    return this._labels[label] = this._parseTimeOrLabel(position),
                                        this
                                }
                                ,
                                p.addPause = function(position, callback, params, scope) {
                                    var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
                                    return t.vars.onComplete = t.vars.onReverseComplete = callback,
                                        t.data = "isPause",
                                        this._hasPause = !0,
                                        this.add(t, position)
                                }
                                ,
                                p.removeLabel = function(label) {
                                    return delete this._labels[label],
                                        this
                                }
                                ,
                                p.getLabelTime = function(label) {
                                    return null != this._labels[label] ? this._labels[label] : -1
                                }
                                ,
                                p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
                                    var i;
                                    if (ignore instanceof Animation && ignore.timeline === this)
                                        this.remove(ignore);
                                    else if (ignore && (ignore instanceof Array || ignore.push && _isArray(ignore)))
                                        for (i = ignore.length; --i > -1; )
                                            ignore[i]instanceof Animation && ignore[i].timeline === this && this.remove(ignore[i]);
                                    if ("string" == typeof offsetOrLabel)
                                        return this._parseTimeOrLabel(offsetOrLabel, appendIfAbsent && "number" == typeof timeOrLabel && null == this._labels[offsetOrLabel] ? timeOrLabel - this.duration() : 0, appendIfAbsent);
                                    if (offsetOrLabel = offsetOrLabel || 0,
                                        "string" != typeof timeOrLabel || !isNaN(timeOrLabel) && null == this._labels[timeOrLabel])
                                        null == timeOrLabel && (timeOrLabel = this.duration());
                                    else {
                                        if (i = timeOrLabel.indexOf("="),
                                            i === -1)
                                            return null == this._labels[timeOrLabel] ? appendIfAbsent ? this._labels[timeOrLabel] = this.duration() + offsetOrLabel : offsetOrLabel : this._labels[timeOrLabel] + offsetOrLabel;
                                        offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1)),
                                            timeOrLabel = i > 1 ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : this.duration()
                                    }
                                    return Number(timeOrLabel) + offsetOrLabel
                                }
                                ,
                                p.seek = function(position, suppressEvents) {
                                    return this.totalTime("number" == typeof position ? position : this._parseTimeOrLabel(position), suppressEvents !== !1)
                                }
                                ,
                                p.stop = function() {
                                    return this.paused(!0)
                                }
                                ,
                                p.gotoAndPlay = function(position, suppressEvents) {
                                    return this.play(position, suppressEvents)
                                }
                                ,
                                p.gotoAndStop = function(position, suppressEvents) {
                                    return this.pause(position, suppressEvents)
                                }
                                ,
                                p.render = function(time, suppressEvents, force) {
                                    this._gc && this._enabled(!0, !1);
                                    var tween, isComplete, next, callback, internalForce, pauseTween, curTime, totalDur = this._dirty ? this.totalDuration() : this._totalDuration, prevTime = this._time, prevStart = this._startTime, prevTimeScale = this._timeScale, prevPaused = this._paused;
                                    if (time >= totalDur - 1e-7)
                                        this._totalTime = this._time = totalDur,
                                        this._reversed || this._hasPausedChild() || (isComplete = !0,
                                            callback = "onComplete",
                                            internalForce = !!this._timeline.autoRemoveChildren,
                                        0 === this._duration && (time <= 0 && time >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) && this._rawPrevTime !== time && this._first && (internalForce = !0,
                                        this._rawPrevTime > _tinyNum && (callback = "onReverseComplete"))),
                                            this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum,
                                            time = totalDur + 1e-4;
                                    else if (time < 1e-7)
                                        if (this._totalTime = this._time = 0,
                                            (0 !== prevTime || 0 === this._duration && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || time < 0 && this._rawPrevTime >= 0)) && (callback = "onReverseComplete",
                                                isComplete = this._reversed),
                                            time < 0)
                                            this._active = !1,
                                                this._timeline.autoRemoveChildren && this._reversed ? (internalForce = isComplete = !0,
                                                    callback = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (internalForce = !0),
                                                this._rawPrevTime = time;
                                        else {
                                            if (this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum,
                                                0 === time && isComplete)
                                                for (tween = this._first; tween && 0 === tween._startTime; )
                                                    tween._duration || (isComplete = !1),
                                                        tween = tween._next;
                                            time = 0,
                                            this._initted || (internalForce = !0)
                                        }
                                    else {
                                        if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
                                            if (time >= prevTime)
                                                for (tween = this._first; tween && tween._startTime <= time && !pauseTween; )
                                                    tween._duration || "isPause" !== tween.data || tween.ratio || 0 === tween._startTime && 0 === this._rawPrevTime || (pauseTween = tween),
                                                        tween = tween._next;
                                            else
                                                for (tween = this._last; tween && tween._startTime >= time && !pauseTween; )
                                                    tween._duration || "isPause" === tween.data && tween._rawPrevTime > 0 && (pauseTween = tween),
                                                        tween = tween._prev;
                                            pauseTween && (this._time = time = pauseTween._startTime,
                                                this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay))
                                        }
                                        this._totalTime = this._time = this._rawPrevTime = time
                                    }
                                    if (this._time !== prevTime && this._first || force || internalForce || pauseTween) {
                                        if (this._initted || (this._initted = !0),
                                            this._active || !this._paused && this._time !== prevTime && time > 0 && (this._active = !0),
                                            0 === prevTime && this.vars.onStart && (0 === this._time && this._duration || suppressEvents || this._callback("onStart")),
                                                curTime = this._time,
                                            curTime >= prevTime)
                                            for (tween = this._first; tween && (next = tween._next,
                                            curTime === this._time && (!this._paused || prevPaused)); )
                                                (tween._active || tween._startTime <= curTime && !tween._paused && !tween._gc) && (pauseTween === tween && this.pause(),
                                                    tween._reversed ? tween.render((tween._dirty ? tween.totalDuration() : tween._totalDuration) - (time - tween._startTime) * tween._timeScale, suppressEvents, force) : tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)),
                                                    tween = next;
                                        else
                                            for (tween = this._last; tween && (next = tween._prev,
                                            curTime === this._time && (!this._paused || prevPaused)); ) {
                                                if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
                                                    if (pauseTween === tween) {
                                                        for (pauseTween = tween._prev; pauseTween && pauseTween.endTime() > this._time; )
                                                            pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force),
                                                                pauseTween = pauseTween._prev;
                                                        pauseTween = null,
                                                            this.pause()
                                                    }
                                                    tween._reversed ? tween.render((tween._dirty ? tween.totalDuration() : tween._totalDuration) - (time - tween._startTime) * tween._timeScale, suppressEvents, force) : tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)
                                                }
                                                tween = next
                                            }
                                        this._onUpdate && (suppressEvents || (_lazyTweens.length && _lazyRender(),
                                            this._callback("onUpdate"))),
                                        callback && (this._gc || prevStart !== this._startTime && prevTimeScale === this._timeScale || (0 === this._time || totalDur >= this.totalDuration()) && (isComplete && (_lazyTweens.length && _lazyRender(),
                                        this._timeline.autoRemoveChildren && this._enabled(!1, !1),
                                            this._active = !1),
                                        !suppressEvents && this.vars[callback] && this._callback(callback)))
                                    }
                                }
                                ,
                                p._hasPausedChild = function() {
                                    for (var tween = this._first; tween; ) {
                                        if (tween._paused || tween instanceof TimelineLite && tween._hasPausedChild())
                                            return !0;
                                        tween = tween._next
                                    }
                                    return !1
                                }
                                ,
                                p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
                                    ignoreBeforeTime = ignoreBeforeTime || -9999999999;
                                    for (var a = [], tween = this._first, cnt = 0; tween; )
                                        tween._startTime < ignoreBeforeTime || (tween instanceof TweenLite ? tweens !== !1 && (a[cnt++] = tween) : (timelines !== !1 && (a[cnt++] = tween),
                                        nested !== !1 && (a = a.concat(tween.getChildren(!0, tweens, timelines)),
                                            cnt = a.length))),
                                            tween = tween._next;
                                    return a
                                }
                                ,
                                p.getTweensOf = function(target, nested) {
                                    var tweens, i, disabled = this._gc, a = [], cnt = 0;
                                    for (disabled && this._enabled(!0, !0),
                                             tweens = TweenLite.getTweensOf(target),
                                             i = tweens.length; --i > -1; )
                                        (tweens[i].timeline === this || nested && this._contains(tweens[i])) && (a[cnt++] = tweens[i]);
                                    return disabled && this._enabled(!1, !0),
                                        a
                                }
                                ,
                                p.recent = function() {
                                    return this._recent
                                }
                                ,
                                p._contains = function(tween) {
                                    for (var tl = tween.timeline; tl; ) {
                                        if (tl === this)
                                            return !0;
                                        tl = tl.timeline
                                    }
                                    return !1
                                }
                                ,
                                p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
                                    ignoreBeforeTime = ignoreBeforeTime || 0;
                                    for (var p, tween = this._first, labels = this._labels; tween; )
                                        tween._startTime >= ignoreBeforeTime && (tween._startTime += amount),
                                            tween = tween._next;
                                    if (adjustLabels)
                                        for (p in labels)
                                            labels[p] >= ignoreBeforeTime && (labels[p] += amount);
                                    return this._uncache(!0)
                                }
                                ,
                                p._kill = function(vars, target) {
                                    if (!vars && !target)
                                        return this._enabled(!1, !1);
                                    for (var tweens = target ? this.getTweensOf(target) : this.getChildren(!0, !0, !1), i = tweens.length, changed = !1; --i > -1; )
                                        tweens[i]._kill(vars, target) && (changed = !0);
                                    return changed
                                }
                                ,
                                p.clear = function(labels) {
                                    var tweens = this.getChildren(!1, !0, !0)
                                        , i = tweens.length;
                                    for (this._time = this._totalTime = 0; --i > -1; )
                                        tweens[i]._enabled(!1, !1);
                                    return labels !== !1 && (this._labels = {}),
                                        this._uncache(!0)
                                }
                                ,
                                p.invalidate = function() {
                                    for (var tween = this._first; tween; )
                                        tween.invalidate(),
                                            tween = tween._next;
                                    return Animation.prototype.invalidate.call(this)
                                }
                                ,
                                p._enabled = function(enabled, ignoreTimeline) {
                                    if (enabled === this._gc)
                                        for (var tween = this._first; tween; )
                                            tween._enabled(enabled, !0),
                                                tween = tween._next;
                                    return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline)
                                }
                                ,
                                p.totalTime = function(time, suppressEvents, uncapped) {
                                    this._forcingPlayhead = !0;
                                    var val = Animation.prototype.totalTime.apply(this, arguments);
                                    return this._forcingPlayhead = !1,
                                        val
                                }
                                ,
                                p.duration = function(value) {
                                    return arguments.length ? (0 !== this.duration() && 0 !== value && this.timeScale(this._duration / value),
                                        this) : (this._dirty && this.totalDuration(),
                                        this._duration)
                                }
                                ,
                                p.totalDuration = function(value) {
                                    if (!arguments.length) {
                                        if (this._dirty) {
                                            for (var prev, end, max = 0, tween = this._last, prevStart = 999999999999; tween; )
                                                prev = tween._prev,
                                                tween._dirty && tween.totalDuration(),
                                                    tween._startTime > prevStart && this._sortChildren && !tween._paused ? this.add(tween, tween._startTime - tween._delay) : prevStart = tween._startTime,
                                                tween._startTime < 0 && !tween._paused && (max -= tween._startTime,
                                                this._timeline.smoothChildTiming && (this._startTime += tween._startTime / this._timeScale),
                                                    this.shiftChildren(-tween._startTime, !1, -9999999999),
                                                    prevStart = 0),
                                                    end = tween._startTime + tween._totalDuration / tween._timeScale,
                                                end > max && (max = end),
                                                    tween = prev;
                                            this._duration = this._totalDuration = max,
                                                this._dirty = !1
                                        }
                                        return this._totalDuration
                                    }
                                    return value && this.totalDuration() ? this.timeScale(this._totalDuration / value) : this
                                }
                                ,
                                p.paused = function(value) {
                                    if (!value)
                                        for (var tween = this._first, time = this._time; tween; )
                                            tween._startTime === time && "isPause" === tween.data && (tween._rawPrevTime = 0),
                                                tween = tween._next;
                                    return Animation.prototype.paused.apply(this, arguments)
                                }
                                ,
                                p.usesFrames = function() {
                                    for (var tl = this._timeline; tl._timeline; )
                                        tl = tl._timeline;
                                    return tl === Animation._rootFramesTimeline
                                }
                                ,
                                p.rawTime = function() {
                                    return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale
                                }
                                ,
                                TimelineLite
                        }, !0),
                        _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(TimelineLite, TweenLite, Ease) {
                            var TimelineMax = function(vars) {
                                TimelineLite.call(this, vars),
                                    this._repeat = this.vars.repeat || 0,
                                    this._repeatDelay = this.vars.repeatDelay || 0,
                                    this._cycle = 0,
                                    this._yoyo = this.vars.yoyo === !0,
                                    this._dirty = !0
                            }
                                , _tinyNum = 1e-10
                                , TweenLiteInternals = TweenLite._internals
                                , _lazyTweens = TweenLiteInternals.lazyTweens
                                , _lazyRender = TweenLiteInternals.lazyRender
                                , _globals = _gsScope._gsDefine.globals
                                , _easeNone = new Ease(null,null,1,0)
                                , p = TimelineMax.prototype = new TimelineLite;
                            return p.constructor = TimelineMax,
                                p.kill()._gc = !1,
                                TimelineMax.version = "1.19.0",
                                p.invalidate = function() {
                                    return this._yoyo = this.vars.yoyo === !0,
                                        this._repeat = this.vars.repeat || 0,
                                        this._repeatDelay = this.vars.repeatDelay || 0,
                                        this._uncache(!0),
                                        TimelineLite.prototype.invalidate.call(this)
                                }
                                ,
                                p.addCallback = function(callback, position, params, scope) {
                                    return this.add(TweenLite.delayedCall(0, callback, params, scope), position)
                                }
                                ,
                                p.removeCallback = function(callback, position) {
                                    if (callback)
                                        if (null == position)
                                            this._kill(null, callback);
                                        else
                                            for (var a = this.getTweensOf(callback, !1), i = a.length, time = this._parseTimeOrLabel(position); --i > -1; )
                                                a[i]._startTime === time && a[i]._enabled(!1, !1);
                                    return this
                                }
                                ,
                                p.removePause = function(position) {
                                    return this.removeCallback(TimelineLite._internals.pauseCallback, position)
                                }
                                ,
                                p.tweenTo = function(position, vars) {
                                    vars = vars || {};
                                    var duration, p, t, copy = {
                                        ease: _easeNone,
                                        useFrames: this.usesFrames(),
                                        immediateRender: !1
                                    }, Engine = vars.repeat && _globals.TweenMax || TweenLite;
                                    for (p in vars)
                                        copy[p] = vars[p];
                                    return copy.time = this._parseTimeOrLabel(position),
                                        duration = Math.abs(Number(copy.time) - this._time) / this._timeScale || .001,
                                        t = new Engine(this,duration,copy),
                                        copy.onStart = function() {
                                            t.target.paused(!0),
                                            t.vars.time !== t.target.time() && duration === t.duration() && t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale),
                                            vars.onStart && t._callback("onStart")
                                        }
                                        ,
                                        t
                                }
                                ,
                                p.tweenFromTo = function(fromPosition, toPosition, vars) {
                                    vars = vars || {},
                                        fromPosition = this._parseTimeOrLabel(fromPosition),
                                        vars.startAt = {
                                            onComplete: this.seek,
                                            onCompleteParams: [fromPosition],
                                            callbackScope: this
                                        },
                                        vars.immediateRender = vars.immediateRender !== !1;
                                    var t = this.tweenTo(toPosition, vars);
                                    return t.duration(Math.abs(t.vars.time - fromPosition) / this._timeScale || .001)
                                }
                                ,
                                p.render = function(time, suppressEvents, force) {
                                    this._gc && this._enabled(!0, !1);
                                    var tween, isComplete, next, callback, internalForce, cycleDuration, pauseTween, curTime, totalDur = this._dirty ? this.totalDuration() : this._totalDuration, dur = this._duration, prevTime = this._time, prevTotalTime = this._totalTime, prevStart = this._startTime, prevTimeScale = this._timeScale, prevRawPrevTime = this._rawPrevTime, prevPaused = this._paused, prevCycle = this._cycle;
                                    if (time >= totalDur - 1e-7)
                                        this._locked || (this._totalTime = totalDur,
                                            this._cycle = this._repeat),
                                        this._reversed || this._hasPausedChild() || (isComplete = !0,
                                            callback = "onComplete",
                                            internalForce = !!this._timeline.autoRemoveChildren,
                                        0 === this._duration && (time <= 0 && time >= -1e-7 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) && prevRawPrevTime !== time && this._first && (internalForce = !0,
                                        prevRawPrevTime > _tinyNum && (callback = "onReverseComplete"))),
                                            this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum,
                                            this._yoyo && 0 !== (1 & this._cycle) ? this._time = time = 0 : (this._time = dur,
                                                time = dur + 1e-4);
                                    else if (time < 1e-7)
                                        if (this._locked || (this._totalTime = this._cycle = 0),
                                                this._time = 0,
                                            (0 !== prevTime || 0 === dur && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || time < 0 && prevRawPrevTime >= 0) && !this._locked) && (callback = "onReverseComplete",
                                                isComplete = this._reversed),
                                            time < 0)
                                            this._active = !1,
                                                this._timeline.autoRemoveChildren && this._reversed ? (internalForce = isComplete = !0,
                                                    callback = "onReverseComplete") : prevRawPrevTime >= 0 && this._first && (internalForce = !0),
                                                this._rawPrevTime = time;
                                        else {
                                            if (this._rawPrevTime = dur || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum,
                                                0 === time && isComplete)
                                                for (tween = this._first; tween && 0 === tween._startTime; )
                                                    tween._duration || (isComplete = !1),
                                                        tween = tween._next;
                                            time = 0,
                                            this._initted || (internalForce = !0)
                                        }
                                    else if (0 === dur && prevRawPrevTime < 0 && (internalForce = !0),
                                            this._time = this._rawPrevTime = time,
                                        this._locked || (this._totalTime = time,
                                        0 !== this._repeat && (cycleDuration = dur + this._repeatDelay,
                                            this._cycle = this._totalTime / cycleDuration >> 0,
                                        0 !== this._cycle && this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time && this._cycle--,
                                            this._time = this._totalTime - this._cycle * cycleDuration,
                                        this._yoyo && 0 !== (1 & this._cycle) && (this._time = dur - this._time),
                                            this._time > dur ? (this._time = dur,
                                                time = dur + 1e-4) : this._time < 0 ? this._time = time = 0 : time = this._time)),
                                        this._hasPause && !this._forcingPlayhead && !suppressEvents) {
                                        if (time = this._time,
                                            time >= prevTime)
                                            for (tween = this._first; tween && tween._startTime <= time && !pauseTween; )
                                                tween._duration || "isPause" !== tween.data || tween.ratio || 0 === tween._startTime && 0 === this._rawPrevTime || (pauseTween = tween),
                                                    tween = tween._next;
                                        else
                                            for (tween = this._last; tween && tween._startTime >= time && !pauseTween; )
                                                tween._duration || "isPause" === tween.data && tween._rawPrevTime > 0 && (pauseTween = tween),
                                                    tween = tween._prev;
                                        pauseTween && (this._time = time = pauseTween._startTime,
                                            this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay))
                                    }
                                    if (this._cycle !== prevCycle && !this._locked) {
                                        var backwards = this._yoyo && 0 !== (1 & prevCycle)
                                            , wrap = backwards === (this._yoyo && 0 !== (1 & this._cycle))
                                            , recTotalTime = this._totalTime
                                            , recCycle = this._cycle
                                            , recRawPrevTime = this._rawPrevTime
                                            , recTime = this._time;
                                        if (this._totalTime = prevCycle * dur,
                                                this._cycle < prevCycle ? backwards = !backwards : this._totalTime += dur,
                                                this._time = prevTime,
                                                this._rawPrevTime = 0 === dur ? prevRawPrevTime - 1e-4 : prevRawPrevTime,
                                                this._cycle = prevCycle,
                                                this._locked = !0,
                                                prevTime = backwards ? 0 : dur,
                                                this.render(prevTime, suppressEvents, 0 === dur),
                                            suppressEvents || this._gc || this.vars.onRepeat && this._callback("onRepeat"),
                                            prevTime !== this._time)
                                            return;
                                        if (wrap && (prevTime = backwards ? dur + 1e-4 : -1e-4,
                                                this.render(prevTime, !0, !1)),
                                                this._locked = !1,
                                            this._paused && !prevPaused)
                                            return;
                                        this._time = recTime,
                                            this._totalTime = recTotalTime,
                                            this._cycle = recCycle,
                                            this._rawPrevTime = recRawPrevTime
                                    }
                                    if (!(this._time !== prevTime && this._first || force || internalForce || pauseTween))
                                        return void (prevTotalTime !== this._totalTime && this._onUpdate && (suppressEvents || this._callback("onUpdate")));
                                    if (this._initted || (this._initted = !0),
                                        this._active || !this._paused && this._totalTime !== prevTotalTime && time > 0 && (this._active = !0),
                                        0 === prevTotalTime && this.vars.onStart && (0 === this._totalTime && this._totalDuration || suppressEvents || this._callback("onStart")),
                                            curTime = this._time,
                                        curTime >= prevTime)
                                        for (tween = this._first; tween && (next = tween._next,
                                        curTime === this._time && (!this._paused || prevPaused)); )
                                            (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) && (pauseTween === tween && this.pause(),
                                                tween._reversed ? tween.render((tween._dirty ? tween.totalDuration() : tween._totalDuration) - (time - tween._startTime) * tween._timeScale, suppressEvents, force) : tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)),
                                                tween = next;
                                    else
                                        for (tween = this._last; tween && (next = tween._prev,
                                        curTime === this._time && (!this._paused || prevPaused)); ) {
                                            if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
                                                if (pauseTween === tween) {
                                                    for (pauseTween = tween._prev; pauseTween && pauseTween.endTime() > this._time; )
                                                        pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force),
                                                            pauseTween = pauseTween._prev;
                                                    pauseTween = null,
                                                        this.pause()
                                                }
                                                tween._reversed ? tween.render((tween._dirty ? tween.totalDuration() : tween._totalDuration) - (time - tween._startTime) * tween._timeScale, suppressEvents, force) : tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)
                                            }
                                            tween = next
                                        }
                                    this._onUpdate && (suppressEvents || (_lazyTweens.length && _lazyRender(),
                                        this._callback("onUpdate"))),
                                    callback && (this._locked || this._gc || prevStart !== this._startTime && prevTimeScale === this._timeScale || (0 === this._time || totalDur >= this.totalDuration()) && (isComplete && (_lazyTweens.length && _lazyRender(),
                                    this._timeline.autoRemoveChildren && this._enabled(!1, !1),
                                        this._active = !1),
                                    !suppressEvents && this.vars[callback] && this._callback(callback)))
                                }
                                ,
                                p.getActive = function(nested, tweens, timelines) {
                                    null == nested && (nested = !0),
                                    null == tweens && (tweens = !0),
                                    null == timelines && (timelines = !1);
                                    var i, tween, a = [], all = this.getChildren(nested, tweens, timelines), cnt = 0, l = all.length;
                                    for (i = 0; i < l; i++)
                                        tween = all[i],
                                        tween.isActive() && (a[cnt++] = tween);
                                    return a
                                }
                                ,
                                p.getLabelAfter = function(time) {
                                    time || 0 !== time && (time = this._time);
                                    var i, labels = this.getLabelsArray(), l = labels.length;
                                    for (i = 0; i < l; i++)
                                        if (labels[i].time > time)
                                            return labels[i].name;
                                    return null
                                }
                                ,
                                p.getLabelBefore = function(time) {
                                    null == time && (time = this._time);
                                    for (var labels = this.getLabelsArray(), i = labels.length; --i > -1; )
                                        if (labels[i].time < time)
                                            return labels[i].name;
                                    return null
                                }
                                ,
                                p.getLabelsArray = function() {
                                    var p, a = [], cnt = 0;
                                    for (p in this._labels)
                                        a[cnt++] = {
                                            time: this._labels[p],
                                            name: p
                                        };
                                    return a.sort(function(a, b) {
                                        return a.time - b.time
                                    }),
                                        a
                                }
                                ,
                                p.progress = function(value, suppressEvents) {
                                    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents) : this._time / this.duration()
                                }
                                ,
                                p.totalProgress = function(value, suppressEvents) {
                                    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this._totalTime / this.totalDuration()
                                }
                                ,
                                p.totalDuration = function(value) {
                                    return arguments.length ? this._repeat !== -1 && value ? this.timeScale(this.totalDuration() / value) : this : (this._dirty && (TimelineLite.prototype.totalDuration.call(this),
                                        this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat),
                                        this._totalDuration)
                                }
                                ,
                                p.time = function(value, suppressEvents) {
                                    return arguments.length ? (this._dirty && this.totalDuration(),
                                    value > this._duration && (value = this._duration),
                                        this._yoyo && 0 !== (1 & this._cycle) ? value = this._duration - value + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (value += this._cycle * (this._duration + this._repeatDelay)),
                                        this.totalTime(value, suppressEvents)) : this._time
                                }
                                ,
                                p.repeat = function(value) {
                                    return arguments.length ? (this._repeat = value,
                                        this._uncache(!0)) : this._repeat
                                }
                                ,
                                p.repeatDelay = function(value) {
                                    return arguments.length ? (this._repeatDelay = value,
                                        this._uncache(!0)) : this._repeatDelay
                                }
                                ,
                                p.yoyo = function(value) {
                                    return arguments.length ? (this._yoyo = value,
                                        this) : this._yoyo
                                }
                                ,
                                p.currentLabel = function(value) {
                                    return arguments.length ? this.seek(value, !0) : this.getLabelBefore(this._time + 1e-8)
                                }
                                ,
                                TimelineMax
                        }, !0),
                        function() {
                            var _RAD2DEG = 180 / Math.PI
                                , _r1 = []
                                , _r2 = []
                                , _r3 = []
                                , _corProps = {}
                                , _globals = _gsScope._gsDefine.globals
                                , Segment = function(a, b, c, d) {
                                c === d && (c = d - (d - b) / 1e6),
                                a === b && (b = a + (c - a) / 1e6),
                                    this.a = a,
                                    this.b = b,
                                    this.c = c,
                                    this.d = d,
                                    this.da = d - a,
                                    this.ca = c - a,
                                    this.ba = b - a
                            }
                                , _correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,"
                                , cubicToQuadratic = function(a, b, c, d) {
                                var q1 = {
                                    a: a
                                }
                                    , q2 = {}
                                    , q3 = {}
                                    , q4 = {
                                    c: d
                                }
                                    , mab = (a + b) / 2
                                    , mbc = (b + c) / 2
                                    , mcd = (c + d) / 2
                                    , mabc = (mab + mbc) / 2
                                    , mbcd = (mbc + mcd) / 2
                                    , m8 = (mbcd - mabc) / 8;
                                return q1.b = mab + (a - mab) / 4,
                                    q2.b = mabc + m8,
                                    q1.c = q2.a = (q1.b + q2.b) / 2,
                                    q2.c = q3.a = (mabc + mbcd) / 2,
                                    q3.b = mbcd - m8,
                                    q4.b = mcd + (d - mcd) / 4,
                                    q3.c = q4.a = (q3.b + q4.b) / 2,
                                    [q1, q2, q3, q4]
                            }
                                , _calculateControlPoints = function(a, curviness, quad, basic, correlate) {
                                var i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl, l = a.length - 1, ii = 0, cp1 = a[0].a;
                                for (i = 0; i < l; i++)
                                    seg = a[ii],
                                        p1 = seg.a,
                                        p2 = seg.d,
                                        p3 = a[ii + 1].d,
                                        correlate ? (r1 = _r1[i],
                                            r2 = _r2[i],
                                            tl = (r2 + r1) * curviness * .25 / (basic ? .5 : _r3[i] || .5),
                                            m1 = p2 - (p2 - p1) * (basic ? .5 * curviness : 0 !== r1 ? tl / r1 : 0),
                                            m2 = p2 + (p3 - p2) * (basic ? .5 * curviness : 0 !== r2 ? tl / r2 : 0),
                                            mm = p2 - (m1 + ((m2 - m1) * (3 * r1 / (r1 + r2) + .5) / 4 || 0))) : (m1 = p2 - (p2 - p1) * curviness * .5,
                                            m2 = p2 + (p3 - p2) * curviness * .5,
                                            mm = p2 - (m1 + m2) / 2),
                                        m1 += mm,
                                        m2 += mm,
                                        seg.c = cp2 = m1,
                                        0 !== i ? seg.b = cp1 : seg.b = cp1 = seg.a + .6 * (seg.c - seg.a),
                                        seg.da = p2 - p1,
                                        seg.ca = cp2 - p1,
                                        seg.ba = cp1 - p1,
                                        quad ? (qb = cubicToQuadratic(p1, cp1, cp2, p2),
                                            a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]),
                                            ii += 4) : ii++,
                                        cp1 = m2;
                                seg = a[ii],
                                    seg.b = cp1,
                                    seg.c = cp1 + .4 * (seg.d - cp1),
                                    seg.da = seg.d - seg.a,
                                    seg.ca = seg.c - seg.a,
                                    seg.ba = cp1 - seg.a,
                                quad && (qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d),
                                    a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]))
                            }
                                , _parseAnchors = function(values, p, correlate, prepend) {
                                var l, i, p1, p2, p3, tmp, a = [];
                                if (prepend)
                                    for (values = [prepend].concat(values),
                                             i = values.length; --i > -1; )
                                        "string" == typeof (tmp = values[i][p]) && "=" === tmp.charAt(1) && (values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)));
                                if (l = values.length - 2,
                                    l < 0)
                                    return a[0] = new Segment(values[0][p],0,0,values[l < -1 ? 0 : 1][p]),
                                        a;
                                for (i = 0; i < l; i++)
                                    p1 = values[i][p],
                                        p2 = values[i + 1][p],
                                        a[i] = new Segment(p1,0,0,p2),
                                    correlate && (p3 = values[i + 2][p],
                                        _r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1),
                                        _r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2));
                                return a[i] = new Segment(values[i][p],0,0,values[i + 1][p]),
                                    a
                            }
                                , bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
                                var i, p, a, j, r, l, seamless, last, obj = {}, props = [], first = prepend || values[0];
                                correlate = "string" == typeof correlate ? "," + correlate + "," : _correlate,
                                null == curviness && (curviness = 1);
                                for (p in values[0])
                                    props.push(p);
                                if (values.length > 1) {
                                    for (last = values[values.length - 1],
                                             seamless = !0,
                                             i = props.length; --i > -1; )
                                        if (p = props[i],
                                            Math.abs(first[p] - last[p]) > .05) {
                                            seamless = !1;
                                            break
                                        }
                                    seamless && (values = values.concat(),
                                    prepend && values.unshift(prepend),
                                        values.push(values[1]),
                                        prepend = values[values.length - 3])
                                }
                                for (_r1.length = _r2.length = _r3.length = 0,
                                         i = props.length; --i > -1; )
                                    p = props[i],
                                        _corProps[p] = correlate.indexOf("," + p + ",") !== -1,
                                        obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
                                for (i = _r1.length; --i > -1; )
                                    _r1[i] = Math.sqrt(_r1[i]),
                                        _r2[i] = Math.sqrt(_r2[i]);
                                if (!basic) {
                                    for (i = props.length; --i > -1; )
                                        if (_corProps[p])
                                            for (a = obj[props[i]],
                                                     l = a.length - 1,
                                                     j = 0; j < l; j++)
                                                r = a[j + 1].da / _r2[j] + a[j].da / _r1[j] || 0,
                                                    _r3[j] = (_r3[j] || 0) + r * r;
                                    for (i = _r3.length; --i > -1; )
                                        _r3[i] = Math.sqrt(_r3[i])
                                }
                                for (i = props.length,
                                         j = quadratic ? 4 : 1; --i > -1; )
                                    p = props[i],
                                        a = obj[p],
                                        _calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]),
                                    seamless && (a.splice(0, j),
                                        a.splice(a.length - j, j));
                                return obj
                            }
                                , _parseBezierData = function(values, type, prepend) {
                                type = type || "soft";
                                var a, b, c, d, cur, i, j, l, p, cnt, tmp, obj = {}, inc = "cubic" === type ? 3 : 2, soft = "soft" === type, props = [];
                                if (soft && prepend && (values = [prepend].concat(values)),
                                    null == values || values.length < inc + 1)
                                    throw "invalid Bezier data";
                                for (p in values[0])
                                    props.push(p);
                                for (i = props.length; --i > -1; ) {
                                    for (p = props[i],
                                             obj[p] = cur = [],
                                             cnt = 0,
                                             l = values.length,
                                             j = 0; j < l; j++)
                                        a = null == prepend ? values[j][p] : "string" == typeof (tmp = values[j][p]) && "=" === tmp.charAt(1) ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp),
                                        soft && j > 1 && j < l - 1 && (cur[cnt++] = (a + cur[cnt - 2]) / 2),
                                            cur[cnt++] = a;
                                    for (l = cnt - inc + 1,
                                             cnt = 0,
                                             j = 0; j < l; j += inc)
                                        a = cur[j],
                                            b = cur[j + 1],
                                            c = cur[j + 2],
                                            d = 2 === inc ? 0 : cur[j + 3],
                                            cur[cnt++] = tmp = 3 === inc ? new Segment(a,b,c,d) : new Segment(a,(2 * b + a) / 3,(2 * b + c) / 3,c);
                                    cur.length = cnt
                                }
                                return obj
                            }
                                , _addCubicLengths = function(a, steps, resolution) {
                                for (var d, d1, s, da, ca, ba, p, i, inv, bez, index, inc = 1 / resolution, j = a.length; --j > -1; )
                                    for (bez = a[j],
                                             s = bez.a,
                                             da = bez.d - s,
                                             ca = bez.c - s,
                                             ba = bez.b - s,
                                             d = d1 = 0,
                                             i = 1; i <= resolution; i++)
                                        p = inc * i,
                                            inv = 1 - p,
                                            d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p),
                                            index = j * resolution + i - 1,
                                            steps[index] = (steps[index] || 0) + d * d
                            }
                                , _parseLengthData = function(obj, resolution) {
                                resolution = resolution >> 0 || 6;
                                var p, i, l, index, a = [], lengths = [], d = 0, total = 0, threshold = resolution - 1, segments = [], curLS = [];
                                for (p in obj)
                                    _addCubicLengths(obj[p], a, resolution);
                                for (l = a.length,
                                         i = 0; i < l; i++)
                                    d += Math.sqrt(a[i]),
                                        index = i % resolution,
                                        curLS[index] = d,
                                    index === threshold && (total += d,
                                        index = i / resolution >> 0,
                                        segments[index] = curLS,
                                        lengths[index] = total,
                                        d = 0,
                                        curLS = []);
                                return {
                                    length: total,
                                    lengths: lengths,
                                    segments: segments
                                }
                            }
                                , BezierPlugin = _gsScope._gsDefine.plugin({
                                propName: "bezier",
                                priority: -1,
                                version: "1.3.7",
                                API: 2,
                                global: !0,
                                init: function(target, vars, tween) {
                                    this._target = target,
                                    vars instanceof Array && (vars = {
                                        values: vars
                                    }),
                                        this._func = {},
                                        this._mod = {},
                                        this._props = [],
                                        this._timeRes = null == vars.timeResolution ? 6 : parseInt(vars.timeResolution, 10);
                                    var p, isFunc, i, j, prepend, values = vars.values || [], first = {}, second = values[0], autoRotate = vars.autoRotate || tween.vars.orientToBezier;
                                    this._autoRotate = autoRotate ? autoRotate instanceof Array ? autoRotate : [["x", "y", "rotation", autoRotate === !0 ? 0 : Number(autoRotate) || 0]] : null;
                                    for (p in second)
                                        this._props.push(p);
                                    for (i = this._props.length; --i > -1; )
                                        p = this._props[i],
                                            this._overwriteProps.push(p),
                                            isFunc = this._func[p] = "function" == typeof target[p],
                                            first[p] = isFunc ? target[p.indexOf("set") || "function" != typeof target["get" + p.substr(3)] ? p : "get" + p.substr(3)]() : parseFloat(target[p]),
                                        prepend || first[p] !== values[0][p] && (prepend = first);
                                    if (this._beziers = "cubic" !== vars.type && "quadratic" !== vars.type && "soft" !== vars.type ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, !1, "thruBasic" === vars.type, vars.correlate, prepend) : _parseBezierData(values, vars.type, first),
                                            this._segCount = this._beziers[p].length,
                                            this._timeRes) {
                                        var ld = _parseLengthData(this._beziers, this._timeRes);
                                        this._length = ld.length,
                                            this._lengths = ld.lengths,
                                            this._segments = ld.segments,
                                            this._l1 = this._li = this._s1 = this._si = 0,
                                            this._l2 = this._lengths[0],
                                            this._curSeg = this._segments[0],
                                            this._s2 = this._curSeg[0],
                                            this._prec = 1 / this._curSeg.length
                                    }
                                    if (autoRotate = this._autoRotate)
                                        for (this._initialRotations = [],
                                             autoRotate[0]instanceof Array || (this._autoRotate = autoRotate = [autoRotate]),
                                                 i = autoRotate.length; --i > -1; ) {
                                            for (j = 0; j < 3; j++)
                                                p = autoRotate[i][j],
                                                    this._func[p] = "function" == typeof target[p] && target[p.indexOf("set") || "function" != typeof target["get" + p.substr(3)] ? p : "get" + p.substr(3)];
                                            p = autoRotate[i][2],
                                                this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0,
                                                this._overwriteProps.push(p)
                                        }
                                    return this._startRatio = tween.vars.runBackwards ? 1 : 0,
                                        !0
                                },
                                set: function(v) {
                                    var curIndex, inv, i, p, b, t, val, l, lengths, curSeg, segments = this._segCount, func = this._func, target = this._target, notStart = v !== this._startRatio;
                                    if (this._timeRes) {
                                        if (lengths = this._lengths,
                                                curSeg = this._curSeg,
                                                v *= this._length,
                                                i = this._li,
                                            v > this._l2 && i < segments - 1) {
                                            for (l = segments - 1; i < l && (this._l2 = lengths[++i]) <= v; )
                                                ;
                                            this._l1 = lengths[i - 1],
                                                this._li = i,
                                                this._curSeg = curSeg = this._segments[i],
                                                this._s2 = curSeg[this._s1 = this._si = 0]
                                        } else if (v < this._l1 && i > 0) {
                                            for (; i > 0 && (this._l1 = lengths[--i]) >= v; )
                                                ;
                                            0 === i && v < this._l1 ? this._l1 = 0 : i++,
                                                this._l2 = lengths[i],
                                                this._li = i,
                                                this._curSeg = curSeg = this._segments[i],
                                                this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0,
                                                this._s2 = curSeg[this._si]
                                        }
                                        if (curIndex = i,
                                                v -= this._l1,
                                                i = this._si,
                                            v > this._s2 && i < curSeg.length - 1) {
                                            for (l = curSeg.length - 1; i < l && (this._s2 = curSeg[++i]) <= v; )
                                                ;
                                            this._s1 = curSeg[i - 1],
                                                this._si = i
                                        } else if (v < this._s1 && i > 0) {
                                            for (; i > 0 && (this._s1 = curSeg[--i]) >= v; )
                                                ;
                                            0 === i && v < this._s1 ? this._s1 = 0 : i++,
                                                this._s2 = curSeg[i],
                                                this._si = i
                                        }
                                        t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                                    } else
                                        curIndex = v < 0 ? 0 : v >= 1 ? segments - 1 : segments * v >> 0,
                                            t = (v - curIndex * (1 / segments)) * segments;
                                    for (inv = 1 - t,
                                             i = this._props.length; --i > -1; )
                                        p = this._props[i],
                                            b = this._beziers[p][curIndex],
                                            val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a,
                                        this._mod[p] && (val = this._mod[p](val, target)),
                                            func[p] ? target[p](val) : target[p] = val;
                                    if (this._autoRotate) {
                                        var b2, x1, y1, x2, y2, add, conv, ar = this._autoRotate;
                                        for (i = ar.length; --i > -1; )
                                            p = ar[i][2],
                                                add = ar[i][3] || 0,
                                                conv = ar[i][4] === !0 ? 1 : _RAD2DEG,
                                                b = this._beziers[ar[i][0]],
                                                b2 = this._beziers[ar[i][1]],
                                            b && b2 && (b = b[curIndex],
                                                b2 = b2[curIndex],
                                                x1 = b.a + (b.b - b.a) * t,
                                                x2 = b.b + (b.c - b.b) * t,
                                                x1 += (x2 - x1) * t,
                                                x2 += (b.c + (b.d - b.c) * t - x2) * t,
                                                y1 = b2.a + (b2.b - b2.a) * t,
                                                y2 = b2.b + (b2.c - b2.b) * t,
                                                y1 += (y2 - y1) * t,
                                                y2 += (b2.c + (b2.d - b2.c) * t - y2) * t,
                                                val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i],
                                            this._mod[p] && (val = this._mod[p](val, target)),
                                                func[p] ? target[p](val) : target[p] = val)
                                    }
                                }
                            })
                                , p = BezierPlugin.prototype;
                            BezierPlugin.bezierThrough = bezierThrough,
                                BezierPlugin.cubicToQuadratic = cubicToQuadratic,
                                BezierPlugin._autoCSS = !0,
                                BezierPlugin.quadraticToCubic = function(a, b, c) {
                                    return new Segment(a,(2 * b + a) / 3,(2 * b + c) / 3,c)
                                }
                                ,
                                BezierPlugin._cssRegister = function() {
                                    var CSSPlugin = _globals.CSSPlugin;
                                    if (CSSPlugin) {
                                        var _internals = CSSPlugin._internals
                                            , _parseToProxy = _internals._parseToProxy
                                            , _setPluginRatio = _internals._setPluginRatio
                                            , CSSPropTween = _internals.CSSPropTween;
                                        _internals._registerComplexSpecialProp("bezier", {
                                            parser: function(t, e, prop, cssp, pt, plugin) {
                                                e instanceof Array && (e = {
                                                    values: e
                                                }),
                                                    plugin = new BezierPlugin;
                                                var i, p, data, values = e.values, l = values.length - 1, pluginValues = [], v = {};
                                                if (l < 0)
                                                    return pt;
                                                for (i = 0; i <= l; i++)
                                                    data = _parseToProxy(t, values[i], cssp, pt, plugin, l !== i),
                                                        pluginValues[i] = data.end;
                                                for (p in e)
                                                    v[p] = e[p];
                                                return v.values = pluginValues,
                                                    pt = new CSSPropTween(t,"bezier",0,0,data.pt,2),
                                                    pt.data = data,
                                                    pt.plugin = plugin,
                                                    pt.setRatio = _setPluginRatio,
                                                0 === v.autoRotate && (v.autoRotate = !0),
                                                !v.autoRotate || v.autoRotate instanceof Array || (i = v.autoRotate === !0 ? 0 : Number(v.autoRotate),
                                                    v.autoRotate = null != data.end.left ? [["left", "top", "rotation", i, !1]] : null != data.end.x && [["x", "y", "rotation", i, !1]]),
                                                v.autoRotate && (cssp._transform || cssp._enableTransforms(!1),
                                                    data.autoRotate = cssp._target._gsTransform,
                                                    data.proxy.rotation = data.autoRotate.rotation || 0,
                                                    cssp._overwriteProps.push("rotation")),
                                                    plugin._onInitTween(data.proxy, v, cssp._tween),
                                                    pt
                                            }
                                        })
                                    }
                                }
                                ,
                                p._mod = function(lookup) {
                                    for (var val, op = this._overwriteProps, i = op.length; --i > -1; )
                                        val = lookup[op[i]],
                                        val && "function" == typeof val && (this._mod[op[i]] = val)
                                }
                                ,
                                p._kill = function(lookup) {
                                    var p, i, a = this._props;
                                    for (p in this._beziers)
                                        if (p in lookup)
                                            for (delete this._beziers[p],
                                                     delete this._func[p],
                                                     i = a.length; --i > -1; )
                                                a[i] === p && a.splice(i, 1);
                                    if (a = this._autoRotate)
                                        for (i = a.length; --i > -1; )
                                            lookup[a[i][2]] && a.splice(i, 1);
                                    return this._super._kill.call(this, lookup)
                                }
                        }(),
                        _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(TweenPlugin, TweenLite) {
                            var _hasPriority, _suffixMap, _cs, _overwriteProps, CSSPlugin = function() {
                                TweenPlugin.call(this, "css"),
                                    this._overwriteProps.length = 0,
                                    this.setRatio = CSSPlugin.prototype.setRatio
                            }, _globals = _gsScope._gsDefine.globals, _specialProps = {}, p = CSSPlugin.prototype = new TweenPlugin("css");
                            p.constructor = CSSPlugin,
                                CSSPlugin.version = "1.19.0",
                                CSSPlugin.API = 2,
                                CSSPlugin.defaultTransformPerspective = 0,
                                CSSPlugin.defaultSkewType = "compensated",
                                CSSPlugin.defaultSmoothOrigin = !0,
                                p = "px",
                                CSSPlugin.suffixMap = {
                                    top: p,
                                    right: p,
                                    bottom: p,
                                    left: p,
                                    width: p,
                                    height: p,
                                    fontSize: p,
                                    padding: p,
                                    margin: p,
                                    perspective: p,
                                    lineHeight: ""
                                };
                            var _autoRound, _reqSafariFix, _isSafari, _isFirefox, _isSafariLT6, _ieVers, _target, _index, _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g, _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, _NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, _suffixExp = /(?:\d|\-|\+|=|#|\.)*/g, _opacityExp = /opacity *= *([^)]*)/i, _opacityValExp = /opacity:([^;]*)/i, _alphaFilterExp = /alpha\(opacity *=.+?\)/i, _rgbhslExp = /^(rgb|hsl)/, _capsExp = /([A-Z])/g, _camelExp = /-([a-z])/gi, _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, _camelFunc = function(s, g) {
                                return g.toUpperCase()
                            }, _horizExp = /(?:Left|Right|Width)/i, _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, _complexExp = /[\s,\(]/i, _DEG2RAD = Math.PI / 180, _RAD2DEG = 180 / Math.PI, _forcePT = {}, _doc = document, _createElement = function(type) {
                                return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type)
                            }, _tempDiv = _createElement("div"), _tempImg = _createElement("img"), _internals = CSSPlugin._internals = {
                                _specialProps: _specialProps
                            }, _agent = navigator.userAgent, _supportsOpacity = function() {
                                var i = _agent.indexOf("Android")
                                    , a = _createElement("a");
                                return _isSafari = _agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i + 8, 1)) > 3),
                                    _isSafariLT6 = _isSafari && Number(_agent.substr(_agent.indexOf("Version/") + 8, 1)) < 6,
                                    _isFirefox = _agent.indexOf("Firefox") !== -1,
                                (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(_agent) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(_agent)) && (_ieVers = parseFloat(RegExp.$1)),
                                !!a && (a.style.cssText = "top:1px;opacity:.55;",
                                    /^0.55/.test(a.style.opacity))
                            }(), _getIEOpacity = function(v) {
                                return _opacityExp.test("string" == typeof v ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                            }, _log = function(s) {
                                window.console && console.log(s)
                            }, _prefixCSS = "", _prefix = "", _checkPropPrefix = function(p, e) {
                                e = e || _tempDiv;
                                var a, i, s = e.style;
                                if (void 0 !== s[p])
                                    return p;
                                for (p = p.charAt(0).toUpperCase() + p.substr(1),
                                         a = ["O", "Moz", "ms", "Ms", "Webkit"],
                                         i = 5; --i > -1 && void 0 === s[a[i] + p]; )
                                    ;
                                return i >= 0 ? (_prefix = 3 === i ? "ms" : a[i],
                                    _prefixCSS = "-" + _prefix.toLowerCase() + "-",
                                _prefix + p) : null
                            }, _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {}
                                , _getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
                                var rv;
                                return _supportsOpacity || "opacity" !== p ? (!calc && t.style[p] ? rv = t.style[p] : (cs = cs || _getComputedStyle(t)) ? rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase()) : t.currentStyle && (rv = t.currentStyle[p]),
                                    null == dflt || rv && "none" !== rv && "auto" !== rv && "auto auto" !== rv ? rv : dflt) : _getIEOpacity(t)
                            }
                                , _convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
                                if ("px" === sfx || !sfx)
                                    return v;
                                if ("auto" === sfx || !v)
                                    return 0;
                                var pix, cache, time, horiz = _horizExp.test(p), node = t, style = _tempDiv.style, neg = v < 0, precise = 1 === v;
                                if (neg && (v = -v),
                                    precise && (v *= 100),
                                    "%" === sfx && p.indexOf("border") !== -1)
                                    pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight);
                                else {
                                    if (style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;",
                                        "%" !== sfx && node.appendChild && "v" !== sfx.charAt(0) && "rem" !== sfx)
                                        style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx;
                                    else {
                                        if (node = t.parentNode || _doc.body,
                                                cache = node._gsCache,
                                                time = TweenLite.ticker.frame,
                                            cache && horiz && cache.time === time)
                                            return cache.width * v / 100;
                                        style[horiz ? "width" : "height"] = v + sfx
                                    }
                                    node.appendChild(_tempDiv),
                                        pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"]),
                                        node.removeChild(_tempDiv),
                                    horiz && "%" === sfx && CSSPlugin.cacheWidths !== !1 && (cache = node._gsCache = node._gsCache || {},
                                        cache.time = time,
                                        cache.width = pix / v * 100),
                                    0 !== pix || recurse || (pix = _convertToPixels(t, p, v, sfx, !0))
                                }
                                return precise && (pix /= 100),
                                    neg ? -pix : pix
                            }
                                , _calculateOffset = _internals.calculateOffset = function(t, p, cs) {
                                if ("absolute" !== _getStyle(t, "position", cs))
                                    return 0;
                                var dim = "left" === p ? "Left" : "Top"
                                    , v = _getStyle(t, "margin" + dim, cs);
                                return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0)
                            }
                                , _getAllStyles = function(t, cs) {
                                var i, tr, p, s = {};
                                if (cs = cs || _getComputedStyle(t, null))
                                    if (i = cs.length)
                                        for (; --i > -1; )
                                            p = cs[i],
                                            p.indexOf("-transform") !== -1 && _transformPropCSS !== p || (s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p));
                                    else
                                        for (i in cs)
                                            i.indexOf("Transform") !== -1 && _transformProp !== i || (s[i] = cs[i]);
                                else if (cs = t.currentStyle || t.style)
                                    for (i in cs)
                                        "string" == typeof i && void 0 === s[i] && (s[i.replace(_camelExp, _camelFunc)] = cs[i]);
                                return _supportsOpacity || (s.opacity = _getIEOpacity(t)),
                                    tr = _getTransform(t, cs, !1),
                                    s.rotation = tr.rotation,
                                    s.skewX = tr.skewX,
                                    s.scaleX = tr.scaleX,
                                    s.scaleY = tr.scaleY,
                                    s.x = tr.x,
                                    s.y = tr.y,
                                _supports3D && (s.z = tr.z,
                                    s.rotationX = tr.rotationX,
                                    s.rotationY = tr.rotationY,
                                    s.scaleZ = tr.scaleZ),
                                s.filters && delete s.filters,
                                    s
                            }, _cssDif = function(t, s1, s2, vars, forceLookup) {
                                var val, p, mpt, difs = {}, style = t.style;
                                for (p in s2)
                                    "cssText" !== p && "length" !== p && isNaN(p) && (s1[p] !== (val = s2[p]) || forceLookup && forceLookup[p]) && p.indexOf("Origin") === -1 && ("number" != typeof val && "string" != typeof val || (difs[p] = "auto" !== val || "left" !== p && "top" !== p ? "" !== val && "auto" !== val && "none" !== val || "string" != typeof s1[p] || "" === s1[p].replace(_NaNExp, "") ? val : 0 : _calculateOffset(t, p),
                                    void 0 !== style[p] && (mpt = new MiniPropTween(style,p,style[p],mpt))));
                                if (vars)
                                    for (p in vars)
                                        "className" !== p && (difs[p] = vars[p]);
                                return {
                                    difs: difs,
                                    firstMPT: mpt
                                }
                            }, _dimensions = {
                                width: ["Left", "Right"],
                                height: ["Top", "Bottom"]
                            }, _margins = ["marginLeft", "marginRight", "marginTop", "marginBottom"], _getDimension = function(t, p, cs) {
                                if ("svg" === (t.nodeName + "").toLowerCase())
                                    return (cs || _getComputedStyle(t))[p] || 0;
                                if (t.getBBox && _isSVG(t))
                                    return t.getBBox()[p] || 0;
                                var v = parseFloat("width" === p ? t.offsetWidth : t.offsetHeight)
                                    , a = _dimensions[p]
                                    , i = a.length;
                                for (cs = cs || _getComputedStyle(t, null); --i > -1; )
                                    v -= parseFloat(_getStyle(t, "padding" + a[i], cs, !0)) || 0,
                                        v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, !0)) || 0;
                                return v
                            }, _parsePosition = function(v, recObj) {
                                if ("contain" === v || "auto" === v || "auto auto" === v)
                                    return v + " ";
                                null != v && "" !== v || (v = "0 0");
                                var i, a = v.split(" "), x = v.indexOf("left") !== -1 ? "0%" : v.indexOf("right") !== -1 ? "100%" : a[0], y = v.indexOf("top") !== -1 ? "0%" : v.indexOf("bottom") !== -1 ? "100%" : a[1];
                                if (a.length > 3 && !recObj) {
                                    for (a = v.split(", ").join(",").split(","),
                                             v = [],
                                             i = 0; i < a.length; i++)
                                        v.push(_parsePosition(a[i]));
                                    return v.join(",")
                                }
                                return null == y ? y = "center" === x ? "50%" : "0" : "center" === y && (y = "50%"),
                                ("center" === x || isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1) && (x = "50%"),
                                    v = x + " " + y + (a.length > 2 ? " " + a[2] : ""),
                                recObj && (recObj.oxp = x.indexOf("%") !== -1,
                                    recObj.oyp = y.indexOf("%") !== -1,
                                    recObj.oxr = "=" === x.charAt(1),
                                    recObj.oyr = "=" === y.charAt(1),
                                    recObj.ox = parseFloat(x.replace(_NaNExp, "")),
                                    recObj.oy = parseFloat(y.replace(_NaNExp, "")),
                                    recObj.v = v),
                                recObj || v
                            }, _parseChange = function(e, b) {
                                return "function" == typeof e && (e = e(_index, _target)),
                                    "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b) || 0
                            }, _parseVal = function(v, d) {
                                return "function" == typeof v && (v = v(_index, _target)),
                                    null == v ? d : "string" == typeof v && "=" === v.charAt(1) ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0
                            }, _parseAngle = function(v, d, p, directionalEnd) {
                                var cap, split, dif, result, isRelative, min = 1e-6;
                                return "function" == typeof v && (v = v(_index, _target)),
                                    null == v ? result = d : "number" == typeof v ? result = v : (cap = 360,
                                        split = v.split("_"),
                                        isRelative = "=" === v.charAt(1),
                                        dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * (v.indexOf("rad") === -1 ? 1 : _RAD2DEG) - (isRelative ? 0 : d),
                                    split.length && (directionalEnd && (directionalEnd[p] = d + dif),
                                    v.indexOf("short") !== -1 && (dif %= cap,
                                    dif !== dif % (cap / 2) && (dif = dif < 0 ? dif + cap : dif - cap)),
                                        v.indexOf("_cw") !== -1 && dif < 0 ? dif = (dif + 9999999999 * cap) % cap - (dif / cap | 0) * cap : v.indexOf("ccw") !== -1 && dif > 0 && (dif = (dif - 9999999999 * cap) % cap - (dif / cap | 0) * cap)),
                                        result = d + dif),
                                result < min && result > -min && (result = 0),
                                    result
                            }, _colorLookup = {
                                aqua: [0, 255, 255],
                                lime: [0, 255, 0],
                                silver: [192, 192, 192],
                                black: [0, 0, 0],
                                maroon: [128, 0, 0],
                                teal: [0, 128, 128],
                                blue: [0, 0, 255],
                                navy: [0, 0, 128],
                                white: [255, 255, 255],
                                fuchsia: [255, 0, 255],
                                olive: [128, 128, 0],
                                yellow: [255, 255, 0],
                                orange: [255, 165, 0],
                                gray: [128, 128, 128],
                                purple: [128, 0, 128],
                                green: [0, 128, 0],
                                red: [255, 0, 0],
                                pink: [255, 192, 203],
                                cyan: [0, 255, 255],
                                transparent: [255, 255, 255, 0]
                            }, _hue = function(h, m1, m2) {
                                return h = h < 0 ? h + 1 : h > 1 ? h - 1 : h,
                                255 * (6 * h < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : 3 * h < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) + .5 | 0
                            }, _parseColor = CSSPlugin.parseColor = function(v, toHSL) {
                                var a, r, g, b, h, s, l, max, min, d, wasHSL;
                                if (v)
                                    if ("number" == typeof v)
                                        a = [v >> 16, v >> 8 & 255, 255 & v];
                                    else {
                                        if ("," === v.charAt(v.length - 1) && (v = v.substr(0, v.length - 1)),
                                                _colorLookup[v])
                                            a = _colorLookup[v];
                                        else if ("#" === v.charAt(0))
                                            4 === v.length && (r = v.charAt(1),
                                                g = v.charAt(2),
                                                b = v.charAt(3),
                                                v = "#" + r + r + g + g + b + b),
                                                v = parseInt(v.substr(1), 16),
                                                a = [v >> 16, v >> 8 & 255, 255 & v];
                                        else if ("hsl" === v.substr(0, 3))
                                            if (a = wasHSL = v.match(_numExp),
                                                    toHSL) {
                                                if (v.indexOf("=") !== -1)
                                                    return v.match(_relNumExp)
                                            } else
                                                h = Number(a[0]) % 360 / 360,
                                                    s = Number(a[1]) / 100,
                                                    l = Number(a[2]) / 100,
                                                    g = l <= .5 ? l * (s + 1) : l + s - l * s,
                                                    r = 2 * l - g,
                                                a.length > 3 && (a[3] = Number(v[3])),
                                                    a[0] = _hue(h + 1 / 3, r, g),
                                                    a[1] = _hue(h, r, g),
                                                    a[2] = _hue(h - 1 / 3, r, g);
                                        else
                                            a = v.match(_numExp) || _colorLookup.transparent;
                                        a[0] = Number(a[0]),
                                            a[1] = Number(a[1]),
                                            a[2] = Number(a[2]),
                                        a.length > 3 && (a[3] = Number(a[3]))
                                    }
                                else
                                    a = _colorLookup.black;
                                return toHSL && !wasHSL && (r = a[0] / 255,
                                    g = a[1] / 255,
                                    b = a[2] / 255,
                                    max = Math.max(r, g, b),
                                    min = Math.min(r, g, b),
                                    l = (max + min) / 2,
                                    max === min ? h = s = 0 : (d = max - min,
                                        s = l > .5 ? d / (2 - max - min) : d / (max + min),
                                        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4,
                                        h *= 60),
                                    a[0] = h + .5 | 0,
                                    a[1] = 100 * s + .5 | 0,
                                    a[2] = 100 * l + .5 | 0),
                                    a
                            }
                                , _formatColors = function(s, toHSL) {
                                var i, color, temp, colors = s.match(_colorExp) || [], charIndex = 0, parsed = colors.length ? "" : s;
                                for (i = 0; i < colors.length; i++)
                                    color = colors[i],
                                        temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex),
                                        charIndex += temp.length + color.length,
                                        color = _parseColor(color, toHSL),
                                    3 === color.length && color.push(1),
                                        parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
                                return parsed + s.substr(charIndex)
                            }, _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                            for (p in _colorLookup)
                                _colorExp += "|" + p + "\\b";
                            _colorExp = new RegExp(_colorExp + ")","gi"),
                                CSSPlugin.colorStringFilter = function(a) {
                                    var toHSL, combined = a[0] + a[1];
                                    _colorExp.test(combined) && (toHSL = combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1,
                                        a[0] = _formatColors(a[0], toHSL),
                                        a[1] = _formatColors(a[1], toHSL)),
                                        _colorExp.lastIndex = 0
                                }
                                ,
                            TweenLite.defaultStringFilter || (TweenLite.defaultStringFilter = CSSPlugin.colorStringFilter);
                            var _getFormatter = function(dflt, clr, collapsible, multi) {
                                if (null == dflt)
                                    return function(v) {
                                        return v
                                    }
                                        ;
                                var formatter, dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "", dVals = dflt.split(dColor).join("").match(_valuesExp) || [], pfx = dflt.substr(0, dflt.indexOf(dVals[0])), sfx = ")" === dflt.charAt(dflt.length - 1) ? ")" : "", delim = dflt.indexOf(" ") !== -1 ? " " : ",", numVals = dVals.length, dSfx = numVals > 0 ? dVals[0].replace(_numExp, "") : "";
                                return numVals ? formatter = clr ? function(v) {
                                    var color, vals, i, a;
                                    if ("number" == typeof v)
                                        v += dSfx;
                                    else if (multi && _commasOutsideParenExp.test(v)) {
                                        for (a = v.replace(_commasOutsideParenExp, "|").split("|"),
                                                 i = 0; i < a.length; i++)
                                            a[i] = formatter(a[i]);
                                        return a.join(",")
                                    }
                                    if (color = (v.match(_colorExp) || [dColor])[0],
                                            vals = v.split(color).join("").match(_valuesExp) || [],
                                            i = vals.length,
                                        numVals > i--)
                                        for (; ++i < numVals; )
                                            vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
                                    return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "")
                                }
                                    : function(v) {
                                    var vals, a, i;
                                    if ("number" == typeof v)
                                        v += dSfx;
                                    else if (multi && _commasOutsideParenExp.test(v)) {
                                        for (a = v.replace(_commasOutsideParenExp, "|").split("|"),
                                                 i = 0; i < a.length; i++)
                                            a[i] = formatter(a[i]);
                                        return a.join(",")
                                    }
                                    if (vals = v.match(_valuesExp) || [],
                                            i = vals.length,
                                        numVals > i--)
                                        for (; ++i < numVals; )
                                            vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
                                    return pfx + vals.join(delim) + sfx
                                }
                                    : function(v) {
                                    return v
                                }
                            }
                                , _getEdgeParser = function(props) {
                                return props = props.split(","),
                                    function(t, e, p, cssp, pt, plugin, vars) {
                                        var i, a = (e + "").split(" ");
                                        for (vars = {},
                                                 i = 0; i < 4; i++)
                                            vars[props[i]] = a[i] = a[i] || a[(i - 1) / 2 >> 0];
                                        return cssp.parse(t, vars, pt, plugin)
                                    }
                            }
                                , MiniPropTween = (_internals._setPluginRatio = function(v) {
                                    this.plugin.setRatio(v);
                                    for (var val, pt, i, str, p, d = this.data, proxy = d.proxy, mpt = d.firstMPT, min = 1e-6; mpt; )
                                        val = proxy[mpt.v],
                                            mpt.r ? val = Math.round(val) : val < min && val > -min && (val = 0),
                                            mpt.t[mpt.p] = val,
                                            mpt = mpt._next;
                                    if (d.autoRotate && (d.autoRotate.rotation = d.mod ? d.mod(proxy.rotation, this.t) : proxy.rotation),
                                        1 === v || 0 === v)
                                        for (mpt = d.firstMPT,
                                                 p = 1 === v ? "e" : "b"; mpt; ) {
                                            if (pt = mpt.t,
                                                    pt.type) {
                                                if (1 === pt.type) {
                                                    for (str = pt.xs0 + pt.s + pt.xs1,
                                                             i = 1; i < pt.l; i++)
                                                        str += pt["xn" + i] + pt["xs" + (i + 1)];
                                                    pt[p] = str
                                                }
                                            } else
                                                pt[p] = pt.s + pt.xs0;
                                            mpt = mpt._next
                                        }
                                }
                                    ,
                                    function(t, p, v, next, r) {
                                        this.t = t,
                                            this.p = p,
                                            this.v = v,
                                            this.r = r,
                                        next && (next._prev = this,
                                            this._next = next)
                                    }
                            )
                                , CSSPropTween = (_internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
                                    var i, p, xp, mpt, firstPT, bpt = pt, start = {}, end = {}, transform = cssp._transform, oldForce = _forcePT;
                                    for (cssp._transform = null,
                                             _forcePT = vars,
                                             pt = firstPT = cssp.parse(t, vars, pt, plugin),
                                             _forcePT = oldForce,
                                         shallow && (cssp._transform = transform,
                                         bpt && (bpt._prev = null,
                                         bpt._prev && (bpt._prev._next = null))); pt && pt !== bpt; ) {
                                        if (pt.type <= 1 && (p = pt.p,
                                                end[p] = pt.s + pt.c,
                                                start[p] = pt.s,
                                            shallow || (mpt = new MiniPropTween(pt,"s",p,mpt,pt.r),
                                                pt.c = 0),
                                            1 === pt.type))
                                            for (i = pt.l; --i > 0; )
                                                xp = "xn" + i,
                                                    p = pt.p + "_" + xp,
                                                    end[p] = pt.data[xp],
                                                    start[p] = pt[xp],
                                                shallow || (mpt = new MiniPropTween(pt,xp,p,mpt,pt.rxp[xp]));
                                        pt = pt._next
                                    }
                                    return {
                                        proxy: start,
                                        end: end,
                                        firstMPT: mpt,
                                        pt: firstPT
                                    }
                                }
                                    ,
                                    _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
                                        this.t = t,
                                            this.p = p,
                                            this.s = s,
                                            this.c = c,
                                            this.n = n || p,
                                        t instanceof CSSPropTween || _overwriteProps.push(this.n),
                                            this.r = r,
                                            this.type = type || 0,
                                        pr && (this.pr = pr,
                                            _hasPriority = !0),
                                            this.b = void 0 === b ? s : b,
                                            this.e = void 0 === e ? s + c : e,
                                        next && (this._next = next,
                                            next._prev = this)
                                    }
                            )
                                , _addNonTweeningNumericPT = function(target, prop, start, end, next, overwriteProp) {
                                var pt = new CSSPropTween(target,prop,start,end - start,next,-1,overwriteProp);
                                return pt.b = start,
                                    pt.e = pt.xs0 = end,
                                    pt
                            }
                                , _parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
                                b = b || dflt || "",
                                "function" == typeof e && (e = e(_index, _target)),
                                    pt = new CSSPropTween(t,p,0,0,pt,setRatio ? 2 : 1,null,!1,pr,b,e),
                                    e += "",
                                clrs && _colorExp.test(e + b) && (e = [b, e],
                                    CSSPlugin.colorStringFilter(e),
                                    b = e[0],
                                    e = e[1]);
                                var i, xi, ni, bv, ev, bnums, enums, bn, hasAlpha, temp, cv, str, useHSL, ba = b.split(", ").join(",").split(" "), ea = e.split(", ").join(",").split(" "), l = ba.length, autoRound = _autoRound !== !1;
                                for (e.indexOf(",") === -1 && b.indexOf(",") === -1 || (ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" "),
                                    ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" "),
                                    l = ba.length),
                                     l !== ea.length && (ba = (dflt || "").split(" "),
                                         l = ba.length),
                                         pt.plugin = plugin,
                                         pt.setRatio = setRatio,
                                         _colorExp.lastIndex = 0,
                                         i = 0; i < l; i++)
                                    if (bv = ba[i],
                                            ev = ea[i],
                                            bn = parseFloat(bv),
                                        bn || 0 === bn)
                                        pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), autoRound && ev.indexOf("px") !== -1, !0);
                                    else if (clrs && _colorExp.test(bv))
                                        str = ev.indexOf(")") + 1,
                                            str = ")" + (str ? ev.substr(str) : ""),
                                            useHSL = ev.indexOf("hsl") !== -1 && _supportsOpacity,
                                            bv = _parseColor(bv, useHSL),
                                            ev = _parseColor(ev, useHSL),
                                            hasAlpha = bv.length + ev.length > 6,
                                            hasAlpha && !_supportsOpacity && 0 === ev[3] ? (pt["xs" + pt.l] += pt.l ? " transparent" : "transparent",
                                                pt.e = pt.e.split(ea[i]).join("transparent")) : (_supportsOpacity || (hasAlpha = !1),
                                                useHSL ? pt.appendXtra(hasAlpha ? "hsla(" : "hsl(", bv[0], _parseChange(ev[0], bv[0]), ",", !1, !0).appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", !1).appendXtra("", bv[2], _parseChange(ev[2], bv[2]), hasAlpha ? "%," : "%" + str, !1) : pt.appendXtra(hasAlpha ? "rgba(" : "rgb(", bv[0], ev[0] - bv[0], ",", !0, !0).appendXtra("", bv[1], ev[1] - bv[1], ",", !0).appendXtra("", bv[2], ev[2] - bv[2], hasAlpha ? "," : str, !0),
                                            hasAlpha && (bv = bv.length < 4 ? 1 : bv[3],
                                                pt.appendXtra("", bv, (ev.length < 4 ? 1 : ev[3]) - bv, str, !1))),
                                            _colorExp.lastIndex = 0;
                                    else if (bnums = bv.match(_numExp)) {
                                        if (enums = ev.match(_relNumExp),
                                            !enums || enums.length !== bnums.length)
                                            return pt;
                                        for (ni = 0,
                                                 xi = 0; xi < bnums.length; xi++)
                                            cv = bnums[xi],
                                                temp = bv.indexOf(cv, ni),
                                                pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", autoRound && "px" === bv.substr(temp + cv.length, 2), 0 === xi),
                                                ni = temp + cv.length;
                                        pt["xs" + pt.l] += bv.substr(ni)
                                    } else
                                        pt["xs" + pt.l] += pt.l || pt["xs" + pt.l] ? " " + ev : ev;
                                if (e.indexOf("=") !== -1 && pt.data) {
                                    for (str = pt.xs0 + pt.data.s,
                                             i = 1; i < pt.l; i++)
                                        str += pt["xs" + i] + pt.data["xn" + i];
                                    pt.e = str + pt["xs" + i]
                                }
                                return pt.l || (pt.type = -1,
                                    pt.xs0 = pt.e),
                                pt.xfirst || pt
                            }
                                , i = 9;
                            for (p = CSSPropTween.prototype,
                                     p.l = p.pr = 0; --i > 0; )
                                p["xn" + i] = 0,
                                    p["xs" + i] = "";
                            p.xs0 = "",
                                p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null,
                                p.appendXtra = function(pfx, s, c, sfx, r, pad) {
                                    var pt = this
                                        , l = pt.l;
                                    return pt["xs" + l] += pad && (l || pt["xs" + l]) ? " " + pfx : pfx || "",
                                        c || 0 === l || pt.plugin ? (pt.l++,
                                            pt.type = pt.setRatio ? 2 : 1,
                                            pt["xs" + pt.l] = sfx || "",
                                            l > 0 ? (pt.data["xn" + l] = s + c,
                                                pt.rxp["xn" + l] = r,
                                                pt["xn" + l] = s,
                                            pt.plugin || (pt.xfirst = new CSSPropTween(pt,"xn" + l,s,c,pt.xfirst || pt,0,pt.n,r,pt.pr),
                                                pt.xfirst.xs0 = 0),
                                                pt) : (pt.data = {
                                                s: s + c
                                            },
                                                pt.rxp = {},
                                                pt.s = s,
                                                pt.c = c,
                                                pt.r = r,
                                                pt)) : (pt["xs" + l] += s + (sfx || ""),
                                            pt)
                                }
                            ;
                            var SpecialProp = function(p, options) {
                                    options = options || {},
                                        this.p = options.prefix ? _checkPropPrefix(p) || p : p,
                                        _specialProps[p] = _specialProps[this.p] = this,
                                        this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi),
                                    options.parser && (this.parse = options.parser),
                                        this.clrs = options.color,
                                        this.multi = options.multi,
                                        this.keyword = options.keyword,
                                        this.dflt = options.defaultValue,
                                        this.pr = options.priority || 0
                                }
                                , _registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
                                    "object" != typeof options && (options = {
                                        parser: defaults
                                    });
                                    var i, temp, a = p.split(","), d = options.defaultValue;
                                    for (defaults = defaults || [d],
                                             i = 0; i < a.length; i++)
                                        options.prefix = 0 === i && options.prefix,
                                            options.defaultValue = defaults[i] || d,
                                            temp = new SpecialProp(a[i],options)
                                }
                                , _registerPluginProp = _internals._registerPluginProp = function(p) {
                                    if (!_specialProps[p]) {
                                        var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
                                        _registerComplexSpecialProp(p, {
                                            parser: function(t, e, p, cssp, pt, plugin, vars) {
                                                var pluginClass = _globals.com.greensock.plugins[pluginName];
                                                return pluginClass ? (pluginClass._cssRegister(),
                                                    _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars)) : (_log("Error: " + pluginName + " js file not loaded."),
                                                    pt)
                                            }
                                        })
                                    }
                                }
                                ;
                            p = SpecialProp.prototype,
                                p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
                                    var i, ba, ea, l, bi, ei, kwd = this.keyword;
                                    if (this.multi && (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b) ? (ba = b.replace(_commasOutsideParenExp, "|").split("|"),
                                            ea = e.replace(_commasOutsideParenExp, "|").split("|")) : kwd && (ba = [b],
                                            ea = [e])),
                                            ea) {
                                        for (l = ea.length > ba.length ? ea.length : ba.length,
                                                 i = 0; i < l; i++)
                                            b = ba[i] = ba[i] || this.dflt,
                                                e = ea[i] = ea[i] || this.dflt,
                                            kwd && (bi = b.indexOf(kwd),
                                                ei = e.indexOf(kwd),
                                            bi !== ei && (ei === -1 ? ba[i] = ba[i].split(kwd).join("") : bi === -1 && (ba[i] += " " + kwd)));
                                        b = ba.join(", "),
                                            e = ea.join(", ")
                                    }
                                    return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio)
                                }
                                ,
                                p.parse = function(t, e, p, cssp, pt, plugin, vars) {
                                    return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, !1, this.dflt)), this.format(e), pt, plugin)
                                }
                                ,
                                CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
                                    _registerComplexSpecialProp(name, {
                                        parser: function(t, e, p, cssp, pt, plugin, vars) {
                                            var rv = new CSSPropTween(t,p,0,0,pt,2,p,!1,priority);
                                            return rv.plugin = plugin,
                                                rv.setRatio = onInitTween(t, e, cssp._tween, p),
                                                rv
                                        },
                                        priority: priority
                                    })
                                }
                                ,
                                CSSPlugin.useSVGTransformAttr = _isSafari || _isFirefox;
                            var _useSVGTransformAttr, _transformProps = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","), _transformProp = _checkPropPrefix("transform"), _transformPropCSS = _prefixCSS + "transform", _transformOriginProp = _checkPropPrefix("transformOrigin"), _supports3D = null !== _checkPropPrefix("perspective"), Transform = _internals.Transform = function() {
                                    this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
                                        this.force3D = !(CSSPlugin.defaultForce3D === !1 || !_supports3D) && (CSSPlugin.defaultForce3D || "auto")
                                }
                                , _SVGElement = window.SVGElement, _createSVG = function(type, container, attributes) {
                                    var p, element = _doc.createElementNS("http://www.w3.org/2000/svg", type), reg = /([a-z])([A-Z])/g;
                                    for (p in attributes)
                                        element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
                                    return container.appendChild(element),
                                        element
                                }, _docElement = _doc.documentElement, _forceSVGTransformAttr = function() {
                                    var svg, rect, width, force = _ieVers || /Android/i.test(_agent) && !window.chrome;
                                    return _doc.createElementNS && !force && (svg = _createSVG("svg", _docElement),
                                        rect = _createSVG("rect", svg, {
                                            width: 100,
                                            height: 50,
                                            x: 100
                                        }),
                                        width = rect.getBoundingClientRect().width,
                                        rect.style[_transformOriginProp] = "50% 50%",
                                        rect.style[_transformProp] = "scaleX(0.5)",
                                        force = width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D),
                                        _docElement.removeChild(svg)),
                                        force
                                }(), _parseSVGOrigin = function(e, local, decoratee, absolute, smoothOrigin, skipRecord) {
                                    var v, x, y, xOrigin, yOrigin, a, b, c, d, tx, ty, determinant, xOriginOld, yOriginOld, tm = e._gsTransform, m = _getMatrix(e, !0);
                                    tm && (xOriginOld = tm.xOrigin,
                                        yOriginOld = tm.yOrigin),
                                    (!absolute || (v = absolute.split(" ")).length < 2) && (b = e.getBBox(),
                                        local = _parsePosition(local).split(" "),
                                        v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x, (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y]),
                                        decoratee.xOrigin = xOrigin = parseFloat(v[0]),
                                        decoratee.yOrigin = yOrigin = parseFloat(v[1]),
                                    absolute && m !== _identity2DMatrix && (a = m[0],
                                        b = m[1],
                                        c = m[2],
                                        d = m[3],
                                        tx = m[4],
                                        ty = m[5],
                                        determinant = a * d - b * c,
                                        x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant,
                                        y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant,
                                        xOrigin = decoratee.xOrigin = v[0] = x,
                                        yOrigin = decoratee.yOrigin = v[1] = y),
                                    tm && (skipRecord && (decoratee.xOffset = tm.xOffset,
                                        decoratee.yOffset = tm.yOffset,
                                        tm = decoratee),
                                        smoothOrigin || smoothOrigin !== !1 && CSSPlugin.defaultSmoothOrigin !== !1 ? (x = xOrigin - xOriginOld,
                                            y = yOrigin - yOriginOld,
                                            tm.xOffset += x * m[0] + y * m[2] - x,
                                            tm.yOffset += x * m[1] + y * m[3] - y) : tm.xOffset = tm.yOffset = 0),
                                    skipRecord || e.setAttribute("data-svg-origin", v.join(" "))
                                }, _canGetBBox = function(e) {
                                    try {
                                        return e.getBBox()
                                    } catch (e) {}
                                }, _isSVG = function(e) {
                                    return !!(_SVGElement && e.getBBox && e.getCTM && _canGetBBox(e) && (!e.parentNode || e.parentNode.getBBox && e.parentNode.getCTM))
                                }, _identity2DMatrix = [1, 0, 0, 1, 0, 0], _getMatrix = function(e, force2D) {
                                    var isDefault, s, m, n, dec, none, tm = e._gsTransform || new Transform, rnd = 1e5, style = e.style;
                                    if (_transformProp ? s = _getStyle(e, _transformPropCSS, null, !0) : e.currentStyle && (s = e.currentStyle.filter.match(_ieGetMatrixExp),
                                            s = s && 4 === s.length ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), tm.x || 0, tm.y || 0].join(",") : ""),
                                            isDefault = !s || "none" === s || "matrix(1, 0, 0, 1, 0, 0)" === s,
                                        isDefault && _transformProp && ((none = "none" === _getComputedStyle(e).display) || !e.parentNode) && (none && (n = style.display,
                                            style.display = "block"),
                                        e.parentNode || (dec = 1,
                                            _docElement.appendChild(e)),
                                            s = _getStyle(e, _transformPropCSS, null, !0),
                                            isDefault = !s || "none" === s || "matrix(1, 0, 0, 1, 0, 0)" === s,
                                            n ? style.display = n : none && _removeProp(style, "display"),
                                        dec && _docElement.removeChild(e)),
                                        (tm.svg || e.getBBox && _isSVG(e)) && (isDefault && (style[_transformProp] + "").indexOf("matrix") !== -1 && (s = style[_transformProp],
                                            isDefault = 0),
                                            m = e.getAttribute("transform"),
                                        isDefault && m && (m.indexOf("matrix") !== -1 ? (s = m,
                                            isDefault = 0) : m.indexOf("translate") !== -1 && (s = "matrix(1,0,0,1," + m.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")",
                                            isDefault = 0))),
                                            isDefault)
                                        return _identity2DMatrix;
                                    for (m = (s || "").match(_numExp) || [],
                                             i = m.length; --i > -1; )
                                        n = Number(m[i]),
                                            m[i] = (dec = n - (n |= 0)) ? (dec * rnd + (dec < 0 ? -.5 : .5) | 0) / rnd + n : n;
                                    return force2D && m.length > 6 ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m
                                }, _getTransform = _internals.getTransform = function(t, cs, rec, parse) {
                                    if (t._gsTransform && rec && !parse)
                                        return t._gsTransform;
                                    var m, i, scaleX, scaleY, rotation, skewX, tm = rec ? t._gsTransform || new Transform : new Transform, invX = tm.scaleX < 0, min = 2e-5, rnd = 1e5, zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, !1, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0, defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
                                    if (tm.svg = !(!t.getBBox || !_isSVG(t)),
                                        tm.svg && (_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, cs, !1, "50% 50%") + "", tm, t.getAttribute("data-svg-origin")),
                                            _useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr),
                                            m = _getMatrix(t),
                                        m !== _identity2DMatrix) {
                                        if (16 === m.length) {
                                            var t1, t2, t3, cos, sin, a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3], a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7], a13 = m[8], a23 = m[9], a33 = m[10], a14 = m[12], a24 = m[13], a34 = m[14], a43 = m[11], angle = Math.atan2(a32, a33);
                                            tm.zOrigin && (a34 = -tm.zOrigin,
                                                a14 = a13 * a34 - m[12],
                                                a24 = a23 * a34 - m[13],
                                                a34 = a33 * a34 + tm.zOrigin - m[14]),
                                                tm.rotationX = angle * _RAD2DEG,
                                            angle && (cos = Math.cos(-angle),
                                                sin = Math.sin(-angle),
                                                t1 = a12 * cos + a13 * sin,
                                                t2 = a22 * cos + a23 * sin,
                                                t3 = a32 * cos + a33 * sin,
                                                a13 = a12 * -sin + a13 * cos,
                                                a23 = a22 * -sin + a23 * cos,
                                                a33 = a32 * -sin + a33 * cos,
                                                a43 = a42 * -sin + a43 * cos,
                                                a12 = t1,
                                                a22 = t2,
                                                a32 = t3),
                                                angle = Math.atan2(-a31, a33),
                                                tm.rotationY = angle * _RAD2DEG,
                                            angle && (cos = Math.cos(-angle),
                                                sin = Math.sin(-angle),
                                                t1 = a11 * cos - a13 * sin,
                                                t2 = a21 * cos - a23 * sin,
                                                t3 = a31 * cos - a33 * sin,
                                                a23 = a21 * sin + a23 * cos,
                                                a33 = a31 * sin + a33 * cos,
                                                a43 = a41 * sin + a43 * cos,
                                                a11 = t1,
                                                a21 = t2,
                                                a31 = t3),
                                                angle = Math.atan2(a21, a11),
                                                tm.rotation = angle * _RAD2DEG,
                                            angle && (cos = Math.cos(-angle),
                                                sin = Math.sin(-angle),
                                                a11 = a11 * cos + a12 * sin,
                                                t2 = a21 * cos + a22 * sin,
                                                a22 = a21 * -sin + a22 * cos,
                                                a32 = a31 * -sin + a32 * cos,
                                                a21 = t2),
                                            tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9 && (tm.rotationX = tm.rotation = 0,
                                                tm.rotationY = 180 - tm.rotationY),
                                                tm.scaleX = (Math.sqrt(a11 * a11 + a21 * a21) * rnd + .5 | 0) / rnd,
                                                tm.scaleY = (Math.sqrt(a22 * a22 + a23 * a23) * rnd + .5 | 0) / rnd,
                                                tm.scaleZ = (Math.sqrt(a32 * a32 + a33 * a33) * rnd + .5 | 0) / rnd,
                                                tm.rotationX || tm.rotationY ? tm.skewX = 0 : (tm.skewX = a12 || a22 ? Math.atan2(a12, a22) * _RAD2DEG + tm.rotation : tm.skewX || 0,
                                                Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270 && (invX ? (tm.scaleX *= -1,
                                                    tm.skewX += tm.rotation <= 0 ? 180 : -180,
                                                    tm.rotation += tm.rotation <= 0 ? 180 : -180) : (tm.scaleY *= -1,
                                                    tm.skewX += tm.skewX <= 0 ? 180 : -180))),
                                                tm.perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0,
                                                tm.x = a14,
                                                tm.y = a24,
                                                tm.z = a34,
                                            tm.svg && (tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12),
                                                tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22))
                                        } else if (!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || !tm.rotationX && !tm.rotationY) {
                                            var k = m.length >= 6
                                                , a = k ? m[0] : 1
                                                , b = m[1] || 0
                                                , c = m[2] || 0
                                                , d = k ? m[3] : 1;
                                            tm.x = m[4] || 0,
                                                tm.y = m[5] || 0,
                                                scaleX = Math.sqrt(a * a + b * b),
                                                scaleY = Math.sqrt(d * d + c * c),
                                                rotation = a || b ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0,
                                                skewX = c || d ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0,
                                            Math.abs(skewX) > 90 && Math.abs(skewX) < 270 && (invX ? (scaleX *= -1,
                                                skewX += rotation <= 0 ? 180 : -180,
                                                rotation += rotation <= 0 ? 180 : -180) : (scaleY *= -1,
                                                skewX += skewX <= 0 ? 180 : -180)),
                                                tm.scaleX = scaleX,
                                                tm.scaleY = scaleY,
                                                tm.rotation = rotation,
                                                tm.skewX = skewX,
                                            _supports3D && (tm.rotationX = tm.rotationY = tm.z = 0,
                                                tm.perspective = defaultTransformPerspective,
                                                tm.scaleZ = 1),
                                            tm.svg && (tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c),
                                                tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d))
                                        }
                                        tm.zOrigin = zOrigin;
                                        for (i in tm)
                                            tm[i] < min && tm[i] > -min && (tm[i] = 0)
                                    }
                                    return rec && (t._gsTransform = tm,
                                    tm.svg && (_useSVGTransformAttr && t.style[_transformProp] ? TweenLite.delayedCall(.001, function() {
                                        _removeProp(t.style, _transformProp)
                                    }) : !_useSVGTransformAttr && t.getAttribute("transform") && TweenLite.delayedCall(.001, function() {
                                        t.removeAttribute("transform")
                                    }))),
                                        tm
                                }
                                , _setIETransformRatio = function(v) {
                                    var filters, val, t = this.data, ang = -t.rotation * _DEG2RAD, skew = ang + t.skewX * _DEG2RAD, rnd = 1e5, a = (Math.cos(ang) * t.scaleX * rnd | 0) / rnd, b = (Math.sin(ang) * t.scaleX * rnd | 0) / rnd, c = (Math.sin(skew) * -t.scaleY * rnd | 0) / rnd, d = (Math.cos(skew) * t.scaleY * rnd | 0) / rnd, style = this.t.style, cs = this.t.currentStyle;
                                    if (cs) {
                                        val = b,
                                            b = -c,
                                            c = -val,
                                            filters = cs.filter,
                                            style.filter = "";
                                        var dx, dy, w = this.t.offsetWidth, h = this.t.offsetHeight, clip = "absolute" !== cs.position, m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d, ox = t.x + w * t.xPercent / 100, oy = t.y + h * t.yPercent / 100;
                                        if (null != t.ox && (dx = (t.oxp ? w * t.ox * .01 : t.ox) - w / 2,
                                                dy = (t.oyp ? h * t.oy * .01 : t.oy) - h / 2,
                                                ox += dx - (dx * a + dy * b),
                                                oy += dy - (dx * c + dy * d)),
                                                clip ? (dx = w / 2,
                                                    dy = h / 2,
                                                    m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")") : m += ", sizingMethod='auto expand')",
                                                filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1 ? style.filter = filters.replace(_ieSetMatrixExp, m) : style.filter = m + " " + filters,
                                            0 !== v && 1 !== v || 1 === a && 0 === b && 0 === c && 1 === d && (clip && m.indexOf("Dx=0, Dy=0") === -1 || _opacityExp.test(filters) && 100 !== parseFloat(RegExp.$1) || filters.indexOf(filters.indexOf("Alpha")) === -1 && style.removeAttribute("filter")),
                                                !clip) {
                                            var marg, prop, dif, mult = _ieVers < 8 ? 1 : -1;
                                            for (dx = t.ieOffsetX || 0,
                                                     dy = t.ieOffsetY || 0,
                                                     t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox),
                                                     t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy),
                                                     i = 0; i < 4; i++)
                                                prop = _margins[i],
                                                    marg = cs[prop],
                                                    val = marg.indexOf("px") !== -1 ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0,
                                                    dif = val !== t[prop] ? i < 2 ? -t.ieOffsetX : -t.ieOffsetY : i < 2 ? dx - t.ieOffsetX : dy - t.ieOffsetY,
                                                    style[prop] = (t[prop] = Math.round(val - dif * (0 === i || 2 === i ? 1 : mult))) + "px"
                                        }
                                    }
                                }, _setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function(v) {
                                    var a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43, zOrigin, min, cos, sin, t1, t2, transform, comma, zero, skew, rnd, t = this.data, style = this.t.style, angle = t.rotation, rotationX = t.rotationX, rotationY = t.rotationY, sx = t.scaleX, sy = t.scaleY, sz = t.scaleZ, x = t.x, y = t.y, z = t.z, isSVG = t.svg, perspective = t.perspective, force3D = t.force3D;
                                    if (((1 === v || 0 === v) && "auto" === force3D && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !force3D) && !z && !perspective && !rotationY && !rotationX && 1 === sz || _useSVGTransformAttr && isSVG || !_supports3D)
                                        return void (angle || t.skewX || isSVG ? (angle *= _DEG2RAD,
                                            skew = t.skewX * _DEG2RAD,
                                            rnd = 1e5,
                                            a11 = Math.cos(angle) * sx,
                                            a21 = Math.sin(angle) * sx,
                                            a12 = Math.sin(angle - skew) * -sy,
                                            a22 = Math.cos(angle - skew) * sy,
                                        skew && "simple" === t.skewType && (t1 = Math.tan(skew - t.skewY * _DEG2RAD),
                                            t1 = Math.sqrt(1 + t1 * t1),
                                            a12 *= t1,
                                            a22 *= t1,
                                        t.skewY && (t1 = Math.tan(t.skewY * _DEG2RAD),
                                            t1 = Math.sqrt(1 + t1 * t1),
                                            a11 *= t1,
                                            a21 *= t1)),
                                        isSVG && (x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset,
                                            y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset,
                                        _useSVGTransformAttr && (t.xPercent || t.yPercent) && (min = this.t.getBBox(),
                                            x += .01 * t.xPercent * min.width,
                                            y += .01 * t.yPercent * min.height),
                                            min = 1e-6,
                                        x < min && x > -min && (x = 0),
                                        y < min && y > -min && (y = 0)),
                                            transform = (a11 * rnd | 0) / rnd + "," + (a21 * rnd | 0) / rnd + "," + (a12 * rnd | 0) / rnd + "," + (a22 * rnd | 0) / rnd + "," + x + "," + y + ")",
                                            isSVG && _useSVGTransformAttr ? this.t.setAttribute("transform", "matrix(" + transform) : style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform) : style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")");
                                    if (_isFirefox && (min = 1e-4,
                                        sx < min && sx > -min && (sx = sz = 2e-5),
                                        sy < min && sy > -min && (sy = sz = 2e-5),
                                        !perspective || t.z || t.rotationX || t.rotationY || (perspective = 0)),
                                        angle || t.skewX)
                                        angle *= _DEG2RAD,
                                            cos = a11 = Math.cos(angle),
                                            sin = a21 = Math.sin(angle),
                                        t.skewX && (angle -= t.skewX * _DEG2RAD,
                                            cos = Math.cos(angle),
                                            sin = Math.sin(angle),
                                        "simple" === t.skewType && (t1 = Math.tan((t.skewX - t.skewY) * _DEG2RAD),
                                            t1 = Math.sqrt(1 + t1 * t1),
                                            cos *= t1,
                                            sin *= t1,
                                        t.skewY && (t1 = Math.tan(t.skewY * _DEG2RAD),
                                            t1 = Math.sqrt(1 + t1 * t1),
                                            a11 *= t1,
                                            a21 *= t1))),
                                            a12 = -sin,
                                            a22 = cos;
                                    else {
                                        if (!(rotationY || rotationX || 1 !== sz || perspective || isSVG))
                                            return void (style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + (1 !== sx || 1 !== sy ? " scale(" + sx + "," + sy + ")" : ""));
                                        a11 = a22 = 1,
                                            a12 = a21 = 0
                                    }
                                    a33 = 1,
                                        a13 = a23 = a31 = a32 = a41 = a42 = 0,
                                        a43 = perspective ? -1 / perspective : 0,
                                        zOrigin = t.zOrigin,
                                        min = 1e-6,
                                        comma = ",",
                                        zero = "0",
                                        angle = rotationY * _DEG2RAD,
                                    angle && (cos = Math.cos(angle),
                                        sin = Math.sin(angle),
                                        a31 = -sin,
                                        a41 = a43 * -sin,
                                        a13 = a11 * sin,
                                        a23 = a21 * sin,
                                        a33 = cos,
                                        a43 *= cos,
                                        a11 *= cos,
                                        a21 *= cos),
                                        angle = rotationX * _DEG2RAD,
                                    angle && (cos = Math.cos(angle),
                                        sin = Math.sin(angle),
                                        t1 = a12 * cos + a13 * sin,
                                        t2 = a22 * cos + a23 * sin,
                                        a32 = a33 * sin,
                                        a42 = a43 * sin,
                                        a13 = a12 * -sin + a13 * cos,
                                        a23 = a22 * -sin + a23 * cos,
                                        a33 *= cos,
                                        a43 *= cos,
                                        a12 = t1,
                                        a22 = t2),
                                    1 !== sz && (a13 *= sz,
                                        a23 *= sz,
                                        a33 *= sz,
                                        a43 *= sz),
                                    1 !== sy && (a12 *= sy,
                                        a22 *= sy,
                                        a32 *= sy,
                                        a42 *= sy),
                                    1 !== sx && (a11 *= sx,
                                        a21 *= sx,
                                        a31 *= sx,
                                        a41 *= sx),
                                    (zOrigin || isSVG) && (zOrigin && (x += a13 * -zOrigin,
                                        y += a23 * -zOrigin,
                                        z += a33 * -zOrigin + zOrigin),
                                    isSVG && (x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset,
                                        y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset),
                                    x < min && x > -min && (x = zero),
                                    y < min && y > -min && (y = zero),
                                    z < min && z > -min && (z = 0)),
                                        transform = t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(",
                                        transform += (a11 < min && a11 > -min ? zero : a11) + comma + (a21 < min && a21 > -min ? zero : a21) + comma + (a31 < min && a31 > -min ? zero : a31),
                                        transform += comma + (a41 < min && a41 > -min ? zero : a41) + comma + (a12 < min && a12 > -min ? zero : a12) + comma + (a22 < min && a22 > -min ? zero : a22),
                                        rotationX || rotationY || 1 !== sz ? (transform += comma + (a32 < min && a32 > -min ? zero : a32) + comma + (a42 < min && a42 > -min ? zero : a42) + comma + (a13 < min && a13 > -min ? zero : a13),
                                            transform += comma + (a23 < min && a23 > -min ? zero : a23) + comma + (a33 < min && a33 > -min ? zero : a33) + comma + (a43 < min && a43 > -min ? zero : a43) + comma) : transform += ",0,0,0,0,1,0,",
                                        transform += x + comma + y + comma + z + comma + (perspective ? 1 + -z / perspective : 1) + ")",
                                        style[_transformProp] = transform
                                }
                                ;
                            p = Transform.prototype,
                                p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0,
                                p.scaleX = p.scaleY = p.scaleZ = 1,
                                _registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                                    parser: function(t, e, parsingProp, cssp, pt, plugin, vars) {
                                        if (cssp._lastParsedTransform === vars)
                                            return pt;
                                        cssp._lastParsedTransform = vars;
                                        var swapFunc;
                                        "function" == typeof vars[parsingProp] && (swapFunc = vars[parsingProp],
                                            vars[parsingProp] = e);
                                        var m2, copy, has3D, hasChange, dr, x, y, matrix, p, originalGSTransform = t._gsTransform, style = t.style, min = 1e-6, i = _transformProps.length, v = vars, endRotations = {}, transformOriginString = "transformOrigin", m1 = _getTransform(t, _cs, !0, v.parseTransform), orig = v.transform && ("function" == typeof v.transform ? v.transform(_index, _target) : v.transform);
                                        if (cssp._transform = m1,
                                            orig && "string" == typeof orig && _transformProp)
                                            copy = _tempDiv.style,
                                                copy[_transformProp] = orig,
                                                copy.display = "block",
                                                copy.position = "absolute",
                                                _doc.body.appendChild(_tempDiv),
                                                m2 = _getTransform(_tempDiv, null, !1),
                                            m1.svg && (x = m1.xOrigin,
                                                y = m1.yOrigin,
                                                m2.x -= m1.xOffset,
                                                m2.y -= m1.yOffset,
                                            (v.transformOrigin || v.svgOrigin) && (orig = {},
                                                _parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, !0),
                                                x = orig.xOrigin,
                                                y = orig.yOrigin,
                                                m2.x -= orig.xOffset - m1.xOffset,
                                                m2.y -= orig.yOffset - m1.yOffset),
                                            (x || y) && (matrix = _getMatrix(_tempDiv, !0),
                                                m2.x -= x - (x * matrix[0] + y * matrix[2]),
                                                m2.y -= y - (x * matrix[1] + y * matrix[3]))),
                                                _doc.body.removeChild(_tempDiv),
                                            m2.perspective || (m2.perspective = m1.perspective),
                                            null != v.xPercent && (m2.xPercent = _parseVal(v.xPercent, m1.xPercent)),
                                            null != v.yPercent && (m2.yPercent = _parseVal(v.yPercent, m1.yPercent));
                                        else if ("object" == typeof v) {
                                            if (m2 = {
                                                    scaleX: _parseVal(null != v.scaleX ? v.scaleX : v.scale, m1.scaleX),
                                                    scaleY: _parseVal(null != v.scaleY ? v.scaleY : v.scale, m1.scaleY),
                                                    scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
                                                    x: _parseVal(v.x, m1.x),
                                                    y: _parseVal(v.y, m1.y),
                                                    z: _parseVal(v.z, m1.z),
                                                    xPercent: _parseVal(v.xPercent, m1.xPercent),
                                                    yPercent: _parseVal(v.yPercent, m1.yPercent),
                                                    perspective: _parseVal(v.transformPerspective, m1.perspective)
                                                },
                                                    dr = v.directionalRotation,
                                                null != dr)
                                                if ("object" == typeof dr)
                                                    for (copy in dr)
                                                        v[copy] = dr[copy];
                                                else
                                                    v.rotation = dr;
                                            "string" == typeof v.x && v.x.indexOf("%") !== -1 && (m2.x = 0,
                                                m2.xPercent = _parseVal(v.x, m1.xPercent)),
                                            "string" == typeof v.y && v.y.indexOf("%") !== -1 && (m2.y = 0,
                                                m2.yPercent = _parseVal(v.y, m1.yPercent)),
                                                m2.rotation = _parseAngle("rotation"in v ? v.rotation : "shortRotation"in v ? v.shortRotation + "_short" : "rotationZ"in v ? v.rotationZ : m1.rotation - m1.skewY, m1.rotation - m1.skewY, "rotation", endRotations),
                                            _supports3D && (m2.rotationX = _parseAngle("rotationX"in v ? v.rotationX : "shortRotationX"in v ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations),
                                                m2.rotationY = _parseAngle("rotationY"in v ? v.rotationY : "shortRotationY"in v ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations)),
                                                m2.skewX = _parseAngle(v.skewX, m1.skewX - m1.skewY),
                                            (m2.skewY = _parseAngle(v.skewY, m1.skewY)) && (m2.skewX += m2.skewY,
                                                m2.rotation += m2.skewY)
                                        }
                                        for (_supports3D && null != v.force3D && (m1.force3D = v.force3D,
                                            hasChange = !0),
                                                 m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType,
                                                 has3D = m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective,
                                             has3D || null == v.scale || (m2.scaleZ = 1); --i > -1; )
                                            p = _transformProps[i],
                                                orig = m2[p] - m1[p],
                                            (orig > min || orig < -min || null != v[p] || null != _forcePT[p]) && (hasChange = !0,
                                                pt = new CSSPropTween(m1,p,m1[p],orig,pt),
                                            p in endRotations && (pt.e = endRotations[p]),
                                                pt.xs0 = 0,
                                                pt.plugin = plugin,
                                                cssp._overwriteProps.push(pt.n));
                                        return orig = v.transformOrigin,
                                        m1.svg && (orig || v.svgOrigin) && (x = m1.xOffset,
                                            y = m1.yOffset,
                                            _parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin),
                                            pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString),
                                            pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString),
                                        x === m1.xOffset && y === m1.yOffset || (pt = _addNonTweeningNumericPT(m1, "xOffset", originalGSTransform ? x : m1.xOffset, m1.xOffset, pt, transformOriginString),
                                            pt = _addNonTweeningNumericPT(m1, "yOffset", originalGSTransform ? y : m1.yOffset, m1.yOffset, pt, transformOriginString)),
                                            orig = _useSVGTransformAttr ? null : "0px 0px"),
                                        (orig || _supports3D && has3D && m1.zOrigin) && (_transformProp ? (hasChange = !0,
                                            p = _transformOriginProp,
                                            orig = (orig || _getStyle(t, p, _cs, !1, "50% 50%")) + "",
                                            pt = new CSSPropTween(style,p,0,0,pt,-1,transformOriginString),
                                            pt.b = style[p],
                                            pt.plugin = plugin,
                                            _supports3D ? (copy = m1.zOrigin,
                                                orig = orig.split(" "),
                                                m1.zOrigin = (orig.length > 2 && (0 === copy || "0px" !== orig[2]) ? parseFloat(orig[2]) : copy) || 0,
                                                pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px",
                                                pt = new CSSPropTween(m1,"zOrigin",0,0,pt,-1,pt.n),
                                                pt.b = copy,
                                                pt.xs0 = pt.e = m1.zOrigin) : pt.xs0 = pt.e = orig) : _parsePosition(orig + "", m1)),
                                        hasChange && (cssp._transformType = m1.svg && _useSVGTransformAttr || !has3D && 3 !== this._transformType ? 2 : 3),
                                        swapFunc && (vars[parsingProp] = swapFunc),
                                            pt
                                    },
                                    prefix: !0
                                }),
                                _registerComplexSpecialProp("boxShadow", {
                                    defaultValue: "0px 0px 0px 0px #999",
                                    prefix: !0,
                                    color: !0,
                                    multi: !0,
                                    keyword: "inset"
                                }),
                                _registerComplexSpecialProp("borderRadius", {
                                    defaultValue: "0px",
                                    parser: function(t, e, p, cssp, pt, plugin) {
                                        e = this.format(e);
                                        var ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em, props = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"], style = t.style;
                                        for (w = parseFloat(t.offsetWidth),
                                                 h = parseFloat(t.offsetHeight),
                                                 ea1 = e.split(" "),
                                                 i = 0; i < props.length; i++)
                                            this.p.indexOf("border") && (props[i] = _checkPropPrefix(props[i])),
                                                bs = bs2 = _getStyle(t, props[i], _cs, !1, "0px"),
                                            bs.indexOf(" ") !== -1 && (bs2 = bs.split(" "),
                                                bs = bs2[0],
                                                bs2 = bs2[1]),
                                                es = es2 = ea1[i],
                                                bn = parseFloat(bs),
                                                bsfx = bs.substr((bn + "").length),
                                                rel = "=" === es.charAt(1),
                                                rel ? (en = parseInt(es.charAt(0) + "1", 10),
                                                    es = es.substr(2),
                                                    en *= parseFloat(es),
                                                    esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "") : (en = parseFloat(es),
                                                    esfx = es.substr((en + "").length)),
                                            "" === esfx && (esfx = _suffixMap[p] || bsfx),
                                            esfx !== bsfx && (hn = _convertToPixels(t, "borderLeft", bn, bsfx),
                                                vn = _convertToPixels(t, "borderTop", bn, bsfx),
                                                "%" === esfx ? (bs = hn / w * 100 + "%",
                                                    bs2 = vn / h * 100 + "%") : "em" === esfx ? (em = _convertToPixels(t, "borderLeft", 1, "em"),
                                                    bs = hn / em + "em",
                                                    bs2 = vn / em + "em") : (bs = hn + "px",
                                                    bs2 = vn + "px"),
                                            rel && (es = parseFloat(bs) + en + esfx,
                                                es2 = parseFloat(bs2) + en + esfx)),
                                                pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, !1, "0px", pt);
                                        return pt
                                    },
                                    prefix: !0,
                                    formatter: _getFormatter("0px 0px 0px 0px", !1, !0)
                                }),
                                _registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                                    defaultValue: "0px",
                                    parser: function(t, e, p, cssp, pt, plugin) {
                                        return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, !1, "0px 0px")), this.format(e), !1, "0px", pt)
                                    },
                                    prefix: !0,
                                    formatter: _getFormatter("0px 0px", !1, !0)
                                }),
                                _registerComplexSpecialProp("backgroundPosition", {
                                    defaultValue: "0 0",
                                    parser: function(t, e, p, cssp, pt, plugin) {
                                        var ba, ea, i, pct, overlap, src, bp = "background-position", cs = _cs || _getComputedStyle(t, null), bs = this.format((cs ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), es = this.format(e);
                                        if (bs.indexOf("%") !== -1 != (es.indexOf("%") !== -1) && es.split(",").length < 2 && (src = _getStyle(t, "backgroundImage").replace(_urlExp, ""),
                                            src && "none" !== src)) {
                                            for (ba = bs.split(" "),
                                                     ea = es.split(" "),
                                                     _tempImg.setAttribute("src", src),
                                                     i = 2; --i > -1; )
                                                bs = ba[i],
                                                    pct = bs.indexOf("%") !== -1,
                                                pct !== (ea[i].indexOf("%") !== -1) && (overlap = 0 === i ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height,
                                                    ba[i] = pct ? parseFloat(bs) / 100 * overlap + "px" : parseFloat(bs) / overlap * 100 + "%");
                                            bs = ba.join(" ")
                                        }
                                        return this.parseComplex(t.style, bs, es, pt, plugin)
                                    },
                                    formatter: _parsePosition
                                }),
                                _registerComplexSpecialProp("backgroundSize", {
                                    defaultValue: "0 0",
                                    formatter: function(v) {
                                        return v += "",
                                            _parsePosition(v.indexOf(" ") === -1 ? v + " " + v : v)
                                    }
                                }),
                                _registerComplexSpecialProp("perspective", {
                                    defaultValue: "0px",
                                    prefix: !0
                                }),
                                _registerComplexSpecialProp("perspectiveOrigin", {
                                    defaultValue: "50% 50%",
                                    prefix: !0
                                }),
                                _registerComplexSpecialProp("transformStyle", {
                                    prefix: !0
                                }),
                                _registerComplexSpecialProp("backfaceVisibility", {
                                    prefix: !0
                                }),
                                _registerComplexSpecialProp("userSelect", {
                                    prefix: !0
                                }),
                                _registerComplexSpecialProp("margin", {
                                    parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")
                                }),
                                _registerComplexSpecialProp("padding", {
                                    parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")
                                }),
                                _registerComplexSpecialProp("clip", {
                                    defaultValue: "rect(0px,0px,0px,0px)",
                                    parser: function(t, e, p, cssp, pt, plugin) {
                                        var b, cs, delim;
                                        return _ieVers < 9 ? (cs = t.currentStyle,
                                            delim = _ieVers < 8 ? " " : ",",
                                            b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")",
                                            e = this.format(e).split(",").join(delim)) : (b = this.format(_getStyle(t, this.p, _cs, !1, this.dflt)),
                                            e = this.format(e)),
                                            this.parseComplex(t.style, b, e, pt, plugin)
                                    }
                                }),
                                _registerComplexSpecialProp("textShadow", {
                                    defaultValue: "0px 0px 0px #999",
                                    color: !0,
                                    multi: !0
                                }),
                                _registerComplexSpecialProp("autoRound,strictUnits", {
                                    parser: function(t, e, p, cssp, pt) {
                                        return pt
                                    }
                                }),
                                _registerComplexSpecialProp("border", {
                                    defaultValue: "0px solid #000",
                                    parser: function(t, e, p, cssp, pt, plugin) {
                                        var bw = _getStyle(t, "borderTopWidth", _cs, !1, "0px")
                                            , end = this.format(e).split(" ")
                                            , esfx = end[0].replace(_suffixExp, "");
                                        return "px" !== esfx && (bw = parseFloat(bw) / _convertToPixels(t, "borderTopWidth", 1, esfx) + esfx),
                                            this.parseComplex(t.style, this.format(bw + " " + _getStyle(t, "borderTopStyle", _cs, !1, "solid") + " " + _getStyle(t, "borderTopColor", _cs, !1, "#000")), end.join(" "), pt, plugin)
                                    },
                                    color: !0,
                                    formatter: function(v) {
                                        var a = v.split(" ");
                                        return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0]
                                    }
                                }),
                                _registerComplexSpecialProp("borderWidth", {
                                    parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                                }),
                                _registerComplexSpecialProp("float,cssFloat,styleFloat", {
                                    parser: function(t, e, p, cssp, pt, plugin) {
                                        var s = t.style
                                            , prop = "cssFloat"in s ? "cssFloat" : "styleFloat";
                                        return new CSSPropTween(s,prop,0,0,pt,-1,p,!1,0,s[prop],e)
                                    }
                                });
                            var _setIEOpacityRatio = function(v) {
                                var skip, t = this.t, filters = t.filter || _getStyle(this.data, "filter") || "", val = this.s + this.c * v | 0;
                                100 === val && (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1 ? (t.removeAttribute("filter"),
                                    skip = !_getStyle(this.data, "filter")) : (t.filter = filters.replace(_alphaFilterExp, ""),
                                    skip = !0)),
                                skip || (this.xn1 && (t.filter = filters = filters || "alpha(opacity=" + val + ")"),
                                    filters.indexOf("pacity") === -1 ? 0 === val && this.xn1 || (t.filter = filters + " alpha(opacity=" + val + ")") : t.filter = filters.replace(_opacityExp, "opacity=" + val))
                            };
                            _registerComplexSpecialProp("opacity,alpha,autoAlpha", {
                                defaultValue: "1",
                                parser: function(t, e, p, cssp, pt, plugin) {
                                    var b = parseFloat(_getStyle(t, "opacity", _cs, !1, "1"))
                                        , style = t.style
                                        , isAutoAlpha = "autoAlpha" === p;
                                    return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + b),
                                    isAutoAlpha && 1 === b && "hidden" === _getStyle(t, "visibility", _cs) && 0 !== e && (b = 0),
                                        _supportsOpacity ? pt = new CSSPropTween(style,"opacity",b,e - b,pt) : (pt = new CSSPropTween(style,"opacity",100 * b,100 * (e - b),pt),
                                            pt.xn1 = isAutoAlpha ? 1 : 0,
                                            style.zoom = 1,
                                            pt.type = 2,
                                            pt.b = "alpha(opacity=" + pt.s + ")",
                                            pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")",
                                            pt.data = t,
                                            pt.plugin = plugin,
                                            pt.setRatio = _setIEOpacityRatio),
                                    isAutoAlpha && (pt = new CSSPropTween(style,"visibility",0,0,pt,-1,null,!1,0,0 !== b ? "inherit" : "hidden",0 === e ? "hidden" : "inherit"),
                                        pt.xs0 = "inherit",
                                        cssp._overwriteProps.push(pt.n),
                                        cssp._overwriteProps.push(p)),
                                        pt
                                }
                            });
                            var _removeProp = function(s, p) {
                                p && (s.removeProperty ? ("ms" !== p.substr(0, 2) && "webkit" !== p.substr(0, 6) || (p = "-" + p),
                                    s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase())) : s.removeAttribute(p))
                            }
                                , _setClassNameRatio = function(v) {
                                if (this.t._gsClassPT = this,
                                    1 === v || 0 === v) {
                                    this.t.setAttribute("class", 0 === v ? this.b : this.e);
                                    for (var mpt = this.data, s = this.t.style; mpt; )
                                        mpt.v ? s[mpt.p] = mpt.v : _removeProp(s, mpt.p),
                                            mpt = mpt._next;
                                    1 === v && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                                } else
                                    this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                            };
                            _registerComplexSpecialProp("className", {
                                parser: function(t, e, p, cssp, pt, plugin, vars) {
                                    var difData, bs, cnpt, cnptLookup, mpt, b = t.getAttribute("class") || "", cssText = t.style.cssText;
                                    if (pt = cssp._classNamePT = new CSSPropTween(t,p,0,0,pt,2),
                                            pt.setRatio = _setClassNameRatio,
                                            pt.pr = -11,
                                            _hasPriority = !0,
                                            pt.b = b,
                                            bs = _getAllStyles(t, _cs),
                                            cnpt = t._gsClassPT) {
                                        for (cnptLookup = {},
                                                 mpt = cnpt.data; mpt; )
                                            cnptLookup[mpt.p] = 1,
                                                mpt = mpt._next;
                                        cnpt.setRatio(1)
                                    }
                                    return t._gsClassPT = pt,
                                        pt.e = "=" !== e.charAt(1) ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""),
                                        t.setAttribute("class", pt.e),
                                        difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup),
                                        t.setAttribute("class", b),
                                        pt.data = difData.firstMPT,
                                        t.style.cssText = cssText,
                                        pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin)
                                }
                            });
                            var _setClearPropsRatio = function(v) {
                                if ((1 === v || 0 === v) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                                    var a, p, i, clearTransform, transform, s = this.t.style, transformParse = _specialProps.transform.parse;
                                    if ("all" === this.e)
                                        s.cssText = "",
                                            clearTransform = !0;
                                    else
                                        for (a = this.e.split(" ").join("").split(","),
                                                 i = a.length; --i > -1; )
                                            p = a[i],
                                            _specialProps[p] && (_specialProps[p].parse === transformParse ? clearTransform = !0 : p = "transformOrigin" === p ? _transformOriginProp : _specialProps[p].p),
                                                _removeProp(s, p);
                                    clearTransform && (_removeProp(s, _transformProp),
                                        transform = this.t._gsTransform,
                                    transform && (transform.svg && (this.t.removeAttribute("data-svg-origin"),
                                        this.t.removeAttribute("transform")),
                                        delete this.t._gsTransform));
                                }
                            };
                            for (_registerComplexSpecialProp("clearProps", {
                                parser: function(t, e, p, cssp, pt) {
                                    return pt = new CSSPropTween(t,p,0,0,pt,2),
                                        pt.setRatio = _setClearPropsRatio,
                                        pt.e = e,
                                        pt.pr = -10,
                                        pt.data = cssp._tween,
                                        _hasPriority = !0,
                                        pt
                                }
                            }),
                                     p = "bezier,throwProps,physicsProps,physics2D".split(","),
                                     i = p.length; i--; )
                                _registerPluginProp(p[i]);
                            p = CSSPlugin.prototype,
                                p._firstPT = p._lastParsedTransform = p._transform = null,
                                p._onInitTween = function(target, vars, tween, index) {
                                    if (!target.nodeType)
                                        return !1;
                                    this._target = _target = target,
                                        this._tween = tween,
                                        this._vars = vars,
                                        _index = index,
                                        _autoRound = vars.autoRound,
                                        _hasPriority = !1,
                                        _suffixMap = vars.suffixMap || CSSPlugin.suffixMap,
                                        _cs = _getComputedStyle(target, ""),
                                        _overwriteProps = this._overwriteProps;
                                    var v, pt, pt2, first, last, next, zIndex, tpt, threeD, style = target.style;
                                    if (_reqSafariFix && "" === style.zIndex && (v = _getStyle(target, "zIndex", _cs),
                                        "auto" !== v && "" !== v || this._addLazySet(style, "zIndex", 0)),
                                        "string" == typeof vars && (first = style.cssText,
                                            v = _getAllStyles(target, _cs),
                                            style.cssText = first + ";" + vars,
                                            v = _cssDif(target, v, _getAllStyles(target)).difs,
                                        !_supportsOpacity && _opacityValExp.test(vars) && (v.opacity = parseFloat(RegExp.$1)),
                                            vars = v,
                                            style.cssText = first),
                                            vars.className ? this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars) : this._firstPT = pt = this.parse(target, vars, null),
                                            this._transformType) {
                                        for (threeD = 3 === this._transformType,
                                                 _transformProp ? _isSafari && (_reqSafariFix = !0,
                                                 "" === style.zIndex && (zIndex = _getStyle(target, "zIndex", _cs),
                                                 "auto" !== zIndex && "" !== zIndex || this._addLazySet(style, "zIndex", 0)),
                                                 _isSafariLT6 && this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"))) : style.zoom = 1,
                                                 pt2 = pt; pt2 && pt2._next; )
                                            pt2 = pt2._next;
                                        tpt = new CSSPropTween(target,"transform",0,0,null,2),
                                            this._linkCSSP(tpt, null, pt2),
                                            tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio,
                                            tpt.data = this._transform || _getTransform(target, _cs, !0),
                                            tpt.tween = tween,
                                            tpt.pr = -1,
                                            _overwriteProps.pop()
                                    }
                                    if (_hasPriority) {
                                        for (; pt; ) {
                                            for (next = pt._next,
                                                     pt2 = first; pt2 && pt2.pr > pt.pr; )
                                                pt2 = pt2._next;
                                            (pt._prev = pt2 ? pt2._prev : last) ? pt._prev._next = pt : first = pt,
                                                (pt._next = pt2) ? pt2._prev = pt : last = pt,
                                                pt = next
                                        }
                                        this._firstPT = first
                                    }
                                    return !0
                                }
                                ,
                                p.parse = function(target, vars, pt, plugin) {
                                    var p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel, style = target.style;
                                    for (p in vars)
                                        es = vars[p],
                                        "function" == typeof es && (es = es(_index, _target)),
                                            sp = _specialProps[p],
                                            sp ? pt = sp.parse(target, es, p, this, pt, plugin, vars) : (bs = _getStyle(target, p, _cs) + "",
                                                isStr = "string" == typeof es,
                                                "color" === p || "fill" === p || "stroke" === p || p.indexOf("Color") !== -1 || isStr && _rgbhslExp.test(es) ? (isStr || (es = _parseColor(es),
                                                    es = (es.length > 3 ? "rgba(" : "rgb(") + es.join(",") + ")"),
                                                    pt = _parseComplex(style, p, bs, es, !0, "transparent", pt, 0, plugin)) : isStr && _complexExp.test(es) ? pt = _parseComplex(style, p, bs, es, !0, null, pt, 0, plugin) : (bn = parseFloat(bs),
                                                    bsfx = bn || 0 === bn ? bs.substr((bn + "").length) : "",
                                                "" !== bs && "auto" !== bs || ("width" === p || "height" === p ? (bn = _getDimension(target, p, _cs),
                                                    bsfx = "px") : "left" === p || "top" === p ? (bn = _calculateOffset(target, p, _cs),
                                                    bsfx = "px") : (bn = "opacity" !== p ? 0 : 1,
                                                    bsfx = "")),
                                                    rel = isStr && "=" === es.charAt(1),
                                                    rel ? (en = parseInt(es.charAt(0) + "1", 10),
                                                        es = es.substr(2),
                                                        en *= parseFloat(es),
                                                        esfx = es.replace(_suffixExp, "")) : (en = parseFloat(es),
                                                        esfx = isStr ? es.replace(_suffixExp, "") : ""),
                                                "" === esfx && (esfx = p in _suffixMap ? _suffixMap[p] : bsfx),
                                                    es = en || 0 === en ? (rel ? en + bn : en) + esfx : vars[p],
                                                bsfx !== esfx && "" !== esfx && (en || 0 === en) && bn && (bn = _convertToPixels(target, p, bn, bsfx),
                                                    "%" === esfx ? (bn /= _convertToPixels(target, p, 100, "%") / 100,
                                                    vars.strictUnits !== !0 && (bs = bn + "%")) : "em" === esfx || "rem" === esfx || "vw" === esfx || "vh" === esfx ? bn /= _convertToPixels(target, p, 1, esfx) : "px" !== esfx && (en = _convertToPixels(target, p, en, esfx),
                                                        esfx = "px"),
                                                rel && (en || 0 === en) && (es = en + bn + esfx)),
                                                rel && (en += bn),
                                                    !bn && 0 !== bn || !en && 0 !== en ? void 0 !== style[p] && (es || es + "" != "NaN" && null != es) ? (pt = new CSSPropTween(style,p,en || bn || 0,0,pt,-1,p,!1,0,bs,es),
                                                        pt.xs0 = "none" !== es || "display" !== p && p.indexOf("Style") === -1 ? es : bs) : _log("invalid " + p + " tween value: " + vars[p]) : (pt = new CSSPropTween(style,p,bn,en - bn,pt,0,p,_autoRound !== !1 && ("px" === esfx || "zIndex" === p),0,bs,es),
                                                        pt.xs0 = esfx))),
                                        plugin && pt && !pt.plugin && (pt.plugin = plugin);
                                    return pt
                                }
                                ,
                                p.setRatio = function(v) {
                                    var val, str, i, pt = this._firstPT, min = 1e-6;
                                    if (1 !== v || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                                        if (v || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6)
                                            for (; pt; ) {
                                                if (val = pt.c * v + pt.s,
                                                        pt.r ? val = Math.round(val) : val < min && val > -min && (val = 0),
                                                        pt.type)
                                                    if (1 === pt.type)
                                                        if (i = pt.l,
                                                            2 === i)
                                                            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
                                                        else if (3 === i)
                                                            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
                                                        else if (4 === i)
                                                            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
                                                        else if (5 === i)
                                                            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
                                                        else {
                                                            for (str = pt.xs0 + val + pt.xs1,
                                                                     i = 1; i < pt.l; i++)
                                                                str += pt["xn" + i] + pt["xs" + (i + 1)];
                                                            pt.t[pt.p] = str
                                                        }
                                                    else
                                                        pt.type === -1 ? pt.t[pt.p] = pt.xs0 : pt.setRatio && pt.setRatio(v);
                                                else
                                                    pt.t[pt.p] = val + pt.xs0;
                                                pt = pt._next
                                            }
                                        else
                                            for (; pt; )
                                                2 !== pt.type ? pt.t[pt.p] = pt.b : pt.setRatio(v),
                                                    pt = pt._next;
                                    else
                                        for (; pt; ) {
                                            if (2 !== pt.type)
                                                if (pt.r && pt.type !== -1)
                                                    if (val = Math.round(pt.s + pt.c),
                                                            pt.type) {
                                                        if (1 === pt.type) {
                                                            for (i = pt.l,
                                                                     str = pt.xs0 + val + pt.xs1,
                                                                     i = 1; i < pt.l; i++)
                                                                str += pt["xn" + i] + pt["xs" + (i + 1)];
                                                            pt.t[pt.p] = str
                                                        }
                                                    } else
                                                        pt.t[pt.p] = val + pt.xs0;
                                                else
                                                    pt.t[pt.p] = pt.e;
                                            else
                                                pt.setRatio(v);
                                            pt = pt._next
                                        }
                                }
                                ,
                                p._enableTransforms = function(threeD) {
                                    this._transform = this._transform || _getTransform(this._target, _cs, !0),
                                        this._transformType = this._transform.svg && _useSVGTransformAttr || !threeD && 3 !== this._transformType ? 2 : 3
                                }
                            ;
                            var lazySet = function(v) {
                                this.t[this.p] = this.e,
                                    this.data._linkCSSP(this, this._next, null, !0)
                            };
                            p._addLazySet = function(t, p, v) {
                                var pt = this._firstPT = new CSSPropTween(t,p,0,0,this._firstPT,2);
                                pt.e = v,
                                    pt.setRatio = lazySet,
                                    pt.data = this
                            }
                                ,
                                p._linkCSSP = function(pt, next, prev, remove) {
                                    return pt && (next && (next._prev = pt),
                                    pt._next && (pt._next._prev = pt._prev),
                                        pt._prev ? pt._prev._next = pt._next : this._firstPT === pt && (this._firstPT = pt._next,
                                            remove = !0),
                                        prev ? prev._next = pt : remove || null !== this._firstPT || (this._firstPT = pt),
                                        pt._next = next,
                                        pt._prev = prev),
                                        pt
                                }
                                ,
                                p._mod = function(lookup) {
                                    for (var pt = this._firstPT; pt; )
                                        "function" == typeof lookup[pt.p] && lookup[pt.p] === Math.round && (pt.r = 1),
                                            pt = pt._next
                                }
                                ,
                                p._kill = function(lookup) {
                                    var pt, p, xfirst, copy = lookup;
                                    if (lookup.autoAlpha || lookup.alpha) {
                                        copy = {};
                                        for (p in lookup)
                                            copy[p] = lookup[p];
                                        copy.opacity = 1,
                                        copy.autoAlpha && (copy.visibility = 1)
                                    }
                                    for (lookup.className && (pt = this._classNamePT) && (xfirst = pt.xfirst,
                                        xfirst && xfirst._prev ? this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev) : xfirst === this._firstPT && (this._firstPT = pt._next),
                                    pt._next && this._linkCSSP(pt._next, pt._next._next, xfirst._prev),
                                        this._classNamePT = null),
                                             pt = this._firstPT; pt; )
                                        pt.plugin && pt.plugin !== p && pt.plugin._kill && (pt.plugin._kill(lookup),
                                            p = pt.plugin),
                                            pt = pt._next;
                                    return TweenPlugin.prototype._kill.call(this, copy)
                                }
                            ;
                            var _getChildStyles = function(e, props, targets) {
                                var children, i, child, type;
                                if (e.slice)
                                    for (i = e.length; --i > -1; )
                                        _getChildStyles(e[i], props, targets);
                                else
                                    for (children = e.childNodes,
                                             i = children.length; --i > -1; )
                                        child = children[i],
                                            type = child.type,
                                        child.style && (props.push(_getAllStyles(child)),
                                        targets && targets.push(child)),
                                        1 !== type && 9 !== type && 11 !== type || !child.childNodes.length || _getChildStyles(child, props, targets)
                            };
                            return CSSPlugin.cascadeTo = function(target, duration, vars) {
                                var i, difs, p, from, tween = TweenLite.to(target, duration, vars), results = [tween], b = [], e = [], targets = [], _reservedProps = TweenLite._internals.reservedProps;
                                for (target = tween._targets || tween.target,
                                         _getChildStyles(target, b, targets),
                                         tween.render(duration, !0, !0),
                                         _getChildStyles(target, e),
                                         tween.render(0, !0, !0),
                                         tween._enabled(!0),
                                         i = targets.length; --i > -1; )
                                    if (difs = _cssDif(targets[i], b[i], e[i]),
                                            difs.firstMPT) {
                                        difs = difs.difs;
                                        for (p in vars)
                                            _reservedProps[p] && (difs[p] = vars[p]);
                                        from = {};
                                        for (p in difs)
                                            from[p] = b[i][p];
                                        results.push(TweenLite.fromTo(targets[i], duration, from, difs))
                                    }
                                return results
                            }
                                ,
                                TweenPlugin.activate([CSSPlugin]),
                                CSSPlugin
                        }, !0),
                        function() {
                            var RoundPropsPlugin = _gsScope._gsDefine.plugin({
                                propName: "roundProps",
                                version: "1.6.0",
                                priority: -1,
                                API: 2,
                                init: function(target, value, tween) {
                                    return this._tween = tween,
                                        !0
                                }
                            })
                                , _roundLinkedList = function(node) {
                                for (; node; )
                                    node.f || node.blob || (node.m = Math.round),
                                        node = node._next
                            }
                                , p = RoundPropsPlugin.prototype;
                            p._onInitAllProps = function() {
                                for (var prop, pt, next, tween = this._tween, rp = tween.vars.roundProps.join ? tween.vars.roundProps : tween.vars.roundProps.split(","), i = rp.length, lookup = {}, rpt = tween._propLookup.roundProps; --i > -1; )
                                    lookup[rp[i]] = Math.round;
                                for (i = rp.length; --i > -1; )
                                    for (prop = rp[i],
                                             pt = tween._firstPT; pt; )
                                        next = pt._next,
                                            pt.pg ? pt.t._mod(lookup) : pt.n === prop && (2 === pt.f && pt.t ? _roundLinkedList(pt.t._firstPT) : (this._add(pt.t, prop, pt.s, pt.c),
                                            next && (next._prev = pt._prev),
                                                pt._prev ? pt._prev._next = next : tween._firstPT === pt && (tween._firstPT = next),
                                                pt._next = pt._prev = null,
                                                tween._propLookup[prop] = rpt)),
                                            pt = next;
                                return !1
                            }
                                ,
                                p._add = function(target, p, s, c) {
                                    this._addTween(target, p, s, s + c, p, Math.round),
                                        this._overwriteProps.push(p)
                                }
                        }(),
                        function() {
                            _gsScope._gsDefine.plugin({
                                propName: "attr",
                                API: 2,
                                version: "0.6.0",
                                init: function(target, value, tween, index) {
                                    var p, end;
                                    if ("function" != typeof target.setAttribute)
                                        return !1;
                                    for (p in value)
                                        end = value[p],
                                        "function" == typeof end && (end = end(index, target)),
                                            this._addTween(target, "setAttribute", target.getAttribute(p) + "", end + "", p, !1, p),
                                            this._overwriteProps.push(p);
                                    return !0
                                }
                            })
                        }(),
                        _gsScope._gsDefine.plugin({
                            propName: "directionalRotation",
                            version: "0.3.0",
                            API: 2,
                            init: function(target, value, tween, index) {
                                "object" != typeof value && (value = {
                                    rotation: value
                                }),
                                    this.finals = {};
                                var p, v, start, end, dif, split, cap = value.useRadians === !0 ? 2 * Math.PI : 360, min = 1e-6;
                                for (p in value)
                                    "useRadians" !== p && (end = value[p],
                                    "function" == typeof end && (end = end(index, target)),
                                        split = (end + "").split("_"),
                                        v = split[0],
                                        start = parseFloat("function" != typeof target[p] ? target[p] : target[p.indexOf("set") || "function" != typeof target["get" + p.substr(3)] ? p : "get" + p.substr(3)]()),
                                        end = this.finals[p] = "string" == typeof v && "=" === v.charAt(1) ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0,
                                        dif = end - start,
                                    split.length && (v = split.join("_"),
                                    v.indexOf("short") !== -1 && (dif %= cap,
                                    dif !== dif % (cap / 2) && (dif = dif < 0 ? dif + cap : dif - cap)),
                                        v.indexOf("_cw") !== -1 && dif < 0 ? dif = (dif + 9999999999 * cap) % cap - (dif / cap | 0) * cap : v.indexOf("ccw") !== -1 && dif > 0 && (dif = (dif - 9999999999 * cap) % cap - (dif / cap | 0) * cap)),
                                    (dif > min || dif < -min) && (this._addTween(target, p, start, start + dif, p),
                                        this._overwriteProps.push(p)));
                                return !0
                            },
                            set: function(ratio) {
                                var pt;
                                if (1 !== ratio)
                                    this._super.setRatio.call(this, ratio);
                                else
                                    for (pt = this._firstPT; pt; )
                                        pt.f ? pt.t[pt.p](this.finals[pt.p]) : pt.t[pt.p] = this.finals[pt.p],
                                            pt = pt._next
                            }
                        })._autoCSS = !0,
                        _gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {
                            var SteppedEase, RoughEase, _createElastic, w = _gsScope.GreenSockGlobals || _gsScope, gs = w.com.greensock, _2PI = 2 * Math.PI, _HALF_PI = Math.PI / 2, _class = gs._class, _create = function(n, f) {
                                var C = _class("easing." + n, function() {}, !0)
                                    , p = C.prototype = new Ease;
                                return p.constructor = C,
                                    p.getRatio = f,
                                    C
                            }, _easeReg = Ease.register || function() {}
                                , _wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
                                var C = _class("easing." + name, {
                                    easeOut: new EaseOut,
                                    easeIn: new EaseIn,
                                    easeInOut: new EaseInOut
                                }, !0);
                                return _easeReg(C, name),
                                    C
                            }, EasePoint = function(time, value, next) {
                                this.t = time,
                                    this.v = value,
                                next && (this.next = next,
                                    next.prev = this,
                                    this.c = next.v - value,
                                    this.gap = next.t - time)
                            }, _createBack = function(n, f) {
                                var C = _class("easing." + n, function(overshoot) {
                                    this._p1 = overshoot || 0 === overshoot ? overshoot : 1.70158,
                                        this._p2 = 1.525 * this._p1
                                }, !0)
                                    , p = C.prototype = new Ease;
                                return p.constructor = C,
                                    p.getRatio = f,
                                    p.config = function(overshoot) {
                                        return new C(overshoot)
                                    }
                                    ,
                                    C
                            }, Back = _wrap("Back", _createBack("BackOut", function(p) {
                                return (p -= 1) * p * ((this._p1 + 1) * p + this._p1) + 1
                            }), _createBack("BackIn", function(p) {
                                return p * p * ((this._p1 + 1) * p - this._p1)
                            }), _createBack("BackInOut", function(p) {
                                return (p *= 2) < 1 ? .5 * p * p * ((this._p2 + 1) * p - this._p2) : .5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2)
                            })), SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
                                power = power || 0 === power ? power : .7,
                                    null == linearRatio ? linearRatio = .7 : linearRatio > 1 && (linearRatio = 1),
                                    this._p = 1 !== linearRatio ? power : 0,
                                    this._p1 = (1 - linearRatio) / 2,
                                    this._p2 = linearRatio,
                                    this._p3 = this._p1 + this._p2,
                                    this._calcEnd = yoyoMode === !0
                            }, !0), p = SlowMo.prototype = new Ease;
                            return p.constructor = SlowMo,
                                p.getRatio = function(p) {
                                    var r = p + (.5 - p) * this._p;
                                    return p < this._p1 ? this._calcEnd ? 1 - (p = 1 - p / this._p1) * p : r - (p = 1 - p / this._p1) * p * p * p * r : p > this._p3 ? this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + (p - r) * (p = (p - this._p3) / this._p1) * p * p * p : this._calcEnd ? 1 : r
                                }
                                ,
                                SlowMo.ease = new SlowMo(.7,.7),
                                p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
                                    return new SlowMo(linearRatio,power,yoyoMode)
                                }
                                ,
                                SteppedEase = _class("easing.SteppedEase", function(steps) {
                                    steps = steps || 1,
                                        this._p1 = 1 / steps,
                                        this._p2 = steps + 1
                                }, !0),
                                p = SteppedEase.prototype = new Ease,
                                p.constructor = SteppedEase,
                                p.getRatio = function(p) {
                                    return p < 0 ? p = 0 : p >= 1 && (p = .999999999),
                                    (this._p2 * p >> 0) * this._p1
                                }
                                ,
                                p.config = SteppedEase.config = function(steps) {
                                    return new SteppedEase(steps)
                                }
                                ,
                                RoughEase = _class("easing.RoughEase", function(vars) {
                                    vars = vars || {};
                                    for (var x, y, bump, invX, obj, pnt, taper = vars.taper || "none", a = [], cnt = 0, points = 0 | (vars.points || 20), i = points, randomize = vars.randomize !== !1, clamp = vars.clamp === !0, template = vars.template instanceof Ease ? vars.template : null, strength = "number" == typeof vars.strength ? .4 * vars.strength : .4; --i > -1; )
                                        x = randomize ? Math.random() : 1 / points * i,
                                            y = template ? template.getRatio(x) : x,
                                            "none" === taper ? bump = strength : "out" === taper ? (invX = 1 - x,
                                                bump = invX * invX * strength) : "in" === taper ? bump = x * x * strength : x < .5 ? (invX = 2 * x,
                                                bump = invX * invX * .5 * strength) : (invX = 2 * (1 - x),
                                                bump = invX * invX * .5 * strength),
                                            randomize ? y += Math.random() * bump - .5 * bump : i % 2 ? y += .5 * bump : y -= .5 * bump,
                                        clamp && (y > 1 ? y = 1 : y < 0 && (y = 0)),
                                            a[cnt++] = {
                                                x: x,
                                                y: y
                                            };
                                    for (a.sort(function(a, b) {
                                        return a.x - b.x
                                    }),
                                             pnt = new EasePoint(1,1,null),
                                             i = points; --i > -1; )
                                        obj = a[i],
                                            pnt = new EasePoint(obj.x,obj.y,pnt);
                                    this._prev = new EasePoint(0,0,0 !== pnt.t ? pnt : pnt.next)
                                }, !0),
                                p = RoughEase.prototype = new Ease,
                                p.constructor = RoughEase,
                                p.getRatio = function(p) {
                                    var pnt = this._prev;
                                    if (p > pnt.t) {
                                        for (; pnt.next && p >= pnt.t; )
                                            pnt = pnt.next;
                                        pnt = pnt.prev
                                    } else
                                        for (; pnt.prev && p <= pnt.t; )
                                            pnt = pnt.prev;
                                    return this._prev = pnt,
                                    pnt.v + (p - pnt.t) / pnt.gap * pnt.c
                                }
                                ,
                                p.config = function(vars) {
                                    return new RoughEase(vars)
                                }
                                ,
                                RoughEase.ease = new RoughEase,
                                _wrap("Bounce", _create("BounceOut", function(p) {
                                    return p < 1 / 2.75 ? 7.5625 * p * p : p < 2 / 2.75 ? 7.5625 * (p -= 1.5 / 2.75) * p + .75 : p < 2.5 / 2.75 ? 7.5625 * (p -= 2.25 / 2.75) * p + .9375 : 7.5625 * (p -= 2.625 / 2.75) * p + .984375
                                }), _create("BounceIn", function(p) {
                                    return (p = 1 - p) < 1 / 2.75 ? 1 - 7.5625 * p * p : p < 2 / 2.75 ? 1 - (7.5625 * (p -= 1.5 / 2.75) * p + .75) : p < 2.5 / 2.75 ? 1 - (7.5625 * (p -= 2.25 / 2.75) * p + .9375) : 1 - (7.5625 * (p -= 2.625 / 2.75) * p + .984375)
                                }), _create("BounceInOut", function(p) {
                                    var invert = p < .5;
                                    return p = invert ? 1 - 2 * p : 2 * p - 1,
                                        p < 1 / 2.75 ? p *= 7.5625 * p : p = p < 2 / 2.75 ? 7.5625 * (p -= 1.5 / 2.75) * p + .75 : p < 2.5 / 2.75 ? 7.5625 * (p -= 2.25 / 2.75) * p + .9375 : 7.5625 * (p -= 2.625 / 2.75) * p + .984375,
                                        invert ? .5 * (1 - p) : .5 * p + .5
                                })),
                                _wrap("Circ", _create("CircOut", function(p) {
                                    return Math.sqrt(1 - (p -= 1) * p)
                                }), _create("CircIn", function(p) {
                                    return -(Math.sqrt(1 - p * p) - 1)
                                }), _create("CircInOut", function(p) {
                                    return (p *= 2) < 1 ? -.5 * (Math.sqrt(1 - p * p) - 1) : .5 * (Math.sqrt(1 - (p -= 2) * p) + 1)
                                })),
                                _createElastic = function(n, f, def) {
                                    var C = _class("easing." + n, function(amplitude, period) {
                                        this._p1 = amplitude >= 1 ? amplitude : 1,
                                            this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1),
                                            this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0),
                                            this._p2 = _2PI / this._p2
                                    }, !0)
                                        , p = C.prototype = new Ease;
                                    return p.constructor = C,
                                        p.getRatio = f,
                                        p.config = function(amplitude, period) {
                                            return new C(amplitude,period)
                                        }
                                        ,
                                        C
                                }
                                ,
                                _wrap("Elastic", _createElastic("ElasticOut", function(p) {
                                    return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * this._p2) + 1
                                }, .3), _createElastic("ElasticIn", function(p) {
                                    return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2))
                                }, .3), _createElastic("ElasticInOut", function(p) {
                                    return (p *= 2) < 1 ? -.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2) * .5 + 1
                                }, .45)),
                                _wrap("Expo", _create("ExpoOut", function(p) {
                                    return 1 - Math.pow(2, -10 * p)
                                }), _create("ExpoIn", function(p) {
                                    return Math.pow(2, 10 * (p - 1)) - .001
                                }), _create("ExpoInOut", function(p) {
                                    return (p *= 2) < 1 ? .5 * Math.pow(2, 10 * (p - 1)) : .5 * (2 - Math.pow(2, -10 * (p - 1)))
                                })),
                                _wrap("Sine", _create("SineOut", function(p) {
                                    return Math.sin(p * _HALF_PI)
                                }), _create("SineIn", function(p) {
                                    return -Math.cos(p * _HALF_PI) + 1
                                }), _create("SineInOut", function(p) {
                                    return -.5 * (Math.cos(Math.PI * p) - 1)
                                })),
                                _class("easing.EaseLookup", {
                                    find: function(s) {
                                        return Ease.map[s]
                                    }
                                }, !0),
                                _easeReg(w.SlowMo, "SlowMo", "ease,"),
                                _easeReg(RoughEase, "RoughEase", "ease,"),
                                _easeReg(SteppedEase, "SteppedEase", "ease,"),
                                Back
                        }, !0)
                }),
                _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
                    function(window, moduleName) {
                        "use strict";
                        var _exports = {}
                            , _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
                        if (!_globals.TweenLite) {
                            var a, i, p, _ticker, _tickerActive, _namespace = function(ns) {
                                    var i, a = ns.split("."), p = _globals;
                                    for (i = 0; i < a.length; i++)
                                        p[a[i]] = p = p[a[i]] || {};
                                    return p
                                }, gs = _namespace("com.greensock"), _tinyNum = 1e-10, _slice = function(a) {
                                    var i, b = [], l = a.length;
                                    for (i = 0; i !== l; b.push(a[i++]))
                                        ;
                                    return b
                                }, _emptyFunc = function() {}, _isArray = function() {
                                    var toString = Object.prototype.toString
                                        , array = toString.call([]);
                                    return function(obj) {
                                        return null != obj && (obj instanceof Array || "object" == typeof obj && !!obj.push && toString.call(obj) === array)
                                    }
                                }(), _defLookup = {}, Definition = function(ns, dependencies, func, global) {
                                    this.sc = _defLookup[ns] ? _defLookup[ns].sc : [],
                                        _defLookup[ns] = this,
                                        this.gsClass = null,
                                        this.func = func;
                                    var _classes = [];
                                    this.check = function(init) {
                                        for (var cur, a, n, cl, hasModule, i = dependencies.length, missing = i; --i > -1; )
                                            (cur = _defLookup[dependencies[i]] || new Definition(dependencies[i],[])).gsClass ? (_classes[i] = cur.gsClass,
                                                missing--) : init && cur.sc.push(this);
                                        if (0 === missing && func) {
                                            if (a = ("com.greensock." + ns).split("."),
                                                    n = a.pop(),
                                                    cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes),
                                                    global)
                                                if (_globals[n] = _exports[n] = cl,
                                                        hasModule = "undefined" != typeof module && module.exports,
                                                    !hasModule && "function" == typeof define && define.amd)
                                                    define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() {
                                                        return cl
                                                    });
                                                else if (hasModule)
                                                    if (ns === moduleName) {
                                                        module.exports = _exports[moduleName] = cl;
                                                        for (i in _exports)
                                                            cl[i] = _exports[i]
                                                    } else
                                                        _exports[moduleName] && (_exports[moduleName][n] = cl);
                                            for (i = 0; i < this.sc.length; i++)
                                                this.sc[i].check()
                                        }
                                    }
                                        ,
                                        this.check(!0)
                                }, _gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
                                    return new Definition(ns,dependencies,func,global)
                                }
                                , _class = gs._class = function(ns, func, global) {
                                    return func = func || function() {}
                                        ,
                                        _gsDefine(ns, [], function() {
                                            return func
                                        }, global),
                                        func
                                }
                                ;
                            _gsDefine.globals = _globals;
                            var _baseParams = [0, 0, 1, 1]
                                , Ease = _class("easing.Ease", function(func, extraParams, type, power) {
                                    this._func = func,
                                        this._type = type || 0,
                                        this._power = power || 0,
                                        this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams
                                }, !0)
                                , _easeMap = Ease.map = {}
                                , _easeReg = Ease.register = function(ease, names, types, create) {
                                    for (var e, name, j, type, na = names.split(","), i = na.length, ta = (types || "easeIn,easeOut,easeInOut").split(","); --i > -1; )
                                        for (name = na[i],
                                                 e = create ? _class("easing." + name, null, !0) : gs.easing[name] || {},
                                                 j = ta.length; --j > -1; )
                                            type = ta[j],
                                                _easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease
                                }
                                ;
                            for (p = Ease.prototype,
                                     p._calcEnd = !1,
                                     p.getRatio = function(p) {
                                         if (this._func)
                                             return this._params[0] = p,
                                                 this._func.apply(null, this._params);
                                         var t = this._type
                                             , pw = this._power
                                             , r = 1 === t ? 1 - p : 2 === t ? p : p < .5 ? 2 * p : 2 * (1 - p);
                                         return 1 === pw ? r *= r : 2 === pw ? r *= r * r : 3 === pw ? r *= r * r * r : 4 === pw && (r *= r * r * r * r),
                                             1 === t ? 1 - r : 2 === t ? r : p < .5 ? r / 2 : 1 - r / 2
                                     }
                                     ,
                                     a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"],
                                     i = a.length; --i > -1; )
                                p = a[i] + ",Power" + i,
                                    _easeReg(new Ease(null,null,1,i), p, "easeOut", !0),
                                    _easeReg(new Ease(null,null,2,i), p, "easeIn" + (0 === i ? ",easeNone" : "")),
                                    _easeReg(new Ease(null,null,3,i), p, "easeInOut");
                            _easeMap.linear = gs.easing.Linear.easeIn,
                                _easeMap.swing = gs.easing.Quad.easeInOut;
                            var EventDispatcher = _class("events.EventDispatcher", function(target) {
                                this._listeners = {},
                                    this._eventTarget = target || this
                            });
                            p = EventDispatcher.prototype,
                                p.addEventListener = function(type, callback, scope, useParam, priority) {
                                    priority = priority || 0;
                                    var listener, i, list = this._listeners[type], index = 0;
                                    for (this !== _ticker || _tickerActive || _ticker.wake(),
                                         null == list && (this._listeners[type] = list = []),
                                             i = list.length; --i > -1; )
                                        listener = list[i],
                                            listener.c === callback && listener.s === scope ? list.splice(i, 1) : 0 === index && listener.pr < priority && (index = i + 1);
                                    list.splice(index, 0, {
                                        c: callback,
                                        s: scope,
                                        up: useParam,
                                        pr: priority
                                    })
                                }
                                ,
                                p.removeEventListener = function(type, callback) {
                                    var i, list = this._listeners[type];
                                    if (list)
                                        for (i = list.length; --i > -1; )
                                            if (list[i].c === callback)
                                                return void list.splice(i, 1)
                                }
                                ,
                                p.dispatchEvent = function(type) {
                                    var i, t, listener, list = this._listeners[type];
                                    if (list)
                                        for (i = list.length,
                                             i > 1 && (list = list.slice(0)),
                                                 t = this._eventTarget; --i > -1; )
                                            listener = list[i],
                                            listener && (listener.up ? listener.c.call(listener.s || t, {
                                                type: type,
                                                target: t
                                            }) : listener.c.call(listener.s || t))
                                }
                            ;
                            var _reqAnimFrame = window.requestAnimationFrame
                                , _cancelAnimFrame = window.cancelAnimationFrame
                                , _getTime = Date.now || function() {
                                    return (new Date).getTime()
                                }
                                , _lastUpdate = _getTime();
                            for (a = ["ms", "moz", "webkit", "o"],
                                     i = a.length; --i > -1 && !_reqAnimFrame; )
                                _reqAnimFrame = window[a[i] + "RequestAnimationFrame"],
                                    _cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
                            _class("Ticker", function(fps, useRAF) {
                                var _fps, _req, _id, _gap, _nextTime, _self = this, _startTime = _getTime(), _useRAF = !(useRAF === !1 || !_reqAnimFrame) && "auto", _lagThreshold = 500, _adjustedLag = 33, _tickWord = "tick", _tick = function(manual) {
                                    var overlap, dispatch, elapsed = _getTime() - _lastUpdate;
                                    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag),
                                        _lastUpdate += elapsed,
                                        _self.time = (_lastUpdate - _startTime) / 1e3,
                                        overlap = _self.time - _nextTime,
                                    (!_fps || overlap > 0 || manual === !0) && (_self.frame++,
                                        _nextTime += overlap + (overlap >= _gap ? .004 : _gap - overlap),
                                        dispatch = !0),
                                    manual !== !0 && (_id = _req(_tick)),
                                    dispatch && _self.dispatchEvent(_tickWord)
                                };
                                EventDispatcher.call(_self),
                                    _self.time = _self.frame = 0,
                                    _self.tick = function() {
                                        _tick(!0)
                                    }
                                    ,
                                    _self.lagSmoothing = function(threshold, adjustedLag) {
                                        _lagThreshold = threshold || 1 / _tinyNum,
                                            _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0)
                                    }
                                    ,
                                    _self.sleep = function() {
                                        null != _id && (_useRAF && _cancelAnimFrame ? _cancelAnimFrame(_id) : clearTimeout(_id),
                                            _req = _emptyFunc,
                                            _id = null,
                                        _self === _ticker && (_tickerActive = !1))
                                    }
                                    ,
                                    _self.wake = function(seamless) {
                                        null !== _id ? _self.sleep() : seamless ? _startTime += -_lastUpdate + (_lastUpdate = _getTime()) : _self.frame > 10 && (_lastUpdate = _getTime() - _lagThreshold + 5),
                                            _req = 0 === _fps ? _emptyFunc : _useRAF && _reqAnimFrame ? _reqAnimFrame : function(f) {
                                                return setTimeout(f, 1e3 * (_nextTime - _self.time) + 1 | 0)
                                            }
                                            ,
                                        _self === _ticker && (_tickerActive = !0),
                                            _tick(2)
                                    }
                                    ,
                                    _self.fps = function(value) {
                                        return arguments.length ? (_fps = value,
                                            _gap = 1 / (_fps || 60),
                                            _nextTime = this.time + _gap,
                                            void _self.wake()) : _fps
                                    }
                                    ,
                                    _self.useRAF = function(value) {
                                        return arguments.length ? (_self.sleep(),
                                            _useRAF = value,
                                            void _self.fps(_fps)) : _useRAF
                                    }
                                    ,
                                    _self.fps(fps),
                                    setTimeout(function() {
                                        "auto" === _useRAF && _self.frame < 5 && "hidden" !== document.visibilityState && _self.useRAF(!1)
                                    }, 1500)
                            }),
                                p = gs.Ticker.prototype = new gs.events.EventDispatcher,
                                p.constructor = gs.Ticker;
                            var Animation = _class("core.Animation", function(duration, vars) {
                                if (this.vars = vars = vars || {},
                                        this._duration = this._totalDuration = duration || 0,
                                        this._delay = Number(vars.delay) || 0,
                                        this._timeScale = 1,
                                        this._active = vars.immediateRender === !0,
                                        this.data = vars.data,
                                        this._reversed = vars.reversed === !0,
                                        _rootTimeline) {
                                    _tickerActive || _ticker.wake();
                                    var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
                                    tl.add(this, tl._time),
                                    this.vars.paused && this.paused(!0)
                                }
                            });
                            _ticker = Animation.ticker = new gs.Ticker,
                                p = Animation.prototype,
                                p._dirty = p._gc = p._initted = p._paused = !1,
                                p._totalTime = p._time = 0,
                                p._rawPrevTime = -1,
                                p._next = p._last = p._onUpdate = p._timeline = p.timeline = null,
                                p._paused = !1;
                            var _checkTimeout = function() {
                                _tickerActive && _getTime() - _lastUpdate > 2e3 && _ticker.wake(),
                                    setTimeout(_checkTimeout, 2e3)
                            };
                            _checkTimeout(),
                                p.play = function(from, suppressEvents) {
                                    return null != from && this.seek(from, suppressEvents),
                                        this.reversed(!1).paused(!1)
                                }
                                ,
                                p.pause = function(atTime, suppressEvents) {
                                    return null != atTime && this.seek(atTime, suppressEvents),
                                        this.paused(!0)
                                }
                                ,
                                p.resume = function(from, suppressEvents) {
                                    return null != from && this.seek(from, suppressEvents),
                                        this.paused(!1)
                                }
                                ,
                                p.seek = function(time, suppressEvents) {
                                    return this.totalTime(Number(time), suppressEvents !== !1)
                                }
                                ,
                                p.restart = function(includeDelay, suppressEvents) {
                                    return this.reversed(!1).paused(!1).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== !1, !0)
                                }
                                ,
                                p.reverse = function(from, suppressEvents) {
                                    return null != from && this.seek(from || this.totalDuration(), suppressEvents),
                                        this.reversed(!0).paused(!1)
                                }
                                ,
                                p.render = function(time, suppressEvents, force) {}
                                ,
                                p.invalidate = function() {
                                    return this._time = this._totalTime = 0,
                                        this._initted = this._gc = !1,
                                        this._rawPrevTime = -1,
                                    !this._gc && this.timeline || this._enabled(!0),
                                        this
                                }
                                ,
                                p.isActive = function() {
                                    var rawTime, tl = this._timeline, startTime = this._startTime;
                                    return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale
                                }
                                ,
                                p._enabled = function(enabled, ignoreTimeline) {
                                    return _tickerActive || _ticker.wake(),
                                        this._gc = !enabled,
                                        this._active = this.isActive(),
                                    ignoreTimeline !== !0 && (enabled && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !enabled && this.timeline && this._timeline._remove(this, !0)),
                                        !1
                                }
                                ,
                                p._kill = function(vars, target) {
                                    return this._enabled(!1, !1)
                                }
                                ,
                                p.kill = function(vars, target) {
                                    return this._kill(vars, target),
                                        this
                                }
                                ,
                                p._uncache = function(includeSelf) {
                                    for (var tween = includeSelf ? this : this.timeline; tween; )
                                        tween._dirty = !0,
                                            tween = tween.timeline;
                                    return this
                                }
                                ,
                                p._swapSelfInParams = function(params) {
                                    for (var i = params.length, copy = params.concat(); --i > -1; )
                                        "{self}" === params[i] && (copy[i] = this);
                                    return copy
                                }
                                ,
                                p._callback = function(type) {
                                    var v = this.vars
                                        , callback = v[type]
                                        , params = v[type + "Params"]
                                        , scope = v[type + "Scope"] || v.callbackScope || this
                                        , l = params ? params.length : 0;
                                    switch (l) {
                                        case 0:
                                            callback.call(scope);
                                            break;
                                        case 1:
                                            callback.call(scope, params[0]);
                                            break;
                                        case 2:
                                            callback.call(scope, params[0], params[1]);
                                            break;
                                        default:
                                            callback.apply(scope, params)
                                    }
                                }
                                ,
                                p.eventCallback = function(type, callback, params, scope) {
                                    if ("on" === (type || "").substr(0, 2)) {
                                        var v = this.vars;
                                        if (1 === arguments.length)
                                            return v[type];
                                        null == callback ? delete v[type] : (v[type] = callback,
                                            v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params,
                                            v[type + "Scope"] = scope),
                                        "onUpdate" === type && (this._onUpdate = callback)
                                    }
                                    return this
                                }
                                ,
                                p.delay = function(value) {
                                    return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + value - this._delay),
                                        this._delay = value,
                                        this) : this._delay
                                }
                                ,
                                p.duration = function(value) {
                                    return arguments.length ? (this._duration = this._totalDuration = value,
                                        this._uncache(!0),
                                    this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== value && this.totalTime(this._totalTime * (value / this._duration), !0),
                                        this) : (this._dirty = !1,
                                        this._duration)
                                }
                                ,
                                p.totalDuration = function(value) {
                                    return this._dirty = !1,
                                        arguments.length ? this.duration(value) : this._totalDuration
                                }
                                ,
                                p.time = function(value, suppressEvents) {
                                    return arguments.length ? (this._dirty && this.totalDuration(),
                                        this.totalTime(value > this._duration ? this._duration : value, suppressEvents)) : this._time
                                }
                                ,
                                p.totalTime = function(time, suppressEvents, uncapped) {
                                    if (_tickerActive || _ticker.wake(),
                                            !arguments.length)
                                        return this._totalTime;
                                    if (this._timeline) {
                                        if (time < 0 && !uncapped && (time += this.totalDuration()),
                                                this._timeline.smoothChildTiming) {
                                            this._dirty && this.totalDuration();
                                            var totalDuration = this._totalDuration
                                                , tl = this._timeline;
                                            if (time > totalDuration && !uncapped && (time = totalDuration),
                                                    this._startTime = (this._paused ? this._pauseTime : tl._time) - (this._reversed ? totalDuration - time : time) / this._timeScale,
                                                tl._dirty || this._uncache(!1),
                                                    tl._timeline)
                                                for (; tl._timeline; )
                                                    tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale && tl.totalTime(tl._totalTime, !0),
                                                        tl = tl._timeline
                                        }
                                        this._gc && this._enabled(!0, !1),
                                        this._totalTime === time && 0 !== this._duration || (_lazyTweens.length && _lazyRender(),
                                            this.render(time, suppressEvents, !1),
                                        _lazyTweens.length && _lazyRender())
                                    }
                                    return this
                                }
                                ,
                                p.progress = p.totalProgress = function(value, suppressEvents) {
                                    var duration = this.duration();
                                    return arguments.length ? this.totalTime(duration * value, suppressEvents) : duration ? this._time / duration : this.ratio
                                }
                                ,
                                p.startTime = function(value) {
                                    return arguments.length ? (value !== this._startTime && (this._startTime = value,
                                    this.timeline && this.timeline._sortChildren && this.timeline.add(this, value - this._delay)),
                                        this) : this._startTime
                                }
                                ,
                                p.endTime = function(includeRepeats) {
                                    return this._startTime + (0 != includeRepeats ? this.totalDuration() : this.duration()) / this._timeScale
                                }
                                ,
                                p.timeScale = function(value) {
                                    if (!arguments.length)
                                        return this._timeScale;
                                    if (value = value || _tinyNum,
                                        this._timeline && this._timeline.smoothChildTiming) {
                                        var pauseTime = this._pauseTime
                                            , t = pauseTime || 0 === pauseTime ? pauseTime : this._timeline.totalTime();
                                        this._startTime = t - (t - this._startTime) * this._timeScale / value
                                    }
                                    return this._timeScale = value,
                                        this._uncache(!1)
                                }
                                ,
                                p.reversed = function(value) {
                                    return arguments.length ? (value != this._reversed && (this._reversed = value,
                                        this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)),
                                        this) : this._reversed
                                }
                                ,
                                p.paused = function(value) {
                                    if (!arguments.length)
                                        return this._paused;
                                    var raw, elapsed, tl = this._timeline;
                                    return value != this._paused && tl && (_tickerActive || value || _ticker.wake(),
                                        raw = tl.rawTime(),
                                        elapsed = raw - this._pauseTime,
                                    !value && tl.smoothChildTiming && (this._startTime += elapsed,
                                        this._uncache(!1)),
                                        this._pauseTime = value ? raw : null,
                                        this._paused = value,
                                        this._active = this.isActive(),
                                    !value && 0 !== elapsed && this._initted && this.duration() && (raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale,
                                        this.render(raw, raw === this._totalTime, !0))),
                                    this._gc && !value && this._enabled(!0, !1),
                                        this
                                }
                            ;
                            var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
                                Animation.call(this, 0, vars),
                                    this.autoRemoveChildren = this.smoothChildTiming = !0
                            });
                            p = SimpleTimeline.prototype = new Animation,
                                p.constructor = SimpleTimeline,
                                p.kill()._gc = !1,
                                p._first = p._last = p._recent = null,
                                p._sortChildren = !1,
                                p.add = p.insert = function(child, position, align, stagger) {
                                    var prevTween, st;
                                    if (child._startTime = Number(position || 0) + child._delay,
                                        child._paused && this !== child._timeline && (child._pauseTime = child._startTime + (this.rawTime() - child._startTime) / child._timeScale),
                                        child.timeline && child.timeline._remove(child, !0),
                                            child.timeline = child._timeline = this,
                                        child._gc && child._enabled(!0, !0),
                                            prevTween = this._last,
                                            this._sortChildren)
                                        for (st = child._startTime; prevTween && prevTween._startTime > st; )
                                            prevTween = prevTween._prev;
                                    return prevTween ? (child._next = prevTween._next,
                                        prevTween._next = child) : (child._next = this._first,
                                        this._first = child),
                                        child._next ? child._next._prev = child : this._last = child,
                                        child._prev = prevTween,
                                        this._recent = child,
                                    this._timeline && this._uncache(!0),
                                        this
                                }
                                ,
                                p._remove = function(tween, skipDisable) {
                                    return tween.timeline === this && (skipDisable || tween._enabled(!1, !0),
                                        tween._prev ? tween._prev._next = tween._next : this._first === tween && (this._first = tween._next),
                                        tween._next ? tween._next._prev = tween._prev : this._last === tween && (this._last = tween._prev),
                                        tween._next = tween._prev = tween.timeline = null,
                                    tween === this._recent && (this._recent = this._last),
                                    this._timeline && this._uncache(!0)),
                                        this
                                }
                                ,
                                p.render = function(time, suppressEvents, force) {
                                    var next, tween = this._first;
                                    for (this._totalTime = this._time = this._rawPrevTime = time; tween; )
                                        next = tween._next,
                                        (tween._active || time >= tween._startTime && !tween._paused) && (tween._reversed ? tween.render((tween._dirty ? tween.totalDuration() : tween._totalDuration) - (time - tween._startTime) * tween._timeScale, suppressEvents, force) : tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)),
                                            tween = next
                                }
                                ,
                                p.rawTime = function() {
                                    return _tickerActive || _ticker.wake(),
                                        this._totalTime
                                }
                            ;
                            var TweenLite = _class("TweenLite", function(target, duration, vars) {
                                if (Animation.call(this, duration, vars),
                                        this.render = TweenLite.prototype.render,
                                    null == target)
                                    throw "Cannot tween a null target.";
                                this.target = target = "string" != typeof target ? target : TweenLite.selector(target) || target;
                                var i, targ, targets, isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType), overwrite = this.vars.overwrite;
                                if (this._overwrite = overwrite = null == overwrite ? _overwriteLookup[TweenLite.defaultOverwrite] : "number" == typeof overwrite ? overwrite >> 0 : _overwriteLookup[overwrite],
                                    (isSelector || target instanceof Array || target.push && _isArray(target)) && "number" != typeof target[0])
                                    for (this._targets = targets = _slice(target),
                                             this._propLookup = [],
                                             this._siblings = [],
                                             i = 0; i < targets.length; i++)
                                        targ = targets[i],
                                            targ ? "string" != typeof targ ? targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType) ? (targets.splice(i--, 1),
                                                this._targets = targets = targets.concat(_slice(targ))) : (this._siblings[i] = _register(targ, this, !1),
                                            1 === overwrite && this._siblings[i].length > 1 && _applyOverwrite(targ, this, null, 1, this._siblings[i])) : (targ = targets[i--] = TweenLite.selector(targ),
                                            "string" == typeof targ && targets.splice(i + 1, 1)) : targets.splice(i--, 1);
                                else
                                    this._propLookup = {},
                                        this._siblings = _register(target, this, !1),
                                    1 === overwrite && this._siblings.length > 1 && _applyOverwrite(target, this, null, 1, this._siblings);
                                (this.vars.immediateRender || 0 === duration && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -_tinyNum,
                                    this.render(Math.min(0, -this._delay)))
                            }, !0)
                                , _isSelector = function(v) {
                                return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType)
                            }
                                , _autoCSS = function(vars, target) {
                                var p, css = {};
                                for (p in vars)
                                    _reservedProps[p] || p in target && "transform" !== p && "x" !== p && "y" !== p && "width" !== p && "height" !== p && "className" !== p && "border" !== p || !(!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS) || (css[p] = vars[p],
                                        delete vars[p]);
                                vars.css = css
                            };
                            p = TweenLite.prototype = new Animation,
                                p.constructor = TweenLite,
                                p.kill()._gc = !1,
                                p.ratio = 0,
                                p._firstPT = p._targets = p._overwrittenProps = p._startAt = null,
                                p._notifyPluginsOfEnabled = p._lazy = !1,
                                TweenLite.version = "1.19.0",
                                TweenLite.defaultEase = p._ease = new Ease(null,null,1,1),
                                TweenLite.defaultOverwrite = "auto",
                                TweenLite.ticker = _ticker,
                                TweenLite.autoSleep = 120,
                                TweenLite.lagSmoothing = function(threshold, adjustedLag) {
                                    _ticker.lagSmoothing(threshold, adjustedLag)
                                }
                                ,
                                TweenLite.selector = window.$ || window.jQuery || function(e) {
                                        var selector = window.$ || window.jQuery;
                                        return selector ? (TweenLite.selector = selector,
                                            selector(e)) : "undefined" == typeof document ? e : document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById("#" === e.charAt(0) ? e.substr(1) : e)
                                    }
                            ;
                            var _lazyTweens = []
                                , _lazyLookup = {}
                                , _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi
                                , _setRatio = function(v) {
                                    for (var val, pt = this._firstPT, min = 1e-6; pt; )
                                        val = pt.blob ? v ? this.join("") : this.start : pt.c * v + pt.s,
                                            pt.m ? val = pt.m(val, this._target || pt.t) : val < min && val > -min && (val = 0),
                                            pt.f ? pt.fp ? pt.t[pt.p](pt.fp, val) : pt.t[pt.p](val) : pt.t[pt.p] = val,
                                            pt = pt._next
                                }
                                , _blobDif = function(start, end, filter, pt) {
                                    var startNums, endNums, num, i, l, nonNumbers, currentNum, a = [start, end], charIndex = 0, s = "", color = 0;
                                    for (a.start = start,
                                         filter && (filter(a),
                                             start = a[0],
                                             end = a[1]),
                                             a.length = 0,
                                             startNums = start.match(_numbersExp) || [],
                                             endNums = end.match(_numbersExp) || [],
                                         pt && (pt._next = null,
                                             pt.blob = 1,
                                             a._firstPT = a._applyPT = pt),
                                             l = endNums.length,
                                             i = 0; i < l; i++)
                                        currentNum = endNums[i],
                                            nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex),
                                            s += nonNumbers || !i ? nonNumbers : ",",
                                            charIndex += nonNumbers.length,
                                            color ? color = (color + 1) % 5 : "rgba(" === nonNumbers.substr(-5) && (color = 1),
                                            currentNum === startNums[i] || startNums.length <= i ? s += currentNum : (s && (a.push(s),
                                                s = ""),
                                                num = parseFloat(startNums[i]),
                                                a.push(num),
                                                a._firstPT = {
                                                    _next: a._firstPT,
                                                    t: a,
                                                    p: a.length - 1,
                                                    s: num,
                                                    c: ("=" === currentNum.charAt(1) ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : parseFloat(currentNum) - num) || 0,
                                                    f: 0,
                                                    m: color && color < 4 ? Math.round : 0
                                                }),
                                            charIndex += currentNum.length;
                                    return s += end.substr(charIndex),
                                    s && a.push(s),
                                        a.setRatio = _setRatio,
                                        a
                                }
                                , _addPropTween = function(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
                                    "function" == typeof end && (end = end(index || 0, target));
                                    var blob, getterName, s = "get" === start ? target[prop] : start, type = typeof target[prop], isRelative = "string" == typeof end && "=" === end.charAt(1), pt = {
                                        t: target,
                                        p: prop,
                                        s: s,
                                        f: "function" === type,
                                        pg: 0,
                                        n: overwriteProp || prop,
                                        m: mod ? "function" == typeof mod ? mod : Math.round : 0,
                                        pr: 0,
                                        c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : parseFloat(end) - s || 0
                                    };
                                    if ("number" !== type && ("function" === type && "get" === start && (getterName = prop.indexOf("set") || "function" != typeof target["get" + prop.substr(3)] ? prop : "get" + prop.substr(3),
                                            pt.s = s = funcParam ? target[getterName](funcParam) : target[getterName]()),
                                            "string" == typeof s && (funcParam || isNaN(s)) ? (pt.fp = funcParam,
                                                blob = _blobDif(s, end, stringFilter || TweenLite.defaultStringFilter, pt),
                                                pt = {
                                                    t: blob,
                                                    p: "setRatio",
                                                    s: 0,
                                                    c: 1,
                                                    f: 2,
                                                    pg: 0,
                                                    n: overwriteProp || prop,
                                                    pr: 0,
                                                    m: 0
                                                }) : isRelative || (pt.s = parseFloat(s),
                                                pt.c = parseFloat(end) - pt.s || 0)),
                                            pt.c)
                                        return (pt._next = this._firstPT) && (pt._next._prev = pt),
                                            this._firstPT = pt,
                                            pt
                                }
                                , _internals = TweenLite._internals = {
                                    isArray: _isArray,
                                    isSelector: _isSelector,
                                    lazyTweens: _lazyTweens,
                                    blobDif: _blobDif
                                }
                                , _plugins = TweenLite._plugins = {}
                                , _tweenLookup = _internals.tweenLookup = {}
                                , _tweenLookupNum = 0
                                , _reservedProps = _internals.reservedProps = {
                                    ease: 1,
                                    delay: 1,
                                    overwrite: 1,
                                    onComplete: 1,
                                    onCompleteParams: 1,
                                    onCompleteScope: 1,
                                    useFrames: 1,
                                    runBackwards: 1,
                                    startAt: 1,
                                    onUpdate: 1,
                                    onUpdateParams: 1,
                                    onUpdateScope: 1,
                                    onStart: 1,
                                    onStartParams: 1,
                                    onStartScope: 1,
                                    onReverseComplete: 1,
                                    onReverseCompleteParams: 1,
                                    onReverseCompleteScope: 1,
                                    onRepeat: 1,
                                    onRepeatParams: 1,
                                    onRepeatScope: 1,
                                    easeParams: 1,
                                    yoyo: 1,
                                    immediateRender: 1,
                                    repeat: 1,
                                    repeatDelay: 1,
                                    data: 1,
                                    paused: 1,
                                    reversed: 1,
                                    autoCSS: 1,
                                    lazy: 1,
                                    onOverwrite: 1,
                                    callbackScope: 1,
                                    stringFilter: 1,
                                    id: 1
                                }
                                , _overwriteLookup = {
                                    none: 0,
                                    all: 1,
                                    auto: 2,
                                    concurrent: 3,
                                    allOnStart: 4,
                                    preexisting: 5,
                                    true: 1,
                                    false: 0
                                }
                                , _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline
                                , _rootTimeline = Animation._rootTimeline = new SimpleTimeline
                                , _nextGCFrame = 30
                                , _lazyRender = _internals.lazyRender = function() {
                                    var tween, i = _lazyTweens.length;
                                    for (_lazyLookup = {}; --i > -1; )
                                        tween = _lazyTweens[i],
                                        tween && tween._lazy !== !1 && (tween.render(tween._lazy[0], tween._lazy[1], !0),
                                            tween._lazy = !1);
                                    _lazyTweens.length = 0
                                }
                                ;
                            _rootTimeline._startTime = _ticker.time,
                                _rootFramesTimeline._startTime = _ticker.frame,
                                _rootTimeline._active = _rootFramesTimeline._active = !0,
                                setTimeout(_lazyRender, 1),
                                Animation._updateRoot = TweenLite.render = function() {
                                    var i, a, p;
                                    if (_lazyTweens.length && _lazyRender(),
                                            _rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, !1, !1),
                                            _rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, !1, !1),
                                        _lazyTweens.length && _lazyRender(),
                                        _ticker.frame >= _nextGCFrame) {
                                        _nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
                                        for (p in _tweenLookup) {
                                            for (a = _tweenLookup[p].tweens,
                                                     i = a.length; --i > -1; )
                                                a[i]._gc && a.splice(i, 1);
                                            0 === a.length && delete _tweenLookup[p]
                                        }
                                        if (p = _rootTimeline._first,
                                            (!p || p._paused) && TweenLite.autoSleep && !_rootFramesTimeline._first && 1 === _ticker._listeners.tick.length) {
                                            for (; p && p._paused; )
                                                p = p._next;
                                            p || _ticker.sleep()
                                        }
                                    }
                                }
                                ,
                                _ticker.addEventListener("tick", Animation._updateRoot);
                            var _register = function(target, tween, scrub) {
                                var a, i, id = target._gsTweenID;
                                if (_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)] || (_tweenLookup[id] = {
                                        target: target,
                                        tweens: []
                                    }),
                                    tween && (a = _tweenLookup[id].tweens,
                                        a[i = a.length] = tween,
                                        scrub))
                                    for (; --i > -1; )
                                        a[i] === tween && a.splice(i, 1);
                                return _tweenLookup[id].tweens
                            }
                                , _onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
                                var r1, r2, func = overwrittenTween.vars.onOverwrite;
                                return func && (r1 = func(overwrittenTween, overwritingTween, target, killedProps)),
                                    func = TweenLite.onOverwrite,
                                func && (r2 = func(overwrittenTween, overwritingTween, target, killedProps)),
                                r1 !== !1 && r2 !== !1
                            }
                                , _applyOverwrite = function(target, tween, props, mode, siblings) {
                                var i, changed, curTween, l;
                                if (1 === mode || mode >= 4) {
                                    for (l = siblings.length,
                                             i = 0; i < l; i++)
                                        if ((curTween = siblings[i]) !== tween)
                                            curTween._gc || curTween._kill(null, target, tween) && (changed = !0);
                                        else if (5 === mode)
                                            break;
                                    return changed
                                }
                                var globalStart, startTime = tween._startTime + _tinyNum, overlaps = [], oCount = 0, zeroDur = 0 === tween._duration;
                                for (i = siblings.length; --i > -1; )
                                    (curTween = siblings[i]) === tween || curTween._gc || curTween._paused || (curTween._timeline !== tween._timeline ? (globalStart = globalStart || _checkOverlap(tween, 0, zeroDur),
                                    0 === _checkOverlap(curTween, globalStart, zeroDur) && (overlaps[oCount++] = curTween)) : curTween._startTime <= startTime && curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime && ((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 2e-10 || (overlaps[oCount++] = curTween)));
                                for (i = oCount; --i > -1; )
                                    if (curTween = overlaps[i],
                                        2 === mode && curTween._kill(props, target, tween) && (changed = !0),
                                        2 !== mode || !curTween._firstPT && curTween._initted) {
                                        if (2 !== mode && !_onOverwrite(curTween, tween))
                                            continue;
                                        curTween._enabled(!1, !1) && (changed = !0)
                                    }
                                return changed
                            }
                                , _checkOverlap = function(tween, reference, zeroDur) {
                                for (var tl = tween._timeline, ts = tl._timeScale, t = tween._startTime; tl._timeline; ) {
                                    if (t += tl._startTime,
                                            ts *= tl._timeScale,
                                            tl._paused)
                                        return -100;
                                    tl = tl._timeline
                                }
                                return t /= ts,
                                    t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum
                            };
                            p._init = function() {
                                var i, initPlugins, pt, p, startVars, l, v = this.vars, op = this._overwrittenProps, dur = this._duration, immediate = !!v.immediateRender, ease = v.ease;
                                if (v.startAt) {
                                    this._startAt && (this._startAt.render(-1, !0),
                                        this._startAt.kill()),
                                        startVars = {};
                                    for (p in v.startAt)
                                        startVars[p] = v.startAt[p];
                                    if (startVars.overwrite = !1,
                                            startVars.immediateRender = !0,
                                            startVars.lazy = immediate && v.lazy !== !1,
                                            startVars.startAt = startVars.delay = null,
                                            this._startAt = TweenLite.to(this.target, 0, startVars),
                                            immediate)
                                        if (this._time > 0)
                                            this._startAt = null;
                                        else if (0 !== dur)
                                            return
                                } else if (v.runBackwards && 0 !== dur)
                                    if (this._startAt)
                                        this._startAt.render(-1, !0),
                                            this._startAt.kill(),
                                            this._startAt = null;
                                    else {
                                        0 !== this._time && (immediate = !1),
                                            pt = {};
                                        for (p in v)
                                            _reservedProps[p] && "autoCSS" !== p || (pt[p] = v[p]);
                                        if (pt.overwrite = 0,
                                                pt.data = "isFromStart",
                                                pt.lazy = immediate && v.lazy !== !1,
                                                pt.immediateRender = immediate,
                                                this._startAt = TweenLite.to(this.target, 0, pt),
                                                immediate) {
                                            if (0 === this._time)
                                                return
                                        } else
                                            this._startAt._init(),
                                                this._startAt._enabled(!1),
                                            this.vars.immediateRender && (this._startAt = null)
                                    }
                                if (this._ease = ease = ease ? ease instanceof Ease ? ease : "function" == typeof ease ? new Ease(ease,v.easeParams) : _easeMap[ease] || TweenLite.defaultEase : TweenLite.defaultEase,
                                    v.easeParams instanceof Array && ease.config && (this._ease = ease.config.apply(ease, v.easeParams)),
                                        this._easeType = this._ease._type,
                                        this._easePower = this._ease._power,
                                        this._firstPT = null,
                                        this._targets)
                                    for (l = this._targets.length,
                                             i = 0; i < l; i++)
                                        this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null, i) && (initPlugins = !0);
                                else
                                    initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
                                if (initPlugins && TweenLite._onPluginEvent("_onInitAllProps", this),
                                    op && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)),
                                        v.runBackwards)
                                    for (pt = this._firstPT; pt; )
                                        pt.s += pt.c,
                                            pt.c = -pt.c,
                                            pt = pt._next;
                                this._onUpdate = v.onUpdate,
                                    this._initted = !0
                            }
                                ,
                                p._initProps = function(target, propLookup, siblings, overwrittenProps, index) {
                                    var p, i, initPlugins, plugin, pt, v;
                                    if (null == target)
                                        return !1;
                                    _lazyLookup[target._gsTweenID] && _lazyRender(),
                                    this.vars.css || target.style && target !== window && target.nodeType && _plugins.css && this.vars.autoCSS !== !1 && _autoCSS(this.vars, target);
                                    for (p in this.vars)
                                        if (v = this.vars[p],
                                                _reservedProps[p])
                                            v && (v instanceof Array || v.push && _isArray(v)) && v.join("").indexOf("{self}") !== -1 && (this.vars[p] = v = this._swapSelfInParams(v, this));
                                        else if (_plugins[p] && (plugin = new _plugins[p])._onInitTween(target, this.vars[p], this, index)) {
                                            for (this._firstPT = pt = {
                                                _next: this._firstPT,
                                                t: plugin,
                                                p: "setRatio",
                                                s: 0,
                                                c: 1,
                                                f: 1,
                                                n: p,
                                                pg: 1,
                                                pr: plugin._priority,
                                                m: 0
                                            },
                                                     i = plugin._overwriteProps.length; --i > -1; )
                                                propLookup[plugin._overwriteProps[i]] = this._firstPT;
                                            (plugin._priority || plugin._onInitAllProps) && (initPlugins = !0),
                                            (plugin._onDisable || plugin._onEnable) && (this._notifyPluginsOfEnabled = !0),
                                            pt._next && (pt._next._prev = pt)
                                        } else
                                            propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
                                    return overwrittenProps && this._kill(overwrittenProps, target) ? this._initProps(target, propLookup, siblings, overwrittenProps, index) : this._overwrite > 1 && this._firstPT && siblings.length > 1 && _applyOverwrite(target, this, propLookup, this._overwrite, siblings) ? (this._kill(propLookup, target),
                                        this._initProps(target, propLookup, siblings, overwrittenProps, index)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (_lazyLookup[target._gsTweenID] = !0),
                                        initPlugins)
                                }
                                ,
                                p.render = function(time, suppressEvents, force) {
                                    var isComplete, callback, pt, rawPrevTime, prevTime = this._time, duration = this._duration, prevRawPrevTime = this._rawPrevTime;
                                    if (time >= duration - 1e-7)
                                        this._totalTime = this._time = duration,
                                            this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1,
                                        this._reversed || (isComplete = !0,
                                            callback = "onComplete",
                                            force = force || this._timeline.autoRemoveChildren),
                                        0 === duration && (this._initted || !this.vars.lazy || force) && (this._startTime === this._timeline._duration && (time = 0),
                                        (prevRawPrevTime < 0 || time <= 0 && time >= -1e-7 || prevRawPrevTime === _tinyNum && "isPause" !== this.data) && prevRawPrevTime !== time && (force = !0,
                                        prevRawPrevTime > _tinyNum && (callback = "onReverseComplete")),
                                            this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum);
                                    else if (time < 1e-7)
                                        this._totalTime = this._time = 0,
                                            this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0,
                                        (0 !== prevTime || 0 === duration && prevRawPrevTime > 0) && (callback = "onReverseComplete",
                                            isComplete = this._reversed),
                                        time < 0 && (this._active = !1,
                                        0 === duration && (this._initted || !this.vars.lazy || force) && (prevRawPrevTime >= 0 && (prevRawPrevTime !== _tinyNum || "isPause" !== this.data) && (force = !0),
                                            this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum)),
                                        this._initted || (force = !0);
                                    else if (this._totalTime = this._time = time,
                                            this._easeType) {
                                        var r = time / duration
                                            , type = this._easeType
                                            , pow = this._easePower;
                                        (1 === type || 3 === type && r >= .5) && (r = 1 - r),
                                        3 === type && (r *= 2),
                                            1 === pow ? r *= r : 2 === pow ? r *= r * r : 3 === pow ? r *= r * r * r : 4 === pow && (r *= r * r * r * r),
                                            1 === type ? this.ratio = 1 - r : 2 === type ? this.ratio = r : time / duration < .5 ? this.ratio = r / 2 : this.ratio = 1 - r / 2
                                    } else
                                        this.ratio = this._ease.getRatio(time / duration);
                                    if (this._time !== prevTime || force) {
                                        if (!this._initted) {
                                            if (this._init(),
                                                !this._initted || this._gc)
                                                return;
                                            if (!force && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
                                                return this._time = this._totalTime = prevTime,
                                                    this._rawPrevTime = prevRawPrevTime,
                                                    _lazyTweens.push(this),
                                                    void (this._lazy = [time, suppressEvents]);
                                            this._time && !isComplete ? this.ratio = this._ease.getRatio(this._time / duration) : isComplete && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                                        }
                                        for (this._lazy !== !1 && (this._lazy = !1),
                                             this._active || !this._paused && this._time !== prevTime && time >= 0 && (this._active = !0),
                                             0 === prevTime && (this._startAt && (time >= 0 ? this._startAt.render(time, suppressEvents, force) : callback || (callback = "_dummyGS")),
                                             this.vars.onStart && (0 === this._time && 0 !== duration || suppressEvents || this._callback("onStart"))),
                                                 pt = this._firstPT; pt; )
                                            pt.f ? pt.t[pt.p](pt.c * this.ratio + pt.s) : pt.t[pt.p] = pt.c * this.ratio + pt.s,
                                                pt = pt._next;
                                        this._onUpdate && (time < 0 && this._startAt && time !== -1e-4 && this._startAt.render(time, suppressEvents, force),
                                        suppressEvents || (this._time !== prevTime || isComplete || force) && this._callback("onUpdate")),
                                        callback && (this._gc && !force || (time < 0 && this._startAt && !this._onUpdate && time !== -1e-4 && this._startAt.render(time, suppressEvents, force),
                                        isComplete && (this._timeline.autoRemoveChildren && this._enabled(!1, !1),
                                            this._active = !1),
                                        !suppressEvents && this.vars[callback] && this._callback(callback),
                                        0 === duration && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum && (this._rawPrevTime = 0)))
                                    }
                                }
                                ,
                                p._kill = function(vars, target, overwritingTween) {
                                    if ("all" === vars && (vars = null),
                                        null == vars && (null == target || target === this.target))
                                        return this._lazy = !1,
                                            this._enabled(!1, !1);
                                    target = "string" != typeof target ? target || this._targets || this.target : TweenLite.selector(target) || target;
                                    var i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed, simultaneousOverwrite = overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline;
                                    if ((_isArray(target) || _isSelector(target)) && "number" != typeof target[0])
                                        for (i = target.length; --i > -1; )
                                            this._kill(vars, target[i], overwritingTween) && (changed = !0);
                                    else {
                                        if (this._targets) {
                                            for (i = this._targets.length; --i > -1; )
                                                if (target === this._targets[i]) {
                                                    propLookup = this._propLookup[i] || {},
                                                        this._overwrittenProps = this._overwrittenProps || [],
                                                        overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
                                                    break
                                                }
                                        } else {
                                            if (target !== this.target)
                                                return !1;
                                            propLookup = this._propLookup,
                                                overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all"
                                        }
                                        if (propLookup) {
                                            if (killProps = vars || propLookup,
                                                    record = vars !== overwrittenProps && "all" !== overwrittenProps && vars !== propLookup && ("object" != typeof vars || !vars._tempKill),
                                                overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
                                                for (p in killProps)
                                                    propLookup[p] && (killed || (killed = []),
                                                        killed.push(p));
                                                if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed))
                                                    return !1
                                            }
                                            for (p in killProps)
                                                (pt = propLookup[p]) && (simultaneousOverwrite && (pt.f ? pt.t[pt.p](pt.s) : pt.t[pt.p] = pt.s,
                                                    changed = !0),
                                                pt.pg && pt.t._kill(killProps) && (changed = !0),
                                                pt.pg && 0 !== pt.t._overwriteProps.length || (pt._prev ? pt._prev._next = pt._next : pt === this._firstPT && (this._firstPT = pt._next),
                                                pt._next && (pt._next._prev = pt._prev),
                                                    pt._next = pt._prev = null),
                                                    delete propLookup[p]),
                                                record && (overwrittenProps[p] = 1);
                                            !this._firstPT && this._initted && this._enabled(!1, !1)
                                        }
                                    }
                                    return changed
                                }
                                ,
                                p.invalidate = function() {
                                    return this._notifyPluginsOfEnabled && TweenLite._onPluginEvent("_onDisable", this),
                                        this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null,
                                        this._notifyPluginsOfEnabled = this._active = this._lazy = !1,
                                        this._propLookup = this._targets ? {} : [],
                                        Animation.prototype.invalidate.call(this),
                                    this.vars.immediateRender && (this._time = -_tinyNum,
                                        this.render(Math.min(0, -this._delay))),
                                        this
                                }
                                ,
                                p._enabled = function(enabled, ignoreTimeline) {
                                    if (_tickerActive || _ticker.wake(),
                                        enabled && this._gc) {
                                        var i, targets = this._targets;
                                        if (targets)
                                            for (i = targets.length; --i > -1; )
                                                this._siblings[i] = _register(targets[i], this, !0);
                                        else
                                            this._siblings = _register(this.target, this, !0)
                                    }
                                    return Animation.prototype._enabled.call(this, enabled, ignoreTimeline),
                                    !(!this._notifyPluginsOfEnabled || !this._firstPT) && TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this)
                                }
                                ,
                                TweenLite.to = function(target, duration, vars) {
                                    return new TweenLite(target,duration,vars)
                                }
                                ,
                                TweenLite.from = function(target, duration, vars) {
                                    return vars.runBackwards = !0,
                                        vars.immediateRender = 0 != vars.immediateRender,
                                        new TweenLite(target,duration,vars)
                                }
                                ,
                                TweenLite.fromTo = function(target, duration, fromVars, toVars) {
                                    return toVars.startAt = fromVars,
                                        toVars.immediateRender = 0 != toVars.immediateRender && 0 != fromVars.immediateRender,
                                        new TweenLite(target,duration,toVars)
                                }
                                ,
                                TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
                                    return new TweenLite(callback,0,{
                                        delay: delay,
                                        onComplete: callback,
                                        onCompleteParams: params,
                                        callbackScope: scope,
                                        onReverseComplete: callback,
                                        onReverseCompleteParams: params,
                                        immediateRender: !1,
                                        lazy: !1,
                                        useFrames: useFrames,
                                        overwrite: 0
                                    })
                                }
                                ,
                                TweenLite.set = function(target, vars) {
                                    return new TweenLite(target,0,vars)
                                }
                                ,
                                TweenLite.getTweensOf = function(target, onlyActive) {
                                    if (null == target)
                                        return [];
                                    target = "string" != typeof target ? target : TweenLite.selector(target) || target;
                                    var i, a, j, t;
                                    if ((_isArray(target) || _isSelector(target)) && "number" != typeof target[0]) {
                                        for (i = target.length,
                                                 a = []; --i > -1; )
                                            a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
                                        for (i = a.length; --i > -1; )
                                            for (t = a[i],
                                                     j = i; --j > -1; )
                                                t === a[j] && a.splice(i, 1)
                                    } else
                                        for (a = _register(target).concat(),
                                                 i = a.length; --i > -1; )
                                            (a[i]._gc || onlyActive && !a[i].isActive()) && a.splice(i, 1);
                                    return a
                                }
                                ,
                                TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
                                    "object" == typeof onlyActive && (vars = onlyActive,
                                        onlyActive = !1);
                                    for (var a = TweenLite.getTweensOf(target, onlyActive), i = a.length; --i > -1; )
                                        a[i]._kill(vars, target)
                                }
                            ;
                            var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
                                this._overwriteProps = (props || "").split(","),
                                    this._propName = this._overwriteProps[0],
                                    this._priority = priority || 0,
                                    this._super = TweenPlugin.prototype
                            }, !0);
                            if (p = TweenPlugin.prototype,
                                    TweenPlugin.version = "1.19.0",
                                    TweenPlugin.API = 2,
                                    p._firstPT = null,
                                    p._addTween = _addPropTween,
                                    p.setRatio = _setRatio,
                                    p._kill = function(lookup) {
                                        var i, a = this._overwriteProps, pt = this._firstPT;
                                        if (null != lookup[this._propName])
                                            this._overwriteProps = [];
                                        else
                                            for (i = a.length; --i > -1; )
                                                null != lookup[a[i]] && a.splice(i, 1);
                                        for (; pt; )
                                            null != lookup[pt.n] && (pt._next && (pt._next._prev = pt._prev),
                                                pt._prev ? (pt._prev._next = pt._next,
                                                    pt._prev = null) : this._firstPT === pt && (this._firstPT = pt._next)),
                                                pt = pt._next;
                                        return !1
                                    }
                                    ,
                                    p._mod = p._roundProps = function(lookup) {
                                        for (var val, pt = this._firstPT; pt; )
                                            val = lookup[this._propName] || null != pt.n && lookup[pt.n.split(this._propName + "_").join("")],
                                            val && "function" == typeof val && (2 === pt.f ? pt.t._applyPT.m = val : pt.m = val),
                                                pt = pt._next
                                    }
                                    ,
                                    TweenLite._onPluginEvent = function(type, tween) {
                                        var changed, pt2, first, last, next, pt = tween._firstPT;
                                        if ("_onInitAllProps" === type) {
                                            for (; pt; ) {
                                                for (next = pt._next,
                                                         pt2 = first; pt2 && pt2.pr > pt.pr; )
                                                    pt2 = pt2._next;
                                                (pt._prev = pt2 ? pt2._prev : last) ? pt._prev._next = pt : first = pt,
                                                    (pt._next = pt2) ? pt2._prev = pt : last = pt,
                                                    pt = next
                                            }
                                            pt = tween._firstPT = first
                                        }
                                        for (; pt; )
                                            pt.pg && "function" == typeof pt.t[type] && pt.t[type]() && (changed = !0),
                                                pt = pt._next;
                                        return changed
                                    }
                                    ,
                                    TweenPlugin.activate = function(plugins) {
                                        for (var i = plugins.length; --i > -1; )
                                            plugins[i].API === TweenPlugin.API && (_plugins[(new plugins[i])._propName] = plugins[i]);
                                        return !0
                                    }
                                    ,
                                    _gsDefine.plugin = function(config) {
                                        if (!(config && config.propName && config.init && config.API))
                                            throw "illegal plugin definition.";
                                        var prop, propName = config.propName, priority = config.priority || 0, overwriteProps = config.overwriteProps, map = {
                                            init: "_onInitTween",
                                            set: "setRatio",
                                            kill: "_kill",
                                            round: "_mod",
                                            mod: "_mod",
                                            initAll: "_onInitAllProps"
                                        }, Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function() {
                                            TweenPlugin.call(this, propName, priority),
                                                this._overwriteProps = overwriteProps || []
                                        }, config.global === !0), p = Plugin.prototype = new TweenPlugin(propName);
                                        p.constructor = Plugin,
                                            Plugin.API = config.API;
                                        for (prop in map)
                                            "function" == typeof config[prop] && (p[map[prop]] = config[prop]);
                                        return Plugin.version = config.version,
                                            TweenPlugin.activate([Plugin]),
                                            Plugin
                                    }
                                    ,
                                    a = window._gsQueue) {
                                for (i = 0; i < a.length; i++)
                                    a[i]();
                                for (p in _defLookup)
                                    _defLookup[p].func || window.console.log("GSAP encountered missing dependency: " + p)
                            }
                            _tickerActive = !1
                        }
                    }("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window, "TweenMax")
            }
        ).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }
        , {}],
    81: [function(require, module, exports) {
        var BaseClass = require("./baseClass")
            , Class = function(descriptor) {
            var rVal = void 0;
            void 0 === descriptor && (descriptor = {}),
                descriptor.initialize ? (rVal = descriptor.initialize,
                    delete descriptor.initialize) : rVal = function() {
                    Array.prototype.splice.apply(arguments, [0, 0, this]),
                        Class.parent.apply(void 0, arguments)
                }
                ,
                void 0 !== descriptor.Extends ? (descriptor.Extends.$$isConstructor = !0,
                    rVal.prototype = Object.create(descriptor.Extends.prototype),
                    rVal.$$parentConstructor = descriptor.Extends,
                    delete descriptor.Extends) : (rVal.prototype = Object.create(BaseClass),
                        rVal.$$parentConstructor = function() {}
                ),
                rVal.prototype.$$getters = {},
                rVal.prototype.$$setters = {};
            for (var i in descriptor)
                "function" == typeof descriptor[i] ? (descriptor[i].$$name = i,
                    descriptor[i].$$owner = rVal.prototype,
                    rVal.prototype[i] = descriptor[i]) : descriptor[i] && "object" == typeof descriptor[i] && (descriptor[i].get || descriptor[i].set) ? (Object.defineProperty(rVal.prototype, i, descriptor[i]),
                descriptor[i].get && (rVal.prototype.$$getters[i] = descriptor[i].get,
                    descriptor[i].get.$$name = i,
                    descriptor[i].get.$$owner = rVal.prototype),
                descriptor[i].set && (rVal.prototype.$$setters[i] = descriptor[i].set,
                    descriptor[i].set.$$name = i,
                    descriptor[i].set.$$owner = rVal.prototype)) : rVal.prototype[i] = descriptor[i];
            rVal.$$isConstructor = !0;
            for (var i = 1; i < arguments.length; i++)
                arguments[i].compare(rVal);
            return rVal
        };
        Class.parent = function(scope) {
            var caller = Class.parent.caller;
            if (arguments = Array.prototype.slice.apply(arguments, [1]),
                    caller.$$isConstructor)
                var parentFunction = caller.$$parentConstructor;
            else {
                if (!caller.$$name)
                    throw "You cannot call parent here";
                var callerName = caller.$$name
                    , isGetter = caller.$$owner.$$getters[callerName]
                    , isSetter = caller.$$owner.$$setters[callerName];
                if (1 == arguments.length && isSetter) {
                    var parentFunction = Object.getPrototypeOf(caller.$$owner).$$setters[callerName];
                    if (void 0 === parentFunction)
                        throw "No setter defined in parent"
                } else if (0 == arguments.length && isGetter) {
                    var parentFunction = Object.getPrototypeOf(caller.$$owner).$$getters[callerName];
                    if (void 0 === parentFunction)
                        throw "No getter defined in parent"
                } else {
                    if (isSetter || isGetter)
                        throw "Incorrect amount of arguments sent to getter or setter";
                    var parentFunction = Object.getPrototypeOf(caller.$$owner)[callerName];
                    if (void 0 === parentFunction)
                        throw "No parent function defined for " + callerName
                }
            }
            return parentFunction.apply(scope, arguments)
        }
            ,
            module.exports = Class
    }
        , {
            "./baseClass": 82
        }],
    82: [function(require, module, exports) {
        module.exports = {
            parent: function() {
                if (this.parent.caller.$$isConstructor)
                    var parentFunction = this.parent.caller.$$parentConstructor;
                else {
                    if (!this.parent.caller.$$name)
                        throw "You cannot call parent here";
                    var callerName = this.parent.caller.$$name
                        , isGetter = this.parent.caller.$$owner.$$getters[callerName]
                        , isSetter = this.parent.caller.$$owner.$$setters[callerName];
                    if (1 == arguments.length && isSetter) {
                        var parentFunction = Object.getPrototypeOf(this.parent.caller.$$owner).$$setters[callerName];
                        if (void 0 === parentFunction)
                            throw "No setter defined in parent"
                    } else if (0 == arguments.length && isGetter) {
                        var parentFunction = Object.getPrototypeOf(this.parent.caller.$$owner).$$getters[callerName];
                        if (void 0 === parentFunction)
                            throw "No getter defined in parent"
                    } else {
                        if (isSetter || isGetter)
                            throw "Incorrect amount of arguments sent to getter or setter";
                        var parentFunction = Object.getPrototypeOf(this.parent.caller.$$owner)[callerName];
                        if (void 0 === parentFunction)
                            throw "No parent function defined for " + callerName
                    }
                }
                return parentFunction.apply(this, arguments)
            }
        }
    }
        , {}],
    83: [function(require, module, exports) {
        module.exports = require("./lib/index")
    }
        , {
            "./lib/index": 84
        }],
    84: [function(require, module, exports) {
        var Class = require("js-oop")
            , EventEmitter = require("events").EventEmitter
            , getExtension = require("./util/getExtension")
            , LoaderImage = require("./loaders/LoaderImage")
            , LoaderText = require("./loaders/LoaderText")
            , LoaderJSON = require("./loaders/LoaderJSON")
            , LoaderVideo = require("./loaders/LoaderVideo")
            , LoaderAudio = require("./loaders/LoaderAudio")
            , LOADERS = {
            png: LoaderImage,
            jpg: LoaderImage,
            jpeg: LoaderImage,
            gif: LoaderImage,
            json: LoaderJSON,
            mp4: LoaderVideo,
            ogg: LoaderVideo,
            ogv: LoaderVideo,
            webm: LoaderVideo,
            mp3: LoaderAudio,
            wav: LoaderAudio
        }
            , LOADER_DEFAULT = LoaderText
            , Preloader = new Class({
            Extends: EventEmitter,
            initialize: function(options) {
                return this instanceof Preloader ? (Class.parent(this),
                    this.options = this.parseOptions(options),
                this.options.onComplete && this.on("complete", this.options.onComplete),
                this.options.onProgress && this.on("progress", this.options.onProgress),
                    this.percTotal = 0,
                    this.loadIdx = 0,
                    this.urls = [],
                    this.loaders = {},
                    this.percentageOfLoad = {},
                    this.progress = 0,
                    this.urlLoading = null,
                    this._onLoadError = this._onLoadError.bind(this),
                    this._onLoadProgress = this._onLoadProgress.bind(this),
                    void (this._continueLoadQueue = this._continueLoadQueue.bind(this))) : new Preloader(options)
            },
            parseOptions: function(options) {
                return {
                    xhrImages: options.xhrImages || !1,
                    loadFullAudio: options.loadFullAudio || !1,
                    loadFillVideo: options.loadFullVideo || !1,
                    onComplete: "function" == typeof options.onComplete ? options.onComplete : void 0,
                    onProgress: "function" == typeof options.onProgress ? options.onProgress : void 0
                }
            },
            mergeOptions: function(options) {
                return {
                    xhrImages: options.xhrImages || this.options.xhrImages,
                    loadFullAudio: options.loadFullAudio || this.options.loadFullAudio,
                    loadFillVideo: options.loadFullVideo || this.options.loadFullVideo,
                    onComplete: "function" == typeof options.onComplete ? options.onComplete : void 0,
                    onProgress: "function" == typeof options.onProgress ? options.onProgress : void 0
                }
            },
            add: function(url, options) {
                url && this.addFromLoaderType(url, this._getLoader(url), options)
            },
            addImage: function(url, options) {
                this.addFromLoaderType(url, LoaderImage, options)
            },
            addJSON: function(url, options) {
                this.addFromLoaderType(url, LoaderJSON, options)
            },
            addText: function(url, options) {
                this.addFromLoaderType(url, LoaderText, options)
            },
            addVideo: function(url, options) {
                this.addFromLoaderType(url, LoaderVideo, options)
            },
            addAudio: function(url, options) {
                this.addFromLoaderType(url, LoaderAudio, options)
            },
            addFromLoaderType: function(url, LoaderType, options) {
                if (!this.loaders[url])
                    return this.loaders[url] = new LoaderType(this.mergeOptions(options || {})),
                        this.urls.push(url),
                        this.loaders[url]
            },
            setPercentage: function(url, percentageOfLoad) {
                this.percentageOfLoad[url] = percentageOfLoad
            },
            load: function() {
                null === this.urlLoading && (this._setupPercentages(),
                    this._continueLoadQueue())
            },
            stopLoad: function() {
                if (null !== this.urlLoading)
                    for (var i = 0, len = this.urls.length; i < len; i++)
                        this.loaders[this.urls[i]].stopLoad()
            },
            get: function(url) {
                return this.loaders[url] && this.loaders[url].content
            },
            _setupPercentages: function() {
                for (var percTotal = 0, percScale = 1, numWOPerc = 0, oneFilePerc = 1 / this.urls.length, i = 0, len = this.urls.length; i < len; i++)
                    this.percentageOfLoad[this.urls[i]] ? percTotal += this.percentageOfLoad[this.urls[i]] : numWOPerc++;
                if (numWOPerc > 0) {
                    percTotal > 1 && (percScale = 1 / percTotal,
                        percTotal *= percScale),
                        oneFilePerc = (1 - percTotal) / numWOPerc;
                    for (var i = 0, len = this.urls.length; i < len; i++)
                        this.percentageOfLoad[this.urls[i]] ? this.percentageOfLoad[this.urls[i]] *= percScale : this.percentageOfLoad[this.urls[i]] = oneFilePerc
                }
            },
            _continueLoadQueue: function() {
                if (this.loadIdx < this.urls.length) {
                    null !== this.urlLoading && (this.percTotal += this.percentageOfLoad[this.urlLoading]),
                        this.urlLoading = this.urls[this.loadIdx];
                    var loader = this.loaders[this.urlLoading];
                    this.loadIdx++,
                        loader.on("progress", this._onLoadProgress),
                        loader.once("error", this._onLoadError),
                        loader.once("complete", this._continueLoadQueue),
                        loader.load(this.urlLoading)
                } else
                    this.emit("complete")
            },
            _onLoadError: function(error) {
                console.warn("Couldn't load " + this.urlLoading + " received the error: " + error);
                var curPerc = this.percentageOfLoad[this.urlLoading];
                this.emit("progress", this.percTotal + curPerc, this.urlLoading),
                    this._continueLoadQueue()
            },
            _onLoadProgress: function(progress) {
                var curPerc = this.percentageOfLoad[this.urlLoading] * progress;
                this.emit("progress", this.percTotal + curPerc, this.urlLoading)
            },
            _getLoader: function(url) {
                var extension = getExtension(url)
                    , loader = LOADER_DEFAULT;
                return extension && LOADERS[extension.toLowerCase()] && (loader = LOADERS[extension.toLowerCase()]),
                    loader
            }
        });
        module.exports = Preloader
    }
        , {
            "./loaders/LoaderAudio": 86,
            "./loaders/LoaderImage": 88,
            "./loaders/LoaderJSON": 89,
            "./loaders/LoaderText": 90,
            "./loaders/LoaderVideo": 91,
            "./util/getExtension": 92,
            events: 79,
            "js-oop": 81
        }],
    85: [function(require, module, exports) {
        var parseHTTPHeader = require("../util/parseHTTPHeader")
            , FileMeta = function(header) {
            this.mime = null,
                this.size = null,
                this.lastModified = null,
                this.httpHeader = null,
            header && this.setFromHTTPHeader(header)
        };
        FileMeta.prototype = {
            setFromHTTPHeader: function(header) {
                this.httpHeader = parseHTTPHeader(header),
                this.httpHeader["content-length"] && (this.size = this.httpHeader["content-length"]),
                this.httpHeader["content-type"] && (this.mime = this.httpHeader["content-type"]),
                this.httpHeader["last-modified"] && (this.lastModified = new Date(this.httpHeader["last-modified"]))
            }
        },
            module.exports = FileMeta
    }
        , {
            "../util/parseHTTPHeader": 95
        }],
    86: [function(require, module, exports) {
        var Class = require("js-oop")
            , LoaderBase = require("./LoaderBase")
            , LoaderVideo = require("./LoaderVideo")
            , LoaderAudio = new Class({
            Extends: LoaderVideo,
            initialize: function(options) {
                Class.parent(this, options),
                    this.loadType = LoaderBase.typeAudio
            }
        });
        module.exports = LoaderAudio
    }
        , {
            "./LoaderBase": 87,
            "./LoaderVideo": 91,
            "js-oop": 81
        }],
    87: [function(require, module, exports) {
        function checkIfGoodValue() {
            return this.loadType === LoaderBase.typeText || this.loadType === LoaderBase.typeArraybuffer || this.loadType === LoaderBase.typeBlob || this.loadType === LoaderBase.typeJSON || this.loadType === LoaderBase.typeDocument || this.loadType === LoaderBase.typeVideo || this.loadType === LoaderBase.typeAudio;
        }
        function checkResponseTypeSupport() {
            return void 0 !== this.xhr.responseType
        }
        function checkAndSetType(xhr, loadType) {
            return xhr.responseType = loadType,
            xhr.responseType === loadType
        }
        var Class = require("js-oop")
            , FileMeta = require("./FileMeta")
            , stringToArrayBuffer = require("../util/stringToArrayBuffer")
            , getMimeFromURL = require("../util/getMimeFromURL")
            , EventEmitter = require("events").EventEmitter
            , LoaderBase = new Class({
            Extends: EventEmitter,
            initialize: function(loadType, options) {
                Class.parent(this),
                    this.options = options,
                this.options.onComplete && this.on("complete", this.options.onComplete),
                this.options.onProgress && this.on("progress", this.options.onProgress),
                    this.xhr = null,
                    this.content = null,
                    this.url = null,
                    this.loadType = loadType || LoaderBase.typeText,
                    this.loadTypeSet = !1,
                    this.fileMeta = null,
                    this._onStateChange = this._onStateChange.bind(this),
                    this._onProgress = this._onProgress.bind(this),
                    this._dispatchProgress = this._dispatchProgress.bind(this),
                    this._dispatchComplete = this._dispatchComplete.bind(this)
            },
            canLoadUsingXHR: function() {
                return "undefined" != typeof XMLHttpRequest
            },
            canLoadType: function(type) {
                var tempXHR = new XMLHttpRequest;
                return tempXHR.open("GET", "someFakeURL", !0),
                    checkAndSetType(tempXHR, type)
            },
            load: function(url) {
                if (this.url = url,
                        this.canLoadUsingXHR()) {
                    if (this.xhr = new XMLHttpRequest,
                            this.xhr.open("GET", url, !0),
                            this.xhr.onreadystatechange = this._onStateChange,
                        void 0 !== this.xhr.onprogress && (this.xhr.onprogress = this._onProgress),
                        this.loadType !== LoaderBase.typeText) {
                        checkIfGoodValue.call(this) || (console.warn("Attempting to use incompatible load type " + this.loadType + ". Switching it to " + LoaderBase.typeText),
                            this.loadType = LoaderBase.typeText);
                        try {
                            this.loadTypeSet = checkResponseTypeSupport.call(this) && checkAndSetType(this.xhr, this.loadType)
                        } catch (e) {
                            this.loadTypeSet = !1
                        }
                        this.loadTypeSet || this.loadType !== LoaderBase.typeBlob && this.loadType !== LoaderBase.typeArraybuffer || this.xhr.overrideMimeType("text/plain; charset=x-user-defined")
                    }
                    this.xhr.send()
                }
            },
            stopLoad: function() {
                this.xhr.abort()
            },
            _dispatchStart: function() {
                this.emit("start")
            },
            _dispatchProgress: function(value) {
                this.emit("progress", value)
            },
            _dispatchComplete: function() {
                this.emit("complete", this.content)
            },
            _dispatchError: function(msg) {
                this.emit("error", msg)
            },
            _onProgress: function(ev) {
                var loaded = ev.loaded || ev.position
                    , totalSize = ev.total || ev.totalSize;
                totalSize ? this._dispatchProgress(loaded / totalSize) : this._dispatchProgress(0)
            },
            _onStateChange: function() {
                if (this.xhr.readyState > 1) {
                    var status, waiting = !1;
                    try {
                        status = this.xhr.status
                    } catch (e) {
                        waiting = !0
                    }
                    if (200 === status)
                        switch (this.xhr.readyState) {
                            case 2:
                                this.fileMeta = new FileMeta(this.xhr.getAllResponseHeaders()),
                                    this._dispatchStart();
                                break;
                            case 3:
                                break;
                            case 4:
                                this._parseContent(),
                                    this._dispatchComplete()
                        }
                    else
                        waiting || (this.xhr.onreadystatechange = void 0,
                            this._dispatchError(this.xhr.status))
                }
            },
            _parseContent: function() {
                if (this.loadTypeSet || this.loadType === LoaderBase.typeText)
                    this.content = this.xhr.response || this.xhr.responseText;
                else
                    switch (this.loadType) {
                        case LoaderBase.typeArraybuffer:
                            if (!ArrayBuffer)
                                throw new Error("This browser does not support ArrayBuffer");
                            this.content = stringToArrayBuffer(this.xhr.response);
                            break;
                        case LoaderBase.typeBlob:
                            if (!Blob)
                                throw new Error("This browser does not support Blob");
                            this.fileMeta || (this.fileMeta = new FileMeta),
                            null === this.fileMeta.mime && (this.fileMeta.mime = getMimeFromURL(this.url)),
                                this.content = new Blob([stringToArrayBuffer(this.xhr.response)],{
                                    type: this.fileMeta.mime
                                });
                            break;
                        case LoaderBase.typeJSON:
                            this.content = JSON.parse(this.xhr.response);
                            break;
                        case LoaderBase.typeDocument:
                            this.content = this.xhr.response
                    }
            }
        });
        LoaderBase.typeText = "text",
            LoaderBase.typeArraybuffer = "arraybuffer",
            LoaderBase.typeBlob = "blob",
            LoaderBase.typeJSON = "json",
            LoaderBase.typeDocument = "document",
            LoaderBase.typeVideo = "video",
            LoaderBase.typeAudio = "audio",
            module.exports = LoaderBase
    }
        , {
            "../util/getMimeFromURL": 93,
            "../util/stringToArrayBuffer": 96,
            "./FileMeta": 85,
            events: 79,
            "js-oop": 81
        }],
    88: [function(require, module, exports) {
        var Class = require("js-oop")
            , LoaderBase = require("./LoaderBase")
            , FileMeta = require("./FileMeta")
            , getMimeFromURL = require("./../util/getMimeFromURL")
            , LoaderImage = new Class({
            Extends: LoaderBase,
            initialize: function(options) {
                this._imageLoaded = !1,
                    Class.parent(this, LoaderBase.typeArraybuffer, options)
            },
            load: function(url) {
                this.options.xhrImages && this.canLoadUsingXHR() && this.canLoadType(this.loadType) && ArrayBuffer && (window.URL || window.webkitURL || FileReader) ? Class.parent(this, url) : this._createAndLoadImage(url)
            },
            _dispatchProgress: function(progress) {
                Class.parent(this, this._imageLoaded ? progress : .9999 * progress)
            },
            _dispatchComplete: function() {
                this._imageLoaded && Class.parent(this)
            },
            _onImageLoadComplete: function() {
                this._imageLoaded = !0,
                    this._dispatchProgress(1),
                    this._dispatchComplete()
            },
            _onImageLoadFail: function() {
                this._dispatchError("Image failed to load")
            },
            _parseContent: function() {
                var arrayBuffer = null
                    , blobData = null;
                if (this.fileMeta || (this.fileMeta = new FileMeta),
                    this.loadTypeSet && null !== this.fileMeta.mime || (this.fileMeta.mime = getMimeFromURL(this.url)),
                    this.xhr.response instanceof ArrayBuffer)
                    arrayBuffer = this.xhr.response;
                else {
                    if (!this.xhr.mozResponseArrayBuffer)
                        throw new Error("Return type for image load unsupported");
                    arrayBuffer = this.xhr.mozResponseArrayBuffer
                }
                if (blobData = new Blob([arrayBuffer],{
                        type: this.fileMeta.mime
                    }),
                    window.URL || window.webkitURL)
                    this._createAndLoadImage((window.URL || window.webkitURL).createObjectURL(blobData));
                else if (FileReader) {
                    var reader = new FileReader;
                    reader.onloadend = function() {
                        (window.URL || window.webkitURL) && (window.URL || window.webkitURL).revokeObjectURL(blobData),
                            this._createAndLoadImage(reader.result)
                    }
                        .bind(this),
                        reader.readAsDataURL(blobData)
                }
            },
            _createAndLoadImage: function(src) {
                this.content = new Image,
                    this.content.onload = this._onImageLoadComplete.bind(this),
                    this.content.onerror = this._onImageLoadFail.bind(this),
                    this.content.src = src
            }
        });
        module.exports = LoaderImage
    }
        , {
            "./../util/getMimeFromURL": 93,
            "./FileMeta": 85,
            "./LoaderBase": 87,
            "js-oop": 81
        }],
    89: [function(require, module, exports) {
        var Class = require("js-oop")
            , LoaderBase = require("./LoaderBase")
            , LoaderJSON = new Class({
            Extends: LoaderBase,
            initialize: function(options) {
                Class.parent(this, LoaderBase.typeJSON, options)
            }
        });
        module.exports = LoaderJSON
    }
        , {
            "./LoaderBase": 87,
            "js-oop": 81
        }],
    90: [function(require, module, exports) {
        var Class = require("js-oop")
            , LoaderBase = require("./LoaderBase")
            , LoaderText = new Class({
            Extends: LoaderBase,
            initialize: function(options) {
                Class.parent(this, LoaderBase.typeText, options)
            }
        });
        module.exports = LoaderText
    }
        , {
            "./LoaderBase": 87,
            "js-oop": 81
        }],
    91: [function(require, module, exports) {
        var Class = require("js-oop")
            , LoaderBase = require("./LoaderBase")
            , LoaderVideo = new Class({
            Extends: LoaderBase,
            initialize: function(options) {
                Class.parent(this, LoaderBase.typeVideo, options)
            },
            load: function(url) {
                this.url = url,
                    this.content = document.createElement(this.loadType),
                    this.content.setAttribute("preload", "auto"),
                    this.content.addEventListener(this.options.loadFullVideo ? "canplaythrough" : "canplay", this._dispatchComplete),
                    this.content.addEventListener("progress", this._onProgress),
                    this.content.setAttribute("src", this.url),
                    this.content.load()
            },
            stopLoad: function() {
                this.content.setAttribute("src", ""),
                    this.content.load()
            },
            _onProgress: function(e) {
                this._dispatchProgress(this._getProgress())
            },
            _dispatchComplete: function() {
                this.content.removeEventListener(this.options.loadFullVideo ? "canplaythrough" : "canplay", this._dispatchComplete),
                    this.content.removeEventListener("progress", this._onProgress),
                    this._dispatchProgress(1),
                    Class.parent(this)
            },
            _getProgress: function() {
                return this.content.buffered && this.content.buffered.length > 0 && this.content.buffered.end && this.content.duration ? this.content.buffered.end(0) / this.content.duration : void 0 !== this.content.bytesTotal && this.content.bytesTotal > 0 && void 0 !== this.content.bufferedBytes ? this.content.bufferedBytes / this.content.bytesTotal : 0
            }
        });
        module.exports = LoaderVideo
    }
        , {
            "./LoaderBase": 87,
            "js-oop": 81
        }],
    92: [function(require, module, exports) {
        var base64Mime = require("base64mime")
            , isBase64 = require("./isBase64");
        module.exports = function(url) {
            var ext;
            if (isBase64(url)) {
                var mime = base64Mime(url);
                ext = mime.split("/")[1]
            } else {
                var splitByBackSlash = url.split("/")
                    , fileData = /\.([a-zA-Z0-9]+)/.exec(splitByBackSlash[splitByBackSlash.length - 1]);
                ext = fileData[1]
            }
            return ext || null
        }
    }
        , {
            "./isBase64": 94,
            base64mime: 7
        }],
    93: [function(require, module, exports) {
        var base64Mime = require("base64mime")
            , getExtension = require("./getExtension")
            , isBase64 = require("./isBase64")
            , FILE_MIME = {
            gif: "image/gif",
            jpg: "image/jpeg",
            jpeg: "image/jpeg",
            png: "image/png",
            svg: "image/svg+xml",
            html: "text/html",
            css: "text/css",
            csv: "text/csv",
            xml: "text/xml",
            mp4: "video/mp4",
            ogg: "video/ogg",
            ogv: "video/ogg",
            webm: "video/webm",
            wav: "audio/wav",
            mp3: "audio/mpeg"
        };
        module.exports = function(url) {
            var mime;
            if (isBase64(url))
                mime = base64Mime(url);
            else {
                var ext = getExtension(url);
                mime = FILE_MIME[ext.toLowerCase()]
            }
            return mime || "application/octet-stream"
        }
    }
        , {
            "./getExtension": 92,
            "./isBase64": 94,
            base64mime: 7
        }],
    94: [function(require, module, exports) {
        module.exports = function(v) {
            var regex = /^(data:\w+\/[a-zA-Z\+\-\.]+;base64,)?([A-Za-z0-9+\/]{4})*([A-Za-z0-9+\/]{4}|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{2}==)$/gi;
            return regex.test(v)
        }
    }
        , {}],
    95: [function(require, module, exports) {
        module.exports = function(headerString) {
            for (var headerSplit = headerString.split("\n"), rVal = {}, regex = /([a-zA-Z0-9\-_]+): *(.+)/, keyValue = null, i = 0, len = headerSplit.length; i < len; i++)
                "" !== headerSplit[i] && (keyValue = regex.exec(headerSplit[i]),
                keyValue && (rVal[keyValue[1]] = keyValue[2]));
            return rVal
        }
    }
        , {}],
    96: [function(require, module, exports) {
        module.exports = function(string) {
            for (var buf = new ArrayBuffer(2 * string.length), bufView = new Uint16Array(buf), i = 0, strLen = string.length; i < strLen; i++)
                bufView[i] = string.charCodeAt(i);
            return buf
        }
    }
        , {}],
    97: [function(require, module, exports) {
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined")
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined")
        }
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout)
                return setTimeout(fun, 0);
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
                return cachedSetTimeout = setTimeout,
                    setTimeout(fun, 0);
            try {
                return cachedSetTimeout(fun, 0)
            } catch (e) {
                try {
                    return cachedSetTimeout.call(null, fun, 0)
                } catch (e) {
                    return cachedSetTimeout.call(this, fun, 0)
                }
            }
        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout)
                return clearTimeout(marker);
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
                return cachedClearTimeout = clearTimeout,
                    clearTimeout(marker);
            try {
                return cachedClearTimeout(marker)
            } catch (e) {
                try {
                    return cachedClearTimeout.call(null, marker)
                } catch (e) {
                    return cachedClearTimeout.call(this, marker)
                }
            }
        }
        function cleanUpNextTick() {
            draining && currentQueue && (draining = !1,
                currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1,
            queue.length && drainQueue())
        }
        function drainQueue() {
            if (!draining) {
                var timeout = runTimeout(cleanUpNextTick);
                draining = !0;
                for (var len = queue.length; len; ) {
                    for (currentQueue = queue,
                             queue = []; ++queueIndex < len; )
                        currentQueue && currentQueue[queueIndex].run();
                    queueIndex = -1,
                        len = queue.length
                }
                currentQueue = null,
                    draining = !1,
                    runClearTimeout(timeout)
            }
        }
        function Item(fun, array) {
            this.fun = fun,
                this.array = array
        }
        function noop() {}
        var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
        !function() {
            try {
                cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout
            } catch (e) {
                cachedSetTimeout = defaultSetTimout
            }
            try {
                cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout
            }
        }();
        var currentQueue, queue = [], draining = !1, queueIndex = -1;
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var i = 1; i < arguments.length; i++)
                    args[i - 1] = arguments[i];
            queue.push(new Item(fun,args)),
            1 !== queue.length || draining || runTimeout(drainQueue)
        }
            ,
            Item.prototype.run = function() {
                this.fun.apply(null, this.array)
            }
            ,
            process.title = "browser",
            process.browser = !0,
            process.env = {},
            process.argv = [],
            process.version = "",
            process.versions = {},
            process.on = noop,
            process.addListener = noop,
            process.once = noop,
            process.off = noop,
            process.removeListener = noop,
            process.removeAllListeners = noop,
            process.emit = noop,
            process.binding = function(name) {
                throw new Error("process.binding is not supported")
            }
            ,
            process.cwd = function() {
                return "/"
            }
            ,
            process.chdir = function(dir) {
                throw new Error("process.chdir is not supported")
            }
            ,
            process.umask = function() {
                return 0
            }
    }
        , {}],
    98: [function(require, module, exports) {
        !function() {
            "use strict";
            function VueHead(Vue, options) {
                function init(update) {
                    var self = this
                        , head = self.$options.head;
                    head && (Object.keys(head).map(function(key) {
                        var prop = head[key];
                        if (prop) {
                            var obj = "function" == typeof prop ? head[key].bind(self)() : head[key];
                            return "title" === key ? void util[key](obj) : void util.handle(obj, key, "head", update)
                        }
                    }),
                        self.$emit("okHead"))
                }
                function destroy() {
                    this.$options.head && (util.undoTitle(diffTitle),
                        util.undo())
                }
                installed || (installed = !0,
                options && Vue.util.extend(opt, options),
                Vue.version.match(/[1].(.)+/g) && Vue.mixin({
                    ready: function() {
                        init.bind(this)()
                    },
                    destroyed: function() {
                        destroy.bind(this)()
                    },
                    events: {
                        updateHead: function() {
                            init.bind(this)(!0),
                                util.update()
                        }
                    }
                }),
                Vue.version.match(/[2].(.)+/g) && Vue.mixin({
                    created: function() {
                        var self = this;
                        self.$on("updateHead", function() {
                            init.bind(self)(!0),
                                util.update()
                        })
                    },
                    mounted: function() {
                        init.bind(this)()
                    },
                    beforeDestroy: function() {
                        destroy.bind(this)()
                    }
                }))
            }
            var opt = {
                complement: window.document.title,
                separator: "|"
            }
                , diffTitle = {}
                , els = []
                , diffEls = []
                , installed = !1
                , util = {
                shorthand: {
                    ch: "charset",
                    tg: "target",
                    n: "name",
                    he: "http-equiv",
                    ip: "itemprop",
                    c: "content",
                    p: "property",
                    sc: "scheme",
                    r: "rel",
                    h: "href",
                    sz: "sizes",
                    t: "type",
                    s: "src",
                    a: "async",
                    d: "defer",
                    i: "inner"
                },
                getPlace: function(place) {
                    return window.document.getElementsByTagName(place)[0]
                },
                undoTitle: function(state) {
                    state.before && (window.document.title = state.before)
                },
                undo: function() {
                    els.length && (els.map(function(el) {
                        el.parentElement.removeChild(el)
                    }),
                        els = [])
                },
                prepareElement: function(obj, el) {
                    var self = this;
                    return Object.keys(obj).map(function(prop) {
                        var sh = self.shorthand[prop] || prop;
                        if (!sh.match(/(body|undo|replace)/g))
                            return "inner" === sh ? void (el.textContent = obj[prop]) : void el.setAttribute(sh, obj[prop])
                    }),
                        el
                },
                title: function(obj) {
                    obj && (diffTitle.before = opt.complement,
                        window.document.title = obj.inner + " " + (obj.separator || opt.separator) + " " + (obj.complement || opt.complement))
                },
                update: function() {
                    els.length && (els.forEach(function(el, key) {
                        if (diffEls[key] && !diffEls[key].isEqualNode(el))
                            return el.parentElement.replaceChild(diffEls[key], els[key]),
                                void els.splice(key, 1, diffEls[key])
                    }),
                        diffEls = [])
                },
                add: function(obj, el, parent) {
                    parent.appendChild(el),
                    (void 0 === obj.undo || obj.undo) && els.push(el)
                },
                handle: function(arr, tag, place, update) {
                    var self = this;
                    arr && arr.map(function(obj) {
                        var parent = obj.body ? self.getPlace("body") : self.getPlace(place)
                            , el = window.document.getElementById(obj.id) || window.document.createElement(tag);
                        return el.hasAttribute("id") || obj.id ? void self.prepareElement(obj, el) : (el = self.prepareElement(obj, el),
                            update ? void diffEls.push(el) : void self.add(obj, el, parent))
                    })
                }
            };
            VueHead.version = "2.0.10",
            "undefined" != typeof Vue && Vue.use(VueHead),
                "object" == typeof exports && "object" == typeof module ? module.exports = VueHead : "function" == typeof define && define.amd ? define(function() {
                    return VueHead
                }) : "undefined" != typeof window && (window.VueHead = VueHead)
        }()
    }
        , {}],
    99: [function(require, module, exports) {
        "use strict";
        function Util(Vue) {
            util = Vue.util,
                config = Vue.config
        }
        function warn(msg) {
            console && util.warn && (!config.silent || config.debug) && console.warn("[VueResource warn]: " + msg)
        }
        function error(msg) {
            console && console.error(msg)
        }
        function nextTick(cb, ctx) {
            return util.nextTick(cb, ctx)
        }
        function trim(str) {
            return str.replace(/^\s*|\s*$/g, "")
        }
        function toLower(str) {
            return str ? str.toLowerCase() : ""
        }
        function isString(val) {
            return "string" == typeof val
        }
        function isFunction(val) {
            return "function" == typeof val
        }
        function isObject(obj) {
            return null !== obj && "object" === ("undefined" == typeof obj ? "undefined" : _typeof(obj))
        }
        function isPlainObject(obj) {
            return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype
        }
        function options(fn, obj, opts) {
            return opts = opts || {},
            isFunction(opts) && (opts = opts.call(obj)),
                merge(fn.bind({
                    $vm: obj,
                    $options: opts
                }), fn, {
                    $options: opts
                })
        }
        function each(obj, iterator) {
            var i, key;
            if ("number" == typeof obj.length)
                for (i = 0; i < obj.length; i++)
                    iterator.call(obj[i], obj[i], i);
            else if (isObject(obj))
                for (key in obj)
                    obj.hasOwnProperty(key) && iterator.call(obj[key], obj[key], key);
            return obj
        }
        function extend(target) {
            var args = array.slice.call(arguments, 1);
            return args.forEach(function(arg) {
                _merge(target, arg)
            }),
                target
        }
        function merge(target) {
            var args = array.slice.call(arguments, 1);
            return args.forEach(function(arg) {
                _merge(target, arg, !0)
            }),
                target
        }
        function _merge(target, source, deep) {
            for (var key in source)
                deep && (isPlainObject(source[key]) || isArray(source[key])) ? (isPlainObject(source[key]) && !isPlainObject(target[key]) && (target[key] = {}),
                isArray(source[key]) && !isArray(target[key]) && (target[key] = []),
                    _merge(target[key], source[key], deep)) : void 0 !== source[key] && (target[key] = source[key])
        }
        function root(options, next) {
            var url = next(options);
            return isString(options.root) && !url.match(/^(https?:)?\//) && (url = options.root + "/" + url),
                url
        }
        function query(options, next) {
            var urlParams = Object.keys(Url.options.params)
                , query = {}
                , url = next(options);
            return each(options.params, function(value, key) {
                urlParams.indexOf(key) === -1 && (query[key] = value)
            }),
                query = Url.params(query),
            query && (url += (url.indexOf("?") == -1 ? "?" : "&") + query),
                url
        }
        function legacy(options, next) {
            var variables = []
                , url = next(options);
            return url = url.replace(/(\/?):([a-z]\w*)/gi, function(match, slash, name) {
                return warn("The `:" + name + "` parameter syntax has been deprecated. Use the `{" + name + "}` syntax instead."),
                    options.params[name] ? (variables.push(name),
                    slash + encodeUriSegment(options.params[name])) : ""
            }),
                variables.forEach(function(key) {
                    delete options.params[key]
                }),
                url
        }
        function encodeUriSegment(value) {
            return encodeUriQuery(value, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+")
        }
        function encodeUriQuery(value, spaces) {
            return encodeURIComponent(value).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, spaces ? "%20" : "+")
        }
        function expand(url, params, variables) {
            var tmpl = parse(url)
                , expanded = tmpl.expand(params);
            return variables && variables.push.apply(variables, tmpl.vars),
                expanded
        }
        function parse(template) {
            var operators = ["+", "#", ".", "/", ";", "?", "&"]
                , variables = [];
            return {
                vars: variables,
                expand: function(context) {
                    return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
                        if (expression) {
                            var operator = null
                                , values = [];
                            if (operators.indexOf(expression.charAt(0)) !== -1 && (operator = expression.charAt(0),
                                    expression = expression.substr(1)),
                                    expression.split(/,/g).forEach(function(variable) {
                                        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3])),
                                            variables.push(tmp[1])
                                    }),
                                operator && "+" !== operator) {
                                var separator = ",";
                                return "?" === operator ? separator = "&" : "#" !== operator && (separator = operator),
                                (0 !== values.length ? operator : "") + values.join(separator)
                            }
                            return values.join(",")
                        }
                        return encodeReserved(literal)
                    })
                }
            }
        }
        function getValues(context, operator, key, modifier) {
            var value = context[key]
                , result = [];
            if (isDefined(value) && "" !== value)
                if ("string" == typeof value || "number" == typeof value || "boolean" == typeof value)
                    value = value.toString(),
                    modifier && "*" !== modifier && (value = value.substring(0, parseInt(modifier, 10))),
                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
                else if ("*" === modifier)
                    Array.isArray(value) ? value.filter(isDefined).forEach(function(value) {
                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null))
                    }) : Object.keys(value).forEach(function(k) {
                        isDefined(value[k]) && result.push(encodeValue(operator, value[k], k))
                    });
                else {
                    var tmp = [];
                    Array.isArray(value) ? value.filter(isDefined).forEach(function(value) {
                        tmp.push(encodeValue(operator, value))
                    }) : Object.keys(value).forEach(function(k) {
                        isDefined(value[k]) && (tmp.push(encodeURIComponent(k)),
                            tmp.push(encodeValue(operator, value[k].toString())))
                    }),
                        isKeyOperator(operator) ? result.push(encodeURIComponent(key) + "=" + tmp.join(",")) : 0 !== tmp.length && result.push(tmp.join(","))
                }
            else
                ";" === operator ? result.push(encodeURIComponent(key)) : "" !== value || "&" !== operator && "?" !== operator ? "" === value && result.push("") : result.push(encodeURIComponent(key) + "=");
            return result
        }
        function isDefined(value) {
            return void 0 !== value && null !== value
        }
        function isKeyOperator(operator) {
            return ";" === operator || "&" === operator || "?" === operator
        }
        function encodeValue(operator, value, key) {
            return value = "+" === operator || "#" === operator ? encodeReserved(value) : encodeURIComponent(value),
                key ? encodeURIComponent(key) + "=" + value : value
        }
        function encodeReserved(str) {
            return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
                return /%[0-9A-Fa-f]/.test(part) || (part = encodeURI(part)),
                    part
            }).join("")
        }
        function template(options) {
            var variables = []
                , url = expand(options.url, options.params, variables);
            return variables.forEach(function(key) {
                delete options.params[key]
            }),
                url
        }
        function Url(url, params) {
            var transform, self = this || {}, options = url;
            return isString(url) && (options = {
                url: url,
                params: params
            }),
                options = merge({}, Url.options, self.$options, options),
                Url.transforms.forEach(function(handler) {
                    transform = factory(handler, transform, self.$vm)
                }),
                transform(options)
        }
        function factory(handler, next, vm) {
            return function(options) {
                return handler.call(vm, options, next)
            }
        }
        function serialize(params, obj, scope) {
            var hash, array = isArray(obj), plain = isPlainObject(obj);
            each(obj, function(value, key) {
                hash = isObject(value) || isArray(value),
                scope && (key = scope + "[" + (plain || hash ? key : "") + "]"),
                    !scope && array ? params.add(value.name, value.value) : hash ? serialize(params, value, key) : params.add(key, value)
            })
        }
        function Promise$2(executor) {
            this.state = PENDING,
                this.value = void 0,
                this.deferred = [];
            var promise = this;
            try {
                executor(function(x) {
                    promise.resolve(x)
                }, function(r) {
                    promise.reject(r)
                })
            } catch (e) {
                promise.reject(e)
            }
        }
        function Promise$1(executor, context) {
            executor instanceof PromiseObj ? this.promise = executor : this.promise = new PromiseObj(executor.bind(context)),
                this.context = context
        }
        function xdrClient(request) {
            return new Promise$1(function(resolve) {
                    var handler, xdr = new XDomainRequest, response = {
                        request: request
                    };
                    request.cancel = function() {
                        xdr.abort()
                    }
                        ,
                        xdr.open(request.method, Url(request), !0),
                        handler = function(event) {
                            response.data = xdr.responseText,
                                response.status = xdr.status,
                                response.statusText = xdr.statusText || "",
                                resolve(response)
                        }
                        ,
                        xdr.timeout = 0,
                        xdr.onload = handler,
                        xdr.onabort = handler,
                        xdr.onerror = handler,
                        xdr.ontimeout = function() {}
                        ,
                        xdr.onprogress = function() {}
                        ,
                        xdr.send(request.data)
                }
            )
        }
        function crossOrigin(request) {
            var requestUrl = Url.parse(Url(request));
            return requestUrl.protocol !== originUrl.protocol || requestUrl.host !== originUrl.host
        }
        function jsonpClient(request) {
            return new Promise$1(function(resolve) {
                    var handler, script, callback = "_jsonp" + Math.random().toString(36).substr(2), response = {
                        request: request,
                        data: null
                    };
                    request.params[request.jsonp] = callback,
                        request.cancel = function() {
                            handler({
                                type: "cancel"
                            })
                        }
                        ,
                        script = document.createElement("script"),
                        script.src = Url(request),
                        script.type = "text/javascript",
                        script.async = !0,
                        window[callback] = function(data) {
                            response.data = data
                        }
                        ,
                        handler = function(event) {
                            "load" === event.type && null !== response.data ? response.status = 200 : "error" === event.type ? response.status = 404 : response.status = 0,
                                resolve(response),
                                delete window[callback],
                                document.body.removeChild(script)
                        }
                        ,
                        script.onload = handler,
                        script.onerror = handler,
                        document.body.appendChild(script)
                }
            )
        }
        function interceptor(handler, vm) {
            return function(client) {
                return isFunction(handler) && (handler = handler.call(vm, Promise$1)),
                    function(request) {
                        return isFunction(handler.request) && (request = handler.request.call(vm, request)),
                            when(request, function(request) {
                                return when(client(request), function(response) {
                                    return isFunction(handler.response) && (response = handler.response.call(vm, response)),
                                        response
                                })
                            })
                    }
            }
        }
        function when(value, fulfilled, rejected) {
            var promise = Promise$1.resolve(value);
            return arguments.length < 2 ? promise : promise.then(fulfilled, rejected)
        }
        function xhrClient(request) {
            return new Promise$1(function(resolve) {
                    var handler, xhr = new XMLHttpRequest, response = {
                        request: request
                    };
                    request.cancel = function() {
                        xhr.abort()
                    }
                        ,
                        xhr.open(request.method, Url(request), !0),
                        handler = function(event) {
                            response.data = "response"in xhr ? xhr.response : xhr.responseText,
                                response.status = 1223 === xhr.status ? 204 : xhr.status,
                                response.statusText = trim(xhr.statusText || ""),
                                response.headers = xhr.getAllResponseHeaders(),
                                resolve(response)
                        }
                        ,
                        xhr.timeout = 0,
                        xhr.onload = handler,
                        xhr.onabort = handler,
                        xhr.onerror = handler,
                        xhr.ontimeout = function() {}
                        ,
                        xhr.onprogress = function() {}
                        ,
                    isPlainObject(request.xhr) && extend(xhr, request.xhr),
                    isPlainObject(request.upload) && extend(xhr.upload, request.upload),
                        each(request.headers || {}, function(value, header) {
                            xhr.setRequestHeader(header, value)
                        }),
                        xhr.send(request.data)
                }
            )
        }
        function Client(request) {
            var response = (request.client || xhrClient)(request);
            return Promise$1.resolve(response).then(function(response) {
                if (response.headers) {
                    var headers = parseHeaders(response.headers);
                    response.headers = function(name) {
                        return name ? headers[toLower(name)] : headers
                    }
                }
                return response.ok = response.status >= 200 && response.status < 300,
                    response
            })
        }
        function parseHeaders(str) {
            var value, name, i, headers = {};
            return isString(str) && each(str.split("\n"), function(row) {
                i = row.indexOf(":"),
                    name = trim(toLower(row.slice(0, i))),
                    value = trim(row.slice(i + 1)),
                    headers[name] ? isArray(headers[name]) ? headers[name].push(value) : headers[name] = [headers[name], value] : headers[name] = value
            }),
                headers
        }
        function Http(url, options) {
            var request, promise, self = this || {}, client = Client;
            return Http.interceptors.forEach(function(handler) {
                client = interceptor(handler, self.$vm)(client)
            }),
                options = isObject(url) ? url : extend({
                    url: url
                }, options),
                request = merge({}, Http.options, self.$options, options),
                promise = client(request).bind(self.$vm).then(function(response) {
                    return response.ok ? response : Promise$1.reject(response)
                }, function(response) {
                    return response instanceof Error && error(response),
                        Promise$1.reject(response)
                }),
            request.success && promise.success(request.success),
            request.error && promise.error(request.error),
                promise
        }
        function Resource(url, params, actions, options) {
            var self = this || {}
                , resource = {};
            return actions = extend({}, Resource.actions, actions),
                each(actions, function(action, name) {
                    action = merge({
                        url: url,
                        params: params || {}
                    }, options, action),
                        resource[name] = function() {
                            return (self.$http || Http)(opts(action, arguments))
                        }
                }),
                resource
        }
        function opts(action, args) {
            var data, success, error, options = extend({}, action), params = {};
            switch (args.length) {
                case 4:
                    error = args[3],
                        success = args[2];
                case 3:
                case 2:
                    if (!isFunction(args[1])) {
                        params = args[0],
                            data = args[1],
                            success = args[2];
                        break
                    }
                    if (isFunction(args[0])) {
                        success = args[0],
                            error = args[1];
                        break
                    }
                    success = args[1],
                        error = args[2];
                case 1:
                    isFunction(args[0]) ? success = args[0] : /^(POST|PUT|PATCH)$/i.test(options.method) ? data = args[0] : params = args[0];
                    break;
                case 0:
                    break;
                default:
                    throw "Expected up to 4 arguments [params, data, success, error], got " + args.length + " arguments"
            }
            return options.data = data,
                options.params = extend({}, options.params, params),
            success && (options.success = success),
            error && (options.error = error),
                options
        }
        function plugin(Vue) {
            plugin.installed || (Util(Vue),
                Vue.url = Url,
                Vue.http = Http,
                Vue.resource = Resource,
                Vue.Promise = Promise$1,
                Object.defineProperties(Vue.prototype, {
                    $url: {
                        get: function() {
                            return options(Vue.url, this, this.$options.url)
                        }
                    },
                    $http: {
                        get: function() {
                            return options(Vue.http, this, this.$options.http)
                        }
                    },
                    $resource: {
                        get: function() {
                            return Vue.resource.bind(this)
                        }
                    },
                    $promise: {
                        get: function() {
                            var _this = this;
                            return function(executor) {
                                return new Vue.Promise(executor,_this)
                            }
                        }
                    }
                }))
        }
        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj
        }
            : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol ? "symbol" : typeof obj
        }
            , util = {}
            , config = {}
            , array = []
            , console = window.console
            , isArray = Array.isArray
            , ie = document.documentMode
            , el = document.createElement("a");
        Url.options = {
            url: "",
            root: null,
            params: {}
        },
            Url.transforms = [template, legacy, query, root],
            Url.params = function(obj) {
                var params = []
                    , escape = encodeURIComponent;
                return params.add = function(key, value) {
                    isFunction(value) && (value = value()),
                    null === value && (value = ""),
                        this.push(escape(key) + "=" + escape(value))
                }
                    ,
                    serialize(params, obj),
                    params.join("&").replace(/%20/g, "+")
            }
            ,
            Url.parse = function(url) {
                return ie && (el.href = url,
                    url = el.href),
                    el.href = url,
                    {
                        href: el.href,
                        protocol: el.protocol ? el.protocol.replace(/:$/, "") : "",
                        port: el.port,
                        host: el.host,
                        hostname: el.hostname,
                        pathname: "/" === el.pathname.charAt(0) ? el.pathname : "/" + el.pathname,
                        search: el.search ? el.search.replace(/^\?/, "") : "",
                        hash: el.hash ? el.hash.replace(/^#/, "") : ""
                    }
            }
        ;
        var RESOLVED = 0
            , REJECTED = 1
            , PENDING = 2;
        Promise$2.reject = function(r) {
            return new Promise$2(function(resolve, reject) {
                    reject(r)
                }
            )
        }
            ,
            Promise$2.resolve = function(x) {
                return new Promise$2(function(resolve, reject) {
                        resolve(x)
                    }
                )
            }
            ,
            Promise$2.all = function(iterable) {
                return new Promise$2(function(resolve, reject) {
                        function resolver(i) {
                            return function(x) {
                                result[i] = x,
                                    count += 1,
                                count === iterable.length && resolve(result)
                            }
                        }
                        var count = 0
                            , result = [];
                        0 === iterable.length && resolve(result);
                        for (var i = 0; i < iterable.length; i += 1)
                            Promise$2.resolve(iterable[i]).then(resolver(i), reject)
                    }
                )
            }
            ,
            Promise$2.race = function(iterable) {
                return new Promise$2(function(resolve, reject) {
                        for (var i = 0; i < iterable.length; i += 1)
                            Promise$2.resolve(iterable[i]).then(resolve, reject)
                    }
                )
            }
        ;
        var p$1 = Promise$2.prototype;
        p$1.resolve = function(x) {
            var promise = this;
            if (promise.state === PENDING) {
                if (x === promise)
                    throw new TypeError("Promise settled with itself.");
                var called = !1;
                try {
                    var then = x && x.then;
                    if (null !== x && "object" === ("undefined" == typeof x ? "undefined" : _typeof(x)) && "function" == typeof then)
                        return void then.call(x, function(x) {
                            called || promise.resolve(x),
                                called = !0
                        }, function(r) {
                            called || promise.reject(r),
                                called = !0
                        })
                } catch (e) {
                    return void (called || promise.reject(e))
                }
                promise.state = RESOLVED,
                    promise.value = x,
                    promise.notify()
            }
        }
            ,
            p$1.reject = function(reason) {
                var promise = this;
                if (promise.state === PENDING) {
                    if (reason === promise)
                        throw new TypeError("Promise settled with itself.");
                    promise.state = REJECTED,
                        promise.value = reason,
                        promise.notify()
                }
            }
            ,
            p$1.notify = function() {
                var promise = this;
                nextTick(function() {
                    if (promise.state !== PENDING)
                        for (; promise.deferred.length; ) {
                            var deferred = promise.deferred.shift()
                                , onResolved = deferred[0]
                                , onRejected = deferred[1]
                                , resolve = deferred[2]
                                , reject = deferred[3];
                            try {
                                promise.state === RESOLVED ? resolve("function" == typeof onResolved ? onResolved.call(void 0, promise.value) : promise.value) : promise.state === REJECTED && ("function" == typeof onRejected ? resolve(onRejected.call(void 0, promise.value)) : reject(promise.value))
                            } catch (e) {
                                reject(e)
                            }
                        }
                })
            }
            ,
            p$1.then = function(onResolved, onRejected) {
                var promise = this;
                return new Promise$2(function(resolve, reject) {
                        promise.deferred.push([onResolved, onRejected, resolve, reject]),
                            promise.notify()
                    }
                )
            }
            ,
            p$1.catch = function(onRejected) {
                return this.then(void 0, onRejected)
            }
        ;
        var PromiseObj = window.Promise || Promise$2;
        Promise$1.all = function(iterable, context) {
            return new Promise$1(PromiseObj.all(iterable),context)
        }
            ,
            Promise$1.resolve = function(value, context) {
                return new Promise$1(PromiseObj.resolve(value),context)
            }
            ,
            Promise$1.reject = function(reason, context) {
                return new Promise$1(PromiseObj.reject(reason),context)
            }
            ,
            Promise$1.race = function(iterable, context) {
                return new Promise$1(PromiseObj.race(iterable),context)
            }
        ;
        var p = Promise$1.prototype;
        p.bind = function(context) {
            return this.context = context,
                this
        }
            ,
            p.then = function(fulfilled, rejected) {
                return fulfilled && fulfilled.bind && this.context && (fulfilled = fulfilled.bind(this.context)),
                rejected && rejected.bind && this.context && (rejected = rejected.bind(this.context)),
                    this.promise = this.promise.then(fulfilled, rejected),
                    this
            }
            ,
            p.catch = function(rejected) {
                return rejected && rejected.bind && this.context && (rejected = rejected.bind(this.context)),
                    this.promise = this.promise.catch(rejected),
                    this
            }
            ,
            p.finally = function(callback) {
                return this.then(function(value) {
                    return callback.call(this),
                        value
                }, function(reason) {
                    return callback.call(this),
                        PromiseObj.reject(reason)
                })
            }
            ,
            p.success = function(callback) {
                return warn("The `success` method has been deprecated. Use the `then` method instead."),
                    this.then(function(response) {
                        return callback.call(this, response.data, response.status, response) || response;
                    })
            }
            ,
            p.error = function(callback) {
                return warn("The `error` method has been deprecated. Use the `catch` method instead."),
                    this.catch(function(response) {
                        return callback.call(this, response.data, response.status, response) || response
                    })
            }
            ,
            p.always = function(callback) {
                warn("The `always` method has been deprecated. Use the `finally` method instead.");
                var cb = function(response) {
                    return callback.call(this, response.data, response.status, response) || response
                };
                return this.then(cb, cb)
            }
        ;
        var originUrl = Url.parse(location.href)
            , supportCors = "withCredentials"in new XMLHttpRequest
            , exports$1 = {
            request: function(_request) {
                return null === _request.crossOrigin && (_request.crossOrigin = crossOrigin(_request)),
                _request.crossOrigin && (supportCors || (_request.client = xdrClient),
                    _request.emulateHTTP = !1),
                    _request
            }
        }
            , exports$2 = {
            request: function(_request) {
                return _request.emulateJSON && isPlainObject(_request.data) && (_request.headers["Content-Type"] = "application/x-www-form-urlencoded",
                    _request.data = Url.params(_request.data)),
                isObject(_request.data) && /FormData/i.test(_request.data.toString()) && delete _request.headers["Content-Type"],
                isPlainObject(_request.data) && (_request.data = JSON.stringify(_request.data)),
                    _request
            },
            response: function(_response) {
                try {
                    _response.data = JSON.parse(_response.data)
                } catch (e) {}
                return _response
            }
        }
            , exports$3 = {
            request: function(_request) {
                return "JSONP" == _request.method && (_request.client = jsonpClient),
                    _request
            }
        }
            , exports$4 = {
            request: function(_request) {
                return isFunction(_request.beforeSend) && _request.beforeSend.call(this, _request),
                    _request
            }
        }
            , exports$5 = {
            request: function(_request) {
                return _request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(_request.method) && (_request.headers["X-HTTP-Method-Override"] = _request.method,
                    _request.method = "POST"),
                    _request
            }
        }
            , exports$6 = {
            request: function(_request) {
                return _request.method = _request.method.toUpperCase(),
                    _request.headers = extend({}, Http.headers.common, _request.crossOrigin ? {} : Http.headers.custom, Http.headers[_request.method.toLowerCase()], _request.headers),
                isPlainObject(_request.data) && /^(GET|JSONP)$/i.test(_request.method) && (extend(_request.params, _request.data),
                    delete _request.data),
                    _request
            }
        }
            , exports$7 = function() {
            var timeout;
            return {
                request: function(_request) {
                    return _request.timeout && (timeout = setTimeout(function() {
                        _request.cancel()
                    }, _request.timeout)),
                        _request
                },
                response: function(_response) {
                    return clearTimeout(timeout),
                        _response
                }
            }
        }
            , jsonType = {
            "Content-Type": "application/json"
        };
        Http.options = {
            method: "get",
            data: "",
            params: {},
            headers: {},
            xhr: null,
            upload: null,
            jsonp: "callback",
            beforeSend: null,
            crossOrigin: null,
            emulateHTTP: !1,
            emulateJSON: !1,
            timeout: 0
        },
            Http.headers = {
                put: jsonType,
                post: jsonType,
                patch: jsonType,
                delete: jsonType,
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                custom: {
                    "X-Requested-With": "XMLHttpRequest"
                }
            },
            Http.interceptors = [exports$4, exports$7, exports$3, exports$5, exports$2, exports$6, exports$1],
            ["get", "put", "post", "patch", "delete", "jsonp"].forEach(function(method) {
                Http[method] = function(url, data, success, options) {
                    return isFunction(data) && (options = success,
                        success = data,
                        data = void 0),
                    isObject(success) && (options = success,
                        success = void 0),
                        this(url, extend({
                            method: method,
                            data: data,
                            success: success
                        }, options))
                }
            }),
            Resource.actions = {
                get: {
                    method: "GET"
                },
                save: {
                    method: "POST"
                },
                query: {
                    method: "GET"
                },
                update: {
                    method: "PUT"
                },
                remove: {
                    method: "DELETE"
                },
                delete: {
                    method: "DELETE"
                }
            },
        "undefined" != typeof window && window.Vue && window.Vue.use(plugin),
            module.exports = plugin
    }
        , {}],
    100: [function(require, module, exports) {
        !function(global, factory) {
            "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.VueRouter = factory()
        }(this, function() {
            "use strict";
            function Target(path, matcher, delegate) {
                this.path = path,
                    this.matcher = matcher,
                    this.delegate = delegate
            }
            function Matcher(target) {
                this.routes = {},
                    this.children = {},
                    this.target = target
            }
            function generateMatch(startingPath, matcher, delegate) {
                return function(path, nestedCallback) {
                    var fullPath = startingPath + path;
                    return nestedCallback ? void nestedCallback(generateMatch(fullPath, matcher, delegate)) : new Target(startingPath + path,matcher,delegate)
                }
            }
            function addRoute(routeArray, path, handler) {
                for (var len = 0, i = 0, l = routeArray.length; i < l; i++)
                    len += routeArray[i].path.length;
                path = path.substr(len);
                var route = {
                    path: path,
                    handler: handler
                };
                routeArray.push(route)
            }
            function eachRoute(baseRoute, matcher, callback, binding) {
                var routes = matcher.routes;
                for (var path in routes)
                    if (routes.hasOwnProperty(path)) {
                        var routeArray = baseRoute.slice();
                        addRoute(routeArray, path, routes[path]),
                            matcher.children[path] ? eachRoute(routeArray, matcher.children[path], callback, binding) : callback.call(binding, routeArray)
                    }
            }
            function map(callback, addRouteCallback) {
                var matcher = new Matcher;
                callback(generateMatch("", matcher, this.delegate)),
                    eachRoute([], matcher, function(route) {
                        addRouteCallback ? addRouteCallback(this, route) : this.add(route)
                    }, this)
            }
            function warn(msg) {
                noWarning || "undefined" == typeof console || console.error("[vue-router] " + msg)
            }
            function tryDecode(uri, asComponent) {
                try {
                    return asComponent ? decodeURIComponent(uri) : decodeURI(uri)
                } catch (e) {
                    warn("malformed URI" + (asComponent ? " component: " : ": ") + uri)
                }
            }
            function isArray(test) {
                return "[object Array]" === Object.prototype.toString.call(test)
            }
            function StaticSegment(string) {
                this.string = string
            }
            function DynamicSegment(name) {
                this.name = name
            }
            function StarSegment(name) {
                this.name = name
            }
            function EpsilonSegment() {}
            function parse(route, names, specificity) {
                "/" === route.charAt(0) && (route = route.substr(1));
                var segments = route.split("/")
                    , results = [];
                specificity.val = "";
                for (var i = 0, l = segments.length; i < l; i++) {
                    var match, segment = segments[i];
                    (match = segment.match(/^:([^\/]+)$/)) ? (results.push(new DynamicSegment(match[1])),
                        names.push(match[1]),
                        specificity.val += "3") : (match = segment.match(/^\*([^\/]+)$/)) ? (results.push(new StarSegment(match[1])),
                        specificity.val += "2",
                        names.push(match[1])) : "" === segment ? (results.push(new EpsilonSegment),
                        specificity.val += "1") : (results.push(new StaticSegment(segment)),
                        specificity.val += "4")
                }
                return specificity.val = +specificity.val,
                    results
            }
            function State(charSpec) {
                this.charSpec = charSpec,
                    this.nextStates = []
            }
            function sortSolutions(states) {
                return states.sort(function(a, b) {
                    return b.specificity.val - a.specificity.val
                })
            }
            function recognizeChar(states, ch) {
                for (var nextStates = [], i = 0, l = states.length; i < l; i++) {
                    var state = states[i];
                    nextStates = nextStates.concat(state.match(ch))
                }
                return nextStates
            }
            function RecognizeResults(queryParams) {
                this.queryParams = queryParams || {}
            }
            function findHandler(state, path, queryParams) {
                for (var handlers = state.handlers, regex = state.regex, captures = path.match(regex), currentCapture = 1, result = new RecognizeResults(queryParams), i = 0, l = handlers.length; i < l; i++) {
                    for (var handler = handlers[i], names = handler.names, params = {}, j = 0, m = names.length; j < m; j++)
                        params[names[j]] = captures[currentCapture++];
                    result.push({
                        handler: handler.handler,
                        params: params,
                        isDynamic: !!names.length
                    })
                }
                return result
            }
            function addSegment(currentState, segment) {
                return segment.eachChar(function(ch) {
                    currentState = currentState.put(ch)
                }),
                    currentState
            }
            function decodeQueryParamPart(part) {
                return part = part.replace(/\+/gm, "%20"),
                    tryDecode(part, !0)
            }
            function warn$1(msg) {
                "undefined" != typeof console && console.error("[vue-router] " + msg)
            }
            function resolvePath(base, relative, append) {
                var query = base.match(/(\?.*)$/);
                if (query && (query = query[1],
                        base = base.slice(0, -query.length)),
                    "?" === relative.charAt(0))
                    return base + relative;
                var stack = base.split("/");
                append && stack[stack.length - 1] || stack.pop();
                for (var segments = relative.replace(/^\//, "").split("/"), i = 0; i < segments.length; i++) {
                    var segment = segments[i];
                    "." !== segment && (".." === segment ? stack.pop() : stack.push(segment))
                }
                return "" !== stack[0] && stack.unshift(""),
                    stack.join("/")
            }
            function isPromise(p) {
                return p && "function" == typeof p.then
            }
            function getRouteConfig(component, name) {
                var options = component && (component.$options || component.options);
                return options && options.route && options.route[name]
            }
            function resolveAsyncComponent(handler, cb) {
                resolver ? resolver.$options.components._ = handler.component : resolver = {
                    resolve: exports$1.Vue.prototype._resolveComponent,
                    $options: {
                        components: {
                            _: handler.component
                        }
                    }
                },
                    resolver.resolve("_", function(Component) {
                        handler.component = Component,
                            cb(Component)
                    })
            }
            function mapParams(path, params, query) {
                return void 0 === params && (params = {}),
                    path = path.replace(/:([^\/]+)/g, function(_, key) {
                        var val = params[key];
                        return val || warn$1('param "' + key + '" not found when generating path for "' + path + '" with params ' + JSON.stringify(params)),
                        val || ""
                    }),
                query && (path += genQuery(query)),
                    path
            }
            function canReuse(view, handler, transition) {
                var component = view.childVM;
                if (!component || !handler)
                    return !1;
                if (view.Component !== handler.component)
                    return !1;
                var canReuseFn = getRouteConfig(component, "canReuse");
                return "boolean" == typeof canReuseFn ? canReuseFn : !canReuseFn || canReuseFn.call(component, {
                    to: transition.to,
                    from: transition.from
                })
            }
            function canDeactivate(view, transition, next) {
                var fromComponent = view.childVM
                    , hook = getRouteConfig(fromComponent, "canDeactivate");
                hook ? transition.callHook(hook, fromComponent, next, {
                    expectBoolean: !0
                }) : next()
            }
            function canActivate(handler, transition, next) {
                resolveAsyncComponent(handler, function(Component) {
                    if (!transition.aborted) {
                        var hook = getRouteConfig(Component, "canActivate");
                        hook ? transition.callHook(hook, null, next, {
                            expectBoolean: !0
                        }) : next()
                    }
                })
            }
            function deactivate(view, transition, next) {
                var component = view.childVM
                    , hook = getRouteConfig(component, "deactivate");
                hook ? transition.callHooks(hook, component, next) : next()
            }
            function activate(view, transition, depth, cb, reuse) {
                var handler = transition.activateQueue[depth];
                if (!handler)
                    return saveChildView(view),
                    view._bound && view.setComponent(null),
                        void (cb && cb());
                var Component = view.Component = handler.component
                    , activateHook = getRouteConfig(Component, "activate")
                    , dataHook = getRouteConfig(Component, "data")
                    , waitForData = getRouteConfig(Component, "waitForData");
                view.depth = depth,
                    view.activated = !1;
                var component = void 0
                    , loading = !(!dataHook || waitForData);
                if (reuse = reuse && view.childVM && view.childVM.constructor === Component)
                    component = view.childVM,
                        component.$loadingRouteData = loading;
                else if (saveChildView(view),
                        view.unbuild(!0),
                        component = view.build({
                            _meta: {
                                $loadingRouteData: loading
                            },
                            created: function() {
                                this._routerView = view
                            }
                        }),
                        view.keepAlive) {
                    component.$loadingRouteData = loading;
                    var cachedChildView = component._keepAliveRouterView;
                    cachedChildView && (view.childView = cachedChildView,
                        component._keepAliveRouterView = null)
                }
                var cleanup = function() {
                    component.$destroy()
                }
                    , insert = function() {
                    if (reuse)
                        return void (cb && cb());
                    var router = transition.router;
                    router._rendered || router._transitionOnLoad ? view.transition(component) : (view.setCurrent ? view.setCurrent(component) : view.childVM = component,
                        component.$before(view.anchor, null, !1)),
                    cb && cb()
                }
                    , afterData = function() {
                    view.childView && activate(view.childView, transition, depth + 1, null, reuse || view.keepAlive),
                        insert()
                }
                    , afterActivate = function() {
                    view.activated = !0,
                        dataHook && waitForData ? loadData(component, transition, dataHook, afterData, cleanup) : (dataHook && loadData(component, transition, dataHook),
                            afterData())
                };
                activateHook ? transition.callHooks(activateHook, component, afterActivate, {
                    cleanup: cleanup,
                    postActivate: !0
                }) : afterActivate()
            }
            function reuse(view, transition) {
                var component = view.childVM
                    , dataHook = getRouteConfig(component, "data");
                dataHook && loadData(component, transition, dataHook)
            }
            function loadData(component, transition, hook, cb, cleanup) {
                component.$loadingRouteData = !0,
                    transition.callHooks(hook, component, function() {
                        component.$loadingRouteData = !1,
                            component.$emit("route-data-loaded", component),
                        cb && cb()
                    }, {
                        cleanup: cleanup,
                        postActivate: !0,
                        processData: function(data) {
                            var promises = [];
                            if (isPlainObject(data) && Object.keys(data).forEach(function(key) {
                                    var val = data[key];
                                    isPromise(val) ? promises.push(val.then(function(resolvedVal) {
                                        component.$set(key, resolvedVal)
                                    })) : component.$set(key, val)
                                }),
                                    promises.length)
                                return promises[0].constructor.all(promises)
                        }
                    })
            }
            function saveChildView(view) {
                view.keepAlive && view.childVM && view.childView && (view.childVM._keepAliveRouterView = view.childView),
                    view.childView = null
            }
            function isPlainObject(val) {
                return "[object Object]" === Object.prototype.toString.call(val)
            }
            function isPlainOjbect(val) {
                return "[object Object]" === Object.prototype.toString.call(val)
            }
            function toArray(val) {
                return val ? Array.prototype.slice.call(val) : []
            }
            function applyOverride(Vue) {
                var _Vue$util = Vue.util
                    , extend = _Vue$util.extend
                    , isArray = _Vue$util.isArray
                    , defineReactive = _Vue$util.defineReactive
                    , init = Vue.prototype._init;
                Vue.prototype._init = function(options) {
                    options = options || {};
                    var root = options._parent || options.parent || this
                        , router = root.$router
                        , route = root.$route;
                    router && (this.$router = router,
                        router._children.push(this),
                        this._defineMeta ? this._defineMeta("$route", route) : defineReactive(this, "$route", route)),
                        init.call(this, options)
                }
                ;
                var destroy = Vue.prototype._destroy;
                Vue.prototype._destroy = function() {
                    !this._isBeingDestroyed && this.$router && this.$router._children.$remove(this),
                        destroy.apply(this, arguments)
                }
                ;
                var strats = Vue.config.optionMergeStrategies
                    , hooksToMergeRE = /^(data|activate|deactivate)$/;
                strats && (strats.route = function(parentVal, childVal) {
                        if (!childVal)
                            return parentVal;
                        if (!parentVal)
                            return childVal;
                        var ret = {};
                        extend(ret, parentVal);
                        for (var key in childVal) {
                            var a = ret[key]
                                , b = childVal[key];
                            a && hooksToMergeRE.test(key) ? ret[key] = (isArray(a) ? a : [a]).concat(b) : ret[key] = b
                        }
                        return ret
                    }
                )
            }
            function View(Vue) {
                var _ = Vue.util
                    , componentDef = Vue.directive("_component") || Vue.internalDirectives.component
                    , viewDef = _.extend({}, componentDef);
                _.extend(viewDef, {
                    _isRouterView: !0,
                    bind: function() {
                        var route = this.vm.$route;
                        if (!route)
                            return void warn$1("<router-view> can only be used inside a router-enabled app.");
                        this._isDynamicLiteral = !0,
                            componentDef.bind.call(this);
                        for (var parentView = void 0, parent = this.vm; parent; ) {
                            if (parent._routerView) {
                                parentView = parent._routerView;
                                break
                            }
                            parent = parent.$parent
                        }
                        if (parentView)
                            this.parentView = parentView,
                                parentView.childView = this;
                        else {
                            var router = route.router;
                            router._rootView = this
                        }
                        var transition = route.router._currentTransition;
                        if (!parentView && transition.done || parentView && parentView.activated) {
                            var depth = parentView ? parentView.depth + 1 : 0;
                            activate(this, transition, depth)
                        }
                    },
                    unbind: function() {
                        this.parentView && (this.parentView.childView = null),
                            componentDef.unbind.call(this)
                    }
                }),
                    Vue.elementDirective("router-view", viewDef)
            }
            function Link(Vue) {
                function sameOrigin(link) {
                    return link.protocol === location.protocol && link.hostname === location.hostname && link.port === location.port
                }
                function toggleClasses(el, key, fn) {
                    if (key = key.trim(),
                        key.indexOf(" ") === -1)
                        return void fn(el, key);
                    for (var keys = key.split(/\s+/), i = 0, l = keys.length; i < l; i++)
                        fn(el, keys[i])
                }
                var _Vue$util = Vue.util
                    , _bind = _Vue$util.bind
                    , isObject = _Vue$util.isObject
                    , addClass = _Vue$util.addClass
                    , removeClass = _Vue$util.removeClass
                    , onPriority = Vue.directive("on").priority
                    , LINK_UPDATE = "__vue-router-link-update__"
                    , activeId = 0;
                Vue.directive("link-active", {
                    priority: 9999,
                    bind: function() {
                        for (var _this = this, id = String(activeId++), childLinks = this.el.querySelectorAll("[v-link]"), i = 0, l = childLinks.length; i < l; i++) {
                            var link = childLinks[i]
                                , existingId = link.getAttribute(LINK_UPDATE)
                                , value = existingId ? existingId + "," + id : id;
                            link.setAttribute(LINK_UPDATE, value)
                        }
                        this.vm.$on(LINK_UPDATE, this.cb = function(link, path) {
                                link.activeIds.indexOf(id) > -1 && link.updateClasses(path, _this.el)
                            }
                        )
                    },
                    unbind: function() {
                        this.vm.$off(LINK_UPDATE, this.cb)
                    }
                }),
                    Vue.directive("link", {
                        priority: onPriority - 2,
                        bind: function() {
                            var vm = this.vm;
                            if (!vm.$route)
                                return void warn$1("v-link can only be used inside a router-enabled app.");
                            this.router = vm.$route.router,
                                this.unwatch = vm.$watch("$route", _bind(this.onRouteUpdate, this));
                            var activeIds = this.el.getAttribute(LINK_UPDATE);
                            activeIds && (this.el.removeAttribute(LINK_UPDATE),
                                this.activeIds = activeIds.split(",")),
                            "A" === this.el.tagName && "_blank" === this.el.getAttribute("target") || (this.handler = _bind(this.onClick, this),
                                this.el.addEventListener("click", this.handler))
                        },
                        update: function(target) {
                            this.target = target,
                            isObject(target) && (this.append = target.append,
                                this.exact = target.exact,
                                this.prevActiveClass = this.activeClass,
                                this.activeClass = target.activeClass),
                                this.onRouteUpdate(this.vm.$route)
                        },
                        onClick: function(e) {
                            if (!(e.metaKey || e.ctrlKey || e.shiftKey || e.defaultPrevented || 0 !== e.button)) {
                                var target = this.target;
                                if (target)
                                    e.preventDefault(),
                                        this.router.go(target);
                                else {
                                    for (var el = e.target; "A" !== el.tagName && el !== this.el; )
                                        el = el.parentNode;
                                    if ("A" === el.tagName && sameOrigin(el)) {
                                        e.preventDefault();
                                        var path = el.pathname;
                                        this.router.history.root && (path = path.replace(this.router.history.rootRE, "")),
                                            this.router.go({
                                                path: path,
                                                replace: target && target.replace,
                                                append: target && target.append
                                            })
                                    }
                                }
                            }
                        },
                        onRouteUpdate: function(route) {
                            var newPath = this.router.stringifyPath(this.target);
                            this.path !== newPath && (this.path = newPath,
                                this.updateActiveMatch(),
                                this.updateHref()),
                                this.activeIds ? this.vm.$emit(LINK_UPDATE, this, route.path) : this.updateClasses(route.path, this.el)
                        },
                        updateActiveMatch: function() {
                            this.activeRE = this.path && !this.exact ? new RegExp("^" + this.path.replace(/\/$/, "").replace(queryStringRE, "").replace(regexEscapeRE, "\\$&") + "(\\/|$)") : null
                        },
                        updateHref: function() {
                            if ("A" === this.el.tagName) {
                                var path = this.path
                                    , router = this.router
                                    , isAbsolute = "/" === path.charAt(0)
                                    , href = path && ("hash" === router.mode || isAbsolute) ? router.history.formatPath(path, this.append) : path;
                                href ? this.el.href = href : this.el.removeAttribute("href")
                            }
                        },
                        updateClasses: function(path, el) {
                            var activeClass = this.activeClass || this.router._linkActiveClass;
                            this.prevActiveClass && this.prevActiveClass !== activeClass && toggleClasses(el, this.prevActiveClass, removeClass);
                            var dest = this.path.replace(queryStringRE, "");
                            path = path.replace(queryStringRE, ""),
                                this.exact ? dest === path || "/" !== dest.charAt(dest.length - 1) && dest === path.replace(trailingSlashRE, "") ? toggleClasses(el, activeClass, addClass) : toggleClasses(el, activeClass, removeClass) : this.activeRE && this.activeRE.test(path) ? toggleClasses(el, activeClass, addClass) : toggleClasses(el, activeClass, removeClass)
                        },
                        unbind: function() {
                            this.el.removeEventListener("click", this.handler),
                            this.unwatch && this.unwatch()
                        }
                    })
            }
            function guardComponent(path, handler) {
                var comp = handler.component;
                Vue.util.isPlainObject(comp) && (comp = handler.component = Vue.extend(comp)),
                "function" != typeof comp && (handler.component = null,
                    warn$1('invalid component for route "' + path + '".'))
            }
            var babelHelpers = {};
            babelHelpers.classCallCheck = function(instance, Constructor) {
                if (!(instance instanceof Constructor))
                    throw new TypeError("Cannot call a class as a function")
            }
                ,
                Target.prototype = {
                    to: function(target, callback) {
                        var delegate = this.delegate;
                        if (delegate && delegate.willAddRoute && (target = delegate.willAddRoute(this.matcher.target, target)),
                                this.matcher.add(this.path, target),
                                callback) {
                            if (0 === callback.length)
                                throw new Error("You must have an argument in the function passed to `to`");
                            this.matcher.addChild(this.path, target, callback, this.delegate)
                        }
                        return this
                    }
                },
                Matcher.prototype = {
                    add: function(path, handler) {
                        this.routes[path] = handler
                    },
                    addChild: function(path, target, callback, delegate) {
                        var matcher = new Matcher(target);
                        this.children[path] = matcher;
                        var match = generateMatch(path, matcher, delegate);
                        delegate && delegate.contextEntered && delegate.contextEntered(target, match),
                            callback(match)
                    }
                };
            var specials = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\"]
                , escapeRegex = new RegExp("(\\" + specials.join("|\\") + ")","g")
                , noWarning = !1;
            StaticSegment.prototype = {
                eachChar: function(callback) {
                    for (var ch, string = this.string, i = 0, l = string.length; i < l; i++)
                        ch = string.charAt(i),
                            callback({
                                validChars: ch
                            })
                },
                regex: function() {
                    return this.string.replace(escapeRegex, "\\$1")
                },
                generate: function() {
                    return this.string
                }
            },
                DynamicSegment.prototype = {
                    eachChar: function(callback) {
                        callback({
                            invalidChars: "/",
                            repeat: !0
                        })
                    },
                    regex: function() {
                        return "([^/]+)"
                    },
                    generate: function(params) {
                        var val = params[this.name];
                        return null == val ? ":" + this.name : val
                    }
                },
                StarSegment.prototype = {
                    eachChar: function(callback) {
                        callback({
                            invalidChars: "",
                            repeat: !0
                        })
                    },
                    regex: function() {
                        return "(.+)"
                    },
                    generate: function(params) {
                        var val = params[this.name];
                        return null == val ? ":" + this.name : val
                    }
                },
                EpsilonSegment.prototype = {
                    eachChar: function() {},
                    regex: function() {
                        return ""
                    },
                    generate: function() {
                        return ""
                    }
                },
                State.prototype = {
                    get: function(charSpec) {
                        for (var nextStates = this.nextStates, i = 0, l = nextStates.length; i < l; i++) {
                            var child = nextStates[i]
                                , isEqual = child.charSpec.validChars === charSpec.validChars;
                            if (isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars)
                                return child
                        }
                    },
                    put: function(charSpec) {
                        var state;
                        return (state = this.get(charSpec)) ? state : (state = new State(charSpec),
                            this.nextStates.push(state),
                        charSpec.repeat && state.nextStates.push(state),
                            state)
                    },
                    match: function(ch) {
                        for (var child, charSpec, chars, nextStates = this.nextStates, returned = [], i = 0, l = nextStates.length; i < l; i++)
                            child = nextStates[i],
                                charSpec = child.charSpec,
                                "undefined" != typeof (chars = charSpec.validChars) ? chars.indexOf(ch) !== -1 && returned.push(child) : "undefined" != typeof (chars = charSpec.invalidChars) && chars.indexOf(ch) === -1 && returned.push(child);
                        return returned
                    }
                };
            var oCreate = Object.create || function(proto) {
                        function F() {}
                        return F.prototype = proto,
                            new F
                    }
                ;
            RecognizeResults.prototype = oCreate({
                splice: Array.prototype.splice,
                slice: Array.prototype.slice,
                push: Array.prototype.push,
                length: 0,
                queryParams: null
            });
            var RouteRecognizer = function() {
                this.rootState = new State,
                    this.names = {}
            };
            RouteRecognizer.prototype = {
                add: function(routes, options) {
                    for (var name, currentState = this.rootState, regex = "^", specificity = {}, handlers = [], allSegments = [], isEmpty = !0, i = 0, l = routes.length; i < l; i++) {
                        var route = routes[i]
                            , names = []
                            , segments = parse(route.path, names, specificity);
                        allSegments = allSegments.concat(segments);
                        for (var j = 0, m = segments.length; j < m; j++) {
                            var segment = segments[j];
                            segment instanceof EpsilonSegment || (isEmpty = !1,
                                currentState = currentState.put({
                                    validChars: "/"
                                }),
                                regex += "/",
                                currentState = addSegment(currentState, segment),
                                regex += segment.regex())
                        }
                        var handler = {
                            handler: route.handler,
                            names: names
                        };
                        handlers.push(handler)
                    }
                    isEmpty && (currentState = currentState.put({
                        validChars: "/"
                    }),
                        regex += "/"),
                        currentState.handlers = handlers,
                        currentState.regex = new RegExp(regex + "$"),
                        currentState.specificity = specificity,
                    (name = options && options.as) && (this.names[name] = {
                        segments: allSegments,
                        handlers: handlers
                    })
                },
                handlersFor: function(name) {
                    var route = this.names[name]
                        , result = [];
                    if (!route)
                        throw new Error("There is no route named " + name);
                    for (var i = 0, l = route.handlers.length; i < l; i++)
                        result.push(route.handlers[i]);
                    return result
                },
                hasRoute: function(name) {
                    return !!this.names[name]
                },
                generate: function(name, params) {
                    var route = this.names[name]
                        , output = "";
                    if (!route)
                        throw new Error("There is no route named " + name);
                    for (var segments = route.segments, i = 0, l = segments.length; i < l; i++) {
                        var segment = segments[i];
                        segment instanceof EpsilonSegment || (output += "/",
                            output += segment.generate(params))
                    }
                    return "/" !== output.charAt(0) && (output = "/" + output),
                    params && params.queryParams && (output += this.generateQueryString(params.queryParams)),
                        output
                },
                generateQueryString: function(params) {
                    var pairs = []
                        , keys = [];
                    for (var key in params)
                        params.hasOwnProperty(key) && keys.push(key);
                    keys.sort();
                    for (var i = 0, len = keys.length; i < len; i++) {
                        key = keys[i];
                        var value = params[key];
                        if (null != value) {
                            var pair = encodeURIComponent(key);
                            if (isArray(value))
                                for (var j = 0, l = value.length; j < l; j++) {
                                    var arrayPair = key + "[]=" + encodeURIComponent(value[j]);
                                    pairs.push(arrayPair)
                                }
                            else
                                pair += "=" + encodeURIComponent(value),
                                    pairs.push(pair)
                        }
                    }
                    return 0 === pairs.length ? "" : "?" + pairs.join("&")
                },
                parseQueryString: function(queryString) {
                    for (var pairs = queryString.split("&"), queryParams = {}, i = 0; i < pairs.length; i++) {
                        var value, pair = pairs[i].split("="), key = decodeQueryParamPart(pair[0]), keyLength = key.length, isArray = !1;
                        1 === pair.length ? value = "true" : (keyLength > 2 && "[]" === key.slice(keyLength - 2) && (isArray = !0,
                            key = key.slice(0, keyLength - 2),
                        queryParams[key] || (queryParams[key] = [])),
                            value = pair[1] ? decodeQueryParamPart(pair[1]) : ""),
                            isArray ? queryParams[key].push(value) : queryParams[key] = value
                    }
                    return queryParams
                },
                recognize: function(path, silent) {
                    noWarning = silent;
                    var pathLen, i, l, queryStart, states = [this.rootState], queryParams = {}, isSlashDropped = !1;
                    if (queryStart = path.indexOf("?"),
                        queryStart !== -1) {
                        var queryString = path.substr(queryStart + 1, path.length);
                        path = path.substr(0, queryStart),
                        queryString && (queryParams = this.parseQueryString(queryString))
                    }
                    if (path = tryDecode(path)) {
                        for ("/" !== path.charAt(0) && (path = "/" + path),
                                 pathLen = path.length,
                             pathLen > 1 && "/" === path.charAt(pathLen - 1) && (path = path.substr(0, pathLen - 1),
                                 isSlashDropped = !0),
                                 i = 0,
                                 l = path.length; i < l && (states = recognizeChar(states, path.charAt(i)),
                            states.length); i++)
                            ;
                        var solutions = [];
                        for (i = 0,
                                 l = states.length; i < l; i++)
                            states[i].handlers && solutions.push(states[i]);
                        states = sortSolutions(solutions);
                        var state = solutions[0];
                        return state && state.handlers ? (isSlashDropped && "(.+)$" === state.regex.source.slice(-5) && (path += "/"),
                            findHandler(state, path, queryParams)) : void 0
                    }
                }
            },
                RouteRecognizer.prototype.map = map;
            var genQuery = RouteRecognizer.prototype.generateQueryString
                , exports$1 = {}
                , resolver = void 0
                , hashRE = /#.*$/
                , HTML5History = function() {
                function HTML5History(_ref) {
                    var root = _ref.root
                        , onChange = _ref.onChange;
                    babelHelpers.classCallCheck(this, HTML5History),
                        root && "/" !== root ? ("/" !== root.charAt(0) && (root = "/" + root),
                            this.root = root.replace(/\/$/, ""),
                            this.rootRE = new RegExp("^\\" + this.root)) : this.root = null,
                        this.onChange = onChange;
                    var baseEl = document.querySelector("base");
                    this.base = baseEl && baseEl.getAttribute("href")
                }
                return HTML5History.prototype.start = function() {
                    var _this = this;
                    this.listener = function(e) {
                        var url = location.pathname + location.search;
                        _this.root && (url = url.replace(_this.rootRE, "")),
                            _this.onChange(url, e && e.state, location.hash)
                    }
                        ,
                        window.addEventListener("popstate", this.listener),
                        this.listener()
                }
                    ,
                    HTML5History.prototype.stop = function() {
                        window.removeEventListener("popstate", this.listener)
                    }
                    ,
                    HTML5History.prototype.go = function(path, replace, append) {
                        var url = this.formatPath(path, append);
                        replace ? history.replaceState({}, "", url) : (history.replaceState({
                            pos: {
                                x: window.pageXOffset,
                                y: window.pageYOffset
                            }
                        }, "", location.href),
                            history.pushState({}, "", url));
                        var hashMatch = path.match(hashRE)
                            , hash = hashMatch && hashMatch[0];
                        path = url.replace(hashRE, "").replace(this.rootRE, ""),
                            this.onChange(path, null, hash)
                    }
                    ,
                    HTML5History.prototype.formatPath = function(path, append) {
                        return "/" === path.charAt(0) ? this.root ? this.root + "/" + path.replace(/^\//, "") : path : resolvePath(this.base || location.pathname, path, append)
                    }
                    ,
                    HTML5History
            }()
                , HashHistory = function() {
                function HashHistory(_ref) {
                    var hashbang = _ref.hashbang
                        , onChange = _ref.onChange;
                    babelHelpers.classCallCheck(this, HashHistory),
                        this.hashbang = hashbang,
                        this.onChange = onChange
                }
                return HashHistory.prototype.start = function() {
                    var self = this;
                    this.listener = function() {
                        var path = location.hash
                            , raw = path.replace(/^#!?/, "");
                        "/" !== raw.charAt(0) && (raw = "/" + raw);
                        var formattedPath = self.formatPath(raw);
                        if (formattedPath !== path)
                            return void location.replace(formattedPath);
                        var query = location.search && path.indexOf("?") > -1 ? "&" + location.search.slice(1) : location.search;
                        self.onChange(path.replace(/^#!?/, "") + query)
                    }
                        ,
                        window.addEventListener("hashchange", this.listener),
                        this.listener()
                }
                    ,
                    HashHistory.prototype.stop = function() {
                        window.removeEventListener("hashchange", this.listener)
                    }
                    ,
                    HashHistory.prototype.go = function(path, replace, append) {
                        path = this.formatPath(path, append),
                            replace ? location.replace(path) : location.hash = path
                    }
                    ,
                    HashHistory.prototype.formatPath = function(path, append) {
                        var isAbsoloute = "/" === path.charAt(0)
                            , prefix = "#" + (this.hashbang ? "!" : "");
                        return isAbsoloute ? prefix + path : prefix + resolvePath(location.hash.replace(/^#!?/, ""), path, append)
                    }
                    ,
                    HashHistory
            }()
                , AbstractHistory = function() {
                function AbstractHistory(_ref) {
                    var onChange = _ref.onChange;
                    babelHelpers.classCallCheck(this, AbstractHistory),
                        this.onChange = onChange,
                        this.currentPath = "/"
                }
                return AbstractHistory.prototype.start = function() {
                    this.onChange("/")
                }
                    ,
                    AbstractHistory.prototype.stop = function() {}
                    ,
                    AbstractHistory.prototype.go = function(path, replace, append) {
                        path = this.currentPath = this.formatPath(path, append),
                            this.onChange(path)
                    }
                    ,
                    AbstractHistory.prototype.formatPath = function(path, append) {
                        return "/" === path.charAt(0) ? path : resolvePath(this.currentPath, path, append)
                    }
                    ,
                    AbstractHistory
            }()
                , RouteTransition = function() {
                function RouteTransition(router, to, from) {
                    babelHelpers.classCallCheck(this, RouteTransition),
                        this.router = router,
                        this.to = to,
                        this.from = from,
                        this.next = null,
                        this.aborted = !1,
                        this.done = !1
                }
                return RouteTransition.prototype.abort = function() {
                    if (!this.aborted) {
                        this.aborted = !0;
                        var abortingOnLoad = !this.from.path && "/" === this.to.path;
                        abortingOnLoad || this.router.replace(this.from.path || "/")
                    }
                }
                    ,
                    RouteTransition.prototype.redirect = function(path) {
                        this.aborted || (this.aborted = !0,
                            "string" == typeof path ? path = mapParams(path, this.to.params, this.to.query) : (path.params = path.params || this.to.params,
                                path.query = path.query || this.to.query),
                            this.router.replace(path))
                    }
                    ,
                    RouteTransition.prototype.start = function(cb) {
                        for (var transition = this, deactivateQueue = [], view = this.router._rootView; view; )
                            deactivateQueue.unshift(view),
                                view = view.childView;
                        var reverseDeactivateQueue = deactivateQueue.slice().reverse()
                            , activateQueue = this.activateQueue = toArray(this.to.matched).map(function(match) {
                            return match.handler
                        })
                            , i = void 0
                            , reuseQueue = void 0;
                        for (i = 0; i < reverseDeactivateQueue.length && canReuse(reverseDeactivateQueue[i], activateQueue[i], transition); i++)
                            ;
                        i > 0 && (reuseQueue = reverseDeactivateQueue.slice(0, i),
                            deactivateQueue = reverseDeactivateQueue.slice(i).reverse(),
                            activateQueue = activateQueue.slice(i)),
                            transition.runQueue(deactivateQueue, canDeactivate, function() {
                                transition.runQueue(activateQueue, canActivate, function() {
                                    transition.runQueue(deactivateQueue, deactivate, function() {
                                        if (transition.router._onTransitionValidated(transition),
                                            reuseQueue && reuseQueue.forEach(function(view) {
                                                return reuse(view, transition)
                                            }),
                                                deactivateQueue.length) {
                                            var _view = deactivateQueue[deactivateQueue.length - 1]
                                                , depth = reuseQueue ? reuseQueue.length : 0;
                                            activate(_view, transition, depth, cb)
                                        } else
                                            cb()
                                    })
                                })
                            })
                    }
                    ,
                    RouteTransition.prototype.runQueue = function(queue, fn, cb) {
                        function step(index) {
                            index >= queue.length ? cb() : fn(queue[index], transition, function() {
                                step(index + 1)
                            })
                        }
                        var transition = this;
                        step(0)
                    }
                    ,
                    RouteTransition.prototype.callHook = function(hook, context, cb) {
                        var _ref = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3]
                            , _ref$expectBoolean = _ref.expectBoolean
                            , expectBoolean = void 0 !== _ref$expectBoolean && _ref$expectBoolean
                            , _ref$postActivate = _ref.postActivate
                            , postActivate = void 0 !== _ref$postActivate && _ref$postActivate
                            , processData = _ref.processData
                            , cleanup = _ref.cleanup
                            , transition = this
                            , nextCalled = !1
                            , abort = function() {
                            cleanup && cleanup(),
                                transition.abort()
                        }
                            , onError = function(err) {
                            if (postActivate ? next() : abort(),
                                err && !transition.router._suppress)
                                throw warn$1("Uncaught error during transition: "),
                                    err instanceof Error ? err : new Error(err)
                        }
                            , onPromiseError = function(err) {
                            try {
                                onError(err)
                            } catch (e) {
                                setTimeout(function() {
                                    throw e
                                }, 0)
                            }
                        }
                            , next = function() {
                            return nextCalled ? void warn$1("transition.next() should be called only once.") : (nextCalled = !0,
                                transition.aborted ? void (cleanup && cleanup()) : void (cb && cb()))
                        }
                            , nextWithBoolean = function(res) {
                            "boolean" == typeof res ? res ? next() : abort() : isPromise(res) ? res.then(function(ok) {
                                ok ? next() : abort()
                            }, onPromiseError) : hook.length || next()
                        }
                            , nextWithData = function(data) {
                            var res = void 0;
                            try {
                                res = processData(data)
                            } catch (err) {
                                return onError(err)
                            }
                            isPromise(res) ? res.then(next, onPromiseError) : next()
                        }
                            , exposed = {
                            to: transition.to,
                            from: transition.from,
                            abort: abort,
                            next: processData ? nextWithData : next,
                            redirect: function() {
                                transition.redirect.apply(transition, arguments)
                            }
                        }
                            , res = void 0;
                        try {
                            res = hook.call(context, exposed)
                        } catch (err) {
                            return onError(err)
                        }
                        expectBoolean ? nextWithBoolean(res) : isPromise(res) ? processData ? res.then(nextWithData, onPromiseError) : res.then(next, onPromiseError) : processData && isPlainOjbect(res) ? nextWithData(res) : hook.length || next()
                    }
                    ,
                    RouteTransition.prototype.callHooks = function(hooks, context, cb, options) {
                        var _this = this;
                        Array.isArray(hooks) ? this.runQueue(hooks, function(hook, _, next) {
                            _this.aborted || _this.callHook(hook, context, next, options)
                        }, cb) : this.callHook(hooks, context, cb, options)
                    }
                    ,
                    RouteTransition
            }()
                , internalKeysRE = /^(component|subRoutes|fullPath)$/
                , Route = function Route(path, router) {
                var _this = this;
                babelHelpers.classCallCheck(this, Route);
                var matched = router._recognizer.recognize(path);
                matched && ([].forEach.call(matched, function(match) {
                    for (var key in match.handler)
                        internalKeysRE.test(key) || (_this[key] = match.handler[key])
                }),
                    this.query = matched.queryParams,
                    this.params = [].reduce.call(matched, function(prev, cur) {
                        if (cur.params)
                            for (var key in cur.params)
                                prev[key] = cur.params[key];
                        return prev
                    }, {})),
                    this.path = path,
                    this.matched = matched || router._notFoundHandler,
                    Object.defineProperty(this, "router", {
                        enumerable: !1,
                        value: router
                    }),
                    Object.freeze(this)
            }
                , trailingSlashRE = /\/$/
                , regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g
                , queryStringRE = /\?.*$/
                , historyBackends = {
                abstract: AbstractHistory,
                hash: HashHistory,
                html5: HTML5History
            }
                , Vue = void 0
                , Router = function() {
                function Router() {
                    var _this = this
                        , _ref = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0]
                        , _ref$hashbang = _ref.hashbang
                        , hashbang = void 0 === _ref$hashbang || _ref$hashbang
                        , _ref$abstract = _ref.abstract
                        , abstract = void 0 !== _ref$abstract && _ref$abstract
                        , _ref$history = _ref.history
                        , history = void 0 !== _ref$history && _ref$history
                        , _ref$saveScrollPosition = _ref.saveScrollPosition
                        , saveScrollPosition = void 0 !== _ref$saveScrollPosition && _ref$saveScrollPosition
                        , _ref$transitionOnLoad = _ref.transitionOnLoad
                        , transitionOnLoad = void 0 !== _ref$transitionOnLoad && _ref$transitionOnLoad
                        , _ref$suppressTransitionError = _ref.suppressTransitionError
                        , suppressTransitionError = void 0 !== _ref$suppressTransitionError && _ref$suppressTransitionError
                        , _ref$root = _ref.root
                        , root = void 0 === _ref$root ? null : _ref$root
                        , _ref$linkActiveClass = _ref.linkActiveClass
                        , linkActiveClass = void 0 === _ref$linkActiveClass ? "v-link-active" : _ref$linkActiveClass;
                    if (babelHelpers.classCallCheck(this, Router),
                            !Router.installed)
                        throw new Error("Please install the Router with Vue.use() before creating an instance.");
                    this.app = null,
                        this._children = [],
                        this._recognizer = new RouteRecognizer,
                        this._guardRecognizer = new RouteRecognizer,
                        this._started = !1,
                        this._startCb = null,
                        this._currentRoute = {},
                        this._currentTransition = null,
                        this._previousTransition = null,
                        this._notFoundHandler = null,
                        this._notFoundRedirect = null,
                        this._beforeEachHooks = [],
                        this._afterEachHooks = [],
                        this._rendered = !1,
                        this._transitionOnLoad = transitionOnLoad,
                        this._root = root,
                        this._abstract = abstract,
                        this._hashbang = hashbang;
                    var hasPushState = "undefined" != typeof window && window.history && window.history.pushState;
                    this._history = history && hasPushState,
                        this._historyFallback = history && !hasPushState;
                    var inBrowser = Vue.util.inBrowser;
                    this.mode = !inBrowser || this._abstract ? "abstract" : this._history ? "html5" : "hash";
                    var History = historyBackends[this.mode];
                    this.history = new History({
                        root: root,
                        hashbang: this._hashbang,
                        onChange: function(path, state, anchor) {
                            _this._match(path, state, anchor)
                        }
                    }),
                        this._saveScrollPosition = saveScrollPosition,
                        this._linkActiveClass = linkActiveClass,
                        this._suppress = suppressTransitionError
                }
                return Router.prototype.map = function(_map) {
                    for (var route in _map)
                        this.on(route, _map[route]);
                    return this
                }
                    ,
                    Router.prototype.on = function(rootPath, handler) {
                        return "*" === rootPath ? this._notFound(handler) : this._addRoute(rootPath, handler, []),
                            this
                    }
                    ,
                    Router.prototype.redirect = function(map) {
                        for (var path in map)
                            this._addRedirect(path, map[path]);
                        return this
                    }
                    ,
                    Router.prototype.alias = function(map) {
                        for (var path in map)
                            this._addAlias(path, map[path]);
                        return this
                    }
                    ,
                    Router.prototype.beforeEach = function(fn) {
                        return this._beforeEachHooks.push(fn),
                            this
                    }
                    ,
                    Router.prototype.afterEach = function(fn) {
                        return this._afterEachHooks.push(fn),
                            this
                    }
                    ,
                    Router.prototype.go = function(path) {
                        var replace = !1
                            , append = !1;
                        Vue.util.isObject(path) && (replace = path.replace,
                            append = path.append),
                            path = this.stringifyPath(path),
                        path && this.history.go(path, replace, append)
                    }
                    ,
                    Router.prototype.replace = function(path) {
                        "string" == typeof path && (path = {
                            path: path
                        }),
                            path.replace = !0,
                            this.go(path)
                    }
                    ,
                    Router.prototype.start = function(App, container, cb) {
                        if (this._started)
                            return void warn$1("already started.");
                        if (this._started = !0,
                                this._startCb = cb,
                                !this.app) {
                            if (!App || !container)
                                throw new Error("Must start vue-router with a component and a root container.");
                            if (App instanceof Vue)
                                throw new Error("Must start vue-router with a component, not a Vue instance.");
                            this._appContainer = container;
                            var Ctor = this._appConstructor = "function" == typeof App ? App : Vue.extend(App);
                            Ctor.options.name = Ctor.options.name || "RouterApp"
                        }
                        if (this._historyFallback) {
                            var _location = window.location
                                , _history = new HTML5History({
                                root: this._root
                            })
                                , path = _history.root ? _location.pathname.replace(_history.rootRE, "") : _location.pathname;
                            if (path && "/" !== path)
                                return void _location.assign((_history.root || "") + "/" + this.history.formatPath(path) + _location.search)
                        }
                        this.history.start()
                    }
                    ,
                    Router.prototype.stop = function() {
                        this.history.stop(),
                            this._started = !1
                    }
                    ,
                    Router.prototype.stringifyPath = function(path) {
                        var generatedPath = "";
                        if (path && "object" == typeof path) {
                            if (path.name) {
                                var extend = Vue.util.extend
                                    , currentParams = this._currentTransition && this._currentTransition.to.params
                                    , targetParams = path.params || {}
                                    , params = currentParams ? extend(extend({}, currentParams), targetParams) : targetParams;
                                generatedPath = encodeURI(this._recognizer.generate(path.name, params))
                            } else
                                path.path && (generatedPath = encodeURI(path.path));
                            if (path.query) {
                                var query = this._recognizer.generateQueryString(path.query);
                                generatedPath += generatedPath.indexOf("?") > -1 ? "&" + query.slice(1) : query
                            }
                        } else
                            generatedPath = encodeURI(path ? path + "" : "");
                        return generatedPath
                    }
                    ,
                    Router.prototype._addRoute = function(path, handler, segments) {
                        if (guardComponent(path, handler),
                                handler.path = path,
                                handler.fullPath = (segments.reduce(function(path, segment) {
                                    return path + segment.path
                                }, "") + path).replace("//", "/"),
                                segments.push({
                                    path: path,
                                    handler: handler
                                }),
                                this._recognizer.add(segments, {
                                    as: handler.name
                                }),
                                handler.subRoutes)
                            for (var subPath in handler.subRoutes)
                                this._addRoute(subPath, handler.subRoutes[subPath], segments.slice())
                    }
                    ,
                    Router.prototype._notFound = function(handler) {
                        guardComponent("*", handler),
                            this._notFoundHandler = [{
                                handler: handler
                            }]
                    }
                    ,
                    Router.prototype._addRedirect = function(path, redirectPath) {
                        "*" === path ? this._notFoundRedirect = redirectPath : this._addGuard(path, redirectPath, this.replace)
                    }
                    ,
                    Router.prototype._addAlias = function(path, aliasPath) {
                        this._addGuard(path, aliasPath, this._match)
                    }
                    ,
                    Router.prototype._addGuard = function(path, mappedPath, _handler) {
                        var _this2 = this;
                        this._guardRecognizer.add([{
                            path: path,
                            handler: function(match, query) {
                                var realPath = mapParams(mappedPath, match.params, query);
                                _handler.call(_this2, realPath)
                            }
                        }])
                    }
                    ,
                    Router.prototype._checkGuard = function(path) {
                        var matched = this._guardRecognizer.recognize(path, !0);
                        return matched ? (matched[0].handler(matched[0], matched.queryParams),
                            !0) : this._notFoundRedirect && (matched = this._recognizer.recognize(path),
                            !matched) ? (this.replace(this._notFoundRedirect),
                            !0) : void 0
                    }
                    ,
                    Router.prototype._match = function(path, state, anchor) {
                        var _this3 = this;
                        if (!this._checkGuard(path)) {
                            var currentRoute = this._currentRoute
                                , currentTransition = this._currentTransition;
                            if (currentTransition) {
                                if (currentTransition.to.path === path)
                                    return;
                                if (currentRoute.path === path)
                                    return currentTransition.aborted = !0,
                                        void (this._currentTransition = this._prevTransition);
                                currentTransition.aborted = !0
                            }
                            var route = new Route(path,this)
                                , transition = new RouteTransition(this,route,currentRoute);
                            this._prevTransition = currentTransition,
                                this._currentTransition = transition,
                            this.app || !function() {
                                var router = _this3;
                                _this3.app = new _this3._appConstructor({
                                    el: _this3._appContainer,
                                    created: function() {
                                        this.$router = router
                                    },
                                    _meta: {
                                        $route: route
                                    }
                                })
                            }();
                            var beforeHooks = this._beforeEachHooks
                                , startTransition = function() {
                                transition.start(function() {
                                    _this3._postTransition(route, state, anchor)
                                })
                            };
                            beforeHooks.length ? transition.runQueue(beforeHooks, function(hook, _, next) {
                                transition === _this3._currentTransition && transition.callHook(hook, null, next, {
                                    expectBoolean: !0
                                })
                            }, startTransition) : startTransition(),
                            !this._rendered && this._startCb && this._startCb.call(null),
                                this._rendered = !0
                        }
                    }
                    ,
                    Router.prototype._onTransitionValidated = function(transition) {
                        var route = this._currentRoute = transition.to;
                        this.app.$route !== route && (this.app.$route = route,
                            this._children.forEach(function(child) {
                                child.$route = route
                            })),
                        this._afterEachHooks.length && this._afterEachHooks.forEach(function(hook) {
                            return hook.call(null, {
                                to: transition.to,
                                from: transition.from
                            })
                        }),
                            this._currentTransition.done = !0
                    }
                    ,
                    Router.prototype._postTransition = function(route, state, anchor) {
                        var pos = state && state.pos;
                        pos && this._saveScrollPosition ? Vue.nextTick(function() {
                            window.scrollTo(pos.x, pos.y)
                        }) : anchor && Vue.nextTick(function() {
                            var el = document.getElementById(anchor.slice(1));
                            el && window.scrollTo(window.scrollX, el.offsetTop)
                        })
                    }
                    ,
                    Router
            }();
            return Router.installed = !1,
                Router.install = function(externalVue) {
                    return Router.installed ? void warn$1("already installed.") : (Vue = externalVue,
                        applyOverride(Vue),
                        View(Vue),
                        Link(Vue),
                        exports$1.Vue = Vue,
                        void (Router.installed = !0))
                }
                ,
            "undefined" != typeof window && window.Vue && window.Vue.use(Router),
                Router
        })
    }
        , {}],
    101: [function(require, module, exports) {
        !function(root, factory) {
            "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define([], factory) : "object" == typeof exports ? exports.VueYouTubeEmbed = factory() : root.VueYouTubeEmbed = factory()
        }(this, function() {
            return function(modules) {
                function __webpack_require__(moduleId) {
                    if (installedModules[moduleId])
                        return installedModules[moduleId].exports;
                    var module = installedModules[moduleId] = {
                        exports: {},
                        id: moduleId,
                        loaded: !1
                    };
                    return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__),
                        module.loaded = !0,
                        module.exports
                }
                var installedModules = {};
                return __webpack_require__.m = modules,
                    __webpack_require__.c = installedModules,
                    __webpack_require__.p = "",
                    __webpack_require__(0)
            }([function(module, exports) {
                "use strict";
                function getIdFromURL(url) {
                    var id = url.replace(youtubeRegexp, "$1");
                    if (id.includes(";")) {
                        var pieces = id.split(";");
                        if (pieces[1].includes("%")) {
                            var uriComponent = decodeURIComponent(pieces[1]);
                            id = ("http://youtube.com" + uriComponent).replace(youtubeRegexp, "$1")
                        } else
                            id = pieces[0]
                    } else
                        id.includes("#") && (id = id.split("#")[0]);
                    return id
                }
                function getTimeFromURL() {
                    var url = arguments.length <= 0 || void 0 === arguments[0] ? "" : arguments[0]
                        , times = url.match(timeRegexp);
                    if (!times)
                        return 0;
                    var _times = _slicedToArray(times, 3)
                        , full = _times[0]
                        , minutes = _times[1]
                        , seconds = _times[2];
                    return "undefined" != typeof seconds ? (seconds = parseInt(seconds, 10),
                        minutes = parseInt(minutes, 10)) : full.includes("m") ? (minutes = parseInt(minutes, 10),
                        seconds = 0) : (seconds = parseInt(minutes, 10),
                        minutes = 0),
                    seconds + 60 * minutes
                }
                function install(Vue) {
                    container.Vue = Vue,
                        Vue.component("youtube", YouTubePlayer),
                        Vue.prototype.$youtube = {
                            getIdFromURL: getIdFromURL,
                            getTimeFromURL: getTimeFromURL
                        };
                    var tag = document.createElement("script");
                    tag.src = "https://www.youtube.com/player_api";
                    var firstScriptTag = document.getElementsByTagName("script")[0];
                    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag),
                        window.onYouTubeIframeAPIReady = function() {
                            container.YT = YT,
                                Vue.nextTick(function() {
                                    container.run()
                                })
                        }
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var _slicedToArray = function() {
                    function sliceIterator(arr, i) {
                        var _arr = []
                            , _n = !0
                            , _d = !1
                            , _e = void 0;
                        try {
                            for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value),
                            !i || _arr.length !== i); _n = !0)
                                ;
                        } catch (err) {
                            _d = !0,
                                _e = err
                        } finally {
                            try {
                                !_n && _i.return && _i.return()
                            } finally {
                                if (_d)
                                    throw _e
                            }
                        }
                        return _arr
                    }
                    return function(arr, i) {
                        if (Array.isArray(arr))
                            return arr;
                        if (Symbol.iterator in Object(arr))
                            return sliceIterator(arr, i);
                        throw new TypeError("Invalid attempt to destructure non-iterable instance")
                    }
                }();
                exports.getIdFromURL = getIdFromURL,
                    exports.getTimeFromURL = getTimeFromURL,
                    exports.install = install,
                String.prototype.includes || (String.prototype.includes = function() {
                        return String.prototype.indexOf.apply(this, arguments) !== -1
                    }
                );
                var youtubeRegexp = /https?:\/\/(?:[0-9A-Z-]+\.)?(?:youtu\.be\/|youtube(?:-nocookie)?\.com\S*[^\w\s-])([\w-]{11})(?=[^\w-]|$)(?![?=&+%\w.-]*(?:['"][^<>]*>|<\/a>))[?=&+%\w.-]*/gi
                    , timeRegexp = /t=(\d+)[ms]?(\d+)?s?/
                    , container = exports.container = {
                    scripts: [],
                    run: function() {
                        var _this = this;
                        this.scripts.forEach(function(callback) {
                            callback(_this.YT)
                        }),
                            this.scripts = []
                    },
                    register: function(callback) {
                        var _this2 = this;
                        this.YT ? this.Vue.nextTick(function() {
                            callback(_this2.YT)
                        }) : this.scripts.push(callback)
                    }
                }
                    , events = {
                    0: "ended",
                    1: "playing",
                    2: "paused",
                    3: "buffering",
                    5: "queued"
                }
                    , pid = 0
                    , YouTubePlayer = exports.YouTubePlayer = {
                    props: ["playerHeight", "playerWidth", "playerVars", "videoId"],
                    template: '<div><div :id="elementId"></div></div>',
                    watch: {
                        playerWidth: "setSize",
                        playerHeight: "setSize",
                        videoId: "update"
                    },
                    data: function() {
                        return pid += 1,
                            {
                                elementId: "youtube-player-" + pid
                            }
                    },
                    methods: {
                        setSize: function() {
                            this.player.setSize(this.playerWidth || "640", this.playerHeight || "390")
                        },
                        update: function(videoId) {
                            var _playerVars = this.playerVars
                                , playerVars = void 0 === _playerVars ? {
                                autoplay: 0
                            } : _playerVars
                                , name = (playerVars.autoplay ? "load" : "cue") + "VideoById";
                            this.player[name](videoId)
                        }
                    },
                    ready: function() {
                        var _this3 = this;
                        container.register(function(YouTube) {
                            var _playerHeight = _this3.playerHeight
                                , height = void 0 === _playerHeight ? "390" : _playerHeight
                                , _playerWidth = _this3.playerWidth
                                , width = void 0 === _playerWidth ? "640" : _playerWidth
                                , _playerVars2 = _this3.playerVars
                                , playerVars = void 0 === _playerVars2 ? {
                                autoplay: 0,
                                start: 0
                            } : _playerVars2
                                , videoId = _this3.videoId;
                            _this3.player = new YouTube.Player(_this3.elementId,{
                                height: height,
                                width: width,
                                playerVars: playerVars,
                                videoId: videoId,
                                events: {
                                    onReady: function(event) {
                                        _this3.$emit("ready", event.target)
                                    },
                                    onStateChange: function(event) {
                                        event.data !== -1 && _this3.$emit(events[event.data], event.target)
                                    },
                                    onError: function(event) {
                                        _this3.$emit("error", event.target)
                                    }
                                }
                            })
                        })
                    },
                    beforeDestroy: function() {
                        null !== this.player && this.player.destroy(),
                            delete this.player
                    }
                };
                exports.default = {
                    getIdFromURL: getIdFromURL,
                    getTimeFromURL: getTimeFromURL,
                    YouTubePlayer: YouTubePlayer,
                    install: install
                }
            }
            ])
        })
    }
        , {}],
    102: [function(require, module, exports) {
        "use strict";
        function set(obj, key, val) {
            if (hasOwn(obj, key))
                return void (obj[key] = val);
            if (obj._isVue)
                return void set(obj._data, key, val);
            var ob = obj.__ob__;
            if (!ob)
                return void (obj[key] = val);
            if (ob.convert(key, val),
                    ob.dep.notify(),
                    ob.vms)
                for (var i = ob.vms.length; i--; ) {
                    var vm = ob.vms[i];
                    vm._proxy(key),
                        vm._digest()
                }
            return val
        }
        function del(obj, key) {
            if (hasOwn(obj, key)) {
                delete obj[key];
                var ob = obj.__ob__;
                if (!ob)
                    return void (obj._isVue && (delete obj._data[key],
                        obj._digest()));
                if (ob.dep.notify(),
                        ob.vms)
                    for (var i = ob.vms.length; i--; ) {
                        var vm = ob.vms[i];
                        vm._unproxy(key),
                            vm._digest()
                    }
            }
        }
        function hasOwn(obj, key) {
            return hasOwnProperty.call(obj, key)
        }
        function isLiteral(exp) {
            return literalValueRE.test(exp)
        }
        function isReserved(str) {
            var c = (str + "").charCodeAt(0);
            return 36 === c || 95 === c
        }
        function _toString(value) {
            return null == value ? "" : value.toString()
        }
        function toNumber(value) {
            if ("string" != typeof value)
                return value;
            var parsed = Number(value);
            return isNaN(parsed) ? value : parsed
        }
        function toBoolean(value) {
            return "true" === value || "false" !== value && value
        }
        function stripQuotes(str) {
            var a = str.charCodeAt(0)
                , b = str.charCodeAt(str.length - 1);
            return a !== b || 34 !== a && 39 !== a ? str : str.slice(1, -1)
        }
        function camelize(str) {
            return str.replace(camelizeRE, toUpper)
        }
        function toUpper(_, c) {
            return c ? c.toUpperCase() : ""
        }
        function hyphenate(str) {
            return str.replace(hyphenateRE, "$1-$2").replace(hyphenateRE, "$1-$2").toLowerCase()
        }
        function classify(str) {
            return str.replace(classifyRE, toUpper)
        }
        function bind(fn, ctx) {
            return function(a) {
                var l = arguments.length;
                return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx)
            }
        }
        function toArray(list, start) {
            start = start || 0;
            for (var i = list.length - start, ret = new Array(i); i--; )
                ret[i] = list[i + start];
            return ret
        }
        function extend(to, from) {
            for (var keys = Object.keys(from), i = keys.length; i--; )
                to[keys[i]] = from[keys[i]];
            return to
        }
        function isObject(obj) {
            return null !== obj && "object" == typeof obj
        }
        function isPlainObject(obj) {
            return toString.call(obj) === OBJECT_STRING
        }
        function def(obj, key, val, enumerable) {
            Object.defineProperty(obj, key, {
                value: val,
                enumerable: !!enumerable,
                writable: !0,
                configurable: !0
            })
        }
        function _debounce(func, wait) {
            var timeout, args, context, timestamp, result, later = function later() {
                var last = Date.now() - timestamp;
                last < wait && last >= 0 ? timeout = setTimeout(later, wait - last) : (timeout = null,
                    result = func.apply(context, args),
                timeout || (context = args = null))
            };
            return function() {
                return context = this,
                    args = arguments,
                    timestamp = Date.now(),
                timeout || (timeout = setTimeout(later, wait)),
                    result
            }
        }
        function indexOf(arr, obj) {
            for (var i = arr.length; i--; )
                if (arr[i] === obj)
                    return i;
            return -1
        }
        function cancellable(fn) {
            var cb = function cb() {
                if (!cb.cancelled)
                    return fn.apply(this, arguments)
            };
            return cb.cancel = function() {
                cb.cancelled = !0
            }
                ,
                cb
        }
        function looseEqual(a, b) {
            return a == b || !(!isObject(a) || !isObject(b)) && JSON.stringify(a) === JSON.stringify(b)
        }
        function isNative(Ctor) {
            return /native code/.test(Ctor.toString())
        }
        function Cache(limit) {
            this.size = 0,
                this.limit = limit,
                this.head = this.tail = void 0,
                this._keymap = Object.create(null)
        }
        function peek() {
            return str.charCodeAt(index + 1)
        }
        function next() {
            return str.charCodeAt(++index)
        }
        function eof() {
            return index >= len
        }
        function eatSpace() {
            for (; peek() === spaceChr; )
                next()
        }
        function isStringStart(chr) {
            return chr === doubleChr || chr === singleChr
        }
        function isExpStart(chr) {
            return expStartChr[chr]
        }
        function isExpEnd(start, chr) {
            return expChrPair[start] === chr
        }
        function parseString() {
            for (var chr, stringQuote = next(); !eof(); )
                if (chr = next(),
                    chr === escapeChr)
                    next();
                else if (chr === stringQuote)
                    break
        }
        function parseSpecialExp(chr) {
            for (var inExp = 0, startChr = chr; !eof(); )
                if (chr = peek(),
                        isStringStart(chr))
                    parseString();
                else if (startChr === chr && inExp++,
                    isExpEnd(startChr, chr) && inExp--,
                        next(),
                    0 === inExp)
                    break
        }
        function parseExpression() {
            for (var start = index; !eof(); )
                if (chr = peek(),
                        isStringStart(chr))
                    parseString();
                else if (isExpStart(chr))
                    parseSpecialExp(chr);
                else if (chr === pipeChr) {
                    if (next(),
                            chr = peek(),
                        chr !== pipeChr) {
                        state !== startState && state !== filterArgState || (state = filterState);
                        break
                    }
                    next()
                } else {
                    if (chr === spaceChr && (state === filterNameState || state === filterArgState)) {
                        eatSpace();
                        break
                    }
                    state === filterState && (state = filterNameState),
                        next()
                }
            return str.slice(start + 1, index) || null
        }
        function parseFilterList() {
            for (var filters = []; !eof(); )
                filters.push(parseFilter());
            return filters
        }
        function parseFilter() {
            var args, filter = {};
            return state = filterState,
                filter.name = parseExpression().trim(),
                state = filterArgState,
                args = parseFilterArguments(),
            args.length && (filter.args = args),
                filter
        }
        function parseFilterArguments() {
            for (var args = []; !eof() && state !== filterState; ) {
                var arg = parseExpression();
                if (!arg)
                    break;
                args.push(processFilterArg(arg))
            }
            return args
        }
        function processFilterArg(arg) {
            if (reservedArgRE.test(arg))
                return {
                    value: toNumber(arg),
                    dynamic: !1
                };
            var stripped = stripQuotes(arg)
                , dynamic = stripped === arg;
            return {
                value: dynamic ? arg : stripped,
                dynamic: dynamic
            }
        }
        function parseDirective(s) {
            var hit = cache$1.get(s);
            if (hit)
                return hit;
            str = s,
                dir = {},
                len = str.length,
                index = -1,
                chr = "",
                state = startState;
            var filters;
            return str.indexOf("|") < 0 ? dir.expression = str.trim() : (dir.expression = parseExpression().trim(),
                filters = parseFilterList(),
            filters.length && (dir.filters = filters)),
                cache$1.put(s, dir),
                dir
        }
        function escapeRegex(str) {
            return str.replace(regexEscapeRE, "\\$&")
        }
        function compileRegex() {
            var open = escapeRegex(config.delimiters[0])
                , close = escapeRegex(config.delimiters[1])
                , unsafeOpen = escapeRegex(config.unsafeDelimiters[0])
                , unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
            tagRE = new RegExp(unsafeOpen + "((?:.|\\n)+?)" + unsafeClose + "|" + open + "((?:.|\\n)+?)" + close,"g"),
                htmlRE = new RegExp("^" + unsafeOpen + "((?:.|\\n)+?)" + unsafeClose + "$"),
                cache = new Cache(1e3)
        }
        function parseText(text) {
            cache || compileRegex();
            var hit = cache.get(text);
            if (hit)
                return hit;
            if (!tagRE.test(text))
                return null;
            for (var match, index, html, value, first, oneTime, tokens = [], lastIndex = tagRE.lastIndex = 0; match = tagRE.exec(text); )
                index = match.index,
                index > lastIndex && tokens.push({
                    value: text.slice(lastIndex, index)
                }),
                    html = htmlRE.test(match[0]),
                    value = html ? match[1] : match[2],
                    first = value.charCodeAt(0),
                    oneTime = 42 === first,
                    value = oneTime ? value.slice(1) : value,
                    tokens.push({
                        tag: !0,
                        value: value.trim(),
                        html: html,
                        oneTime: oneTime
                    }),
                    lastIndex = index + match[0].length;
            return lastIndex < text.length && tokens.push({
                value: text.slice(lastIndex)
            }),
                cache.put(text, tokens),
                tokens
        }
        function tokensToExp(tokens, vm) {
            return tokens.length > 1 ? tokens.map(function(token) {
                return formatToken(token, vm)
            }).join("+") : formatToken(tokens[0], vm, !0)
        }
        function formatToken(token, vm, single) {
            return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"'
        }
        function inlineFilters(exp, single) {
            if (filterRE.test(exp)) {
                var dir = parseDirective(exp);
                return dir.filters ? "this._applyFilters(" + dir.expression + ",null," + JSON.stringify(dir.filters) + ",false)" : "(" + exp + ")"
            }
            return single ? exp : "(" + exp + ")"
        }
        function appendWithTransition(el, target, vm, cb) {
            applyTransition(el, 1, function() {
                target.appendChild(el)
            }, vm, cb)
        }
        function beforeWithTransition(el, target, vm, cb) {
            applyTransition(el, 1, function() {
                before(el, target)
            }, vm, cb)
        }
        function removeWithTransition(el, vm, cb) {
            applyTransition(el, -1, function() {
                remove(el)
            }, vm, cb)
        }
        function applyTransition(el, direction, op, vm, cb) {
            var transition = el.__v_trans;
            if (!transition || !transition.hooks && !transitionEndEvent || !vm._isCompiled || vm.$parent && !vm.$parent._isCompiled)
                return op(),
                    void (cb && cb());
            var action = direction > 0 ? "enter" : "leave";
            transition[action](op, cb)
        }
        function query(el) {
            if ("string" == typeof el) {
                el = document.querySelector(el)
            }
            return el
        }
        function inDoc(node) {
            if (!node)
                return !1;
            var doc = node.ownerDocument.documentElement
                , parent = node.parentNode;
            return doc === node || doc === parent || !(!parent || 1 !== parent.nodeType || !doc.contains(parent))
        }
        function getAttr(node, _attr) {
            var val = node.getAttribute(_attr);
            return null !== val && node.removeAttribute(_attr),
                val
        }
        function getBindAttr(node, name) {
            var val = getAttr(node, ":" + name);
            return null === val && (val = getAttr(node, "v-bind:" + name)),
                val
        }
        function hasBindAttr(node, name) {
            return node.hasAttribute(name) || node.hasAttribute(":" + name) || node.hasAttribute("v-bind:" + name)
        }
        function before(el, target) {
            target.parentNode.insertBefore(el, target)
        }
        function after(el, target) {
            target.nextSibling ? before(el, target.nextSibling) : target.parentNode.appendChild(el)
        }
        function remove(el) {
            el.parentNode.removeChild(el)
        }
        function prepend(el, target) {
            target.firstChild ? before(el, target.firstChild) : target.appendChild(el)
        }
        function replace(target, el) {
            var parent = target.parentNode;
            parent && parent.replaceChild(el, target)
        }
        function on(el, event, cb, useCapture) {
            el.addEventListener(event, cb, useCapture)
        }
        function off(el, event, cb) {
            el.removeEventListener(event, cb)
        }
        function getClass(el) {
            var classname = el.className;
            return "object" == typeof classname && (classname = classname.baseVal || ""),
                classname
        }
        function setClass(el, cls) {
            isIE9 && !/svg$/.test(el.namespaceURI) ? el.className = cls : el.setAttribute("class", cls)
        }
        function addClass(el, cls) {
            if (el.classList)
                el.classList.add(cls);
            else {
                var cur = " " + getClass(el) + " ";
                cur.indexOf(" " + cls + " ") < 0 && setClass(el, (cur + cls).trim())
            }
        }
        function removeClass(el, cls) {
            if (el.classList)
                el.classList.remove(cls);
            else {
                for (var cur = " " + getClass(el) + " ", tar = " " + cls + " "; cur.indexOf(tar) >= 0; )
                    cur = cur.replace(tar, " ");
                setClass(el, cur.trim())
            }
            el.className || el.removeAttribute("class")
        }
        function extractContent(el, asFragment) {
            var child, rawContent;
            if (isTemplate(el) && isFragment(el.content) && (el = el.content),
                    el.hasChildNodes())
                for (trimNode(el),
                         rawContent = asFragment ? document.createDocumentFragment() : document.createElement("div"); child = el.firstChild; )
                    rawContent.appendChild(child);
            return rawContent
        }
        function trimNode(node) {
            for (var child; child = node.firstChild,
                isTrimmable(child); )
                node.removeChild(child);
            for (; child = node.lastChild,
                       isTrimmable(child); )
                node.removeChild(child)
        }
        function isTrimmable(node) {
            return node && (3 === node.nodeType && !node.data.trim() || 8 === node.nodeType)
        }
        function isTemplate(el) {
            return el.tagName && "template" === el.tagName.toLowerCase()
        }
        function createAnchor(content, persist) {
            var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? " " : "");
            return anchor.__v_anchor = !0,
                anchor
        }
        function findRef(node) {
            if (node.hasAttributes())
                for (var attrs = node.attributes, i = 0, l = attrs.length; i < l; i++) {
                    var name = attrs[i].name;
                    if (refRE.test(name))
                        return camelize(name.replace(refRE, ""))
                }
        }
        function mapNodeRange(node, end, op) {
            for (var next; node !== end; )
                next = node.nextSibling,
                    op(node),
                    node = next;
            op(end)
        }
        function removeNodeRange(start, end, vm, frag, cb) {
            function onRemoved() {
                if (removed++,
                    done && removed >= nodes.length) {
                    for (var i = 0; i < nodes.length; i++)
                        frag.appendChild(nodes[i]);
                    cb && cb()
                }
            }
            var done = !1
                , removed = 0
                , nodes = [];
            mapNodeRange(start, end, function(node) {
                node === end && (done = !0),
                    nodes.push(node),
                    removeWithTransition(node, vm, onRemoved)
            })
        }
        function isFragment(node) {
            return node && 11 === node.nodeType
        }
        function getOuterHTML(el) {
            if (el.outerHTML)
                return el.outerHTML;
            var container = document.createElement("div");
            return container.appendChild(el.cloneNode(!0)),
                container.innerHTML
        }
        function checkComponentAttr(el, options) {
            var tag = el.tagName.toLowerCase()
                , hasAttrs = el.hasAttributes();
            if (commonTagRE.test(tag) || reservedTagRE.test(tag)) {
                if (hasAttrs)
                    return getIsBinding(el, options)
            } else {
                if (resolveAsset(options, "components", tag))
                    return {
                        id: tag
                    };
                var is = hasAttrs && getIsBinding(el, options);
                if (is)
                    return is
            }
        }
        function getIsBinding(el, options) {
            var exp = el.getAttribute("is");
            if (null != exp) {
                if (resolveAsset(options, "components", exp))
                    return el.removeAttribute("is"),
                        {
                            id: exp
                        }
            } else if (exp = getBindAttr(el, "is"),
                null != exp)
                return {
                    id: exp,
                    dynamic: !0
                }
        }
        function mergeData(to, from) {
            var key, toVal, fromVal;
            for (key in from)
                toVal = to[key],
                    fromVal = from[key],
                    hasOwn(to, key) ? isObject(toVal) && isObject(fromVal) && mergeData(toVal, fromVal) : set(to, key, fromVal);
            return to
        }
        function mergeAssets(parentVal, childVal) {
            var res = Object.create(parentVal || null);
            return childVal ? extend(res, guardArrayAssets(childVal)) : res
        }
        function guardComponents(options) {
            if (options.components)
                for (var def, components = options.components = guardArrayAssets(options.components), ids = Object.keys(components), i = 0, l = ids.length; i < l; i++) {
                    var key = ids[i];
                    commonTagRE.test(key) || reservedTagRE.test(key) || (def = components[key],
                    isPlainObject(def) && (components[key] = Vue.extend(def)))
                }
        }
        function guardProps(options) {
            var i, val, props = options.props;
            if (isArray(props))
                for (options.props = {},
                         i = props.length; i--; )
                    val = props[i],
                        "string" == typeof val ? options.props[val] = null : val.name && (options.props[val.name] = val);
            else if (isPlainObject(props)) {
                var keys = Object.keys(props);
                for (i = keys.length; i--; )
                    val = props[keys[i]],
                    "function" == typeof val && (props[keys[i]] = {
                        type: val
                    })
            }
        }
        function guardArrayAssets(assets) {
            if (isArray(assets)) {
                for (var asset, res = {}, i = assets.length; i--; ) {
                    asset = assets[i];
                    var id = "function" == typeof asset ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
                    id && (res[id] = asset)
                }
                return res
            }
            return assets
        }
        function mergeOptions(parent, child, vm) {
            function mergeField(key) {
                var strat = strats[key] || defaultStrat;
                options[key] = strat(parent[key], child[key], vm, key)
            }
            guardComponents(child),
                guardProps(child);
            var key, options = {};
            if (child.extends && (parent = "function" == typeof child.extends ? mergeOptions(parent, child.extends.options, vm) : mergeOptions(parent, child.extends, vm)),
                    child.mixins)
                for (var i = 0, l = child.mixins.length; i < l; i++) {
                    var mixin = child.mixins[i]
                        , mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;
                    parent = mergeOptions(parent, mixinOptions, vm)
                }
            for (key in parent)
                mergeField(key);
            for (key in child)
                hasOwn(parent, key) || mergeField(key);
            return options
        }
        function resolveAsset(options, type, id, warnMissing) {
            if ("string" == typeof id) {
                var camelizedId, assets = options[type], res = assets[id] || assets[camelizedId = camelize(id)] || assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
                return res
            }
        }
        function Dep() {
            this.id = uid$1++,
                this.subs = []
        }
        function withoutConversion(fn) {
            shouldConvert = !1,
                fn(),
                shouldConvert = !0
        }
        function Observer(value) {
            if (this.value = value,
                    this.dep = new Dep,
                    def(value, "__ob__", this),
                    isArray(value)) {
                var augment = hasProto ? protoAugment : copyAugment;
                augment(value, arrayMethods, arrayKeys),
                    this.observeArray(value)
            } else
                this.walk(value)
        }
        function protoAugment(target, src) {
            target.__proto__ = src
        }
        function copyAugment(target, src, keys) {
            for (var i = 0, l = keys.length; i < l; i++) {
                var key = keys[i];
                def(target, key, src[key])
            }
        }
        function observe(value, vm) {
            if (value && "object" == typeof value) {
                var ob;
                return hasOwn(value, "__ob__") && value.__ob__ instanceof Observer ? ob = value.__ob__ : shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue && (ob = new Observer(value)),
                ob && vm && ob.addVm(vm),
                    ob
            }
        }
        function defineReactive(obj, key, val) {
            var dep = new Dep
                , property = Object.getOwnPropertyDescriptor(obj, key);
            if (!property || property.configurable !== !1) {
                var getter = property && property.get
                    , setter = property && property.set
                    , childOb = observe(val);
                Object.defineProperty(obj, key, {
                    enumerable: !0,
                    configurable: !0,
                    get: function() {
                        var value = getter ? getter.call(obj) : val;
                        if (Dep.target && (dep.depend(),
                            childOb && childOb.dep.depend(),
                                isArray(value)))
                            for (var e, i = 0, l = value.length; i < l; i++)
                                e = value[i],
                                e && e.__ob__ && e.__ob__.dep.depend();
                        return value
                    },
                    set: function(newVal) {
                        var value = getter ? getter.call(obj) : val;
                        newVal !== value && (setter ? setter.call(obj, newVal) : val = newVal,
                            childOb = observe(newVal),
                            dep.notify())
                    }
                })
            }
        }
        function initMixin(Vue) {
            Vue.prototype._init = function(options) {
                options = options || {},
                    this.$el = null,
                    this.$parent = options.parent,
                    this.$root = this.$parent ? this.$parent.$root : this,
                    this.$children = [],
                    this.$refs = {},
                    this.$els = {},
                    this._watchers = [],
                    this._directives = [],
                    this._uid = uid++,
                    this._isVue = !0,
                    this._events = {},
                    this._eventsCount = {},
                    this._isFragment = !1,
                    this._fragment = this._fragmentStart = this._fragmentEnd = null,
                    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = !1,
                    this._unlinkFn = null,
                    this._context = options._context || this.$parent,
                    this._scope = options._scope,
                    this._frag = options._frag,
                this._frag && this._frag.children.push(this),
                this.$parent && this.$parent.$children.push(this),
                    options = this.$options = mergeOptions(this.constructor.options, options, this),
                    this._updateRef(),
                    this._data = {},
                    this._callHook("init"),
                    this._initState(),
                    this._initEvents(),
                    this._callHook("created"),
                options.el && this.$mount(options.el)
            }
        }
        function getPathCharType(ch) {
            if (void 0 === ch)
                return "eof";
            var code = ch.charCodeAt(0);
            switch (code) {
                case 91:
                case 93:
                case 46:
                case 34:
                case 39:
                case 48:
                    return ch;
                case 95:
                case 36:
                    return "ident";
                case 32:
                case 9:
                case 10:
                case 13:
                case 160:
                case 65279:
                case 8232:
                case 8233:
                    return "ws"
            }
            return code >= 97 && code <= 122 || code >= 65 && code <= 90 ? "ident" : code >= 49 && code <= 57 ? "number" : "else"
        }
        function formatSubPath(path) {
            var trimmed = path.trim();
            return ("0" !== path.charAt(0) || !isNaN(path)) && (isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed)
        }
        function parse(path) {
            function maybeUnescapeQuote() {
                var nextChar = path[index + 1];
                if (mode === IN_SINGLE_QUOTE && "'" === nextChar || mode === IN_DOUBLE_QUOTE && '"' === nextChar)
                    return index++,
                        newChar = "\\" + nextChar,
                        actions[APPEND](),
                        !0
            }
            var c, newChar, key, type, transition, action, typeMap, keys = [], index = -1, mode = BEFORE_PATH, subPathDepth = 0, actions = [];
            for (actions[PUSH] = function() {
                void 0 !== key && (keys.push(key),
                    key = void 0)
            }
                     ,
                     actions[APPEND] = function() {
                         void 0 === key ? key = newChar : key += newChar
                     }
                     ,
                     actions[INC_SUB_PATH_DEPTH] = function() {
                         actions[APPEND](),
                             subPathDepth++
                     }
                     ,
                     actions[PUSH_SUB_PATH] = function() {
                         if (subPathDepth > 0)
                             subPathDepth--,
                                 mode = IN_SUB_PATH,
                                 actions[APPEND]();
                         else {
                             if (subPathDepth = 0,
                                     key = formatSubPath(key),
                                 key === !1)
                                 return !1;
                             actions[PUSH]()
                         }
                     }
                ; null != mode; )
                if (index++,
                        c = path[index],
                    "\\" !== c || !maybeUnescapeQuote()) {
                    if (type = getPathCharType(c),
                            typeMap = pathStateMachine[mode],
                            transition = typeMap[type] || typeMap.else || ERROR,
                        transition === ERROR)
                        return;
                    if (mode = transition[0],
                            action = actions[transition[1]],
                        action && (newChar = transition[2],
                            newChar = void 0 === newChar ? c : newChar,
                        action() === !1))
                        return;
                    if (mode === AFTER_PATH)
                        return keys.raw = path,
                            keys
                }
        }
        function parsePath(path) {
            var hit = pathCache.get(path);
            return hit || (hit = parse(path),
            hit && pathCache.put(path, hit)),
                hit
        }
        function getPath(obj, path) {
            return parseExpression$1(path).get(obj)
        }
        function setPath(obj, path, val) {
            var original = obj;
            if ("string" == typeof path && (path = parse(path)),
                !path || !isObject(obj))
                return !1;
            for (var last, key, i = 0, l = path.length; i < l; i++)
                last = obj,
                    key = path[i],
                "*" === key.charAt(0) && (key = parseExpression$1(key.slice(1)).get.call(original, original)),
                    i < l - 1 ? (obj = obj[key],
                    isObject(obj) || (obj = {},
                        set(last, key, obj))) : isArray(obj) ? obj.$set(key, val) : key in obj ? obj[key] = val : set(obj, key, val);
            return !0
        }
        function noop() {}
        function save(str, isString) {
            var i = saved.length;
            return saved[i] = isString ? str.replace(newlineRE, "\\n") : str,
            '"' + i + '"'
        }
        function rewrite(raw) {
            var c = raw.charAt(0)
                , path = raw.slice(1);
            return allowedKeywordsRE.test(path) ? raw : (path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path,
            c + "scope." + path)
        }
        function restore(str, i) {
            return saved[i]
        }
        function compileGetter(exp) {
            improperKeywordsRE.test(exp),
                saved.length = 0;
            var body = exp.replace(saveRE, save).replace(wsRE, "");
            return body = (" " + body).replace(identRE, rewrite).replace(restoreRE, restore),
                makeGetterFn(body)
        }
        function makeGetterFn(body) {
            try {
                return new Function("scope","return " + body + ";")
            } catch (e) {
                return noop
            }
        }
        function compileSetter(exp) {
            var path = parsePath(exp);
            if (path)
                return function(scope, val) {
                    setPath(scope, path, val)
                }
        }
        function parseExpression$1(exp, needSet) {
            exp = exp.trim();
            var hit = expressionCache.get(exp);
            if (hit)
                return needSet && !hit.set && (hit.set = compileSetter(hit.exp)),
                    hit;
            var res = {
                exp: exp
            };
            return res.get = isSimplePath(exp) && exp.indexOf("[") < 0 ? makeGetterFn("scope." + exp) : compileGetter(exp),
            needSet && (res.set = compileSetter(exp)),
                expressionCache.put(exp, res),
                res
        }
        function isSimplePath(exp) {
            return pathTestRE.test(exp) && !literalValueRE$1.test(exp) && "Math." !== exp.slice(0, 5)
        }
        function resetBatcherState() {
            queue.length = 0,
                userQueue.length = 0,
                has = {},
                circular = {},
                waiting = !1
        }
        function flushBatcherQueue() {
            for (var _again = !0; _again; )
                _again = !1,
                    runBatcherQueue(queue),
                    runBatcherQueue(userQueue),
                    queue.length ? _again = !0 : (devtools && config.devtools && devtools.emit("flush"),
                        resetBatcherState())
        }
        function runBatcherQueue(queue) {
            for (var i = 0; i < queue.length; i++) {
                var watcher = queue[i]
                    , id = watcher.id;
                has[id] = null,
                    watcher.run()
            }
            queue.length = 0
        }
        function pushWatcher(watcher) {
            var id = watcher.id;
            if (null == has[id]) {
                var q = watcher.user ? userQueue : queue;
                has[id] = q.length,
                    q.push(watcher),
                waiting || (waiting = !0,
                    nextTick(flushBatcherQueue))
            }
        }
        function Watcher(vm, expOrFn, cb, options) {
            options && extend(this, options);
            var isFn = "function" == typeof expOrFn;
            if (this.vm = vm,
                    vm._watchers.push(this),
                    this.expression = expOrFn,
                    this.cb = cb,
                    this.id = ++uid$2,
                    this.active = !0,
                    this.dirty = this.lazy,
                    this.deps = [],
                    this.newDeps = [],
                    this.depIds = new _Set,
                    this.newDepIds = new _Set,
                    this.prevError = null,
                    isFn)
                this.getter = expOrFn,
                    this.setter = void 0;
            else {
                var res = parseExpression$1(expOrFn, this.twoWay);
                this.getter = res.get,
                    this.setter = res.set
            }
            this.value = this.lazy ? void 0 : this.get(),
                this.queued = this.shallow = !1
        }
        function traverse(val, seen) {
            var i = void 0
                , keys = void 0;
            seen || (seen = seenObjects,
                seen.clear());
            var isA = isArray(val)
                , isO = isObject(val);
            if ((isA || isO) && Object.isExtensible(val)) {
                if (val.__ob__) {
                    var depId = val.__ob__.dep.id;
                    if (seen.has(depId))
                        return;
                    seen.add(depId)
                }
                if (isA)
                    for (i = val.length; i--; )
                        traverse(val[i], seen);
                else if (isO)
                    for (keys = Object.keys(val),
                             i = keys.length; i--; )
                        traverse(val[keys[i]], seen)
            }
        }
        function isRealTemplate(node) {
            return isTemplate(node) && isFragment(node.content)
        }
        function stringToFragment(templateString, raw) {
            var cacheKey = raw ? templateString : templateString.trim()
                , hit = templateCache.get(cacheKey);
            if (hit)
                return hit;
            var frag = document.createDocumentFragment()
                , tagMatch = templateString.match(tagRE$1)
                , entityMatch = entityRE.test(templateString)
                , commentMatch = commentRE.test(templateString);
            if (tagMatch || entityMatch || commentMatch) {
                var tag = tagMatch && tagMatch[1]
                    , wrap = map[tag] || map.efault
                    , depth = wrap[0]
                    , prefix = wrap[1]
                    , suffix = wrap[2]
                    , node = document.createElement("div");
                for (node.innerHTML = prefix + templateString + suffix; depth--; )
                    node = node.lastChild;
                for (var child; child = node.firstChild; )
                    frag.appendChild(child)
            } else
                frag.appendChild(document.createTextNode(templateString));
            return raw || trimNode(frag),
                templateCache.put(cacheKey, frag),
                frag
        }
        function nodeToFragment(node) {
            if (isRealTemplate(node))
                return stringToFragment(node.innerHTML);
            if ("SCRIPT" === node.tagName)
                return stringToFragment(node.textContent);
            for (var child, clonedNode = cloneNode(node), frag = document.createDocumentFragment(); child = clonedNode.firstChild; )
                frag.appendChild(child);
            return trimNode(frag),
                frag
        }
        function cloneNode(node) {
            if (!node.querySelectorAll)
                return node.cloneNode();
            var i, original, cloned, res = node.cloneNode(!0);
            if (hasBrokenTemplate) {
                var tempClone = res;
                if (isRealTemplate(node) && (node = node.content,
                        tempClone = res.content),
                        original = node.querySelectorAll("template"),
                        original.length)
                    for (cloned = tempClone.querySelectorAll("template"),
                             i = cloned.length; i--; )
                        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i])
            }
            if (hasTextareaCloneBug)
                if ("TEXTAREA" === node.tagName)
                    res.value = node.value;
                else if (original = node.querySelectorAll("textarea"),
                        original.length)
                    for (cloned = res.querySelectorAll("textarea"),
                             i = cloned.length; i--; )
                        cloned[i].value = original[i].value;
            return res
        }
        function parseTemplate(template, shouldClone, raw) {
            var node, frag;
            return isFragment(template) ? (trimNode(template),
                shouldClone ? cloneNode(template) : template) : ("string" == typeof template ? raw || "#" !== template.charAt(0) ? frag = stringToFragment(template, raw) : (frag = idSelectorCache.get(template),
            frag || (node = document.getElementById(template.slice(1)),
            node && (frag = nodeToFragment(node),
                idSelectorCache.put(template, frag)))) : template.nodeType && (frag = nodeToFragment(template)),
                frag && shouldClone ? cloneNode(frag) : frag)
        }
        function Fragment(linker, vm, frag, host, scope, parentFrag) {
            this.children = [],
                this.childFrags = [],
                this.vm = vm,
                this.scope = scope,
                this.inserted = !1,
                this.parentFrag = parentFrag,
            parentFrag && parentFrag.childFrags.push(this),
                this.unlink = linker(vm, frag, host, scope, this);
            var single = this.single = 1 === frag.childNodes.length && !frag.childNodes[0].__v_anchor;
            single ? (this.node = frag.childNodes[0],
                this.before = singleBefore,
                this.remove = singleRemove) : (this.node = createAnchor("fragment-start"),
                this.end = createAnchor("fragment-end"),
                this.frag = frag,
                prepend(this.node, frag),
                frag.appendChild(this.end),
                this.before = multiBefore,
                this.remove = multiRemove),
                this.node.__v_frag = this
        }
        function singleBefore(target, withTransition) {
            this.inserted = !0;
            var method = withTransition !== !1 ? beforeWithTransition : before;
            method(this.node, target, this.vm),
            inDoc(this.node) && this.callHook(attach)
        }
        function singleRemove() {
            this.inserted = !1;
            var shouldCallRemove = inDoc(this.node)
                , self = this;
            this.beforeRemove(),
                removeWithTransition(this.node, this.vm, function() {
                    shouldCallRemove && self.callHook(detach),
                        self.destroy()
                })
        }
        function multiBefore(target, withTransition) {
            this.inserted = !0;
            var vm = this.vm
                , method = withTransition !== !1 ? beforeWithTransition : before;
            mapNodeRange(this.node, this.end, function(node) {
                method(node, target, vm)
            }),
            inDoc(this.node) && this.callHook(attach)
        }
        function multiRemove() {
            this.inserted = !1;
            var self = this
                , shouldCallRemove = inDoc(this.node);
            this.beforeRemove(),
                removeNodeRange(this.node, this.end, this.vm, this.frag, function() {
                    shouldCallRemove && self.callHook(detach),
                        self.destroy()
                })
        }
        function attach(child) {
            !child._isAttached && inDoc(child.$el) && child._callHook("attached")
        }
        function detach(child) {
            child._isAttached && !inDoc(child.$el) && child._callHook("detached")
        }
        function FragmentFactory(vm, el) {
            this.vm = vm;
            var template, isString = "string" == typeof el;
            isString || isTemplate(el) && !el.hasAttribute("v-if") ? template = parseTemplate(el, !0) : (template = document.createDocumentFragment(),
                template.appendChild(el)),
                this.template = template;
            var linker, cid = vm.constructor.cid;
            if (cid > 0) {
                var cacheId = cid + (isString ? el : getOuterHTML(el));
                linker = linkerCache.get(cacheId),
                linker || (linker = compile(template, vm.$options, !0),
                    linkerCache.put(cacheId, linker))
            } else
                linker = compile(template, vm.$options, !0);
            this.linker = linker
        }
        function findPrevFrag(frag, anchor, id) {
            var el = frag.node.previousSibling;
            if (el) {
                for (frag = el.__v_frag; !(frag && frag.forId === id && frag.inserted || el === anchor); ) {
                    if (el = el.previousSibling,
                            !el)
                        return;
                    frag = el.__v_frag
                }
                return frag
            }
        }
        function range(n) {
            for (var i = -1, ret = new Array(Math.floor(n)); ++i < n; )
                ret[i] = i;
            return ret
        }
        function getTrackByKey(index, key, value, trackByKey) {
            return trackByKey ? "$index" === trackByKey ? index : trackByKey.charAt(0).match(/\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value
        }
        function findVmFromFrag(frag) {
            var node = frag.node;
            if (frag.end)
                for (; !node.__vue__ && node !== frag.end && node.nextSibling; )
                    node = node.nextSibling;
            return node.__vue__
        }
        function getValue(el, multi, init) {
            for (var op, val, selected, res = multi ? [] : null, i = 0, l = el.options.length; i < l; i++)
                if (op = el.options[i],
                        selected = init ? op.hasAttribute("selected") : op.selected) {
                    if (val = op.hasOwnProperty("_value") ? op._value : op.value,
                            !multi)
                        return val;
                    res.push(val)
                }
            return res
        }
        function indexOf$1(arr, val) {
            for (var i = arr.length; i--; )
                if (looseEqual(arr[i], val))
                    return i;
            return -1
        }
        function keyFilter(handler, keys) {
            var codes = keys.map(function(key) {
                var charCode = key.charCodeAt(0);
                return charCode > 47 && charCode < 58 ? parseInt(key, 10) : 1 === key.length && (charCode = key.toUpperCase().charCodeAt(0),
                charCode > 64 && charCode < 91) ? charCode : keyCodes[key]
            });
            return codes = [].concat.apply([], codes),
                function(e) {
                    if (codes.indexOf(e.keyCode) > -1)
                        return handler.call(this, e)
                }
        }
        function stopFilter(handler) {
            return function(e) {
                return e.stopPropagation(),
                    handler.call(this, e)
            }
        }
        function preventFilter(handler) {
            return function(e) {
                return e.preventDefault(),
                    handler.call(this, e)
            }
        }
        function selfFilter(handler) {
            return function(e) {
                if (e.target === e.currentTarget)
                    return handler.call(this, e)
            }
        }
        function normalize(prop) {
            if (propCache[prop])
                return propCache[prop];
            var res = prefix(prop);
            return propCache[prop] = propCache[res] = res,
                res
        }
        function prefix(prop) {
            prop = hyphenate(prop);
            var camel = camelize(prop)
                , upper = camel.charAt(0).toUpperCase() + camel.slice(1);
            testEl || (testEl = document.createElement("div"));
            var prefixed, i = prefixes.length;
            if ("filter" !== camel && camel in testEl.style)
                return {
                    kebab: prop,
                    camel: camel
                };
            for (; i--; )
                if (prefixed = camelPrefixes[i] + upper,
                    prefixed in testEl.style)
                    return {
                        kebab: prefixes[i] + prop,
                        camel: prefixed
                    }
        }
        function normalize$1(value) {
            var res = [];
            if (isArray(value))
                for (var i = 0, l = value.length; i < l; i++) {
                    var _key = value[i];
                    if (_key)
                        if ("string" == typeof _key)
                            res.push(_key);
                        else
                            for (var k in _key)
                                _key[k] && res.push(k)
                }
            else if (isObject(value))
                for (var key in value)
                    value[key] && res.push(key);
            return res
        }
        function apply(el, key, fn) {
            if (key = key.trim(),
                key.indexOf(" ") === -1)
                return void fn(el, key);
            for (var keys = key.split(/\s+/), i = 0, l = keys.length; i < l; i++)
                fn(el, keys[i])
        }
        function callActivateHooks(hooks, vm, cb) {
            function next() {
                ++called >= total ? cb() : hooks[called].call(vm, next)
            }
            var total = hooks.length
                , called = 0;
            hooks[0].call(vm, next)
        }
        function compileProps(el, propOptions, vm) {
            for (var options, name, attr, value, path, parsed, prop, props = [], propsData = vm.$options.propsData, names = Object.keys(propOptions), i = names.length; i--; )
                if (name = names[i],
                        options = propOptions[name] || empty,
                        path = camelize(name),
                        identRE$1.test(path)) {
                    if (prop = {
                            name: name,
                            path: path,
                            options: options,
                            mode: propBindingModes.ONE_WAY,
                            raw: null
                        },
                            attr = hyphenate(name),
                        null === (value = getBindAttr(el, attr)) && (null !== (value = getBindAttr(el, attr + ".sync")) ? prop.mode = propBindingModes.TWO_WAY : null !== (value = getBindAttr(el, attr + ".once")) && (prop.mode = propBindingModes.ONE_TIME)),
                        null !== value)
                        prop.raw = value,
                            parsed = parseDirective(value),
                            value = parsed.expression,
                            prop.filters = parsed.filters,
                            isLiteral(value) && !parsed.filters ? prop.optimizedLiteral = !0 : prop.dynamic = !0,
                            prop.parentPath = value;
                    else if (null !== (value = getAttr(el, attr)))
                        prop.raw = value;
                    else if (propsData && null !== (value = propsData[name] || propsData[path]))
                        prop.raw = value;
                    else
                        ;props.push(prop)
                }
            return makePropsLinkFn(props)
        }
        function makePropsLinkFn(props) {
            return function(vm, scope) {
                vm._props = {};
                for (var prop, path, options, value, raw, inlineProps = vm.$options.propsData, i = props.length; i--; )
                    if (prop = props[i],
                            raw = prop.raw,
                            path = prop.path,
                            options = prop.options,
                            vm._props[path] = prop,
                        inlineProps && hasOwn(inlineProps, path) && initProp(vm, prop, inlineProps[path]),
                        null === raw)
                        initProp(vm, prop, void 0);
                    else if (prop.dynamic)
                        prop.mode === propBindingModes.ONE_TIME ? (value = (scope || vm._context || vm).$get(prop.parentPath),
                            initProp(vm, prop, value)) : vm._context ? vm._bindDir({
                            name: "prop",
                            def: propDef,
                            prop: prop
                        }, null, null, scope) : initProp(vm, prop, vm.$get(prop.parentPath));
                    else if (prop.optimizedLiteral) {
                        var stripped = stripQuotes(raw);
                        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped,
                            initProp(vm, prop, value)
                    } else
                        value = options.type === Boolean && ("" === raw || raw === hyphenate(prop.name)) || raw,
                            initProp(vm, prop, value)
            }
        }
        function processPropValue(vm, prop, rawValue, fn) {
            var isSimple = prop.dynamic && isSimplePath(prop.parentPath)
                , value = rawValue;
            void 0 === value && (value = getPropDefaultValue(vm, prop)),
                value = coerceProp(prop, value, vm);
            var coerced = value !== rawValue;
            assertProp(prop, value, vm) || (value = void 0),
                isSimple && !coerced ? withoutConversion(function() {
                    fn(value)
                }) : fn(value)
        }
        function initProp(vm, prop, value) {
            processPropValue(vm, prop, value, function(value) {
                defineReactive(vm, prop.path, value)
            })
        }
        function updateProp(vm, prop, value) {
            processPropValue(vm, prop, value, function(value) {
                vm[prop.path] = value
            })
        }
        function getPropDefaultValue(vm, prop) {
            var options = prop.options;
            if (!hasOwn(options, "default"))
                return options.type !== Boolean && void 0;
            var def = options.default;
            return isObject(def),
                "function" == typeof def && options.type !== Function ? def.call(vm) : def
        }
        function assertProp(prop, value, vm) {
            if (!prop.options.required && (null === prop.raw || null == value))
                return !0;
            var options = prop.options
                , type = options.type
                , valid = !type
                , expectedTypes = [];
            if (type) {
                isArray(type) || (type = [type]);
                for (var i = 0; i < type.length && !valid; i++) {
                    var assertedType = assertType(value, type[i]);
                    expectedTypes.push(assertedType.expectedType),
                        valid = assertedType.valid
                }
            }
            if (!valid)
                return !1;
            var validator = options.validator;
            return !(validator && !validator(value))
        }
        function coerceProp(prop, value, vm) {
            var coerce = prop.options.coerce;
            return coerce && "function" == typeof coerce ? coerce(value) : value
        }
        function assertType(value, type) {
            var valid, expectedType;
            return type === String ? (expectedType = "string",
                valid = typeof value === expectedType) : type === Number ? (expectedType = "number",
                valid = typeof value === expectedType) : type === Boolean ? (expectedType = "boolean",
                valid = typeof value === expectedType) : type === Function ? (expectedType = "function",
                valid = typeof value === expectedType) : type === Object ? (expectedType = "object",
                valid = isPlainObject(value)) : type === Array ? (expectedType = "array",
                valid = isArray(value)) : valid = value instanceof type,
                {
                    valid: valid,
                    expectedType: expectedType
                }
        }
        function pushJob(job) {
            queue$1.push(job),
            queued || (queued = !0,
                nextTick(flush))
        }
        function flush() {
            for (var f = document.documentElement.offsetHeight, i = 0; i < queue$1.length; i++)
                queue$1[i]();
            return queue$1 = [],
                queued = !1,
                f
        }
        function Transition(el, id, hooks, vm) {
            this.id = id,
                this.el = el,
                this.enterClass = hooks && hooks.enterClass || id + "-enter",
                this.leaveClass = hooks && hooks.leaveClass || id + "-leave",
                this.hooks = hooks,
                this.vm = vm,
                this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null,
                this.justEntered = !1,
                this.entered = this.left = !1,
                this.typeCache = {},
                this.type = hooks && hooks.type;
            var self = this;
            ["enterNextTick", "enterDone", "leaveNextTick", "leaveDone"].forEach(function(m) {
                self[m] = bind(self[m], self)
            })
        }
        function isHidden(el) {
            if (/svg$/.test(el.namespaceURI)) {
                var rect = el.getBoundingClientRect();
                return !(rect.width || rect.height)
            }
            return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length)
        }
        function compile(el, options, partial) {
            var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null
                , childLinkFn = nodeLinkFn && nodeLinkFn.terminal || isScript(el) || !el.hasChildNodes() ? null : compileNodeList(el.childNodes, options);
            return function(vm, el, host, scope, frag) {
                var childNodes = toArray(el.childNodes)
                    , dirs = linkAndCapture(function() {
                    nodeLinkFn && nodeLinkFn(vm, el, host, scope, frag),
                    childLinkFn && childLinkFn(vm, childNodes, host, scope, frag)
                }, vm);
                return makeUnlinkFn(vm, dirs)
            }
        }
        function linkAndCapture(linker, vm) {
            vm._directives = [];
            var originalDirCount = vm._directives.length;
            linker();
            var dirs = vm._directives.slice(originalDirCount);
            sortDirectives(dirs);
            for (var i = 0, l = dirs.length; i < l; i++)
                dirs[i]._bind();
            return dirs
        }
        function sortDirectives(dirs) {
            if (0 !== dirs.length) {
                var i, j, k, l, groupedMap = {}, index = 0, priorities = [];
                for (i = 0,
                         j = dirs.length; i < j; i++) {
                    var dir = dirs[i]
                        , priority = dir.descriptor.def.priority || DEFAULT_PRIORITY
                        , array = groupedMap[priority];
                    array || (array = groupedMap[priority] = [],
                        priorities.push(priority)),
                        array.push(dir)
                }
                for (priorities.sort(function(a, b) {
                    return a > b ? -1 : a === b ? 0 : 1
                }),
                         i = 0,
                         j = priorities.length; i < j; i++) {
                    var group = groupedMap[priorities[i]];
                    for (k = 0,
                             l = group.length; k < l; k++)
                        dirs[index++] = group[k]
                }
            }
        }
        function makeUnlinkFn(vm, dirs, context, contextDirs) {
            function unlink(destroying) {
                teardownDirs(vm, dirs, destroying),
                context && contextDirs && teardownDirs(context, contextDirs)
            }
            return unlink.dirs = dirs,
                unlink
        }
        function teardownDirs(vm, dirs, destroying) {
            for (var i = dirs.length; i--; )
                dirs[i]._teardown()
        }
        function compileAndLinkProps(vm, el, props, scope) {
            var propsLinkFn = compileProps(el, props, vm)
                , propDirs = linkAndCapture(function() {
                propsLinkFn(vm, scope)
            }, vm);
            return makeUnlinkFn(vm, propDirs)
        }
        function compileRoot(el, options, contextOptions) {
            var contextLinkFn, replacerLinkFn, containerAttrs = options._containerAttrs, replacerAttrs = options._replacerAttrs;
            if (11 !== el.nodeType)
                options._asComponent ? (containerAttrs && contextOptions && (contextLinkFn = compileDirectives(containerAttrs, contextOptions)),
                replacerAttrs && (replacerLinkFn = compileDirectives(replacerAttrs, options))) : replacerLinkFn = compileDirectives(el.attributes, options);
            else
                ;return options._containerAttrs = options._replacerAttrs = null,
                function(vm, el, scope) {
                    var contextDirs, context = vm._context;
                    context && contextLinkFn && (contextDirs = linkAndCapture(function() {
                        contextLinkFn(context, el, null, scope)
                    }, context));
                    var selfDirs = linkAndCapture(function() {
                        replacerLinkFn && replacerLinkFn(vm, el)
                    }, vm);
                    return makeUnlinkFn(vm, selfDirs, context, contextDirs)
                }
        }
        function compileNode(node, options) {
            var type = node.nodeType;
            return 1 !== type || isScript(node) ? 3 === type && node.data.trim() ? compileTextNode(node, options) : null : compileElement(node, options)
        }
        function compileElement(el, options) {
            if ("TEXTAREA" === el.tagName) {
                if (null !== getAttr(el, "v-pre"))
                    return skip;
                var tokens = parseText(el.value);
                tokens && (el.setAttribute(":value", tokensToExp(tokens)),
                    el.value = "")
            }
            var linkFn, hasAttrs = el.hasAttributes(), attrs = hasAttrs && toArray(el.attributes);
            return hasAttrs && (linkFn = checkTerminalDirectives(el, attrs, options)),
            linkFn || (linkFn = checkElementDirectives(el, options)),
            linkFn || (linkFn = checkComponent(el, options)),
            !linkFn && hasAttrs && (linkFn = compileDirectives(attrs, options)),
                linkFn
        }
        function compileTextNode(node, options) {
            if (node._skip)
                return removeText;
            var tokens = parseText(node.wholeText);
            if (!tokens)
                return null;
            for (var next = node.nextSibling; next && 3 === next.nodeType; )
                next._skip = !0,
                    next = next.nextSibling;
            for (var el, token, frag = document.createDocumentFragment(), i = 0, l = tokens.length; i < l; i++)
                token = tokens[i],
                    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value),
                    frag.appendChild(el);
            return makeTextNodeLinkFn(tokens, frag, options)
        }
        function removeText(vm, node) {
            remove(node)
        }
        function processTextToken(token, options) {
            function setTokenType(type) {
                if (!token.descriptor) {
                    var parsed = parseDirective(token.value);
                    token.descriptor = {
                        name: type,
                        def: directives[type],
                        expression: parsed.expression,
                        filters: parsed.filters
                    }
                }
            }
            var el;
            return token.oneTime ? el = document.createTextNode(token.value) : token.html ? (el = document.createComment("v-html"),
                setTokenType("html")) : (el = document.createTextNode(" "),
                setTokenType("text")),
                el
        }
        function makeTextNodeLinkFn(tokens, frag) {
            return function(vm, el, host, scope) {
                for (var token, value, node, fragClone = frag.cloneNode(!0), childNodes = toArray(fragClone.childNodes), i = 0, l = tokens.length; i < l; i++)
                    token = tokens[i],
                        value = token.value,
                    token.tag && (node = childNodes[i],
                        token.oneTime ? (value = (scope || vm).$eval(value),
                            token.html ? replace(node, parseTemplate(value, !0)) : node.data = _toString(value)) : vm._bindDir(token.descriptor, node, host, scope));
                replace(el, fragClone)
            }
        }
        function compileNodeList(nodeList, options) {
            for (var nodeLinkFn, childLinkFn, node, linkFns = [], i = 0, l = nodeList.length; i < l; i++)
                node = nodeList[i],
                    nodeLinkFn = compileNode(node, options),
                    childLinkFn = nodeLinkFn && nodeLinkFn.terminal || "SCRIPT" === node.tagName || !node.hasChildNodes() ? null : compileNodeList(node.childNodes, options),
                    linkFns.push(nodeLinkFn, childLinkFn);
            return linkFns.length ? makeChildLinkFn(linkFns) : null
        }
        function makeChildLinkFn(linkFns) {
            return function(vm, nodes, host, scope, frag) {
                for (var node, nodeLinkFn, childrenLinkFn, i = 0, n = 0, l = linkFns.length; i < l; n++) {
                    node = nodes[n],
                        nodeLinkFn = linkFns[i++],
                        childrenLinkFn = linkFns[i++];
                    var childNodes = toArray(node.childNodes);
                    nodeLinkFn && nodeLinkFn(vm, node, host, scope, frag),
                    childrenLinkFn && childrenLinkFn(vm, childNodes, host, scope, frag)
                }
            }
        }
        function checkElementDirectives(el, options) {
            var tag = el.tagName.toLowerCase();
            if (!commonTagRE.test(tag)) {
                var def = resolveAsset(options, "elementDirectives", tag);
                return def ? makeTerminalNodeLinkFn(el, tag, "", options, def) : void 0
            }
        }
        function checkComponent(el, options) {
            var component = checkComponentAttr(el, options);
            if (component) {
                var ref = findRef(el)
                    , descriptor = {
                    name: "component",
                    ref: ref,
                    expression: component.id,
                    def: internalDirectives.component,
                    modifiers: {
                        literal: !component.dynamic
                    }
                }
                    , componentLinkFn = function(vm, el, host, scope, frag) {
                    ref && defineReactive((scope || vm).$refs, ref, null),
                        vm._bindDir(descriptor, el, host, scope, frag)
                };
                return componentLinkFn.terminal = !0,
                    componentLinkFn
            }
        }
        function checkTerminalDirectives(el, attrs, options) {
            if (null !== getAttr(el, "v-pre"))
                return skip;
            if (el.hasAttribute("v-else")) {
                var prev = el.previousElementSibling;
                if (prev && prev.hasAttribute("v-if"))
                    return skip
            }
            for (var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef, i = 0, j = attrs.length; i < j; i++)
                attr = attrs[i],
                    name = attr.name.replace(modifierRE, ""),
                (matched = name.match(dirAttrRE)) && (def = resolveAsset(options, "directives", matched[1]),
                def && def.terminal && (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) && (termDef = def,
                    rawName = attr.name,
                    modifiers = parseModifiers(attr.name),
                    value = attr.value,
                    dirName = matched[1],
                    arg = matched[2]));
            return termDef ? makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers) : void 0
        }
        function skip() {}
        function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {
            var parsed = parseDirective(value)
                , descriptor = {
                name: dirName,
                arg: arg,
                expression: parsed.expression,
                filters: parsed.filters,
                raw: value,
                attr: rawName,
                modifiers: modifiers,
                def: def
            };
            "for" !== dirName && "router-view" !== dirName || (descriptor.ref = findRef(el));
            var fn = function(vm, el, host, scope, frag) {
                descriptor.ref && defineReactive((scope || vm).$refs, descriptor.ref, null),
                    vm._bindDir(descriptor, el, host, scope, frag)
            };
            return fn.terminal = !0,
                fn
        }
        function compileDirectives(attrs, options) {
            function pushDir(dirName, def, interpTokens) {
                var hasOneTimeToken = interpTokens && hasOneTime(interpTokens)
                    , parsed = !hasOneTimeToken && parseDirective(value);
                dirs.push({
                    name: dirName,
                    attr: rawName,
                    raw: rawValue,
                    def: def,
                    arg: arg,
                    modifiers: modifiers,
                    expression: parsed && parsed.expression,
                    filters: parsed && parsed.filters,
                    interp: interpTokens,
                    hasOneTime: hasOneTimeToken
                })
            }
            for (var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched, i = attrs.length, dirs = []; i--; )
                if (attr = attrs[i],
                        name = rawName = attr.name,
                        value = rawValue = attr.value,
                        tokens = parseText(value),
                        arg = null,
                        modifiers = parseModifiers(name),
                        name = name.replace(modifierRE, ""),
                        tokens)
                    value = tokensToExp(tokens),
                        arg = name,
                        pushDir("bind", directives.bind, tokens);
                else if (transitionRE.test(name))
                    modifiers.literal = !bindRE.test(name),
                        pushDir("transition", internalDirectives.transition);
                else if (onRE.test(name))
                    arg = name.replace(onRE, ""),
                        pushDir("on", directives.on);
                else if (bindRE.test(name))
                    dirName = name.replace(bindRE, ""),
                        "style" === dirName || "class" === dirName ? pushDir(dirName, internalDirectives[dirName]) : (arg = dirName,
                            pushDir("bind", directives.bind));
                else if (matched = name.match(dirAttrRE)) {
                    if (dirName = matched[1],
                            arg = matched[2],
                        "else" === dirName)
                        continue;
                    dirDef = resolveAsset(options, "directives", dirName, !0),
                    dirDef && pushDir(dirName, dirDef)
                }
            if (dirs.length)
                return makeNodeLinkFn(dirs)
        }
        function parseModifiers(name) {
            var res = Object.create(null)
                , match = name.match(modifierRE);
            if (match)
                for (var i = match.length; i--; )
                    res[match[i].slice(1)] = !0;
            return res
        }
        function makeNodeLinkFn(directives) {
            return function(vm, el, host, scope, frag) {
                for (var i = directives.length; i--; )
                    vm._bindDir(directives[i], el, host, scope, frag)
            }
        }
        function hasOneTime(tokens) {
            for (var i = tokens.length; i--; )
                if (tokens[i].oneTime)
                    return !0
        }
        function isScript(el) {
            return "SCRIPT" === el.tagName && (!el.hasAttribute("type") || "text/javascript" === el.getAttribute("type"))
        }
        function transclude(el, options) {
            return options && (options._containerAttrs = extractAttrs(el)),
            isTemplate(el) && (el = parseTemplate(el)),
            options && (options._asComponent && !options.template && (options.template = "<slot></slot>"),
            options.template && (options._content = extractContent(el),
                el = transcludeTemplate(el, options))),
            isFragment(el) && (prepend(createAnchor("v-start", !0), el),
                el.appendChild(createAnchor("v-end", !0))),
                el
        }
        function transcludeTemplate(el, options) {
            var template = options.template
                , frag = parseTemplate(template, !0);
            if (frag) {
                var replacer = frag.firstChild;
                if (!replacer)
                    return frag;
                var tag = replacer.tagName && replacer.tagName.toLowerCase();
                return options.replace ? (el === document.body,
                    frag.childNodes.length > 1 || 1 !== replacer.nodeType || "component" === tag || resolveAsset(options, "components", tag) || hasBindAttr(replacer, "is") || resolveAsset(options, "elementDirectives", tag) || replacer.hasAttribute("v-for") || replacer.hasAttribute("v-if") ? frag : (options._replacerAttrs = extractAttrs(replacer),
                        mergeAttrs(el, replacer),
                        replacer)) : (el.appendChild(frag),
                    el)
            }
        }
        function extractAttrs(el) {
            if (1 === el.nodeType && el.hasAttributes())
                return toArray(el.attributes)
        }
        function mergeAttrs(from, to) {
            for (var name, value, attrs = from.attributes, i = attrs.length; i--; )
                name = attrs[i].name,
                    value = attrs[i].value,
                    to.hasAttribute(name) || specialCharRE.test(name) ? "class" === name && !parseText(value) && (value = value.trim()) && value.split(/\s+/).forEach(function(cls) {
                        addClass(to, cls)
                    }) : to.setAttribute(name, value)
        }
        function resolveSlots(vm, content) {
            if (content) {
                for (var el, name, contents = vm._slotContents = Object.create(null), i = 0, l = content.children.length; i < l; i++)
                    el = content.children[i],
                    (name = el.getAttribute("slot")) && (contents[name] || (contents[name] = [])).push(el);
                for (name in contents)
                    contents[name] = extractFragment(contents[name], content);
                if (content.hasChildNodes()) {
                    var nodes = content.childNodes;
                    if (1 === nodes.length && 3 === nodes[0].nodeType && !nodes[0].data.trim())
                        return;
                    contents.default = extractFragment(content.childNodes, content)
                }
            }
        }
        function extractFragment(nodes, parent) {
            var frag = document.createDocumentFragment();
            nodes = toArray(nodes);
            for (var i = 0, l = nodes.length; i < l; i++) {
                var node = nodes[i];
                !isTemplate(node) || node.hasAttribute("v-if") || node.hasAttribute("v-for") || (parent.removeChild(node),
                    node = parseTemplate(node, !0)),
                    frag.appendChild(node)
            }
            return frag
        }
        function stateMixin(Vue) {
            function noop() {}
            function makeComputedGetter(getter, owner) {
                var watcher = new Watcher(owner,getter,null,{
                    lazy: !0
                });
                return function() {
                    return watcher.dirty && watcher.evaluate(),
                    Dep.target && watcher.depend(),
                        watcher.value
                }
            }
            Object.defineProperty(Vue.prototype, "$data", {
                get: function() {
                    return this._data
                },
                set: function(newData) {
                    newData !== this._data && this._setData(newData)
                }
            }),
                Vue.prototype._initState = function() {
                    this._initProps(),
                        this._initMeta(),
                        this._initMethods(),
                        this._initData(),
                        this._initComputed()
                }
                ,
                Vue.prototype._initProps = function() {
                    var options = this.$options
                        , el = options.el
                        , props = options.props;
                    el = options.el = query(el),
                        this._propsUnlinkFn = el && 1 === el.nodeType && props ? compileAndLinkProps(this, el, props, this._scope) : null
                }
                ,
                Vue.prototype._initData = function() {
                    var dataFn = this.$options.data
                        , data = this._data = dataFn ? dataFn() : {};
                    isPlainObject(data) || (data = {});
                    var i, key, props = this._props, keys = Object.keys(data);
                    for (i = keys.length; i--; )
                        key = keys[i],
                        props && hasOwn(props, key) || this._proxy(key);
                    observe(data, this)
                }
                ,
                Vue.prototype._setData = function(newData) {
                    newData = newData || {};
                    var oldData = this._data;
                    this._data = newData;
                    var keys, key, i;
                    for (keys = Object.keys(oldData),
                             i = keys.length; i--; )
                        key = keys[i],
                        key in newData || this._unproxy(key);
                    for (keys = Object.keys(newData),
                             i = keys.length; i--; )
                        key = keys[i],
                        hasOwn(this, key) || this._proxy(key);
                    oldData.__ob__.removeVm(this),
                        observe(newData, this),
                        this._digest()
                }
                ,
                Vue.prototype._proxy = function(key) {
                    if (!isReserved(key)) {
                        var self = this;
                        Object.defineProperty(self, key, {
                            configurable: !0,
                            enumerable: !0,
                            get: function() {
                                return self._data[key]
                            },
                            set: function(val) {
                                self._data[key] = val
                            }
                        })
                    }
                }
                ,
                Vue.prototype._unproxy = function(key) {
                    isReserved(key) || delete this[key]
                }
                ,
                Vue.prototype._digest = function() {
                    for (var i = 0, l = this._watchers.length; i < l; i++)
                        this._watchers[i].update(!0)
                }
                ,
                Vue.prototype._initComputed = function() {
                    var computed = this.$options.computed;
                    if (computed)
                        for (var key in computed) {
                            var userDef = computed[key]
                                , def = {
                                enumerable: !0,
                                configurable: !0
                            };
                            "function" == typeof userDef ? (def.get = makeComputedGetter(userDef, this),
                                def.set = noop) : (def.get = userDef.get ? userDef.cache !== !1 ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop,
                                def.set = userDef.set ? bind(userDef.set, this) : noop),
                                Object.defineProperty(this, key, def)
                        }
                }
                ,
                Vue.prototype._initMethods = function() {
                    var methods = this.$options.methods;
                    if (methods)
                        for (var key in methods)
                            this[key] = bind(methods[key], this)
                }
                ,
                Vue.prototype._initMeta = function() {
                    var metas = this.$options._meta;
                    if (metas)
                        for (var key in metas)
                            defineReactive(this, key, metas[key])
                }
        }
        function eventsMixin(Vue) {
            function registerComponentEvents(vm, el) {
                for (var name, value, handler, attrs = el.attributes, i = 0, l = attrs.length; i < l; i++)
                    name = attrs[i].name,
                    eventRE.test(name) && (name = name.replace(eventRE, ""),
                        value = attrs[i].value,
                    isSimplePath(value) && (value += ".apply(this, $arguments)"),
                        handler = (vm._scope || vm._context).$eval(value, !0),
                        handler._fromParent = !0,
                        vm.$on(name.replace(eventRE), handler))
            }
            function registerCallbacks(vm, action, hash) {
                if (hash) {
                    var handlers, key, i, j;
                    for (key in hash)
                        if (handlers = hash[key],
                                isArray(handlers))
                            for (i = 0,
                                     j = handlers.length; i < j; i++)
                                register(vm, action, key, handlers[i]);
                        else
                            register(vm, action, key, handlers)
                }
            }
            function register(vm, action, key, handler, options) {
                var type = typeof handler;
                if ("function" === type)
                    vm[action](key, handler, options);
                else if ("string" === type) {
                    var methods = vm.$options.methods
                        , method = methods && methods[handler];
                    method && vm[action](key, method, options)
                } else
                    handler && "object" === type && register(vm, action, key, handler.handler, handler)
            }
            function onAttached() {
                this._isAttached || (this._isAttached = !0,
                    this.$children.forEach(callAttach))
            }
            function callAttach(child) {
                !child._isAttached && inDoc(child.$el) && child._callHook("attached")
            }
            function onDetached() {
                this._isAttached && (this._isAttached = !1,
                    this.$children.forEach(callDetach))
            }
            function callDetach(child) {
                child._isAttached && !inDoc(child.$el) && child._callHook("detached")
            }
            Vue.prototype._initEvents = function() {
                var options = this.$options;
                options._asComponent && registerComponentEvents(this, options.el),
                    registerCallbacks(this, "$on", options.events),
                    registerCallbacks(this, "$watch", options.watch)
            }
                ,
                Vue.prototype._initDOMHooks = function() {
                    this.$on("hook:attached", onAttached),
                        this.$on("hook:detached", onDetached)
                }
                ,
                Vue.prototype._callHook = function(hook) {
                    this.$emit("pre-hook:" + hook);
                    var handlers = this.$options[hook];
                    if (handlers)
                        for (var i = 0, j = handlers.length; i < j; i++)
                            handlers[i].call(this);
                    this.$emit("hook:" + hook)
                }
        }
        function noop$1() {}
        function Directive(descriptor, vm, el, host, scope, frag) {
            this.vm = vm,
                this.el = el,
                this.descriptor = descriptor,
                this.name = descriptor.name,
                this.expression = descriptor.expression,
                this.arg = descriptor.arg,
                this.modifiers = descriptor.modifiers,
                this.filters = descriptor.filters,
                this.literal = this.modifiers && this.modifiers.literal,
                this._locked = !1,
                this._bound = !1,
                this._listeners = null,
                this._host = host,
                this._scope = scope,
                this._frag = frag
        }
        function lifecycleMixin(Vue) {
            Vue.prototype._updateRef = function(remove) {
                var ref = this.$options._ref;
                if (ref) {
                    var refs = (this._scope || this._context).$refs;
                    remove ? refs[ref] === this && (refs[ref] = null) : refs[ref] = this
                }
            }
                ,
                Vue.prototype._compile = function(el) {
                    var options = this.$options
                        , original = el;
                    if (el = transclude(el, options),
                            this._initElement(el),
                        1 !== el.nodeType || null === getAttr(el, "v-pre")) {
                        var contextOptions = this._context && this._context.$options
                            , rootLinker = compileRoot(el, options, contextOptions);
                        resolveSlots(this, options._content);
                        var contentLinkFn, ctor = this.constructor;
                        options._linkerCachable && (contentLinkFn = ctor.linker,
                        contentLinkFn || (contentLinkFn = ctor.linker = compile(el, options)));
                        var rootUnlinkFn = rootLinker(this, el, this._scope)
                            , contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);
                        this._unlinkFn = function() {
                            rootUnlinkFn(),
                                contentUnlinkFn(!0)
                        }
                            ,
                        options.replace && replace(original, el),
                            this._isCompiled = !0,
                            this._callHook("compiled")
                    }
                }
                ,
                Vue.prototype._initElement = function(el) {
                    isFragment(el) ? (this._isFragment = !0,
                        this.$el = this._fragmentStart = el.firstChild,
                        this._fragmentEnd = el.lastChild,
                    3 === this._fragmentStart.nodeType && (this._fragmentStart.data = this._fragmentEnd.data = ""),
                        this._fragment = el) : this.$el = el,
                        this.$el.__vue__ = this,
                        this._callHook("beforeCompile")
                }
                ,
                Vue.prototype._bindDir = function(descriptor, node, host, scope, frag) {
                    this._directives.push(new Directive(descriptor,this,node,host,scope,frag))
                }
                ,
                Vue.prototype._destroy = function(remove, deferCleanup) {
                    if (this._isBeingDestroyed)
                        return void (deferCleanup || this._cleanup());
                    var destroyReady, pendingRemoval, self = this, cleanupIfPossible = function() {
                        !destroyReady || pendingRemoval || deferCleanup || self._cleanup()
                    };
                    remove && this.$el && (pendingRemoval = !0,
                        this.$remove(function() {
                            pendingRemoval = !1,
                                cleanupIfPossible()
                        })),
                        this._callHook("beforeDestroy"),
                        this._isBeingDestroyed = !0;
                    var i, parent = this.$parent;
                    for (parent && !parent._isBeingDestroyed && (parent.$children.$remove(this),
                        this._updateRef(!0)),
                             i = this.$children.length; i--; )
                        this.$children[i].$destroy();
                    for (this._propsUnlinkFn && this._propsUnlinkFn(),
                         this._unlinkFn && this._unlinkFn(),
                             i = this._watchers.length; i--; )
                        this._watchers[i].teardown();
                    this.$el && (this.$el.__vue__ = null),
                        destroyReady = !0,
                        cleanupIfPossible()
                }
                ,
                Vue.prototype._cleanup = function() {
                    this._isDestroyed || (this._frag && this._frag.children.$remove(this),
                    this._data && this._data.__ob__ && this._data.__ob__.removeVm(this),
                        this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null,
                        this._isDestroyed = !0,
                        this._callHook("destroyed"),
                        this.$off())
                }
        }
        function miscMixin(Vue) {
            Vue.prototype._applyFilters = function(value, oldValue, filters, write) {
                var filter, fn, args, arg, offset, i, l, j, k;
                for (i = 0,
                         l = filters.length; i < l; i++)
                    if (filter = filters[write ? l - i - 1 : i],
                            fn = resolveAsset(this.$options, "filters", filter.name, !0),
                        fn && (fn = write ? fn.write : fn.read || fn,
                        "function" == typeof fn)) {
                        if (args = write ? [value, oldValue] : [value],
                                offset = write ? 2 : 1,
                                filter.args)
                            for (j = 0,
                                     k = filter.args.length; j < k; j++)
                                arg = filter.args[j],
                                    args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
                        value = fn.apply(this, args)
                    }
                return value
            }
                ,
                Vue.prototype._resolveComponent = function(value, cb) {
                    var factory;
                    if (factory = "function" == typeof value ? value : resolveAsset(this.$options, "components", value, !0))
                        if (factory.options)
                            cb(factory);
                        else if (factory.resolved)
                            cb(factory.resolved);
                        else if (factory.requested)
                            factory.pendingCallbacks.push(cb);
                        else {
                            factory.requested = !0;
                            var cbs = factory.pendingCallbacks = [cb];
                            factory.call(this, function(res) {
                                isPlainObject(res) && (res = Vue.extend(res)),
                                    factory.resolved = res;
                                for (var i = 0, l = cbs.length; i < l; i++)
                                    cbs[i](res)
                            }, function(reason) {})
                        }
                }
        }
        function dataAPI(Vue) {
            function clean(obj) {
                return JSON.parse(JSON.stringify(obj))
            }
            Vue.prototype.$get = function(exp, asStatement) {
                var res = parseExpression$1(exp);
                if (res) {
                    if (asStatement) {
                        var self = this;
                        return function() {
                            self.$arguments = toArray(arguments);
                            var result = res.get.call(self, self);
                            return self.$arguments = null,
                                result
                        }
                    }
                    try {
                        return res.get.call(this, this)
                    } catch (e) {}
                }
            }
                ,
                Vue.prototype.$set = function(exp, val) {
                    var res = parseExpression$1(exp, !0);
                    res && res.set && res.set.call(this, this, val)
                }
                ,
                Vue.prototype.$delete = function(key) {
                    del(this._data, key)
                }
                ,
                Vue.prototype.$watch = function(expOrFn, cb, options) {
                    var parsed, vm = this;
                    "string" == typeof expOrFn && (parsed = parseDirective(expOrFn),
                        expOrFn = parsed.expression);
                    var watcher = new Watcher(vm,expOrFn,cb,{
                        deep: options && options.deep,
                        sync: options && options.sync,
                        filters: parsed && parsed.filters,
                        user: !options || options.user !== !1
                    });
                    return options && options.immediate && cb.call(vm, watcher.value),
                        function() {
                            watcher.teardown()
                        }
                }
                ,
                Vue.prototype.$eval = function(text, asStatement) {
                    if (filterRE$1.test(text)) {
                        var dir = parseDirective(text)
                            , val = this.$get(dir.expression, asStatement);
                        return dir.filters ? this._applyFilters(val, null, dir.filters) : val
                    }
                    return this.$get(text, asStatement)
                }
                ,
                Vue.prototype.$interpolate = function(text) {
                    var tokens = parseText(text)
                        , vm = this;
                    return tokens ? 1 === tokens.length ? vm.$eval(tokens[0].value) + "" : tokens.map(function(token) {
                        return token.tag ? vm.$eval(token.value) : token.value
                    }).join("") : text
                }
                ,
                Vue.prototype.$log = function(path) {
                    var data = path ? getPath(this._data, path) : this._data;
                    if (data && (data = clean(data)),
                            !path) {
                        var key;
                        for (key in this.$options.computed)
                            data[key] = clean(this[key]);
                        if (this._props)
                            for (key in this._props)
                                data[key] = clean(this[key])
                    }
                    console.log(data)
                }
        }
        function domAPI(Vue) {
            function insert(vm, target, cb, withTransition, op1, op2) {
                target = query(target);
                var targetIsDetached = !inDoc(target)
                    , op = withTransition === !1 || targetIsDetached ? op1 : op2
                    , shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
                return vm._isFragment ? (mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function(node) {
                    op(node, target, vm)
                }),
                cb && cb()) : op(vm.$el, target, vm, cb),
                shouldCallHook && vm._callHook("attached"),
                    vm
            }
            function query(el) {
                return "string" == typeof el ? document.querySelector(el) : el
            }
            function append(el, target, vm, cb) {
                target.appendChild(el),
                cb && cb()
            }
            function beforeWithCb(el, target, vm, cb) {
                before(el, target),
                cb && cb()
            }
            function removeWithCb(el, vm, cb) {
                remove(el),
                cb && cb()
            }
            Vue.prototype.$nextTick = function(fn) {
                nextTick(fn, this)
            }
                ,
                Vue.prototype.$appendTo = function(target, cb, withTransition) {
                    return insert(this, target, cb, withTransition, append, appendWithTransition)
                }
                ,
                Vue.prototype.$prependTo = function(target, cb, withTransition) {
                    return target = query(target),
                        target.hasChildNodes() ? this.$before(target.firstChild, cb, withTransition) : this.$appendTo(target, cb, withTransition),
                        this
                }
                ,
                Vue.prototype.$before = function(target, cb, withTransition) {
                    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition)
                }
                ,
                Vue.prototype.$after = function(target, cb, withTransition) {
                    return target = query(target),
                        target.nextSibling ? this.$before(target.nextSibling, cb, withTransition) : this.$appendTo(target.parentNode, cb, withTransition),
                        this
                }
                ,
                Vue.prototype.$remove = function(cb, withTransition) {
                    if (!this.$el.parentNode)
                        return cb && cb();
                    var inDocument = this._isAttached && inDoc(this.$el);
                    inDocument || (withTransition = !1);
                    var self = this
                        , realCb = function() {
                        inDocument && self._callHook("detached"),
                        cb && cb()
                    };
                    if (this._isFragment)
                        removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
                    else {
                        var op = withTransition === !1 ? removeWithCb : removeWithTransition;
                        op(this.$el, this, realCb)
                    }
                    return this
                }
        }
        function eventsAPI(Vue) {
            function modifyListenerCount(vm, event, count) {
                var parent = vm.$parent;
                if (parent && count && !hookRE.test(event))
                    for (; parent; )
                        parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count,
                            parent = parent.$parent
            }
            Vue.prototype.$on = function(event, fn) {
                return (this._events[event] || (this._events[event] = [])).push(fn),
                    modifyListenerCount(this, event, 1),
                    this
            }
                ,
                Vue.prototype.$once = function(event, fn) {
                    function on() {
                        self.$off(event, on),
                            fn.apply(this, arguments)
                    }
                    var self = this;
                    return on.fn = fn,
                        this.$on(event, on),
                        this
                }
                ,
                Vue.prototype.$off = function(event, fn) {
                    var cbs;
                    if (!arguments.length) {
                        if (this.$parent)
                            for (event in this._events)
                                cbs = this._events[event],
                                cbs && modifyListenerCount(this, event, -cbs.length);
                        return this._events = {},
                            this
                    }
                    if (cbs = this._events[event],
                            !cbs)
                        return this;
                    if (1 === arguments.length)
                        return modifyListenerCount(this, event, -cbs.length),
                            this._events[event] = null,
                            this;
                    for (var cb, i = cbs.length; i--; )
                        if (cb = cbs[i],
                            cb === fn || cb.fn === fn) {
                            modifyListenerCount(this, event, -1),
                                cbs.splice(i, 1);
                            break
                        }
                    return this
                }
                ,
                Vue.prototype.$emit = function(event) {
                    var isSource = "string" == typeof event;
                    event = isSource ? event : event.name;
                    var cbs = this._events[event]
                        , shouldPropagate = isSource || !cbs;
                    if (cbs) {
                        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
                        var hasParentCbs = isSource && cbs.some(function(cb) {
                                return cb._fromParent
                            });
                        hasParentCbs && (shouldPropagate = !1);
                        for (var args = toArray(arguments, 1), i = 0, l = cbs.length; i < l; i++) {
                            var cb = cbs[i]
                                , res = cb.apply(this, args);
                            res !== !0 || hasParentCbs && !cb._fromParent || (shouldPropagate = !0)
                        }
                    }
                    return shouldPropagate
                }
                ,
                Vue.prototype.$broadcast = function(event) {
                    var isSource = "string" == typeof event;
                    if (event = isSource ? event : event.name,
                            this._eventsCount[event]) {
                        var children = this.$children
                            , args = toArray(arguments);
                        isSource && (args[0] = {
                            name: event,
                            source: this
                        });
                        for (var i = 0, l = children.length; i < l; i++) {
                            var child = children[i]
                                , shouldPropagate = child.$emit.apply(child, args);
                            shouldPropagate && child.$broadcast.apply(child, args)
                        }
                        return this
                    }
                }
                ,
                Vue.prototype.$dispatch = function(event) {
                    var shouldPropagate = this.$emit.apply(this, arguments);
                    if (shouldPropagate) {
                        var parent = this.$parent
                            , args = toArray(arguments);
                        for (args[0] = {
                            name: event,
                            source: this
                        }; parent; )
                            shouldPropagate = parent.$emit.apply(parent, args),
                                parent = shouldPropagate ? parent.$parent : null;
                        return this
                    }
                }
            ;
            var hookRE = /^hook:/
        }
        function lifecycleAPI(Vue) {
            function ready() {
                this._isAttached = !0,
                    this._isReady = !0,
                    this._callHook("ready")
            }
            Vue.prototype.$mount = function(el) {
                if (!this._isCompiled)
                    return el = query(el),
                    el || (el = document.createElement("div")),
                        this._compile(el),
                        this._initDOMHooks(),
                        inDoc(this.$el) ? (this._callHook("attached"),
                            ready.call(this)) : this.$once("hook:attached", ready),
                        this
            }
                ,
                Vue.prototype.$destroy = function(remove, deferCleanup) {
                    this._destroy(remove, deferCleanup)
                }
                ,
                Vue.prototype.$compile = function(el, host, scope, frag) {
                    return compile(el, this.$options, !0)(this, el, host, scope, frag)
                }
        }
        function Vue(options) {
            this._init(options)
        }
        function limitBy(arr, n, offset) {
            return offset = offset ? parseInt(offset, 10) : 0,
                n = toNumber(n),
                "number" == typeof n ? arr.slice(offset, offset + n) : arr
        }
        function filterBy(arr, search, delimiter) {
            if (arr = convertArray(arr),
                null == search)
                return arr;
            if ("function" == typeof search)
                return arr.filter(search);
            search = ("" + search).toLowerCase();
            for (var item, key, val, j, n = "in" === delimiter ? 3 : 2, keys = Array.prototype.concat.apply([], toArray(arguments, n)), res = [], i = 0, l = arr.length; i < l; i++)
                if (item = arr[i],
                        val = item && item.$value || item,
                        j = keys.length) {
                    for (; j--; )
                        if (key = keys[j],
                            "$key" === key && contains(item.$key, search) || contains(getPath(val, key), search)) {
                            res.push(item);
                            break
                        }
                } else
                    contains(item, search) && res.push(item);
            return res
        }
        function orderBy(arr) {
            function baseCompare(a, b, sortKeyIndex) {
                var sortKey = sortKeys[sortKeyIndex];
                return sortKey && ("$key" !== sortKey && (isObject(a) && "$value"in a && (a = a.$value),
                isObject(b) && "$value"in b && (b = b.$value)),
                    a = isObject(a) ? getPath(a, sortKey) : a,
                    b = isObject(b) ? getPath(b, sortKey) : b),
                    a === b ? 0 : a > b ? order : -order
            }
            var comparator = null
                , sortKeys = void 0;
            arr = convertArray(arr);
            var args = toArray(arguments, 1)
                , order = args[args.length - 1];
            "number" == typeof order ? (order = order < 0 ? -1 : 1,
                args = args.length > 1 ? args.slice(0, -1) : args) : order = 1;
            var firstArg = args[0];
            return firstArg ? ("function" == typeof firstArg ? comparator = function(a, b) {
                return firstArg(a, b) * order
            }
                : (sortKeys = Array.prototype.concat.apply([], args),
                    comparator = function(a, b, i) {
                        return i = i || 0,
                            i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1)
                    }
            ),
                arr.slice().sort(comparator)) : arr
        }
        function contains(val, search) {
            var i;
            if (isPlainObject(val)) {
                var keys = Object.keys(val);
                for (i = keys.length; i--; )
                    if (contains(val[keys[i]], search))
                        return !0
            } else if (isArray(val)) {
                for (i = val.length; i--; )
                    if (contains(val[i], search))
                        return !0
            } else if (null != val)
                return val.toString().toLowerCase().indexOf(search) > -1
        }
        function installGlobalAPI(Vue) {
            function createClass(name) {
                return new Function("return function " + classify(name) + " (options) { this._init(options) }")()
            }
            Vue.options = {
                directives: directives,
                elementDirectives: elementDirectives,
                filters: filters,
                transitions: {},
                components: {},
                partials: {},
                replace: !0
            },
                Vue.util = util,
                Vue.config = config,
                Vue.set = set,
                Vue.delete = del,
                Vue.nextTick = nextTick,
                Vue.compiler = compiler,
                Vue.FragmentFactory = FragmentFactory,
                Vue.internalDirectives = internalDirectives,
                Vue.parsers = {
                    path: path,
                    text: text,
                    template: template,
                    directive: directive,
                    expression: expression
                },
                Vue.cid = 0;
            var cid = 1;
            Vue.extend = function(extendOptions) {
                extendOptions = extendOptions || {};
                var Super = this
                    , isFirstExtend = 0 === Super.cid;
                if (isFirstExtend && extendOptions._Ctor)
                    return extendOptions._Ctor;
                var name = extendOptions.name || Super.options.name
                    , Sub = createClass(name || "VueComponent");
                return Sub.prototype = Object.create(Super.prototype),
                    Sub.prototype.constructor = Sub,
                    Sub.cid = cid++,
                    Sub.options = mergeOptions(Super.options, extendOptions),
                    Sub.super = Super,
                    Sub.extend = Super.extend,
                    config._assetTypes.forEach(function(type) {
                        Sub[type] = Super[type]
                    }),
                name && (Sub.options.components[name] = Sub),
                isFirstExtend && (extendOptions._Ctor = Sub),
                    Sub
            }
                ,
                Vue.use = function(plugin) {
                    if (!plugin.installed) {
                        var args = toArray(arguments, 1);
                        return args.unshift(this),
                            "function" == typeof plugin.install ? plugin.install.apply(plugin, args) : plugin.apply(null, args),
                            plugin.installed = !0,
                            this
                    }
                }
                ,
                Vue.mixin = function(mixin) {
                    Vue.options = mergeOptions(Vue.options, mixin)
                }
                ,
                config._assetTypes.forEach(function(type) {
                    Vue[type] = function(id, definition) {
                        return definition ? ("component" === type && isPlainObject(definition) && (definition.name || (definition.name = id),
                            definition = Vue.extend(definition)),
                            this.options[type + "s"][id] = definition,
                            definition) : this.options[type + "s"][id]
                    }
                }),
                extend(Vue.transition, transition)
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty
            , literalValueRE = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/
            , camelizeRE = /-(\w)/g
            , hyphenateRE = /([^-])([A-Z])/g
            , classifyRE = /(?:^|[-_\/])(\w)/g
            , toString = Object.prototype.toString
            , OBJECT_STRING = "[object Object]"
            , isArray = Array.isArray
            , hasProto = "__proto__"in {}
            , inBrowser = "undefined" != typeof window && "[object Object]" !== Object.prototype.toString.call(window)
            , devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__
            , UA = inBrowser && window.navigator.userAgent.toLowerCase()
            , isIE = UA && UA.indexOf("trident") > 0
            , isIE9 = UA && UA.indexOf("msie 9.0") > 0
            , isAndroid = UA && UA.indexOf("android") > 0
            , isIOS = UA && /iphone|ipad|ipod|ios/.test(UA)
            , transitionProp = void 0
            , transitionEndEvent = void 0
            , animationProp = void 0
            , animationEndEvent = void 0;
        if (inBrowser && !isIE9) {
            var isWebkitTrans = void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend
                , isWebkitAnim = void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend;
            transitionProp = isWebkitTrans ? "WebkitTransition" : "transition",
                transitionEndEvent = isWebkitTrans ? "webkitTransitionEnd" : "transitionend",
                animationProp = isWebkitAnim ? "WebkitAnimation" : "animation",
                animationEndEvent = isWebkitAnim ? "webkitAnimationEnd" : "animationend"
        }
        var nextTick = function() {
            function nextTickHandler() {
                pending = !1;
                var copies = callbacks.slice(0);
                callbacks.length = 0;
                for (var i = 0; i < copies.length; i++)
                    copies[i]()
            }
            var callbacks = []
                , pending = !1
                , timerFunc = void 0;
            if ("undefined" != typeof Promise && isNative(Promise)) {
                var p = Promise.resolve()
                    , noop = function() {};
                timerFunc = function() {
                    p.then(nextTickHandler),
                    isIOS && setTimeout(noop)
                }
            } else if ("undefined" != typeof MutationObserver) {
                var counter = 1
                    , observer = new MutationObserver(nextTickHandler)
                    , textNode = document.createTextNode(String(counter));
                observer.observe(textNode, {
                    characterData: !0
                }),
                    timerFunc = function() {
                        counter = (counter + 1) % 2,
                            textNode.data = String(counter)
                    }
            } else
                timerFunc = setTimeout;
            return function(cb, ctx) {
                var func = ctx ? function() {
                    cb.call(ctx)
                }
                    : cb;
                callbacks.push(func),
                pending || (pending = !0,
                    timerFunc(nextTickHandler, 0))
            }
        }()
            , _Set = void 0;
        "undefined" != typeof Set && isNative(Set) ? _Set = Set : (_Set = function() {
                this.set = Object.create(null)
            }
                ,
                _Set.prototype.has = function(key) {
                    return void 0 !== this.set[key]
                }
                ,
                _Set.prototype.add = function(key) {
                    this.set[key] = 1
                }
                ,
                _Set.prototype.clear = function() {
                    this.set = Object.create(null)
                }
        );
        var p = Cache.prototype;
        p.put = function(key, value) {
            var removed, entry = this.get(key, !0);
            return entry || (this.size === this.limit && (removed = this.shift()),
                entry = {
                    key: key
                },
                this._keymap[key] = entry,
                this.tail ? (this.tail.newer = entry,
                    entry.older = this.tail) : this.head = entry,
                this.tail = entry,
                this.size++),
                entry.value = value,
                removed
        }
            ,
            p.shift = function() {
                var entry = this.head;
                return entry && (this.head = this.head.newer,
                    this.head.older = void 0,
                    entry.newer = entry.older = void 0,
                    this._keymap[entry.key] = void 0,
                    this.size--),
                    entry
            }
            ,
            p.get = function(key, returnEntry) {
                var entry = this._keymap[key];
                if (void 0 !== entry)
                    return entry === this.tail ? returnEntry ? entry : entry.value : (entry.newer && (entry === this.head && (this.head = entry.newer),
                        entry.newer.older = entry.older),
                    entry.older && (entry.older.newer = entry.newer),
                        entry.newer = void 0,
                        entry.older = this.tail,
                    this.tail && (this.tail.newer = entry),
                        this.tail = entry,
                        returnEntry ? entry : entry.value)
            }
        ;
        var str, dir, len, index, chr, state, cache$1 = new Cache(1e3), reservedArgRE = /^in$|^-?\d+/, startState = 0, filterState = 1, filterNameState = 2, filterArgState = 3, doubleChr = 34, singleChr = 39, pipeChr = 124, escapeChr = 92, spaceChr = 32, expStartChr = {
            91: 1,
            123: 1,
            40: 1
        }, expChrPair = {
            91: 93,
            123: 125,
            40: 41
        }, directive = Object.freeze({
            parseDirective: parseDirective
        }), regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g, cache = void 0, tagRE = void 0, htmlRE = void 0, filterRE = /[^|]\|[^|]/, text = Object.freeze({
            compileRegex: compileRegex,
            parseText: parseText,
            tokensToExp: tokensToExp
        }), delimiters = ["{{", "}}"], unsafeDelimiters = ["{{{", "}}}"], config = Object.defineProperties({
            debug: !1,
            silent: !1,
            async: !0,
            warnExpressionErrors: !0,
            devtools: !1,
            _delimitersChanged: !0,
            _assetTypes: ["component", "directive", "elementDirective", "filter", "transition", "partial"],
            _propBindingModes: {
                ONE_WAY: 0,
                TWO_WAY: 1,
                ONE_TIME: 2
            },
            _maxUpdateCount: 100
        }, {
            delimiters: {
                get: function() {
                    return delimiters
                },
                set: function(val) {
                    delimiters = val,
                        compileRegex()
                },
                configurable: !0,
                enumerable: !0
            },
            unsafeDelimiters: {
                get: function() {
                    return unsafeDelimiters
                },
                set: function(val) {
                    unsafeDelimiters = val,
                        compileRegex()
                },
                configurable: !0,
                enumerable: !0
            }
        }), warn = void 0, transition = Object.freeze({
            appendWithTransition: appendWithTransition,
            beforeWithTransition: beforeWithTransition,
            removeWithTransition: removeWithTransition,
            applyTransition: applyTransition
        }), refRE = /^v-ref:/, commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i, reservedTagRE = /^(slot|partial|component)$/i, strats = config.optionMergeStrategies = Object.create(null);
        strats.data = function(parentVal, childVal, vm) {
            return vm ? parentVal || childVal ? function() {
                var instanceData = "function" == typeof childVal ? childVal.call(vm) : childVal
                    , defaultData = "function" == typeof parentVal ? parentVal.call(vm) : void 0;
                return instanceData ? mergeData(instanceData, defaultData) : defaultData
            }
                : void 0 : childVal ? "function" != typeof childVal ? parentVal : parentVal ? function() {
                return mergeData(childVal.call(this), parentVal.call(this))
            }
                : childVal : parentVal
        }
            ,
            strats.el = function(parentVal, childVal, vm) {
                if (vm || !childVal || "function" == typeof childVal) {
                    var ret = childVal || parentVal;
                    return vm && "function" == typeof ret ? ret.call(vm) : ret
                }
            }
            ,
            strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function(parentVal, childVal) {
                return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal
            }
            ,
            config._assetTypes.forEach(function(type) {
                strats[type + "s"] = mergeAssets
            }),
            strats.watch = strats.events = function(parentVal, childVal) {
                if (!childVal)
                    return parentVal;
                if (!parentVal)
                    return childVal;
                var ret = {};
                extend(ret, parentVal);
                for (var key in childVal) {
                    var parent = ret[key]
                        , child = childVal[key];
                    parent && !isArray(parent) && (parent = [parent]),
                        ret[key] = parent ? parent.concat(child) : [child]
                }
                return ret
            }
            ,
            strats.props = strats.methods = strats.computed = function(parentVal, childVal) {
                if (!childVal)
                    return parentVal;
                if (!parentVal)
                    return childVal;
                var ret = Object.create(null);
                return extend(ret, parentVal),
                    extend(ret, childVal),
                    ret
            }
        ;
        var defaultStrat = function(parentVal, childVal) {
            return void 0 === childVal ? parentVal : childVal
        }
            , uid$1 = 0;
        Dep.target = null,
            Dep.prototype.addSub = function(sub) {
                this.subs.push(sub)
            }
            ,
            Dep.prototype.removeSub = function(sub) {
                this.subs.$remove(sub)
            }
            ,
            Dep.prototype.depend = function() {
                Dep.target.addDep(this)
            }
            ,
            Dep.prototype.notify = function() {
                for (var subs = toArray(this.subs), i = 0, l = subs.length; i < l; i++)
                    subs[i].update()
            }
        ;
        var arrayProto = Array.prototype
            , arrayMethods = Object.create(arrayProto);
        ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(function(method) {
            var original = arrayProto[method];
            def(arrayMethods, method, function() {
                for (var i = arguments.length, args = new Array(i); i--; )
                    args[i] = arguments[i];
                var inserted, result = original.apply(this, args), ob = this.__ob__;
                switch (method) {
                    case "push":
                        inserted = args;
                        break;
                    case "unshift":
                        inserted = args;
                        break;
                    case "splice":
                        inserted = args.slice(2)
                }
                return inserted && ob.observeArray(inserted),
                    ob.dep.notify(),
                    result
            })
        }),
            def(arrayProto, "$set", function(index, val) {
                return index >= this.length && (this.length = Number(index) + 1),
                    this.splice(index, 1, val)[0]
            }),
            def(arrayProto, "$remove", function(item) {
                if (this.length) {
                    var index = indexOf(this, item);
                    return index > -1 ? this.splice(index, 1) : void 0
                }
            });
        var arrayKeys = Object.getOwnPropertyNames(arrayMethods)
            , shouldConvert = !0;
        Observer.prototype.walk = function(obj) {
            for (var keys = Object.keys(obj), i = 0, l = keys.length; i < l; i++)
                this.convert(keys[i], obj[keys[i]])
        }
            ,
            Observer.prototype.observeArray = function(items) {
                for (var i = 0, l = items.length; i < l; i++)
                    observe(items[i])
            }
            ,
            Observer.prototype.convert = function(key, val) {
                defineReactive(this.value, key, val)
            }
            ,
            Observer.prototype.addVm = function(vm) {
                (this.vms || (this.vms = [])).push(vm)
            }
            ,
            Observer.prototype.removeVm = function(vm) {
                this.vms.$remove(vm)
            }
        ;
        var util = Object.freeze({
            defineReactive: defineReactive,
            set: set,
            del: del,
            hasOwn: hasOwn,
            isLiteral: isLiteral,
            isReserved: isReserved,
            _toString: _toString,
            toNumber: toNumber,
            toBoolean: toBoolean,
            stripQuotes: stripQuotes,
            camelize: camelize,
            hyphenate: hyphenate,
            classify: classify,
            bind: bind,
            toArray: toArray,
            extend: extend,
            isObject: isObject,
            isPlainObject: isPlainObject,
            def: def,
            debounce: _debounce,
            indexOf: indexOf,
            cancellable: cancellable,
            looseEqual: looseEqual,
            isArray: isArray,
            hasProto: hasProto,
            inBrowser: inBrowser,
            devtools: devtools,
            isIE: isIE,
            isIE9: isIE9,
            isAndroid: isAndroid,
            isIOS: isIOS,
            get transitionProp() {
                return transitionProp
            },
            get transitionEndEvent() {
                return transitionEndEvent
            },
            get animationProp() {
                return animationProp
            },
            get animationEndEvent() {
                return animationEndEvent
            },
            nextTick: nextTick,
            get _Set() {
                return _Set
            },
            query: query,
            inDoc: inDoc,
            getAttr: getAttr,
            getBindAttr: getBindAttr,
            hasBindAttr: hasBindAttr,
            before: before,
            after: after,
            remove: remove,
            prepend: prepend,
            replace: replace,
            on: on,
            off: off,
            setClass: setClass,
            addClass: addClass,
            removeClass: removeClass,
            extractContent: extractContent,
            trimNode: trimNode,
            isTemplate: isTemplate,
            createAnchor: createAnchor,
            findRef: findRef,
            mapNodeRange: mapNodeRange,
            removeNodeRange: removeNodeRange,
            isFragment: isFragment,
            getOuterHTML: getOuterHTML,
            mergeOptions: mergeOptions,
            resolveAsset: resolveAsset,
            checkComponentAttr: checkComponentAttr,
            commonTagRE: commonTagRE,
            reservedTagRE: reservedTagRE,
            get warn() {
                return warn
            }
        })
            , uid = 0
            , pathCache = new Cache(1e3)
            , APPEND = 0
            , PUSH = 1
            , INC_SUB_PATH_DEPTH = 2
            , PUSH_SUB_PATH = 3
            , BEFORE_PATH = 0
            , IN_PATH = 1
            , BEFORE_IDENT = 2
            , IN_IDENT = 3
            , IN_SUB_PATH = 4
            , IN_SINGLE_QUOTE = 5
            , IN_DOUBLE_QUOTE = 6
            , AFTER_PATH = 7
            , ERROR = 8
            , pathStateMachine = [];
        pathStateMachine[BEFORE_PATH] = {
            ws: [BEFORE_PATH],
            ident: [IN_IDENT, APPEND],
            "[": [IN_SUB_PATH],
            eof: [AFTER_PATH]
        },
            pathStateMachine[IN_PATH] = {
                ws: [IN_PATH],
                ".": [BEFORE_IDENT],
                "[": [IN_SUB_PATH],
                eof: [AFTER_PATH]
            },
            pathStateMachine[BEFORE_IDENT] = {
                ws: [BEFORE_IDENT],
                ident: [IN_IDENT, APPEND]
            },
            pathStateMachine[IN_IDENT] = {
                ident: [IN_IDENT, APPEND],
                0: [IN_IDENT, APPEND],
                number: [IN_IDENT, APPEND],
                ws: [IN_PATH, PUSH],
                ".": [BEFORE_IDENT, PUSH],
                "[": [IN_SUB_PATH, PUSH],
                eof: [AFTER_PATH, PUSH]
            },
            pathStateMachine[IN_SUB_PATH] = {
                "'": [IN_SINGLE_QUOTE, APPEND],
                '"': [IN_DOUBLE_QUOTE, APPEND],
                "[": [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
                "]": [IN_PATH, PUSH_SUB_PATH],
                eof: ERROR,
                else: [IN_SUB_PATH, APPEND]
            },
            pathStateMachine[IN_SINGLE_QUOTE] = {
                "'": [IN_SUB_PATH, APPEND],
                eof: ERROR,
                else: [IN_SINGLE_QUOTE, APPEND]
            },
            pathStateMachine[IN_DOUBLE_QUOTE] = {
                '"': [IN_SUB_PATH, APPEND],
                eof: ERROR,
                else: [IN_DOUBLE_QUOTE, APPEND]
            };
        var path = Object.freeze({
            parsePath: parsePath,
            getPath: getPath,
            setPath: setPath
        })
            , expressionCache = new Cache(1e3)
            , allowedKeywords = "Math,Date,this,true,false,null,undefined,Infinity,NaN,isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,parseInt,parseFloat"
            , allowedKeywordsRE = new RegExp("^(" + allowedKeywords.replace(/,/g, "\\b|") + "\\b)")
            , improperKeywords = "break,case,class,catch,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,in,instanceof,let,return,super,switch,throw,try,var,while,with,yield,enum,await,implements,package,protected,static,interface,private,public"
            , improperKeywordsRE = new RegExp("^(" + improperKeywords.replace(/,/g, "\\b|") + "\\b)")
            , wsRE = /\s/g
            , newlineRE = /\n/g
            , saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\"']|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g
            , restoreRE = /"(\d+)"/g
            , pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/
            , identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g
            , literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/
            , saved = []
            , expression = Object.freeze({
            parseExpression: parseExpression$1,
            isSimplePath: isSimplePath
        })
            , queue = []
            , userQueue = []
            , has = {}
            , circular = {}
            , waiting = !1
            , uid$2 = 0;
        Watcher.prototype.get = function() {
            this.beforeGet();
            var value, scope = this.scope || this.vm;
            try {
                value = this.getter.call(scope, scope)
            } catch (e) {}
            return this.deep && traverse(value),
            this.preProcess && (value = this.preProcess(value)),
            this.filters && (value = scope._applyFilters(value, null, this.filters, !1)),
            this.postProcess && (value = this.postProcess(value)),
                this.afterGet(),
                value
        }
            ,
            Watcher.prototype.set = function(value) {
                var scope = this.scope || this.vm;
                this.filters && (value = scope._applyFilters(value, this.value, this.filters, !0));
                try {
                    this.setter.call(scope, scope, value)
                } catch (e) {}
                var forContext = scope.$forContext;
                if (forContext && forContext.alias === this.expression) {
                    if (forContext.filters)
                        return;
                    forContext._withLock(function() {
                        scope.$key ? forContext.rawValue[scope.$key] = value : forContext.rawValue.$set(scope.$index, value)
                    })
                }
            }
            ,
            Watcher.prototype.beforeGet = function() {
                Dep.target = this
            }
            ,
            Watcher.prototype.addDep = function(dep) {
                var id = dep.id;
                this.newDepIds.has(id) || (this.newDepIds.add(id),
                    this.newDeps.push(dep),
                this.depIds.has(id) || dep.addSub(this))
            }
            ,
            Watcher.prototype.afterGet = function() {
                Dep.target = null;
                for (var i = this.deps.length; i--; ) {
                    var dep = this.deps[i];
                    this.newDepIds.has(dep.id) || dep.removeSub(this)
                }
                var tmp = this.depIds;
                this.depIds = this.newDepIds,
                    this.newDepIds = tmp,
                    this.newDepIds.clear(),
                    tmp = this.deps,
                    this.deps = this.newDeps,
                    this.newDeps = tmp,
                    this.newDeps.length = 0
            }
            ,
            Watcher.prototype.update = function(shallow) {
                this.lazy ? this.dirty = !0 : this.sync || !config.async ? this.run() : (this.shallow = this.queued ? !!shallow && this.shallow : !!shallow,
                    this.queued = !0,
                    pushWatcher(this))
            }
            ,
            Watcher.prototype.run = function() {
                if (this.active) {
                    var value = this.get();
                    if (value !== this.value || (isObject(value) || this.deep) && !this.shallow) {
                        var oldValue = this.value;
                        this.value = value;
                        this.prevError;
                        this.cb.call(this.vm, value, oldValue)
                    }
                    this.queued = this.shallow = !1
                }
            }
            ,
            Watcher.prototype.evaluate = function() {
                var current = Dep.target;
                this.value = this.get(),
                    this.dirty = !1,
                    Dep.target = current
            }
            ,
            Watcher.prototype.depend = function() {
                for (var i = this.deps.length; i--; )
                    this.deps[i].depend()
            }
            ,
            Watcher.prototype.teardown = function() {
                if (this.active) {
                    this.vm._isBeingDestroyed || this.vm._vForRemoving || this.vm._watchers.$remove(this);
                    for (var i = this.deps.length; i--; )
                        this.deps[i].removeSub(this);
                    this.active = !1,
                        this.vm = this.cb = this.value = null
                }
            }
        ;
        var seenObjects = new _Set
            , text$1 = {
            bind: function() {
                this.attr = 3 === this.el.nodeType ? "data" : "textContent"
            },
            update: function(value) {
                this.el[this.attr] = _toString(value)
            }
        }
            , templateCache = new Cache(1e3)
            , idSelectorCache = new Cache(1e3)
            , map = {
            efault: [0, "", ""],
            legend: [1, "<fieldset>", "</fieldset>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"]
        };
        map.td = map.th = [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            map.option = map.optgroup = [1, '<select multiple="multiple">', "</select>"],
            map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, "<table>", "</table>"],
            map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ev="http://www.w3.org/2001/xml-events"version="1.1">', "</svg>"];
        var tagRE$1 = /<([\w:-]+)/
            , entityRE = /&#?\w+?;/
            , commentRE = /<!--/
            , hasBrokenTemplate = function() {
            if (inBrowser) {
                var a = document.createElement("div");
                return a.innerHTML = "<template>1</template>",
                    !a.cloneNode(!0).firstChild.innerHTML
            }
            return !1
        }()
            , hasTextareaCloneBug = function() {
            if (inBrowser) {
                var t = document.createElement("textarea");
                return t.placeholder = "t",
                "t" === t.cloneNode(!0).value
            }
            return !1
        }()
            , template = Object.freeze({
            cloneNode: cloneNode,
            parseTemplate: parseTemplate
        })
            , html = {
            bind: function() {
                8 === this.el.nodeType && (this.nodes = [],
                    this.anchor = createAnchor("v-html"),
                    replace(this.el, this.anchor))
            },
            update: function(value) {
                value = _toString(value),
                    this.nodes ? this.swap(value) : this.el.innerHTML = value
            },
            swap: function(value) {
                for (var i = this.nodes.length; i--; )
                    remove(this.nodes[i]);
                var frag = parseTemplate(value, !0, !0);
                this.nodes = toArray(frag.childNodes),
                    before(frag, this.anchor)
            }
        };
        Fragment.prototype.callHook = function(hook) {
            var i, l;
            for (i = 0,
                     l = this.childFrags.length; i < l; i++)
                this.childFrags[i].callHook(hook);
            for (i = 0,
                     l = this.children.length; i < l; i++)
                hook(this.children[i])
        }
            ,
            Fragment.prototype.beforeRemove = function() {
                var i, l;
                for (i = 0,
                         l = this.childFrags.length; i < l; i++)
                    this.childFrags[i].beforeRemove(!1);
                for (i = 0,
                         l = this.children.length; i < l; i++)
                    this.children[i].$destroy(!1, !0);
                var dirs = this.unlink.dirs;
                for (i = 0,
                         l = dirs.length; i < l; i++)
                    dirs[i]._watcher && dirs[i]._watcher.teardown()
            }
            ,
            Fragment.prototype.destroy = function() {
                this.parentFrag && this.parentFrag.childFrags.$remove(this),
                    this.node.__v_frag = null,
                    this.unlink()
            }
        ;
        var linkerCache = new Cache(5e3);
        FragmentFactory.prototype.create = function(host, scope, parentFrag) {
            var frag = cloneNode(this.template);
            return new Fragment(this.linker,this.vm,frag,host,scope,parentFrag)
        }
        ;
        var ON = 700
            , MODEL = 800
            , BIND = 850
            , TRANSITION = 1100
            , EL = 1500
            , COMPONENT = 1500
            , PARTIAL = 1750
            , IF = 2100
            , FOR = 2200
            , SLOT = 2300
            , uid$3 = 0
            , vFor = {
            priority: FOR,
            terminal: !0,
            params: ["track-by", "stagger", "enter-stagger", "leave-stagger"],
            bind: function() {
                var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);
                if (inMatch) {
                    var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
                    itMatch ? (this.iterator = itMatch[1].trim(),
                        this.alias = itMatch[2].trim()) : this.alias = inMatch[1].trim(),
                        this.expression = inMatch[2]
                }
                if (this.alias) {
                    this.id = "__v-for__" + ++uid$3;
                    var tag = this.el.tagName;
                    this.isOption = ("OPTION" === tag || "OPTGROUP" === tag) && "SELECT" === this.el.parentNode.tagName,
                        this.start = createAnchor("v-for-start"),
                        this.end = createAnchor("v-for-end"),
                        replace(this.el, this.end),
                        before(this.start, this.end),
                        this.cache = Object.create(null),
                        this.factory = new FragmentFactory(this.vm,this.el)
                }
            },
            update: function(data) {
                this.diff(data),
                    this.updateRef(),
                    this.updateModel()
            },
            diff: function(data) {
                var i, l, frag, key, value, primitive, item = data[0], convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, "$key") && hasOwn(item, "$value"), trackByKey = this.params.trackBy, oldFrags = this.frags, frags = this.frags = new Array(data.length), alias = this.alias, iterator = this.iterator, start = this.start, end = this.end, inDocument = inDoc(start), init = !oldFrags;
                for (i = 0,
                         l = data.length; i < l; i++)
                    item = data[i],
                        key = convertedFromObject ? item.$key : null,
                        value = convertedFromObject ? item.$value : item,
                        primitive = !isObject(value),
                        frag = !init && this.getCachedFrag(value, i, key),
                        frag ? (frag.reused = !0,
                            frag.scope.$index = i,
                        key && (frag.scope.$key = key),
                        iterator && (frag.scope[iterator] = null !== key ? key : i),
                        (trackByKey || convertedFromObject || primitive) && withoutConversion(function() {
                            frag.scope[alias] = value
                        })) : (frag = this.create(value, alias, i, key),
                            frag.fresh = !init),
                        frags[i] = frag,
                    init && frag.before(end);
                if (!init) {
                    var removalIndex = 0
                        , totalRemoved = oldFrags.length - frags.length;
                    for (this.vm._vForRemoving = !0,
                             i = 0,
                             l = oldFrags.length; i < l; i++)
                        frag = oldFrags[i],
                        frag.reused || (this.deleteCachedFrag(frag),
                            this.remove(frag, removalIndex++, totalRemoved, inDocument));
                    this.vm._vForRemoving = !1,
                    removalIndex && (this.vm._watchers = this.vm._watchers.filter(function(w) {
                        return w.active
                    }));
                    var targetPrev, prevEl, currentPrev, insertionIndex = 0;
                    for (i = 0,
                             l = frags.length; i < l; i++)
                        frag = frags[i],
                            targetPrev = frags[i - 1],
                            prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start,
                            frag.reused && !frag.staggerCb ? (currentPrev = findPrevFrag(frag, start, this.id),
                            currentPrev === targetPrev || currentPrev && findPrevFrag(currentPrev, start, this.id) === targetPrev || this.move(frag, prevEl)) : this.insert(frag, insertionIndex++, prevEl, inDocument),
                            frag.reused = frag.fresh = !1
                }
            },
            create: function(value, alias, index, key) {
                var host = this._host
                    , parentScope = this._scope || this.vm
                    , scope = Object.create(parentScope);
                scope.$refs = Object.create(parentScope.$refs),
                    scope.$els = Object.create(parentScope.$els),
                    scope.$parent = parentScope,
                    scope.$forContext = this,
                    withoutConversion(function() {
                        defineReactive(scope, alias, value)
                    }),
                    defineReactive(scope, "$index", index),
                    key ? defineReactive(scope, "$key", key) : scope.$key && def(scope, "$key", null),
                this.iterator && defineReactive(scope, this.iterator, null !== key ? key : index);
                var frag = this.factory.create(host, scope, this._frag);
                return frag.forId = this.id,
                    this.cacheFrag(value, frag, index, key),
                    frag
            },
            updateRef: function() {
                var ref = this.descriptor.ref;
                if (ref) {
                    var refs, hash = (this._scope || this.vm).$refs;
                    this.fromObject ? (refs = {},
                        this.frags.forEach(function(frag) {
                            refs[frag.scope.$key] = findVmFromFrag(frag)
                        })) : refs = this.frags.map(findVmFromFrag),
                        hash[ref] = refs
                }
            },
            updateModel: function() {
                if (this.isOption) {
                    var parent = this.start.parentNode
                        , model = parent && parent.__v_model;
                    model && model.forceUpdate()
                }
            },
            insert: function(frag, index, prevEl, inDocument) {
                frag.staggerCb && (frag.staggerCb.cancel(),
                    frag.staggerCb = null);
                var staggerAmount = this.getStagger(frag, index, null, "enter");
                if (inDocument && staggerAmount) {
                    var anchor = frag.staggerAnchor;
                    anchor || (anchor = frag.staggerAnchor = createAnchor("stagger-anchor"),
                        anchor.__v_frag = frag),
                        after(anchor, prevEl);
                    var op = frag.staggerCb = cancellable(function() {
                        frag.staggerCb = null,
                            frag.before(anchor),
                            remove(anchor)
                    });
                    setTimeout(op, staggerAmount)
                } else {
                    var target = prevEl.nextSibling;
                    target || (after(this.end, prevEl),
                        target = this.end),
                        frag.before(target)
                }
            },
            remove: function(frag, index, total, inDocument) {
                if (frag.staggerCb)
                    return frag.staggerCb.cancel(),
                        void (frag.staggerCb = null);
                var staggerAmount = this.getStagger(frag, index, total, "leave");
                if (inDocument && staggerAmount) {
                    var op = frag.staggerCb = cancellable(function() {
                        frag.staggerCb = null,
                            frag.remove()
                    });
                    setTimeout(op, staggerAmount)
                } else
                    frag.remove()
            },
            move: function(frag, prevEl) {
                prevEl.nextSibling || this.end.parentNode.appendChild(this.end),
                    frag.before(prevEl.nextSibling, !1)
            },
            cacheFrag: function(value, frag, index, key) {
                var id, trackByKey = this.params.trackBy, cache = this.cache, primitive = !isObject(value);
                key || trackByKey || primitive ? (id = getTrackByKey(index, key, value, trackByKey),
                cache[id] || (cache[id] = frag)) : (id = this.id,
                    hasOwn(value, id) ? null === value[id] && (value[id] = frag) : Object.isExtensible(value) && def(value, id, frag)),
                    frag.raw = value
            },
            getCachedFrag: function(value, index, key) {
                var frag, trackByKey = this.params.trackBy, primitive = !isObject(value);
                if (key || trackByKey || primitive) {
                    var id = getTrackByKey(index, key, value, trackByKey);
                    frag = this.cache[id]
                } else
                    frag = value[this.id];
                return frag && (frag.reused || frag.fresh),
                    frag
            },
            deleteCachedFrag: function(frag) {
                var value = frag.raw
                    , trackByKey = this.params.trackBy
                    , scope = frag.scope
                    , index = scope.$index
                    , key = hasOwn(scope, "$key") && scope.$key
                    , primitive = !isObject(value);
                if (trackByKey || key || primitive) {
                    var id = getTrackByKey(index, key, value, trackByKey);
                    this.cache[id] = null
                } else
                    value[this.id] = null,
                        frag.raw = null
            },
            getStagger: function(frag, index, total, type) {
                type += "Stagger";
                var trans = frag.node.__v_trans
                    , hooks = trans && trans.hooks
                    , hook = hooks && (hooks[type] || hooks.stagger);
                return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10)
            },
            _preProcess: function(value) {
                return this.rawValue = value,
                    value
            },
            _postProcess: function(value) {
                if (isArray(value))
                    return value;
                if (isPlainObject(value)) {
                    for (var key, keys = Object.keys(value), i = keys.length, res = new Array(i); i--; )
                        key = keys[i],
                            res[i] = {
                                $key: key,
                                $value: value[key]
                            };
                    return res
                }
                return "number" != typeof value || isNaN(value) || (value = range(value)),
                value || []
            },
            unbind: function() {
                if (this.descriptor.ref && ((this._scope || this.vm).$refs[this.descriptor.ref] = null),
                        this.frags)
                    for (var frag, i = this.frags.length; i--; )
                        frag = this.frags[i],
                            this.deleteCachedFrag(frag),
                            frag.destroy()
            }
        }
            , vIf = {
            priority: IF,
            terminal: !0,
            bind: function() {
                var el = this.el;
                if (el.__vue__)
                    this.invalid = !0;
                else {
                    var next = el.nextElementSibling;
                    next && null !== getAttr(next, "v-else") && (remove(next),
                        this.elseEl = next),
                        this.anchor = createAnchor("v-if"),
                        replace(el, this.anchor)
                }
            },
            update: function(value) {
                this.invalid || (value ? this.frag || this.insert() : this.remove())
            },
            insert: function() {
                this.elseFrag && (this.elseFrag.remove(),
                    this.elseFrag = null),
                this.factory || (this.factory = new FragmentFactory(this.vm,this.el)),
                    this.frag = this.factory.create(this._host, this._scope, this._frag),
                    this.frag.before(this.anchor)
            },
            remove: function() {
                this.frag && (this.frag.remove(),
                    this.frag = null),
                this.elseEl && !this.elseFrag && (this.elseFactory || (this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm,this.elseEl)),
                    this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag),
                    this.elseFrag.before(this.anchor))
            },
            unbind: function() {
                this.frag && this.frag.destroy(),
                this.elseFrag && this.elseFrag.destroy()
            }
        }
            , show = {
            bind: function() {
                var next = this.el.nextElementSibling;
                next && null !== getAttr(next, "v-else") && (this.elseEl = next)
            },
            update: function(value) {
                this.apply(this.el, value),
                this.elseEl && this.apply(this.elseEl, !value)
            },
            apply: function(el, value) {
                function toggle() {
                    el.style.display = value ? "" : "none"
                }
                inDoc(el) ? applyTransition(el, value ? 1 : -1, toggle, this.vm) : toggle()
            }
        }
            , text$2 = {
            bind: function() {
                var self = this
                    , el = this.el
                    , isRange = "range" === el.type
                    , lazy = this.params.lazy
                    , number = this.params.number
                    , debounce = this.params.debounce
                    , composing = !1;
                if (isAndroid || isRange || (this.on("compositionstart", function() {
                        composing = !0
                    }),
                        this.on("compositionend", function() {
                            composing = !1,
                            lazy || self.listener()
                        })),
                        this.focused = !1,
                    isRange || lazy || (this.on("focus", function() {
                        self.focused = !0
                    }),
                        this.on("blur", function() {
                            self.focused = !1,
                            self._frag && !self._frag.inserted || self.rawListener()
                        })),
                        this.listener = this.rawListener = function() {
                            if (!composing && self._bound) {
                                var val = number || isRange ? toNumber(el.value) : el.value;
                                self.set(val),
                                    nextTick(function() {
                                        self._bound && !self.focused && self.update(self._watcher.value)
                                    })
                            }
                        }
                        ,
                    debounce && (this.listener = _debounce(this.listener, debounce)),
                        this.hasjQuery = "function" == typeof jQuery,
                        this.hasjQuery) {
                    var method = jQuery.fn.on ? "on" : "bind";
                    jQuery(el)[method]("change", this.rawListener),
                    lazy || jQuery(el)[method]("input", this.listener)
                } else
                    this.on("change", this.rawListener),
                    lazy || this.on("input", this.listener);
                !lazy && isIE9 && (this.on("cut", function() {
                    nextTick(self.listener)
                }),
                    this.on("keyup", function(e) {
                        46 !== e.keyCode && 8 !== e.keyCode || self.listener()
                    })),
                (el.hasAttribute("value") || "TEXTAREA" === el.tagName && el.value.trim()) && (this.afterBind = this.listener)
            },
            update: function(value) {
                value = _toString(value),
                value !== this.el.value && (this.el.value = value)
            },
            unbind: function() {
                var el = this.el;
                if (this.hasjQuery) {
                    var method = jQuery.fn.off ? "off" : "unbind";
                    jQuery(el)[method]("change", this.listener),
                        jQuery(el)[method]("input", this.listener)
                }
            }
        }
            , radio = {
            bind: function() {
                var self = this
                    , el = this.el;
                this.getValue = function() {
                    if (el.hasOwnProperty("_value"))
                        return el._value;
                    var val = el.value;
                    return self.params.number && (val = toNumber(val)),
                        val
                }
                    ,
                    this.listener = function() {
                        self.set(self.getValue())
                    }
                    ,
                    this.on("change", this.listener),
                el.hasAttribute("checked") && (this.afterBind = this.listener)
            },
            update: function(value) {
                this.el.checked = looseEqual(value, this.getValue())
            }
        }
            , select = {
            bind: function() {
                var _this = this
                    , self = this
                    , el = this.el;
                this.forceUpdate = function() {
                    self._watcher && self.update(self._watcher.get())
                }
                ;
                var multiple = this.multiple = el.hasAttribute("multiple");
                this.listener = function() {
                    var value = getValue(el, multiple);
                    value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value,
                        self.set(value)
                }
                    ,
                    this.on("change", this.listener);
                var initValue = getValue(el, multiple, !0);
                (multiple && initValue.length || !multiple && null !== initValue) && (this.afterBind = this.listener),
                    this.vm.$on("hook:attached", function() {
                        nextTick(_this.forceUpdate)
                    }),
                inDoc(el) || nextTick(this.forceUpdate)
            },
            update: function(value) {
                var el = this.el;
                el.selectedIndex = -1;
                for (var op, val, multi = this.multiple && isArray(value), options = el.options, i = options.length; i--; )
                    op = options[i],
                        val = op.hasOwnProperty("_value") ? op._value : op.value,
                        op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val)
            },
            unbind: function() {
                this.vm.$off("hook:attached", this.forceUpdate)
            }
        }
            , checkbox = {
            bind: function() {
                function getBooleanValue() {
                    var val = el.checked;
                    return val && el.hasOwnProperty("_trueValue") ? el._trueValue : !val && el.hasOwnProperty("_falseValue") ? el._falseValue : val
                }
                var self = this
                    , el = this.el;
                this.getValue = function() {
                    return el.hasOwnProperty("_value") ? el._value : self.params.number ? toNumber(el.value) : el.value
                }
                    ,
                    this.listener = function() {
                        var model = self._watcher.get();
                        if (isArray(model)) {
                            var val = self.getValue()
                                , i = indexOf(model, val);
                            el.checked ? i < 0 && self.set(model.concat(val)) : i > -1 && self.set(model.slice(0, i).concat(model.slice(i + 1)))
                        } else
                            self.set(getBooleanValue())
                    }
                    ,
                    this.on("change", this.listener),
                el.hasAttribute("checked") && (this.afterBind = this.listener)
            },
            update: function(value) {
                var el = this.el;
                isArray(value) ? el.checked = indexOf(value, this.getValue()) > -1 : el.hasOwnProperty("_trueValue") ? el.checked = looseEqual(value, el._trueValue) : el.checked = !!value
            }
        }
            , handlers = {
            text: text$2,
            radio: radio,
            select: select,
            checkbox: checkbox
        }
            , model = {
            priority: MODEL,
            twoWay: !0,
            handlers: handlers,
            params: ["lazy", "number", "debounce"],
            bind: function() {
                this.checkFilters(),
                this.hasRead && !this.hasWrite;
                var handler, el = this.el, tag = el.tagName;
                if ("INPUT" === tag)
                    handler = handlers[el.type] || handlers.text;
                else if ("SELECT" === tag)
                    handler = handlers.select;
                else {
                    if ("TEXTAREA" !== tag)
                        return;
                    handler = handlers.text
                }
                el.__v_model = this,
                    handler.bind.call(this),
                    this.update = handler.update,
                    this._unbind = handler.unbind
            },
            checkFilters: function() {
                var filters = this.filters;
                if (filters)
                    for (var i = filters.length; i--; ) {
                        var filter = resolveAsset(this.vm.$options, "filters", filters[i].name);
                        ("function" == typeof filter || filter.read) && (this.hasRead = !0),
                        filter.write && (this.hasWrite = !0)
                    }
            },
            unbind: function() {
                this.el.__v_model = null,
                this._unbind && this._unbind()
            }
        }
            , keyCodes = {
            esc: 27,
            tab: 9,
            enter: 13,
            space: 32,
            delete: [8, 46],
            up: 38,
            left: 37,
            right: 39,
            down: 40
        }
            , on$1 = {
            priority: ON,
            acceptStatement: !0,
            keyCodes: keyCodes,
            bind: function() {
                if ("IFRAME" === this.el.tagName && "load" !== this.arg) {
                    var self = this;
                    this.iframeBind = function() {
                        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture)
                    }
                        ,
                        this.on("load", this.iframeBind)
                }
            },
            update: function(handler) {
                if (this.descriptor.raw || (handler = function() {}
                    ),
                    "function" == typeof handler) {
                    this.modifiers.stop && (handler = stopFilter(handler)),
                    this.modifiers.prevent && (handler = preventFilter(handler)),
                    this.modifiers.self && (handler = selfFilter(handler));
                    var keys = Object.keys(this.modifiers).filter(function(key) {
                        return "stop" !== key && "prevent" !== key && "self" !== key && "capture" !== key
                    });
                    keys.length && (handler = keyFilter(handler, keys)),
                        this.reset(),
                        this.handler = handler,
                        this.iframeBind ? this.iframeBind() : on(this.el, this.arg, this.handler, this.modifiers.capture)
                }
            },
            reset: function() {
                var el = this.iframeBind ? this.el.contentWindow : this.el;
                this.handler && off(el, this.arg, this.handler)
            },
            unbind: function() {
                this.reset()
            }
        }
            , prefixes = ["-webkit-", "-moz-", "-ms-"]
            , camelPrefixes = ["Webkit", "Moz", "ms"]
            , importantRE = /!important;?$/
            , propCache = Object.create(null)
            , testEl = null
            , style = {
            deep: !0,
            update: function(value) {
                "string" == typeof value ? this.el.style.cssText = value : isArray(value) ? this.handleObject(value.reduce(extend, {})) : this.handleObject(value || {})
            },
            handleObject: function(value) {
                var name, val, cache = this.cache || (this.cache = {});
                for (name in cache)
                    name in value || (this.handleSingle(name, null),
                        delete cache[name]);
                for (name in value)
                    val = value[name],
                    val !== cache[name] && (cache[name] = val,
                        this.handleSingle(name, val))
            },
            handleSingle: function(prop, value) {
                if (prop = normalize(prop))
                    if (null != value && (value += ""),
                            value) {
                        var isImportant = importantRE.test(value) ? "important" : "";
                        isImportant ? (value = value.replace(importantRE, "").trim(),
                            this.el.style.setProperty(prop.kebab, value, isImportant)) : this.el.style[prop.camel] = value
                    } else
                        this.el.style[prop.camel] = ""
            }
        }
            , xlinkNS = "http://www.w3.org/1999/xlink"
            , xlinkRE = /^xlink:/
            , disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/
            , attrWithPropsRE = /^(?:value|checked|selected|muted)$/
            , enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/
            , modelProps = {
            value: "_value",
            "true-value": "_trueValue",
            "false-value": "_falseValue"
        }
            , bind$1 = {
            priority: BIND,
            bind: function() {
                var attr = this.arg
                    , tag = this.el.tagName;
                attr || (this.deep = !0);
                var descriptor = this.descriptor
                    , tokens = descriptor.interp;
                if (tokens) {
                    descriptor.hasOneTime && (this.expression = tokensToExp(tokens, this._scope || this.vm)),
                    (disallowedInterpAttrRE.test(attr) || "name" === attr && ("PARTIAL" === tag || "SLOT" === tag)) && (this.el.removeAttribute(attr),
                        this.invalid = !0)
                }
            },
            update: function(value) {
                if (!this.invalid) {
                    var attr = this.arg;
                    this.arg ? this.handleSingle(attr, value) : this.handleObject(value || {})
                }
            },
            handleObject: style.handleObject,
            handleSingle: function(attr, value) {
                var el = this.el
                    , interp = this.descriptor.interp;
                if (this.modifiers.camel && (attr = camelize(attr)),
                    !interp && attrWithPropsRE.test(attr) && attr in el) {
                    var attrValue = "value" === attr && null == value ? "" : value;
                    el[attr] !== attrValue && (el[attr] = attrValue)
                }
                var modelProp = modelProps[attr];
                if (!interp && modelProp) {
                    el[modelProp] = value;
                    var model = el.__v_model;
                    model && model.listener()
                }
                return "value" === attr && "TEXTAREA" === el.tagName ? void el.removeAttribute(attr) : void (enumeratedAttrRE.test(attr) ? el.setAttribute(attr, value ? "true" : "false") : null != value && value !== !1 ? "class" === attr ? (el.__v_trans && (value += " " + el.__v_trans.id + "-transition"),
                    setClass(el, value)) : xlinkRE.test(attr) ? el.setAttributeNS(xlinkNS, attr, value === !0 ? "" : value) : el.setAttribute(attr, value === !0 ? "" : value) : el.removeAttribute(attr))
            }
        }
            , el = {
            priority: EL,
            bind: function() {
                if (this.arg) {
                    var id = this.id = camelize(this.arg)
                        , refs = (this._scope || this.vm).$els;
                    hasOwn(refs, id) ? refs[id] = this.el : defineReactive(refs, id, this.el)
                }
            },
            unbind: function() {
                var refs = (this._scope || this.vm).$els;
                refs[this.id] === this.el && (refs[this.id] = null)
            }
        }
            , ref = {
            bind: function() {}
        }
            , cloak = {
            bind: function() {
                var el = this.el;
                this.vm.$once("pre-hook:compiled", function() {
                    el.removeAttribute("v-cloak")
                })
            }
        }
            , directives = {
            text: text$1,
            html: html,
            for: vFor,
            if: vIf,
            show: show,
            model: model,
            on: on$1,
            bind: bind$1,
            el: el,
            ref: ref,
            cloak: cloak
        }
            , vClass = {
            deep: !0,
            update: function(value) {
                value ? "string" == typeof value ? this.setClass(value.trim().split(/\s+/)) : this.setClass(normalize$1(value)) : this.cleanup()
            },
            setClass: function(value) {
                this.cleanup(value);
                for (var i = 0, l = value.length; i < l; i++) {
                    var val = value[i];
                    val && apply(this.el, val, addClass)
                }
                this.prevKeys = value
            },
            cleanup: function(value) {
                var prevKeys = this.prevKeys;
                if (prevKeys)
                    for (var i = prevKeys.length; i--; ) {
                        var key = prevKeys[i];
                        (!value || value.indexOf(key) < 0) && apply(this.el, key, removeClass)
                    }
            }
        }
            , component = {
            priority: COMPONENT,
            params: ["keep-alive", "transition-mode", "inline-template"],
            bind: function() {
                this.el.__vue__ || (this.keepAlive = this.params.keepAlive,
                this.keepAlive && (this.cache = {}),
                this.params.inlineTemplate && (this.inlineTemplate = extractContent(this.el, !0)),
                    this.pendingComponentCb = this.Component = null,
                    this.pendingRemovals = 0,
                    this.pendingRemovalCb = null,
                    this.anchor = createAnchor("v-component"),
                    replace(this.el, this.anchor),
                    this.el.removeAttribute("is"),
                    this.el.removeAttribute(":is"),
                this.descriptor.ref && this.el.removeAttribute("v-ref:" + hyphenate(this.descriptor.ref)),
                this.literal && this.setComponent(this.expression))
            },
            update: function(value) {
                this.literal || this.setComponent(value)
            },
            setComponent: function(value, cb) {
                if (this.invalidatePending(),
                        value) {
                    var self = this;
                    this.resolveComponent(value, function() {
                        self.mountComponent(cb)
                    })
                } else
                    this.unbuild(!0),
                        this.remove(this.childVM, cb),
                        this.childVM = null
            },
            resolveComponent: function(value, cb) {
                var self = this;
                this.pendingComponentCb = cancellable(function(Component) {
                    self.ComponentName = Component.options.name || ("string" == typeof value ? value : null),
                        self.Component = Component,
                        cb()
                }),
                    this.vm._resolveComponent(value, this.pendingComponentCb)
            },
            mountComponent: function(cb) {
                this.unbuild(!0);
                var self = this
                    , activateHooks = this.Component.options.activate
                    , cached = this.getCached()
                    , newComponent = this.build();
                activateHooks && !cached ? (this.waitingFor = newComponent,
                    callActivateHooks(activateHooks, newComponent, function() {
                        self.waitingFor === newComponent && (self.waitingFor = null,
                            self.transition(newComponent, cb))
                    })) : (cached && newComponent._updateRef(),
                    this.transition(newComponent, cb))
            },
            invalidatePending: function() {
                this.pendingComponentCb && (this.pendingComponentCb.cancel(),
                    this.pendingComponentCb = null)
            },
            build: function(extraOptions) {
                var cached = this.getCached();
                if (cached)
                    return cached;
                if (this.Component) {
                    var options = {
                        name: this.ComponentName,
                        el: cloneNode(this.el),
                        template: this.inlineTemplate,
                        parent: this._host || this.vm,
                        _linkerCachable: !this.inlineTemplate,
                        _ref: this.descriptor.ref,
                        _asComponent: !0,
                        _isRouterView: this._isRouterView,
                        _context: this.vm,
                        _scope: this._scope,
                        _frag: this._frag
                    };
                    extraOptions && extend(options, extraOptions);
                    var child = new this.Component(options);
                    return this.keepAlive && (this.cache[this.Component.cid] = child),
                        child
                }
            },
            getCached: function() {
                return this.keepAlive && this.cache[this.Component.cid]
            },
            unbuild: function(defer) {
                this.waitingFor && (this.keepAlive || this.waitingFor.$destroy(),
                    this.waitingFor = null);
                var child = this.childVM;
                return !child || this.keepAlive ? void (child && (child._inactive = !0,
                    child._updateRef(!0))) : void child.$destroy(!1, defer)
            },
            remove: function(child, cb) {
                var keepAlive = this.keepAlive;
                if (child) {
                    this.pendingRemovals++,
                        this.pendingRemovalCb = cb;
                    var self = this;
                    child.$remove(function() {
                        self.pendingRemovals--,
                        keepAlive || child._cleanup(),
                        !self.pendingRemovals && self.pendingRemovalCb && (self.pendingRemovalCb(),
                            self.pendingRemovalCb = null)
                    })
                } else
                    cb && cb()
            },
            transition: function(target, cb) {
                var self = this
                    , current = this.childVM;
                switch (current && (current._inactive = !0),
                    target._inactive = !1,
                    this.childVM = target,
                    self.params.transitionMode) {
                    case "in-out":
                        target.$before(self.anchor, function() {
                            self.remove(current, cb)
                        });
                        break;
                    case "out-in":
                        self.remove(current, function() {
                            target.$before(self.anchor, cb)
                        });
                        break;
                    default:
                        self.remove(current),
                            target.$before(self.anchor, cb)
                }
            },
            unbind: function() {
                if (this.invalidatePending(),
                        this.unbuild(),
                        this.cache) {
                    for (var key in this.cache)
                        this.cache[key].$destroy();
                    this.cache = null
                }
            }
        }
            , propBindingModes = config._propBindingModes
            , empty = {}
            , identRE$1 = /^[$_a-zA-Z]+[\w$]*$/
            , bindingModes = config._propBindingModes
            , propDef = {
            bind: function() {
                var child = this.vm
                    , parent = child._context
                    , prop = this.descriptor.prop
                    , childKey = prop.path
                    , parentKey = prop.parentPath
                    , twoWay = prop.mode === bindingModes.TWO_WAY
                    , parentWatcher = this.parentWatcher = new Watcher(parent,parentKey,function(val) {
                        updateProp(child, prop, val)
                    }
                    ,{
                        twoWay: twoWay,
                        filters: prop.filters,
                        scope: this._scope
                    });
                if (initProp(child, prop, parentWatcher.value),
                        twoWay) {
                    var self = this;
                    child.$once("pre-hook:created", function() {
                        self.childWatcher = new Watcher(child,childKey,function(val) {
                                parentWatcher.set(val)
                            }
                            ,{
                                sync: !0
                            })
                    })
                }
            },
            unbind: function() {
                this.parentWatcher.teardown(),
                this.childWatcher && this.childWatcher.teardown()
            }
        }
            , queue$1 = []
            , queued = !1
            , TYPE_TRANSITION = "transition"
            , TYPE_ANIMATION = "animation"
            , transDurationProp = transitionProp + "Duration"
            , animDurationProp = animationProp + "Duration"
            , raf = inBrowser && window.requestAnimationFrame
            , waitForTransitionStart = raf ? function(fn) {
            raf(function() {
                raf(fn)
            })
        }
            : function(fn) {
            setTimeout(fn, 50)
        }
            , p$1 = Transition.prototype;
        p$1.enter = function(op, cb) {
            this.cancelPending(),
                this.callHook("beforeEnter"),
                this.cb = cb,
                addClass(this.el, this.enterClass),
                op(),
                this.entered = !1,
                this.callHookWithCb("enter"),
            this.entered || (this.cancel = this.hooks && this.hooks.enterCancelled,
                pushJob(this.enterNextTick))
        }
            ,
            p$1.enterNextTick = function() {
                var _this = this;
                this.justEntered = !0,
                    waitForTransitionStart(function() {
                        _this.justEntered = !1
                    });
                var enterDone = this.enterDone
                    , type = this.getCssTransitionType(this.enterClass);
                this.pendingJsCb ? type === TYPE_TRANSITION && removeClass(this.el, this.enterClass) : type === TYPE_TRANSITION ? (removeClass(this.el, this.enterClass),
                    this.setupCssCb(transitionEndEvent, enterDone)) : type === TYPE_ANIMATION ? this.setupCssCb(animationEndEvent, enterDone) : enterDone()
            }
            ,
            p$1.enterDone = function() {
                this.entered = !0,
                    this.cancel = this.pendingJsCb = null,
                    removeClass(this.el, this.enterClass),
                    this.callHook("afterEnter"),
                this.cb && this.cb()
            }
            ,
            p$1.leave = function(op, cb) {
                this.cancelPending(),
                    this.callHook("beforeLeave"),
                    this.op = op,
                    this.cb = cb,
                    addClass(this.el, this.leaveClass),
                    this.left = !1,
                    this.callHookWithCb("leave"),
                this.left || (this.cancel = this.hooks && this.hooks.leaveCancelled,
                this.op && !this.pendingJsCb && (this.justEntered ? this.leaveDone() : pushJob(this.leaveNextTick)))
            }
            ,
            p$1.leaveNextTick = function() {
                var type = this.getCssTransitionType(this.leaveClass);
                if (type) {
                    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
                    this.setupCssCb(event, this.leaveDone)
                } else
                    this.leaveDone()
            }
            ,
            p$1.leaveDone = function() {
                this.left = !0,
                    this.cancel = this.pendingJsCb = null,
                    this.op(),
                    removeClass(this.el, this.leaveClass),
                    this.callHook("afterLeave"),
                this.cb && this.cb(),
                    this.op = null
            }
            ,
            p$1.cancelPending = function() {
                this.op = this.cb = null;
                var hasPending = !1;
                this.pendingCssCb && (hasPending = !0,
                    off(this.el, this.pendingCssEvent, this.pendingCssCb),
                    this.pendingCssEvent = this.pendingCssCb = null),
                this.pendingJsCb && (hasPending = !0,
                    this.pendingJsCb.cancel(),
                    this.pendingJsCb = null),
                hasPending && (removeClass(this.el, this.enterClass),
                    removeClass(this.el, this.leaveClass)),
                this.cancel && (this.cancel.call(this.vm, this.el),
                    this.cancel = null)
            }
            ,
            p$1.callHook = function(type) {
                this.hooks && this.hooks[type] && this.hooks[type].call(this.vm, this.el)
            }
            ,
            p$1.callHookWithCb = function(type) {
                var hook = this.hooks && this.hooks[type];
                hook && (hook.length > 1 && (this.pendingJsCb = cancellable(this[type + "Done"])),
                    hook.call(this.vm, this.el, this.pendingJsCb))
            }
            ,
            p$1.getCssTransitionType = function(className) {
                if (!(!transitionEndEvent || document.hidden || this.hooks && this.hooks.css === !1 || isHidden(this.el))) {
                    var type = this.type || this.typeCache[className];
                    if (type)
                        return type;
                    var inlineStyles = this.el.style
                        , computedStyles = window.getComputedStyle(this.el)
                        , transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
                    if (transDuration && "0s" !== transDuration)
                        type = TYPE_TRANSITION;
                    else {
                        var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
                        animDuration && "0s" !== animDuration && (type = TYPE_ANIMATION)
                    }
                    return type && (this.typeCache[className] = type),
                        type
                }
            }
            ,
            p$1.setupCssCb = function(event, cb) {
                this.pendingCssEvent = event;
                var self = this
                    , el = this.el
                    , onEnd = this.pendingCssCb = function(e) {
                        e.target === el && (off(el, event, onEnd),
                            self.pendingCssEvent = self.pendingCssCb = null,
                        !self.pendingJsCb && cb && cb())
                    }
                    ;
                on(el, event, onEnd)
            }
        ;
        var transition$1 = {
            priority: TRANSITION,
            update: function(id, oldId) {
                var el = this.el
                    , hooks = resolveAsset(this.vm.$options, "transitions", id);
                id = id || "v",
                    oldId = oldId || "v",
                    el.__v_trans = new Transition(el,id,hooks,this.vm),
                    removeClass(el, oldId + "-transition"),
                    addClass(el, id + "-transition")
            }
        }
            , internalDirectives = {
            style: style,
            class: vClass,
            component: component,
            prop: propDef,
            transition: transition$1
        }
            , bindRE = /^v-bind:|^:/
            , onRE = /^v-on:|^@/
            , dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/
            , modifierRE = /\.[^\.]+/g
            , transitionRE = /^(v-bind:|:)?transition$/
            , DEFAULT_PRIORITY = 1e3
            , DEFAULT_TERMINAL_PRIORITY = 2e3;
        skip.terminal = !0;
        var specialCharRE = /[^\w\-:\.]/
            , compiler = Object.freeze({
            compile: compile,
            compileAndLinkProps: compileAndLinkProps,
            compileRoot: compileRoot,
            transclude: transclude,
            resolveSlots: resolveSlots
        })
            , eventRE = /^v-on:|^@/;
        Directive.prototype._bind = function() {
            var name = this.name
                , descriptor = this.descriptor;
            if (("cloak" !== name || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
                var attr = descriptor.attr || "v-" + name;
                this.el.removeAttribute(attr)
            }
            var def = descriptor.def;
            if ("function" == typeof def ? this.update = def : extend(this, def),
                    this._setupParams(),
                this.bind && this.bind(),
                    this._bound = !0,
                    this.literal)
                this.update && this.update(descriptor.raw);
            else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
                var dir = this;
                this.update ? this._update = function(val, oldVal) {
                    dir._locked || dir.update(val, oldVal)
                }
                    : this._update = noop$1;
                var preProcess = this._preProcess ? bind(this._preProcess, this) : null
                    , postProcess = this._postProcess ? bind(this._postProcess, this) : null
                    , watcher = this._watcher = new Watcher(this.vm,this.expression,this._update,{
                    filters: this.filters,
                    twoWay: this.twoWay,
                    deep: this.deep,
                    preProcess: preProcess,
                    postProcess: postProcess,
                    scope: this._scope
                });
                this.afterBind ? this.afterBind() : this.update && this.update(watcher.value)
            }
        }
            ,
            Directive.prototype._setupParams = function() {
                if (this.params) {
                    var params = this.params;
                    this.params = Object.create(null);
                    for (var key, val, mappedKey, i = params.length; i--; )
                        key = hyphenate(params[i]),
                            mappedKey = camelize(key),
                            val = getBindAttr(this.el, key),
                            null != val ? this._setupParamWatcher(mappedKey, val) : (val = getAttr(this.el, key),
                            null != val && (this.params[mappedKey] = "" === val || val))
                }
            }
            ,
            Directive.prototype._setupParamWatcher = function(key, expression) {
                var self = this
                    , called = !1
                    , unwatch = (this._scope || this.vm).$watch(expression, function(val, oldVal) {
                    if (self.params[key] = val,
                            called) {
                        var cb = self.paramWatchers && self.paramWatchers[key];
                        cb && cb.call(self, val, oldVal)
                    } else
                        called = !0
                }, {
                    immediate: !0,
                    user: !1
                });
                (this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch)
            }
            ,
            Directive.prototype._checkStatement = function() {
                var expression = this.expression;
                if (expression && this.acceptStatement && !isSimplePath(expression)) {
                    var fn = parseExpression$1(expression).get
                        , scope = this._scope || this.vm
                        , handler = function(e) {
                        scope.$event = e,
                            fn.call(scope, scope),
                            scope.$event = null
                    };
                    return this.filters && (handler = scope._applyFilters(handler, null, this.filters)),
                        this.update(handler),
                        !0
                }
            }
            ,
            Directive.prototype.set = function(value) {
                this.twoWay && this._withLock(function() {
                    this._watcher.set(value)
                })
            }
            ,
            Directive.prototype._withLock = function(fn) {
                var self = this;
                self._locked = !0,
                    fn.call(self),
                    nextTick(function() {
                        self._locked = !1
                    })
            }
            ,
            Directive.prototype.on = function(event, handler, useCapture) {
                on(this.el, event, handler, useCapture),
                    (this._listeners || (this._listeners = [])).push([event, handler])
            }
            ,
            Directive.prototype._teardown = function() {
                if (this._bound) {
                    this._bound = !1,
                    this.unbind && this.unbind(),
                    this._watcher && this._watcher.teardown();
                    var i, listeners = this._listeners;
                    if (listeners)
                        for (i = listeners.length; i--; )
                            off(this.el, listeners[i][0], listeners[i][1]);
                    var unwatchFns = this._paramUnwatchFns;
                    if (unwatchFns)
                        for (i = unwatchFns.length; i--; )
                            unwatchFns[i]();
                    this.vm = this.el = this._watcher = this._listeners = null
                }
            }
        ;
        var filterRE$1 = /[^|]\|[^|]/;
        initMixin(Vue),
            stateMixin(Vue),
            eventsMixin(Vue),
            lifecycleMixin(Vue),
            miscMixin(Vue),
            dataAPI(Vue),
            domAPI(Vue),
            eventsAPI(Vue),
            lifecycleAPI(Vue);
        var slot = {
            priority: SLOT,
            params: ["name"],
            bind: function() {
                var name = this.params.name || "default"
                    , content = this.vm._slotContents && this.vm._slotContents[name];
                content && content.hasChildNodes() ? this.compile(content.cloneNode(!0), this.vm._context, this.vm) : this.fallback()
            },
            compile: function(content, context, host) {
                if (content && context) {
                    if (this.el.hasChildNodes() && 1 === content.childNodes.length && 1 === content.childNodes[0].nodeType && content.childNodes[0].hasAttribute("v-if")) {
                        var elseBlock = document.createElement("template");
                        elseBlock.setAttribute("v-else", ""),
                            elseBlock.innerHTML = this.el.innerHTML,
                            elseBlock._context = this.vm,
                            content.appendChild(elseBlock)
                    }
                    var scope = host ? host._scope : this._scope;
                    this.unlink = context.$compile(content, host, scope, this._frag)
                }
                content ? replace(this.el, content) : remove(this.el)
            },
            fallback: function() {
                this.compile(extractContent(this.el, !0), this.vm)
            },
            unbind: function() {
                this.unlink && this.unlink()
            }
        }
            , partial = {
            priority: PARTIAL,
            params: ["name"],
            paramWatchers: {
                name: function(value) {
                    vIf.remove.call(this),
                    value && this.insert(value)
                }
            },
            bind: function() {
                this.anchor = createAnchor("v-partial"),
                    replace(this.el, this.anchor),
                    this.insert(this.params.name)
            },
            insert: function(id) {
                var partial = resolveAsset(this.vm.$options, "partials", id, !0);
                partial && (this.factory = new FragmentFactory(this.vm,partial),
                    vIf.insert.call(this))
            },
            unbind: function() {
                this.frag && this.frag.destroy()
            }
        }
            , elementDirectives = {
            slot: slot,
            partial: partial
        }
            , convertArray = vFor._postProcess
            , digitsRE = /(\d{3})(?=\d)/g
            , filters = {
            orderBy: orderBy,
            filterBy: filterBy,
            limitBy: limitBy,
            json: {
                read: function(value, indent) {
                    return "string" == typeof value ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2)
                },
                write: function(value) {
                    try {
                        return JSON.parse(value)
                    } catch (e) {
                        return value
                    }
                }
            },
            capitalize: function(value) {
                return value || 0 === value ? (value = value.toString(),
                value.charAt(0).toUpperCase() + value.slice(1)) : ""
            },
            uppercase: function(value) {
                return value || 0 === value ? value.toString().toUpperCase() : ""
            },
            lowercase: function(value) {
                return value || 0 === value ? value.toString().toLowerCase() : ""
            },
            currency: function(value, _currency, decimals) {
                if (value = parseFloat(value),
                    !isFinite(value) || !value && 0 !== value)
                    return "";
                _currency = null != _currency ? _currency : "$",
                    decimals = null != decimals ? decimals : 2;
                var stringified = Math.abs(value).toFixed(decimals)
                    , _int = decimals ? stringified.slice(0, -1 - decimals) : stringified
                    , i = _int.length % 3
                    , head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? "," : "") : ""
                    , _float = decimals ? stringified.slice(-1 - decimals) : ""
                    , sign = value < 0 ? "-" : "";
                return sign + _currency + head + _int.slice(i).replace(digitsRE, "$1,") + _float
            },
            pluralize: function(value) {
                var args = toArray(arguments, 1)
                    , length = args.length;
                if (length > 1) {
                    var index = value % 10 - 1;
                    return index in args ? args[index] : args[length - 1]
                }
                return args[0] + (1 === value ? "" : "s")
            },
            debounce: function(handler, delay) {
                if (handler)
                    return delay || (delay = 300),
                        _debounce(handler, delay)
            }
        };
        installGlobalAPI(Vue),
            Vue.version = "1.0.28",
            setTimeout(function() {
                config.devtools && devtools && devtools.emit("init", Vue)
            }, 0),
            module.exports = Vue
    }
        , {}],
    103: [function(require, module, exports) {
        var inserted = exports.cache = {};
        exports.insert = function(css) {
            if (!inserted[css]) {
                inserted[css] = !0;
                var elem = document.createElement("style");
                return elem.setAttribute("type", "text/css"),
                    "textContent"in elem ? elem.textContent = css : elem.styleSheet.cssText = css,
                    document.getElementsByTagName("head")[0].appendChild(elem),
                    elem
            }
        }
    }
        , {}],
    104: [function(require, module, exports) {
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert("a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,html,i,iframe,img,ins,kbd,label,legend,li,main,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:'';content:none}table{border-collapse:collapse;border-spacing:0}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn,em,i{font-style:italic}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}textarea{overflow:auto}optgroup{font-weight:700}.common-fixed-full{position:fixed}.common-absolute-full,.common-fixed-full{top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-absolute-full{position:absolute}.common-block-full{display:block;width:100%;height:100%}.common-center-cover{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover,.common-hover:hover{color:#7ad71f}.common-hover{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center{display:block;text-align:center}#app .text-highlight{font-weight:700}#app .text-transition{font-size:50em;line-height:1.2em;font-weight:700;margin-bottom:-.264em}#app .text-nav-infos{font-size:20em;font-weight:400}#app .text-simple{font-size:50em;line-height:1.2em;font-weight:700}#app .text-regular{font-size:30em;line-height:1.33em;font-weight:400}#app .text-normal{font-size:25em;line-height:1.4em;font-weight:700}#app .text-medium{font-size:25em;line-height:1.6em;font-weight:500}#app .text-small{font-size:18em;line-height:1.38em;font-weight:400}#app .text-expertise,#app .text-title,#app .text-title-highlight{font-size:50em;line-height:1.2em;font-weight:700}#app .text-lines{font-size:25em;line-height:1.6em;font-weight:700}#app .text-item-mobile-title,#app .text-item-title{font-size:25em;line-height:1.6em;font-weight:700;margin-bottom:.48em}#app .text-item-mobile-sub,#app .text-item-sub{font-size:18em;line-height:normal;font-weight:400}#app .text-credit-title{font-size:30em;line-height:2em;font-weight:700}#app .text-credit{font-size:30em;line-height:1.33em;font-weight:400;opacity:.5}#app .popin-title{font-size:18em;font-weight:400}#app.is-mobile .text-transition{font-size:20em}#app.is-mobile .text-simple{font-size:16em}#app.is-mobile .text-regular{font-size:15em}#app.is-mobile .text-normal{font-size:13em;font-weight:400}#app.is-mobile .text-medium,#app.is-mobile .text-small{font-size:13em}#app.is-mobile .text-expertise,#app.is-mobile .text-title,#app.is-mobile .text-title-highlight{font-size:20em}#app.is-mobile .text-lines{font-size:13em;font-weight:400}#app.is-mobile .text-item-mobile-title,#app.is-mobile .text-item-title{font-size:15em;margin-bottom:0}#app.is-mobile .text-item-mobile-sub,#app.is-mobile .text-item-sub{font-size:13em}#app.is-mobile .text-case-title{font-size:15em;line-height:inherit}#app.is-mobile .text-case-title-info{font-size:12em;line-height:inherit}#app.is-mobile .text-credit,#app.is-mobile .text-credit-title{font-size:15em}#app.is-mobile .popin-title{font-size:20em;font-weight:700}#app.is-mobile .popin-subtitle{font-size:13em;line-height:1.3em;opacity:.5}#app .text-highlight,#app .text-link,#app .text-title-highlight,#app a.text-link,#app a:hover.text-link,#app a:visited.text-link{color:#7ad71f}#app .text-expertise,#app .text-item-title,#app .text-lines,#app .text-medium,#app .text-nav-infos,#app .text-normal,#app .text-simple,#app .text-small,#app .text-title,#app .text-transition{color:#fff}#app .text-item-mobile-sub,#app .text-item-sub{color:#606267}#app .popin-mobile .text-highlight,#app .popin-mobile .text-link,#app .popin-mobile .text-title-highlight,#app .popin-mobile a.text-link,#app .popin-mobile a:hover.text-link,#app .popin-mobile a:visited.text-link,#app .popin .text-highlight,#app .popin .text-link,#app .popin .text-title-highlight,#app .popin a.text-link,#app .popin a:hover.text-link,#app .popin a:visited.text-link,#app.theme-light .popin-mobile .text-highlight,#app.theme-light .popin-mobile .text-link,#app.theme-light .popin-mobile .text-title-highlight,#app.theme-light .popin-mobile a.text-link,#app.theme-light .popin-mobile a:hover.text-link,#app.theme-light .popin-mobile a:visited.text-link,#app.theme-light .popin .text-highlight,#app.theme-light .popin .text-link,#app.theme-light .popin .text-title-highlight,#app.theme-light .popin a.text-link,#app.theme-light .popin a:hover.text-link,#app.theme-light .popin a:visited.text-link,#app.theme-light .text-highlight,#app.theme-light .text-link,#app.theme-light .text-title-highlight,#app.theme-light a.text-link,#app.theme-light a:hover.text-link,#app.theme-light a:visited.text-link{color:#71777b}#app .popin-mobile .popin-subtitle,#app .popin-mobile .popin-title,#app .popin-mobile .text-case-title,#app .popin-mobile .text-case-title-info,#app .popin-mobile .text-expertise,#app .popin-mobile .text-item-title,#app .popin-mobile .text-lines,#app .popin-mobile .text-medium,#app .popin-mobile .text-normal,#app .popin-mobile .text-regular,#app .popin-mobile .text-simple,#app .popin-mobile .text-small,#app .popin-mobile .text-title,#app .popin-mobile .text-transition,#app .popin .popin-subtitle,#app .popin .popin-title,#app .popin .text-case-title,#app .popin .text-case-title-info,#app .popin .text-expertise,#app .popin .text-item-title,#app .popin .text-lines,#app .popin .text-medium,#app .popin .text-normal,#app .popin .text-regular,#app .popin .text-simple,#app .popin .text-small,#app .popin .text-title,#app .popin .text-transition,#app.theme-light .popin-mobile .popin-subtitle,#app.theme-light .popin-mobile .popin-title,#app.theme-light .popin-mobile .text-case-title,#app.theme-light .popin-mobile .text-case-title-info,#app.theme-light .popin-mobile .text-expertise,#app.theme-light .popin-mobile .text-item-title,#app.theme-light .popin-mobile .text-lines,#app.theme-light .popin-mobile .text-medium,#app.theme-light .popin-mobile .text-normal,#app.theme-light .popin-mobile .text-regular,#app.theme-light .popin-mobile .text-simple,#app.theme-light .popin-mobile .text-small,#app.theme-light .popin-mobile .text-title,#app.theme-light .popin-mobile .text-transition,#app.theme-light .popin-subtitle,#app.theme-light .popin-title,#app.theme-light .popin .popin-subtitle,#app.theme-light .popin .popin-title,#app.theme-light .popin .text-case-title,#app.theme-light .popin .text-case-title-info,#app.theme-light .popin .text-expertise,#app.theme-light .popin .text-item-title,#app.theme-light .popin .text-lines,#app.theme-light .popin .text-medium,#app.theme-light .popin .text-normal,#app.theme-light .popin .text-regular,#app.theme-light .popin .text-simple,#app.theme-light .popin .text-small,#app.theme-light .popin .text-title,#app.theme-light .popin .text-transition,#app.theme-light .text-case-title,#app.theme-light .text-case-title-info,#app.theme-light .text-expertise,#app.theme-light .text-item-title,#app.theme-light .text-lines,#app.theme-light .text-medium,#app.theme-light .text-normal,#app.theme-light .text-regular,#app.theme-light .text-simple,#app.theme-light .text-small,#app.theme-light .text-title,#app.theme-light .text-transition{color:#37383a}#app .popin-mobile .text-nav-infos,#app .popin .text-nav-infos,#app.theme-light .popin-mobile .text-nav-infos,#app.theme-light .popin .text-nav-infos,#app.theme-light .text-nav-infos{color:#000}button,input,label,select,textarea{margin:0;border:0;padding:0;display:inline-block;vertical-align:middle;white-space:normal;background:none;line-height:1;font-size:13px;font-family:Arial}input:focus{outline:0}input,textarea{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}button,input[type=button],input[type=checkbox],input[type=radio],input[type=reset],input[type=submit],select{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}input[type=checkbox],input[type=radio]{width:13px;height:13px}input[type=search]{-webkit-appearance:textfield;-webkit-box-sizing:content-box}::-webkit-search-decoration{display:none}button,input[type=button],input[type=reset],input[type=submit]{overflow:visible;width:auto}::-webkit-file-upload-button{padding:0;border:0;background:none}textarea{overflow:auto}select[multiple],textarea{vertical-align:top}*{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}div[v-cloak]{display:none}body,html{position:absolute;top:0;right:0;bottom:0;left:0;width:100%;height:100%;overflow:hidden;-webkit-overflow-scrolling:touch}#app.shape-light{background-color:#fff}#app{height:100%;overflow:hidden;font-family:Raleway,sans-serif;color:#fff;background-color:#151516}#app .text-highlight{color:#7ad71f}#app .line-through{text-decoration:line-through}#app a,#app input,#app p{font-family:Raleway,sans-serif}#app .debug{color:#fff}#app .debug a,#app .debug input,#app .debug p{font-family:Arial,sans-serif}#app .dg.ac{opacity:.2;-webkit-transition:opacity .5s;transition:opacity .5s;z-index:50!important;top:60px!important}#app .dg.ac:hover{opacity:1}#app .rs-template-manifesto .text-normal span{opacity:1;-webkit-transition:opacity .1s .1s;transition:opacity .1s .1s}#app .rs-template-manifesto .text-normal span.topline{opacity:.25;-webkit-transition:opacity .1s .1s;transition:opacity .1s .1s}#app.is-mobile .rs-template-manifesto .text-normal span.topline{opacity:1;-webkit-transition:opacity 0s 0s;transition:opacity 0s 0s}#app .rs-template.rs-template-case .text-regular a{font-weight:400;color:#37383a}#app .rs-template.rs-template-case.fia .text-highlight{color:#d3b16e}#app .rs-template.rs-template-case.maif .text-highlight{color:#e51106}#app .rs-template.rs-template-case.bpi .slider-auto .slider-item h3{height:8vh;padding-top:15vh;line-height:1.5em}#app .rs-template.rs-template-case.bpi .slider-auto .slider-item p{padding:9vh 0 46vh}#app .rs-template.rs-template-case.bpi .slider-auto .slider-item p .dark{color:#5e5f64;line-height:1.5em}#app .rs-template.rs-template-case.bpi .slider-auto .slider-item p .dark strong{color:#000}#app.is-mobile .rs-template.rs-template-case.bpi .video-cta+.block-grey{margin-top:0}.page-switch-transition{-webkit-transition:opacity .2s;transition:opacity .2s}.page-switch-enter,.page-switch-leave{opacity:0}#app.is-mobile header .shapes{opacity:0;-webkit-transition:all .5s cubic-bezier(.79,0,.24,1) .25s;transition:all .5s cubic-bezier(.79,0,.24,1) .25s}#app.is-mobile header .shapes .svg-shapes{stroke:#ebeded}#app.is-mobile header .shapes .svg-shapes,#app.is-mobile header .shapes .svg-shapes-color{-webkit-transition:all 0s cubic-bezier(.79,0,.24,1) 0s;transition:all 0s cubic-bezier(.79,0,.24,1) 0s}#app.is-mobile header .shapes .svg-shapes-color{opacity:0}#app.is-mobile header.opened{opacity:1;-webkit-transition:all .5s cubic-bezier(.79,0,.24,1) .25s;transition:all .5s cubic-bezier(.79,0,.24,1) .25s}#app.fbapp{width:100%}#app.fbapp header{padding:0!important}#app.fbapp header .nav-burger{top:29px!important;right:35px!important;padding:19px!important}#app.fbapp header .nav-burger,#app.fbapp header .nav-burger:before{width:54px!important;height:54px!important}#app.fbapp header .nav-burger .button-open-close{width:16px!important;height:16px!important}#app.fbapp header nav a.logo{top:30px;left:48px}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _typeof2 = require("babel-runtime/helpers/typeof")
            , _typeof3 = _interopRequireDefault(_typeof2)
            , _stringify = require("babel-runtime/core-js/json/stringify")
            , _stringify2 = _interopRequireDefault(_stringify)
            , _MainNav = require("./components/MainNav.vue")
            , _MainNav2 = _interopRequireDefault(_MainNav)
            , _Loader = require("./components/Loader.vue")
            , _Loader2 = _interopRequireDefault(_Loader)
            , _PopinPreview = require("./components/PopinPreview.vue")
            , _PopinPreview2 = _interopRequireDefault(_PopinPreview)
            , _YoutubeOverlay = require("./components/YoutubeOverlay.vue")
            , _YoutubeOverlay2 = _interopRequireDefault(_YoutubeOverlay)
            , _scrollManager = require("./scripts/scrollManager")
            , _scrollManager2 = _interopRequireDefault(_scrollManager)
            , _Timer = require("./scripts/threeTools/Timer")
            , _Timer2 = _interopRequireDefault(_Timer);
        exports.default = {
            data: function() {
                return {
                    fps: 0,
                    mouse: {
                        x: 0,
                        y: 0,
                        out: !1,
                        delta: 0,
                        down: !1
                    },
                    size: {
                        w: 0,
                        h: 0
                    },
                    UILightFlag: !1,
                    BGLightFlag: !1,
                    subNavOpened: !1,
                    mobileNavOpened: !1,
                    data: null,
                    dataPopin: null,
                    wordingData: null,
                    isLoading: !1,
                    isFirstLoading: !0,
                    server: null,
                    debug: null,
                    lastScrollID: null,
                    touchDevice: !1,
                    smoothScroll: 0,
                    scrollSpeed: .08,
                    scrollEase: .9,
                    isMobile: !1,
                    fontSize: 0,
                    lang: null,
                    url: window.location.href,
                    titleEn: "Reputation Squad, the augmented influence agency",
                    titleFr: "Reputation Squad, l'influence augmentée",
                    descEn: "We craft digitally enhanced solutions designed to win conversations.",
                    descFr: "Créer des solutions digitales conçues pour remporter la bataille des conversations."
                }
            },
            computed: {
                scrollCustom: function() {
                    return !this.isMobile && !this.touchDevice
                },
                isMobile: function() {
                    return this.$root.size.w < 769
                },
                fontSize: function() {
                    return this.isMobile ? this.$root.size.w / 320 : this.$root.size.w / 1920
                },
                themeLight: function() {
                    return this.UILightFlag && !this.isLoading
                },
                shapeLight: function() {
                    return this.BGLightFlag && !this.isLoading || this.themeLight
                },
                prefixURL: function() {
                    return "en" === this.lang ? "" : "/fr"
                }
            },
            created: function() {
                this.server = this.getServer(),
                    this.debug = this.isDebugMode(),
                    this.langDetect()
            },
            ready: function() {
                window.onresize = this.onResize,
                    this.onResize(),
                    this.fpsList = [];
                var timer = new _Timer2.default;
                timer.onTimer = this.onEnterFrame,
                    timer.start(70),
                    document.onmousemove = this.onMouseMove,
                    window.onmouseleave = this.onMouseLeave,
                    document.onmouseout = this.onMouseLeave,
                    document.onmouseup = this.onMouseUp,
                    document.onmousedown = this.onMouseDown,
                    document.addEventListener("touchend", this.onTouchEnd),
                    document.addEventListener("touchstart", this.onTouchStart),
                    this.scrollCustom = !this.isMobile,
                    this.scrollManager = new _scrollManager2.default,
                    this.scrollManager.listen(this.onScrollHandler.bind(this), this.onTouchHorizontal.bind(this)),
                    this.scrollManager.preventEvents = this.scrollCustom,
                    setTimeout(function() {
                        this.isFirstLoading && !this.isLoading && (this.isFirstLoading = !1)
                    }
                        .bind(this), 500)
            },
            methods: {
                getServer: function() {
                    var host = window.location.hostname
                        , hostFirstDot = host.substr(0, host.indexOf("."));
                    return "localhost" == host || "192" == hostFirstDot ? "dev" : "rs-1606-website" == hostFirstDot ? "preview" : "prod"
                },
                isDebugMode: function() {
                    var urlParams = this.$route.query;
                    return "prod" != this.server && (urlParams && urlParams.debug ? 1 == urlParams.debug : "dev" == this.server || "preview" == this.server)
                },
                langDetect: function() {
                    var lang = this.$route.path.split("/")[1];
                    switch (lang) {
                        case "fr":
                            this.lang = "fr";
                            break;
                        default:
                            this.lang = "en"
                    }
                },
                onGetData: function(data) {
                    this.data = data,
                        this.wordingData = this.data["global-wording"]
                },
                preloadAssets: function(data) {
                    var assets = this.getAssetInNode(data, 0);
                    this.$dispatch("onLoadRequest", assets)
                },
                getAssetInNode: function(node, level) {
                    for (var value, childAssets, assets = [], offsetString = "", i = 0; i < level; i++)
                        offsetString += " ";
                    for (var key in node) {
                        if (value = node[key],
                            "pic" !== key && "box-pic" !== key && "mesh" !== key || assets.push(value),
                            "pics" === key && (assets = assets.concat(value)),
                            "popin" === key) {
                            var popinData, popins = JSON.parse((0,
                                _stringify2.default)(this.$data.data)).popins;
                            popins.map(function(popin) {
                                popin.url === value && (popinData = popin)
                            }),
                            popinData && (childAssets = this.getAssetInNode(popinData, level + 1),
                                assets = assets.concat(childAssets))
                        }
                        "object" === ("undefined" == typeof value ? "undefined" : (0,
                            _typeof3.default)(value)) && (childAssets = this.getAssetInNode(value, level + 1),
                            assets = assets.concat(childAssets))
                    }
                    return assets
                },
                getLoadedAsset: function(url) {
                    var loader = this.$get("$refs.loader")
                        , asset = loader.getLoadedAsset(url);
                    return asset
                },
                onResize: function() {
                    this.$set("size.w", window.innerWidth),
                        this.$set("size.h", window.innerHeight),
                        this.$broadcast("onResize")
                },
                onEnterFrame: function(ratioDeltaTime, deltaTime, currentTime) {
                    this.fpsList.push(1e3 / deltaTime),
                    this.fpsList.length >= 30 && (this.fps = Math.round(this.avgArray(this.fpsList)),
                        this.fpsList = []),
                        this.$broadcast("onEnterFrame", ratioDeltaTime, deltaTime, currentTime),
                    Math.abs(this.smoothScroll) > 1 && (this.smoothScroll *= this.scrollEase,
                        this.$broadcast("onSmoothScroll", this.smoothScroll))
                },
                onMouseMove: function(e) {
                    this.mouse.x = 2 * (e.clientX / window.innerWidth - .5),
                        this.mouse.y = 2 * (e.clientY / window.innerHeight - .5),
                        this.mouse.out = !1,
                        this.$broadcast("onMouseMove", e)
                },
                onMouseLeave: function(e) {
                    e.relatedTarget || e.toElement || (this.mouse.out = !0,
                        this.$broadcast("onMouseLeave"))
                },
                onMouseUp: function(e) {
                    this.mouse.down = !1,
                        this.$broadcast("onMouseUp")
                },
                onMouseDown: function(e) {
                    if (this.mouse.down = !0,
                            this.$broadcast("onMouseDown"),
                        "INPUT" != e.target.nodeName)
                        return e.stopPropagation && e.stopPropagation(),
                        e.preventDefault && e.preventDefault(),
                            e.cancelBubble = !0,
                            e.returnValue = !1,
                            e.cancelBubble = !0,
                            e.returnValue = !1,
                            !1
                },
                onTouchStart: function() {
                    this.mouse.down = !0,
                        this.$broadcast("onMouseDown")
                },
                onTouchEnd: function() {
                    this.mouse.down = !1,
                        this.$broadcast("onMouseUp")
                },
                onScrollHandler: function(delta, swipe, scrollID, isTouch) {
                    var clampDelta = delta;
                    isTouch || (clampDelta = clampDelta / 120 * (100 * this.scrollSpeed)),
                        this.touchDevice = isTouch,
                    this.isLoading || (this.$broadcast("onRawWheel", clampDelta, null),
                        this.smoothScroll += clampDelta),
                    swipe && scrollID != this.lastScrollID && this.$broadcast("onWheelSwipe", clampDelta),
                    this.lastScrollID != scrollID && (this.$broadcast("onNewScroll", clampDelta),
                        this.lastScrollID = scrollID),
                        this.mouse.delta = Math.round(clampDelta)
                },
                onTouchHorizontal: function(delta, swipe, scrollID, isTouch) {
                    this.$broadcast("onScrollHorizontal", delta)
                },
                avgArray: function(array) {
                    var total = 0;
                    return array.map(function(el, index) {
                        total += el
                    }),
                    total / array.length
                },
                changeMetas: function() {
                    var self = this;
                    this.url = window.location.href,
                        self.$emit("updateHead")
                },
                alternateUrl: function(lang) {
                    return "fr" === lang ? "https://www.reputationsquad.com/fr" : "https://www.reputationsquad.com/"
                },
                isFacebookApp: function() {
                    var ua = navigator.userAgent || navigator.vendor || window.opera;
                    return ua.indexOf("FBAN") > -1 || ua.indexOf("FBAV") > -1
                }
            },
            events: {
                onLoadRequest: function(url, vueID) {
                    this.$broadcast("onLoadRequest", url, vueID),
                        this.$set("isLoading", !0)
                },
                onLoadComplete: function() {
                    this.$broadcast("onLoadComplete")
                },
                onLoadProgress: function(progress) {
                    this.$broadcast("onLoadProgress", progress)
                },
                onLoadSmoothProgress: function(progress) {
                    this.$broadcast("onLoadSmoothProgress", progress)
                },
                onLoadAlready: function() {
                    this.$set("isLoading", !1),
                        this.$broadcast("onLoadAlready")
                },
                onLoadAnimStart: function() {
                    this.$set("isLoading", !0),
                        this.$broadcast("onLoadAnimStart")
                },
                onLoadAnimStop: function() {
                    this.$set("isLoading", !1),
                        this.$set("isFirstLoading", !1),
                        this.$broadcast("onLoadAnimStop")
                },
                onShapeFillRequest: function() {
                    this.$broadcast("onShapeFillRequest")
                },
                onOpenMobileNav: function() {
                    this.mobileNavOpened = !0
                },
                onCloseMobileNav: function() {
                    this.mobileNavOpened = !1
                },
                onOpenSubNav: function() {
                    this.subNavOpened = !0
                },
                onCloseSubNav: function() {
                    this.subNavOpened = !1
                },
                onPlayVideo: function(videoID) {
                    this.$broadcast("onPlayVideo", videoID)
                },
                onCloseVideo: function() {
                    this.$broadcast("onCloseVideo")
                },
                popinPreviewShow: function(urlPic) {
                    this.$broadcast("popinPreviewShow", urlPic)
                },
                popinPreviewHide: function() {
                    this.$broadcast("popinPreviewHide")
                },
                onEnterSplashScreen: function() {
                    this.$broadcast("startShapeInteract")
                },
                onLeaveSplashScreen: function() {
                    this.$broadcast("stopShapeInteract")
                }
            },
            components: {
                loader: _Loader2.default,
                "main-nav": _MainNav2.default,
                "popin-preview": _PopinPreview2.default,
                "youtube-overlay": _YoutubeOverlay2.default
            },
            watch: {
                lang: function(value) {
                    "en" !== value && "fr" !== value || (this.$http.get("/data/data-" + value + ".json").then(function(response) {
                        this.onGetData(response.data)
                    }, function(error) {
                        console.log(error)
                    }),
                        document.documentElement.lang = this.lang)
                },
                scrollCustom: function(value) {
                    this.scrollManager.preventEvents = value
                },
                "$route.path": function(value) {
                    this.langDetect(),
                        this.changeMetas()
                }
            },
            head: {
                title: function() {
                    return "en" === this.lang ? {
                        inner: this.titleEn,
                        separator: " ",
                        complement: " "
                    } : {
                        inner: this.titleFr,
                        separator: " ",
                        complement: " "
                    }
                },
                meta: function() {
                    return "en" === this.lang ? [{
                        name: "description",
                        content: this.descEn,
                        id: "desc"
                    }, {
                        name: "og:description",
                        content: this.descEn,
                        id: "ogdesc"
                    }, {
                        name: "twitter:title",
                        content: this.titleEn,
                        id: "twtitle"
                    }, {
                        name: "twitter:description",
                        content: this.descEn,
                        id: "twdesc"
                    }] : [{
                        name: "description",
                        content: this.descFr,
                        id: "desc"
                    }, {
                        name: "og:description",
                        content: this.descFr,
                        id: "ogdesc"
                    }, {
                        name: "twitter:title",
                        content: this.titleFr,
                        id: "twtitle"
                    }, {
                        name: "twitter:description",
                        content: this.descFr,
                        id: "twdesc"
                    }]
                },
                link: function() {
                    return [{
                        rel: "canonical",
                        h: this.url,
                        id: "canonical"
                    }, {
                        rel: "alternate",
                        h: this.alternateUrl("en"),
                        id: "alternateen"
                    }, {
                        rel: "alternate",
                        h: this.alternateUrl("fr"),
                        id: "alternatefr"
                    }]
                }
            }
        },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = "<div v-cloak=\"\" :class=\"{'theme-light':themeLight, 'shape-light':shapeLight, 'is-mobile':isMobile, 'fbapp':this.isFacebookApp()}\" :style=\"{'font-size':fontSize+'px'}\"><appdebug :fps=fps :mouse=mouse v-if=debug></appdebug><shapes></shapes><popin v-if=dataPopin v-show=!isLoading :class=\"{'mobile-nav-opened':mobileNavOpened}\" :data=dataPopin></popin><popin-preview></popin-preview><router-view class=page-content :class=\"{'loading':isLoading}\" v-if=data></router-view><main-nav v-show=\"data &amp;&amp; !subNavOpened &amp;&amp; !isFirstLoading\"></main-nav><loader v-show=isLoading v-ref:loader=\"\"></loader><youtube-overlay></youtube-overlay><glitch></glitch></div>"
    }
        , {
            "./components/Loader.vue": 110,
            "./components/MainNav.vue": 111,
            "./components/PopinPreview.vue": 118,
            "./components/YoutubeOverlay.vue": 126,
            "./scripts/scrollManager": 130,
            "./scripts/threeTools/Timer": 131,
            "babel-runtime/core-js/json/stringify": 3,
            "babel-runtime/helpers/typeof": 6,
            "vueify/lib/insert-css": 103
        }],
    105: [function(require, module, exports) {
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert("#app .appdebug[_v-7b3b4962]{background-color:rgba(0,0,0,.2);position:fixed;top:100em;left:50em;z-index:100}#app .appdebug a[_v-7b3b4962],#app .appdebug input[_v-7b3b4962],#app .appdebug p[_v-7b3b4962]{font-family:Arial,sans-serif;font-size:10px}#app .appdebug .wheel-stats[_v-7b3b4962]{width:100px;height:100px}#app.is-mobile .appdebug[_v-7b3b4962]{top:70em;left:40em}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }),
            exports.default = {
                data: function() {
                    return {}
                },
                props: {
                    fps: 0,
                    mouse: {
                        x: 0,
                        y: 0,
                        out: !1,
                        delta: 0
                    }
                },
                ready: function() {
                    this.fpsList = [],
                        this.ctx = this.$el.querySelectorAll(".wheel-stats")[0].getContext("2d"),
                        this.ctx.canvas.width = this.ctx.canvas.offsetWidth,
                        this.ctx.canvas.height = this.ctx.canvas.offsetHeight
                },
                methods: {
                    drawStats: function(ctx, value, valueMax, scroll, color, size) {
                        var w = ctx.canvas.width
                            , h = ctx.canvas.height
                            , hh = .5 * h
                            , r = -value / valueMax
                            , data = ctx.getImageData(0, 0, w, h);
                        scroll && (ctx.canvas.width = ctx.canvas.width,
                            ctx.putImageData(data, -1, 0)),
                            ctx.fillStyle = color || "#ff0000",
                            ctx.fillRect(w - 1, r * hh + hh - (size ? .5 * size : 0), 1, size ? size : 1),
                            ctx.fillStyle = "#0000ff",
                            ctx.fillRect(w - 1, hh, 1, 1)
                    }
                },
                events: {
                    onEnterFrame: function(ratioDeltaTime, deltaTime, currentTime) {
                        this.drawStats(this.ctx, 1e3 / deltaTime, 70, !0, "#ff0000"),
                            this.drawStats(this.ctx, this.mouse.delta, 350, !1, "#00ff00")
                    },
                    onWheelCheck: function() {
                        this.drawStats(this.ctx, 0, 350, !1, "rgba(0,0,0,0.3)", 500)
                    },
                    onWheelStart: function() {
                        this.drawStats(this.ctx, 0, 350, !1, "rgba(255,0,0,1)", 500)
                    },
                    onWheelSwipe: function(maxDelta) {
                        this.drawStats(this.ctx, maxDelta, 350, !1, "#00f0f0", 500)
                    }
                }
            },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = '<div class="appdebug debug" _v-7b3b4962=""><p class=fps _v-7b3b4962="">{{fps}} FPS</p><canvas class=wheel-stats _v-7b3b4962=""></canvas><div v-if=!$root.isMobile _v-7b3b4962=""><p class=mouse _v-7b3b4962="">{{mouse.out ? \' -- \' : Math.round(mouse.x * 100)/100}} : {{mouse.out ? \' -- \' : Math.round(mouse.y * 100)/100}}<p class=mouse-down v-show=mouse.down _v-7b3b4962="">DOWN<p class=wheel v-show="mouse.delta != 0" _v-7b3b4962="">{{mouse.delta}}<p _v-7b3b4962="">scroll speed</p><input class=scroll-speed type=text v-model=$root.scrollSpeed placeholder="scroll speed" _v-7b3b4962="">scroll speed<p _v-7b3b4962="">scroll ease</p><input class=scroll-ease type=text v-model=$root.scrollEase placeholder="scroll ease" _v-7b3b4962=""></div></div>'
    }
        , {
            "vueify/lib/insert-css": 103
        }],
    106: [function(require, module, exports) {
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full[_v-55a204c1]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-absolute-full[_v-55a204c1]{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full[_v-55a204c1]{display:block;width:100%;height:100%}.common-center-cover[_v-55a204c1]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover[_v-55a204c1],.common-hover[_v-55a204c1]:hover{color:#7ad71f}.common-hover[_v-55a204c1]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-55a204c1]{display:block;text-align:center}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }),
            exports.default = {
                filters: {
                    "clock-time": function(value) {
                        return this.d && 0 !== value ? (this.d.setTime(value),
                            this.d.toLocaleTimeString("fr" == this.$root.lang ? "fr-FR" : "en-GB")) : "--:--:--"
                    }
                },
                data: function() {
                    return {
                        time: 0
                    }
                },
                props: ["zone"],
                computed: {},
                ready: function() {
                    var params;
                    switch (this.zone) {
                        case "paris":
                            params = {
                                tz: "Europe/Paris"
                            };
                            break;
                        case "london":
                            params = {
                                tz: "Europe/London"
                            }
                    }
                    this.d = new Date,
                        this.$http.post("/assets/rs-time.php", params, {
                            emulateJSON: !0
                        }).then(function(response) {
                            var serverTime = response.data.slice(0, -6);
                            this.time = Date.parse(serverTime)
                        }, function(error) {
                            console.log(error)
                        })
                },
                attached: function() {},
                methods: {},
                events: {
                    onEnterFrame: function(ratioDeltaTime, deltaTime, currentTime) {
                        0 !== this.time && (this.time += deltaTime)
                    }
                }
            },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = '<span _v-55a204c1="">{{time | clock-time}}</span>'
    }
        , {
            "vueify/lib/insert-css": 103
        }],
    107: [function(require, module, exports) {
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert('#app .cover[_v-035d7fea],.common-fixed-full[_v-035d7fea]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app .cover .picture-mask[_v-035d7fea],#app .cover .picture-shape[_v-035d7fea],.common-absolute-full[_v-035d7fea]{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app .cover .picture[_v-035d7fea],.common-block-full[_v-035d7fea]{display:block;width:100%;height:100%}#app .cover .picture-cover[_v-035d7fea],.common-center-cover[_v-035d7fea]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover[_v-035d7fea],.common-hover[_v-035d7fea]:hover{color:#7ad71f}.common-hover[_v-035d7fea]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-035d7fea]{display:block;text-align:center}#app .cover[_v-035d7fea]{z-index:2;pointer-events:none}#app .cover .title[_v-035d7fea]{position:absolute;display:block;bottom:50%;font-size:300em;line-height:normal;margin-bottom:-.235em;margin-left:0;opacity:1;text-transform:lowercase;font-weight:700;text-align:right;z-index:1;-webkit-transition:opacity .5s 0s,margin-left .5s 0s;transition:opacity .5s 0s,margin-left .5s 0s}#app .cover .picture-cover[_v-035d7fea]{opacity:1;-webkit-transition:opacity .2s 0s;transition:opacity .2s 0s}#app .cover .picture-mask[_v-035d7fea]{background-color:#000;opacity:.15;-webkit-transition:opacity .2s 0s;transition:opacity .2s 0s}#app .cover .picture-shape[_v-035d7fea]{opacity:1;-webkit-transition:opacity 1.5s .5s;transition:opacity 1.5s .5s;-webkit-transform:translateZ(0);transform:translateZ(0)}#app .cover .picture-shape.sub-nav[_v-035d7fea]{opacity:0;-webkit-transition:opacity 0s 0s;transition:opacity 0s 0s}#app .cover .picture-wrapper[_v-035d7fea]{-webkit-clip-path:url(#shapes-clipping);clip-path:url(#shapes-clipping)}#app .cover .transition-block[_v-035d7fea]{position:absolute;top:0;bottom:0;left:0;right:0;z-index:3;margin:0 auto;width:53%;height:50%;opacity:1;overflow:hidden}#app .cover .transition-block .text-transition[_v-035d7fea]{position:absolute;bottom:1px;-webkit-transition:bottom 1s cubic-bezier(.23,1,.32,1),opacity .8s;transition:bottom 1s cubic-bezier(.23,1,.32,1),opacity .8s;opacity:1}#app .cover .transition-block .text-transition.block-bottom[_v-035d7fea]{opacity:0;-webkit-transition:bottom 1s cubic-bezier(.23,1,.32,1),opacity .8s;transition:bottom 1s cubic-bezier(.23,1,.32,1),opacity .8s}#app .cover .transition-block .text-transition.block-top[_v-035d7fea]{-webkit-transition:bottom 2.5s cubic-bezier(.23,1,.32,1),opacity 2s;transition:bottom 2.5s cubic-bezier(.23,1,.32,1),opacity 2s;opacity:0;bottom:-200px}#app .cover .scroll-intro[_v-035d7fea]{position:absolute;bottom:15.625em;left:48%;font-size:16px;bottom:90px;width:100%;text-align:center;color:#7ad71f;opacity:0;-webkit-transition:opacity .5s;transition:opacity .5s;cursor:pointer;z-index:5}#app .cover .scroll-intro.show[_v-035d7fea]{opacity:1;-webkit-transition:opacity .5s 1.7s;transition:opacity .5s 1.7s;-webkit-animation:jump 2.8s infinite cubic-bezier(.215,.61,.355,1) 4s;animation:jump 2.8s infinite cubic-bezier(.215,.61,.355,1) 4s}#app .cover .scroll-intro.show[_v-035d7fea]:hover{-webkit-animation:none;animation:none;opacity:1}#app .cover .scroll-intro .scroll[_v-035d7fea]{position:relative;height:100px}#app .cover .scroll-intro .scroll div.top[_v-035d7fea]{position:absolute;left:0;top:20px;font-size:14px;color:#fff}#app .cover .scroll-intro .scroll div.top[_v-035d7fea]:after{display:block;content:"";width:10px;height:0;margin-left:17px;border-left:1px solid #fff;-webkit-animation-timing-function:cubic-bezier(1,.3,.3,1);animation-timing-function:cubic-bezier(1,.3,.3,1);-webkit-animation-duration:1.5s;animation-duration:1.5s;-webkit-animation-name:scroll;animation-name:scroll;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}#app .cover .scroll-intro .scroll div.bot[_v-035d7fea]{position:absolute;left:0;bottom:20px;font-size:14px;color:#fff}#app .cover .scroll-intro .scroll div.bot[_v-035d7fea]:after{display:block;content:"";width:10px;height:0;margin-left:17px;border-left:1px solid #fff;-webkit-animation-timing-function:cubic-bezier(1,.3,.3,1);animation-timing-function:cubic-bezier(1,.3,.3,1);-webkit-animation-duration:1.5s;animation-duration:1.5s;-webkit-animation-name:scrollInverse;animation-name:scrollInverse;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}#app .cover .scroll-intro .scroll div.text[_v-035d7fea]{position:absolute;left:0;bottom:0;font-size:14px;color:#fff;-webkit-animation-timing-function:cubic-bezier(1,.3,.3,1);animation-timing-function:cubic-bezier(1,.3,.3,1);-webkit-animation-duration:1.5s;animation-duration:1.5s;-webkit-animation-name:descenteText;animation-name:descenteText;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}#app .cover.init-intro .title[_v-035d7fea]{margin-left:50%;opacity:0;-webkit-transition:opacity 0s,margin-left 0s;transition:opacity 0s,margin-left 0s}#app .cover.init-intro .picture-cover[_v-035d7fea],#app .cover.init-intro .picture-shape[_v-035d7fea],#app .cover.init-intro .scroll-intro[_v-035d7fea]{opacity:0;-webkit-transition:opacity 0s 0s;transition:opacity 0s 0s}#app .cover.init-intro.no-fade .picture-cover[_v-035d7fea],#app .cover.init-intro.no-fade .picture-shape[_v-035d7fea],#app .cover.init-intro.no-fade .scroll-intro[_v-035d7fea]{opacity:1;-webkit-transition:opacity 0s 0s;transition:opacity 0s 0s}#app.is-mobile .cover .title[_v-035d7fea]{font-size:40em}#app.is-mobile .cover .transition-block[_v-035d7fea]{width:calc(100vw - 80px)}');
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _gsap = require("../../node_modules/gsap")
            , _gsap2 = _interopRequireDefault(_gsap);
        exports.default = {
            data: function() {
                return {
                    scale: 1,
                    tx: 0,
                    ty: 0,
                    introPercent: 0,
                    gyro: [],
                    gyro_o: 0,
                    gyro_x: 0,
                    gyro_y: 0,
                    movelock: !0,
                    ismouse: !1,
                    modx: 0,
                    mody: 0,
                    position_x: 0,
                    position_y: 0
                }
            },
            props: ["section", "init-intro", "no-fade"],
            computed: {
                titleLeft: function() {
                    var titleWidth = this.$el.querySelector(".title").offsetWidth;
                    return .6 * this.$root.size.w - this.smoothstep(0, .5, this.introPercent) * (.6 * this.$root.size.w + titleWidth)
                },
                scaleCover: function() {
                    return .1 * this.smoothstep(.6, .2, this.introPercent) + .9
                },
                opacityCover: function() {
                    return this.smoothstep(.6, .2, this.introPercent)
                },
                subNav: function() {
                    return this.$root.subNavOpened
                }
            },
            ready: function() {},
            attached: function() {},
            methods: {
                smoothstep: function(min, max, value) {
                    var x = Math.max(0, Math.min(1, (value - min) / (max - min)));
                    return x * x * (3 - 2 * x)
                },
                lerp: function(v0, v1, t) {
                    return v0 * (1 - t) + v1 * t
                }
            },
            watch: {
                introPercent: function(value) {
                    this.$dispatch("onIntroProgress", value)
                },
                initIntro: function(value) {
                    var masked = this.$el.querySelector(".picture-svg");
                    masked && (value ? _gsap2.default.to(masked, 0, {
                        scale: 1,
                        transformOrigin: "50% 50%"
                    }) : _gsap2.default.to(masked, 5, {
                        scale: 1.1,
                        transformOrigin: "50% 50%"
                    }))
                }
            },
            events: {
                onPageScroll: function(value) {
                    this.introPercent = Math.min(value / this.$root.size.h, 1)
                }
            },
            components: {}
        },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = '<div class=cover :class="{\'init-intro\':initIntro, \'no-fade\':noFade}" _v-035d7fea=""><h1 class=title :style="{\'left\':(titleLeft) + \'px\'}" _v-035d7fea="">{{{section.title}}}</h1><div class=picture :style="{\'transform\':\'scale(\'+scaleCover+\')\',\'opacity\':opacityCover}" _v-035d7fea=""><div class=picture-cover :style="{\'background-image\':\'url(\' + section.pic + \')\'}" _v-035d7fea=""></div><div class=picture-mask _v-035d7fea=""></div><svg class=picture-shape v-if=!$root.isMobile :class="{\'sub-nav\':subNav}" _v-035d7fea=""><g class=picture-wrapper x=0 y=0 width=100% height=100% _v-035d7fea=""><image class=picture-svg xlink:href={{section.pic}} x=0 y=0 width=100% height=100% preserveAspectRatio="xMidYMid slice" _v-035d7fea=""></image></g></svg></div><div class=scroll-intro :class="{\'show\':introPercent == 0}" _v-035d7fea=""><div class=scroll _v-035d7fea=""><div class=text _v-035d7fea="">{{{$root.data[\'global-wording\'][\'scroll\']}}}</div><div class=top _v-035d7fea=""></div><div class=bot _v-035d7fea=""></div></div></div><div class=transition-block _v-035d7fea=""><p class=text-transition :class="{\'block-bottom\':introPercent < 0.4,\'block-top\':introPercent >= 0.8 }" _v-035d7fea="">{{{section.transition}}}</div></div>'
    }
        , {
            "../../node_modules/gsap": 80,
            "vueify/lib/insert-css": 103
        }],
    108: [function(require, module, exports) {
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full[_v-39311392]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-absolute-full[_v-39311392]{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full[_v-39311392]{display:block;width:100%;height:100%}.common-center-cover[_v-39311392]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover[_v-39311392],.common-hover[_v-39311392]:hover{color:#7ad71f}.common-hover[_v-39311392]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-39311392]{display:block;text-align:center}.glitch-layer[_v-39311392]{position:absolute;top:0;right:0;bottom:0;left:0;z-index:5;overflow:hidden;pointer-events:none}.artefact[_v-39311392]{position:absolute;background-image:url(/assets/spritesheet.png);opacity:1;-webkit-transition:opacity .2s .3s;transition:opacity .2s .3s}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }),
            exports.default = {
                data: function() {
                    return {
                        isGlitching: !1,
                        artefacts: []
                    }
                },
                ready: function() {
                    this.spriteSize = 110;
                    for (var i = 0; i < 1; i++)
                        this.artefacts.push(this.generateartefact())
                },
                methods: {
                    generateartefact: function() {
                        return {
                            x: Math.random() * this.$root.size.w,
                            y: Math.random() * this.$root.size.h,
                            offset: 100 * -Math.round(3 * Math.random()) / 3,
                            size: 50 * Math.random() + 60
                        }
                    },
                    glitch: function() {
                        if (!this.isGlitching) {
                            var artefacts = [];
                            this.isGlitching = !0,
                                this.artefacts.map(function(el, index) {
                                    artefacts.push(this.generateartefact())
                                }
                                    .bind(this)),
                                this.artefacts = artefacts,
                                setTimeout(this.afterGlitch.bind(this), 200)
                        }
                    },
                    afterGlitch: function() {
                        this.isGlitching = !1
                    }
                },
                events: {
                    onNewScroll: "glitch"
                }
            },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = "<div class=glitch-layer v-show=isGlitching _v-39311392=\"\"><div class=artefact v-for=\"item in artefacts\" v-bind:style=\"{left:item.x + 'px',top:item.y + 'px',width:item.size + 'px',height:item.size + 'px', 'background-size':item.size*4+'px '+item.size+'px', 'background-position':item.offset+'% 0'}\" _v-39311392=\"\"></div></div>"
    }
        , {
            "vueify/lib/insert-css": 103
        }],
    109: [function(require, module, exports) {
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert('.common-fixed-full[_v-7d619fc2]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app .page-intro .debug-texts[_v-7d619fc2],.common-absolute-full[_v-7d619fc2]{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app .page-intro .line[_v-7d619fc2],.common-block-full[_v-7d619fc2]{display:block;width:100%;height:100%}.common-center-cover[_v-7d619fc2]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}#app .page-intro .text-link[_v-7d619fc2]:hover,#app .page-intro .wrapper-outro.show .text-link[_v-7d619fc2]:hover,#app .page-intro .wrapper-outro .text-link[_v-7d619fc2]:hover,.common-force-hover[_v-7d619fc2],.common-hover[_v-7d619fc2]:hover{color:#7ad71f}#app .page-intro .text-link[_v-7d619fc2],#app .page-intro .wrapper-outro.show .text-link[_v-7d619fc2],#app .page-intro .wrapper-outro .text-link[_v-7d619fc2],.common-hover[_v-7d619fc2]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-7d619fc2]{display:block;text-align:center}#app .page-intro[_v-7d619fc2]:after,.noise[_v-7d619fc2]:after{-webkit-animation:noise 5s steps(10) infinite;animation:noise 5s steps(10) infinite;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAgAElEQVR4Xm3d29FTRxOFYen+u8VBGHIwBIGDwM4ByME4CAgCOwfjIHAQ/PVO8ajWv4uvipK0DzM9fVi9umdL3F+/fv3077//3n755Zdbr69fv759+vTp9t9//93evn17+/XXX28fPnw4x16+fHnO9/ndu3e3/p4/f35eP378ePv999/P67Nnz87xL1++3P7666/bn3/+ee7rr/fN1fiN03Xd0/Fe7/f7OfbmzZvbzz//fPv7778f8zXeTz/9dMb5+vXruae5et94ziVbsr969erc63zXt4bG7n1raszPnz+fa7uuY44bL7k61zVd37/00utvv/125G7+Pr9///7M3bo71ljfvn079zaP462hc8nSdemn+e7fvn17alAK7ETvO8YIDdJg/XUTYyTIixcvjuIyZgJRVIpojBTWv953LIEzSGNbZPebr8UQtmv/+OOPx9hdkyxdb7Gc4dx0ux2DJl9jN1+Ka67+WlvnWl+G6S+FdJz8yZqxuq77W29jOd+96aJxkyFZVmfeN3ZjpZPmb8wM033N3X30ST+93p8/f/6UgnhwNycMBVFsA/fXOVZPYQnLuimrBeYNFpyCM1r3Z8Cu2Yjr2uZP4Bbagjv2zz//PIzXWCmk+1ICpfH0xu2+xvbP58bs3sbg1SK4Y2RuDcnZWP2J7uZrzZyu9x1jzMZKH3RARseag+4ybtf1OfmSJ/1Ape65v3nz5qlJuijIScEmbcFCDKSAqCbuPHjrOpFjwQmeV3Qu43VP5zresf4YqOMJmEJ4ZfeAp+ZNBjAKGkFErym/a3hla9kxki9j81zKSyGcoLkbeyGs8boG9FJmsuVMHJinM2Zw2/vm6X5Rbc0dp9fGatz7y5cvn7JiJwmYN1BOF3aep3gPjli7SQjSoiwihWQ4RhfqKbaxKAAWM/BeLwd0vRzAwJtPioTmEqUcQB7jDJQjmhqfg6QgeScFgfLF/OZJXkbq/uSCHumP8URThgP34LCxRVbO9IgQHtsNneg1z+ZdjNUADUYpQhCkgCX3NRnhWrAFLGwxpGiRt3olCydo4RwhOYwjuVNw96Z8XoeIdG8OQYEZLlnB9cJa58AkqJanOo4IyBWN0T3NkV5AfetPnu7pPaeHKKIRUbi/e/fuSUh1U8Zp4BYErjqGSVi0hH7Fcd6MiSUcrO4YxTdXfyXt/rA5jAOjwezWEVIip1hDtvDm6BwPXjiRhDvXv2TtT1RwTM5DxlU+Y+aczVeua42gHJNiXM7RZ+QCIjFW8zfnSerPnj17Yh30U8jDvy7k9b0nILbBc9A47MS44En4JoD8w/ApznsexoBdn/AZibeCGOQBm0M/u45zheWdXyjpfp6eM3QelHWcPJgdp8TyOJBI7J7kZKDm716owXHK05BDhLcuUXr/8OHDEy/vpgaAf5hCwvHQhYrOCz2LQQgol1FgPc/P+C2Cl8VwihaYnRIzJAgDP1iWBeaxGTAF8TjUtLmaB+VexXcMJCZrcjenqJFXGsP6kQUKJdvWHym8dXA6NHfRARHJmaQBEHkgi/JQuCZo4eAHhey85CUkJSa00MQtQqR1n4SLHHRf93QNNiJCkQpwgy6rIdQzjbtsS/0BGnB9kCTSef/mPgQgQ3E6sqHZGSIHbE7GVdil5I5z0q7tH3KE/IhyDC0ZMMPGPhECb1XOXYx6Sjq8CIxJ6F5RTKHf4FgReCBgYZ3gcBc7UU9gXyI3j8uQW4tEOtQ3yc17FYOMKNKSoffYDlgVlbC+61pTnxtD/rMW7I9jdi24lNCN2VitURkg/4L4Pu88h2V9/PjxtE54NHawlXQDdDyPqxIu1CVOLZCu73whqw2j9dHCMLVlIARb40ukFNE18oeFyT8YDkhyD8VrlUjS3dc1rUFFndwghhG7TwSrfcD41jUIhCjYOgnMKfogBIhnHF2CxjoRUmGYUClF8oV7wqowyyPVF4qmokJrwmK6p8lTHooHr5tHaIsgoQ968voMDp4yxkILj8sRUGBjmRfGN5d+kxaHHATHU+JW//IKo8uNnEefrbWAVA6LtMiXaiyQrwBNJv0tVBiKnNYJBTQAqptx9HxSlkJMqArTFIr5LLPReoGrKQtUIQsorgofxSWHmmGh1Fxod2MiBy0OcykKWrSIsxYGTv6iedkeotArmi/pci7FJYNgeemLQeRMUaU1tIREdHd/utWfu9ftXYUqwrIiBYGvFqd5yHPQPpRXa6J7Oyfy9LcojEETuj8YvUSCoa4UVXsFn1fzUGiG1BfrvQSre6uGUbB1PoXqzYnCnMocydvnhWiJGlTqWS3dlgdBFINCF72zZE8XB7Jw5h14Ey4vEnpLRbd/FHb3GZPCsuCoUN7QZlBdAo3AjoPO3RpoDAovCpqD/ClE4m9OXWz5gIE5G9iTfLE+TgIKtxVDdhGRLsBi46Pz3cugCJGWCfjrvK0PkXa/3W6nl4XSqlZbEBosUixQxFAiOMhTN5TBXwvqXPkhz9ACwa4Ued2rOytq1SWgr8+adCmQspMN1NjrsAZGRs1Tpg4CFglCJFn3Ml4R3n3BnBwAlkUN1nR1stapdaINf62NGO/+5cuXpy1OupmHpBysAtTwJt6GcaXsBNnOqN6OYlOljJ1QNu8wNvgCE91PMZTdWJgMbwQZKTfjlkN65WQpRQ1R7pFnOFr3qcHAqNrF2prLPk7zy1tQQB3S2mx4Nb+Ikkd6Re+1Yzp2IEtfp8UmdIODCfxeG0AUgAmFoYJpwxSdplAJVnW9UCY64LyGIBiiIBSWhwl/GA12QdfSbXAimuB492qmyiW9LgODIOaTC7RWbGKJwvSiS+AcozYGqo/BJkNQfP/69evJIdfkh1mphilaflCRa1co3NBLixZZqnHwlXduMlacdr0oAzWuW2ODGBGszdLx5uJUGRo9FtVqoa5V9SdX86rSQUyvotNaUqJ1IjO9qnsQAZCsE0zPconoVYBmxJND7Fck+LYChJIiCrSYEK7uHoJ2tgq0xTcmVqY2SIgN84TFSBq/BfOiFLzFoNwEftBnRsqJJGRtj/VshugarXu5SISh3pp+enQMhB25HkVHecGuNW6huSyP83X+RMjnz5+fdv8CY7DoPqOZvWrA8TwGbJIMKtRBmr4RJVlg4zSGeidPxdIYGkzpAixn14bBBsECjGYsCuk15VeVqz+0QfSvsKGukyckaPm0cURx8tmyAMuot7XJFZqf2jK6A8lfemjtjXvqEFiXIHB2+fJ6DeUonLQLEmwLSVXsFpoKQrkl4bvHgw16QUWHir65W6yEz2G2s4B5KQR1bFXuHI6RUgBoE72t1wMbyAJlySW8GaylZPKDuOTktBmje7bApQ8RK6/q450tXBb3SnG8iyfZAxB+5QFMYkNPNHj0RbHI2Lyo8RVjCb9Yyrhk2aTNSynBvQiAtgsCgjlhO43Z+J0HpSBRbtTSyUl0I1pr1+cMdLL0vPMQQdtk75VDcjLr8j4nOZAVy6L4TrZI+KsN3kS8sFebMLxUEadwRPkoWP2RQKCjc1oLKaNrcP/kkL+6Bw0XOaIGM/PsVvJ4xMiaWouCLYMwtCho7o41Vn8oMgjqOnWYKE1xvdeeD87AHiMrajlPMi5FRnKQJtB3ur3b8MO7U7pGn9ATbip13qSlIJ+gwI2lsyrJGSPFwf/Gh9nBjv0BTI3yMMEU52E0hEKhJ4cpUNVC2j6YFFqsyG0tdu7kDXnQXgl51T0MJeJAob6f+k40WQcEad02sjCvk0PQswRgxS7WJsAohKG8Ibd4QhAt7FXDTFNR4ajVIun12riafilM+xwWw1mEAP5uC8aCuh874/mKSDClplLT6PwmC4fUevFwm+S8T0Quq1vdMD44B80ZzNOdimXbGuk0uU6E9Ga7shuu8JnVwQJ8ljhbCMjCuBhIgt++E2/rXAJr3whxLX6LZgSCS9yqc/DX/eCv92A3ZdvrSVYbS4zSeesWAc0pKe8mWMfReYwMyyuKIUX3aBOBUCyw9Ur26qPTXKwwbHA7cAoe2C3RdxO8VSUruOCjJpyWwl4nCrumMcEBhSZc1+RFCZtBXEeR+2hS92mJd6/OQh6Mxan2RVhzpqDklXwpXZ6iHBtGyIR6BjVOZ6grOLZNIL/ISaBWbsbe7PmTt6A4BoHDeksJnZexdK88Ao/OcIogYWdCiXGTtkoc3roX7qoxVOXNWVQ6j6kp6sAMaNGPsgZFplfG2DyoWdg1djttGCmSk8sDGHLMtv+bT+STUVHLqF0jN2JXqDPoap7WegwiSevuaofwGnCmUFuWo0DTpW0CtFiLIsFK7rx62ZDuZ0YUqaKFN6OWOgSiStK/tl1AZnIku35csoqW7tk9E0ggqkUnyEu27t+aqWtXVyiszgcnpvyuVWtxvCVMXX/qkAZYBrMJbD2bx8PgBtXzEk0SIyMyNuaEKmq0aX8TEBOhoO22anx2TEQ0HtqswO288cCJXEWeIizIwcbklN0gkz84KuhUtWN02inynHrE2GqXHESOFJ3YbPeeDnRfR7BJn1D960QKpByJCDNC1cBMoYZpYUJ4Oa/QKORhKWSLKFiO1aQE0adlo32PllJ8Mi+UJT9P10HgAPKeXps+Wfdr2dgAa9yFG5HXWKCQsUQx5YNIEEVG0c1hMNYQ5JQJ9bK0AAwOE7d2wDy287l4DLJ0g7e30zhNzHAWo8Eo8kCcAlE4U4wWiuhgmFWOGggpAZ8dF6UgTHtoO7uIAGchAxbIsVI0AsJBVfCIAJYpp/ZZDdI4jeFrF2qVxxauridhu7gBCj+KT1gshGfxRHVAn/unuk9Zu9WqUtbOuBodJsNnxamFtGgwulQ3GXm9iFd9o+QdTwHgeTu3apfGWUrMkNvNUJgmu7W1fgWubgdqr75jBLqBCmD/sKwKQxX3KlWyLYz1eRKqSYS03pH2N6/iRVsH6BkpAFMWxUp6HROdup/GwM5aBBxOIf7kiOSVzFX/IkuVDstFj5ZKY2jpgBIN1+bp+v6h1pxWu6TxK/w4j5wDnhq786EJxwd1zd3YZz9ke/sSJu/ahfpyigmXEmYk+CwR7xOHG64Wx5AUhaH12hiikJdiWQyom6ANY1GM6CFrSV/OsTa7eysb6p4x96FAOVKfjl72EVIssvEzJCorB69zY4hIhJRwnn5nSfUHbFUDqKRxf7x8ezaSsYo4gQv9hJRfUEiwZbsUeRCJzS8/tLCEFf6Oq/4buz/sSZe2662DwlMQPDfX9qfSg386EFCDUpOn9yKdksnlvr2me/TMOP+13aQr/Ph+iCIG7DSIOgSNg4XYRvcoILEiO4JaK4pKCuwVT9/7tTCao7HgcNfzZF61PS1tH/0iX3mT6EUDKFRPGKvjvUezU6Qx5cLWuMxTXk1WnWbosGyLEdVhSgHEQ6HZWpP7sCzPZXUTtrH1BktKvsvrVawSsGaeHk4L8aVGTEku4dXOgx8Ny8bwHnNrfF/9wrSwH/mn+3gkhcg5rU+7gxI2j4lcrBBVRqm1QhCIPqeDrmt9YMf3ZjQXG2/JkC0CdD7ZNUAfdYg+lMmXtVi0sOLN6J6FgD5J3/WSapMu1xdFYKTP4Ko5dU0ldIxOYld4YSu4fgpBCqzHvaBMvkJNuzfn0JVW8yANlA6q5DP7GKBT/ZYxMEkR2D1ktKfUmunpESFoXorBrTumYmc9kcOiIqKJs7bQtiiVc9d3DcFspSa09oJzaLIt4rxbxaydkeAZFoVFRFJei+t61BKjQksxqz7LN83JixEGhtO9FdnJ6xtkXUOGhehlmXprHEzi1yVuXASgc+f7ITi2Ygr+Ci0cHQbqCa3Hdq/IyZCMoPkmebbgBPbdeH2rhPJ9w6ihhG9OrAaTkpT1xeB0xymdd/dZXvBUTOOQMYfrr2vknAxq109ilztFrMdmRagIAJsd398AYBSIgqzsQ3QHshQsTizN5MWKoZStq4mPbx+LUYyJahKyz/C0a7u3a0VGQjMCb1Lo8Txs6UdJEtSIKtGLnioOOZBmY2PqQjCgHMAhJWzwjjF1n+TePYy+LRjkRnXO8I2Jvfb+8XWElGPDRP8lj0ngwlIS1n6Q4DQLM44kvDknQ9hswmxQRPhtbhAneVcH9BelVhGLhF5zjuY/2Pv9i0TJB0rtTlKsiFYIgykP1kniDIC2y0Pgq+sUtskuejFVzqgg7Fo/oOARJLQYre98x45BPE2hUGuA/kmOFtB5+M/jPVOEFnafSJN8PelnfNu7sB+cYVYt3PNTvkDjNW+0B8IpGKfxuhcEoaVa8JsXGgNUa9ekSPmBwqxdQagJ2GcRmmERlmWJHLAxliGuAyRjcisxTmEIA7M2diUZavSpSygbR8eaWoDo8ZBzykkYCb178P6utx9hft5DUQnaAiXGPuttwfstAHUGJEokpDkVh3p2jStR62312aNLIEUUQYLNN8ngyzhLlUUtsqRzUSRBj+1kQ6YDWRkEm1KQNWATt9gEZMUrReu45Cp3YE0gjoEVhOimzqgvYYILiVGhhlrbvwAncJrDqEsUjfpMagNPqaCpHAv++4x56U5spS761tA6E+bbYnp7cwgTiOOE4BXsnUqdklTbFqF+oFxJDXvh8QnPcxkPpiv4EtTzSzg9+pxR93sXklzja+7twju2X4/bdspW+V2XYzU+OtyaGFMiT0YK0sYRZZ1T/etiZNTe62B4Skb7Rhd5uwOdo1/FdQ6ObGjznKdOYD06h2VRbp/lkwTxQATDaA5SDJzP+i1IMqRcTIiQCsDGw7I80YhgoLubkCVXr2AjZS5rAyHJs4ZRC3RcO6MIRE+1M/SrkIjk5RTJjP1tO0bnt/Oor04v9gXuFbGn/V7rpEUq/S1YRakeaNHqExQuwcGWFgtlqzUScmGgccBbx+USytSU1FLhdS1QpMox4BE5oMjuaXGtRcIX9bvXgT11fXIUdXpZztk0EznyZHMlY+dbc+N3b8aV1/S3yK6fZ63u49iHQZZDdt9AAmb5jQJf5VUJo36qbIlT8w30iBKLsGcg4fNcrejmRFXVOIyqvXKlneTUX7P3oJahMPCz51sXig+qOq8G61z3efwTjLUOf9dCVv0DvpAJZUAEhNPLU72eLVybOrqwKU47QbLkRYT0ABgro65YSULr5Wi2JbzWA68GAxTMm3QD5C3UsFdKV8htxIE2NJlna23oHstt6Cpn6Dr1ikStVbNR65hqPcVr8yhck31bOToDjIKxKSGOQfqOoUWn1M0RTcqjtnOZUlOKFgDlNYHHP7teCx3bEM4qdRWvWqb5FHOKxu7RHsHfG1ti9LBZi9KCz1AIScpldAytcTzt0Su4RT+1NDiSvpoohQTWYXw5UC4B1xhen7GpIoaTpIfkTU9nC3cLNEkVTevVxpLwRAkbNGWqSdQiSELjwlPtCPRWrupeTz6qbJe6dk5i5P3qB30yjUZ5MHltomFvnG7ZFLZHXtGjv5Yu5AF5k0IREsbDuuy36PpuO0rLX90jz5LxJHW/SkqoXlsoBiJR5ZXCuck1EHlLg/UeBcSvVa68STElekCc3Uo1kATeee3prtFqUBMpNDmLShvhUEUr9HQbUG5jJ2/K06dbqKNANcS17yZK3YPCWpscAdZ251S9hemdB+UwCk082OarBJiKirkJ0FGJeTeyCj/Vqc0hlbFIMSfo05qg8M7D+W2na6/AcPlEgSgSOBQH2T4WuqlFRHGimeI7v0TDcWxJj40Okheb44ByjFyC8mKPCmE6OzlkExRaiFLKC02EJS1/Thj5hVeDoybdVgXmoWmY0DrGoMzXz+wMLmzozDYOcsCJwKdfVk3ezXuNL9mitnpMXaeWWdoLhqAGkgJ6Oq6DoDbp2CZ/euNoWicdtwZ6y2keD8pJosud8eUNPUIpBlsABpQg/UlevWpRN/4mec09RaOIkwdQS4sWJSBSfbAsjNehuEGLB7aXUDCor5GB0a4FN0tm9seio6sMy9sVhsnSesE0GTufY2NTmCtyoqA+BmmDqgVIUilCuG2fSCJV/jd5Ey0l1N7oHCMlHGgQlgRHHJqfDO6Vp4qU/ZLLRkwLQJNBpD1uSuAwDLudYA5i68DPnHetXKQxKX9ucZwB+7zERRuGw8kNnFo5oecll0kDj68jCOkmDneFnUkTEt0FHRgHj1wGAusZVRdVYtuIUFtgJinNs7/2pps/j5SLFlqaA6nQ/lHgUShq6gcLJGYt9F4Vss0D8mwdMP7WL/KhtXIstY09DnVSY3GgZbPyW2s8EdIkKKdiSGGFU0uesF5DcusE7WsKzrPxfNdrN+gIoK5wus/a8l2TkUSFyO1VrZESJU7XG9ucvaKtyARG1HwcwAaZKBVB6cb9cqsut3yimWrnkEPogqhFrKc56Sv5wN+JEBRWOGoDSNj2QvyWoAKy445lfY/Y4PeKQ3lk2xPa7rxKbaPYRAeNqx7x1Aems20fsNA82iGKwcZXtILDlKB/1XxyiHaN4jMDLRMTVdinugdl98ukrQUlVqiKcHJlSDkpvT22cPvgoTf5RKmvikT7et3tVoXlEgJGVjtoc8gbokj90L28roU2h+ajRIkwdK4/4c+I8pXo7jgmRXkSqTrJ8eZmNM4CJnWL5cxlTnKWyhs5wpwUih3XheBM0EZb6tDo6pB9BkmYtzj0tWOeSNyNG01EfSiVOfgRlte9CMWcPWuJkRfKLxxCRKKhzSOf8F7eLJl7VfAhIZS5NQUlMrCmof2MhU5KbTxM0DqSNxkzkjzcOTBMT927Ddj0pNw43V40FaOx+YMxoJZgRFJHDdE2LY+uh6UmbyzhmwDYnGJTw030NZZkp24xz9Y9ySKiVOda4n1Omar6rvWoEZKRfAxg30J3unlEqecOrC359M/kFdTemtfzRRfig0BsZ6Ax/+/ZXhdhTRKewVA0G02q8D5jNyzPE+G1a0WDQo5BUoJNqe7lNZTbOGqEDLU03GaRDrPo0TaB16ivVvomeCxTNCdXf8lrA63xvcc41WXQISP1z1ezMSx9OM4IKhEW950com3MS5dCmojH7sNhTUY5tmj1vpoYQ8PieANPb8E6tOoDhuP5W3d0zY9qGnS5a9UE5tDO0JoBbeqWomKf2QKz8occd72v4+TRweg1uXUP5Kv05DffMyBdyi/Y46G9tU5kflZsEQ0GJ4VZi0BlU4Lr3M8A2w2WDxIeRVY0bdHW2CpeOcM9Cko4m1w2d1S/riWrTqp8xjDYDhjO+fwWi8gElc2BqDBMsosO2wqMh8Irljkz2ATTKnkQK981/6G9TQpvw/6EVNzg9LyZEKKDV4IzUGXBqndMrc/bkaVIIdyCebm2OsOliBSuWyoxtyAP8+1vq+Q0wZMoTlaFrg4sR2he7AeZsAY1GjLRdaBNvtAmoeytQyR7xag1IDHJiWqfpN7ChDRGkRJSnBBsAp1PeAv/hajelf0Ei8TWRBwSwZgpuHmwFjCGFoJBiVVn2VMlvN+vb6cc38RViDUWucGepqLv0INZCkIWtG6St3syqtyQIltv8qvjWme6U0qIrhy9a5sHeZH45euTQ3ipr4bx8vVIzTktZ80+A6oBYDAlihwR1nEkgME4Q9eowLuvP5DRZ0SguVqYxzMZk2enjK7JcOAUUWF8a5ZkT1H2/TfhtUeu27rJ6Ze0G0/zsiiUxK1Bq6br5FeOgKBwFvswZ4Oq1gmsYz0YruDbGxRbm5i6Diu6sgesammuZl7Cq8T1hYSzFj+K3WISWAL0/UOQgzHJTzw2g2KAnGh/NgR0YWgUiU2porVOFKlbYStoOWWG1EHQTORQW2RCji1OH8/2Kl42WatcJSUPTa9QCqXu990SBZCGnFBVgC0WMywicG01gA30t7FzHCEumru/c419rUNAq/ZL1+0Px3Qvw8qdzSuaFHvJJqrlChGNUtuHbzz0F3whI9aMxtvLP3WI38uSIOUQoeemBOi9MPNM6yphv0AjITauTRwQImq2WZjxUGoPpslJmI0xLQiTsnCe2X0iaIvbruMc2FfyLbWXj+SIrm8esi6TUkD26tmC5mju1sJZbBPTsU25H8HoSeq8cytdCZXnpPgmha8WkRI8eae48dDCdk9TgOZei2qcxXNteTDZWN7rhyUnL0NfMRcJelmUWqZxWjwj8Ei1hXUvVCv4Gh8ygFWG5TgQwYYXJ1AL6XCscze+57ykgZND9v8x7ESLtofAsno1oEuxpotLmSZpDPiI9i4mK/5SXsKDAQrf2gCt9F+qZkQ8H1VUTduJAxd5tRyQbFrlDILmYj0cpnEyMHalJksWx6wLRbeOEAR86tnRawbzhEnySO7rwOepE4UNegaHFVnonPAlYB6i4UfAhEFLN9E3dp6ClVEmyEsJhXILohB1iF6W+mUNLue0aBtCoM52cM6hkMSItN3tRZhT3rMXArqTHbx1jOJ1IdJN77tfrmwMkZZjJId6Lx3TBRaWjI/9ENinYcjy+PIWfOjoHsP91TQebuhaDEloirxt4cNXhSdv735dVwwoI/j+owjqPmNQUmticFumGox91qPjyc2J+q8i0X/w5Xrjb7ca4dGXax6lAhrdqzJCEIC5Ry+LIZpEux2EUIoNpqwrarbxZuPGfQiAjap9OFkfR6c0Ad3vWEKqZhlK7uoacJR8FMGR5IWF163YeXvGxRDlR5ENWtVSWuqiAxVufpCls7x5mSPqbtitZKjdvXz858TdlPBN4rH5JlFsSXjgYvl758ARY2iVWGQKAw/dm3EUf2oATUI1RYsDIeTIATAlG1Ei1TgMlVzorZyWDIpGjtXnYNFmk5oBsWj8jCEpJ58tio7p73mCBqRxhtWZfAJCyaNf93jYOiVhUuBCaCmuugn2qwPwcaG3RVgLtC2qTWLRjE35GEnXw3ycXkWcchGBFKIKlrzJYi0pAhRoizAar1TA2ftoDIWwIrNrwaWGI0Kj0Ugf6Yqy/VZMhmJcdFwjl4x6ho8IwbtxbjfAx26Eq4rHPkt6inSED/wAAAbDSURBVC8K9sQgqqlVIdLgMUVlSCQC3KC0lNSYIhOcGB8sLlShupqRthdsRJFZ8uXR8lL3Iwb00Vhdp4OQDtQmKV6ydlwKEDUcgSEaT43TPccgktu2rBsA/CzflshgO09ZISXtFIreKRAlcvWNayx82xvNn/KSK8/ThrCY7vHTsRgMttM4QcnWOnKN5ifGk4NxLg74o07xFoJ6YKC46+UvuYVOklePT2OVI8mTCMn5SpvqtMEpn6UbQKu584ykNwXOVJ/CuwV2vYhgSOwLRCkSWwTv6RqYz/uwpRapG0uRqOZ6p7qjyNlm3tL01mIvQp2DsoJvu4191jHAlppXMlc7JUO6SG7Pd62hyN54uh9yT7I8DCK5ULiKtwHsfHXs+mVLCsYqJMDuaTEJt9U+r1xq+iNjdYzCMZftUyEE8oU6h6ep7lOG+qVjaik9KwQDI0RuEApF8kIOSEMw0p2H4BqXspcIYZWgrnH7x9HS7SEX9bK0EGAZiqmyxX4UX2t5WJlBcP0UQEGNzQPQPkWk2gUkab2IDj2pFAmyknHbLJyksVNKf12DeUnQOYAv6aj2lzkhMOhwY4AlLRgOpg5TzJp7WZhugZzc+BsVHH0L5fT7+H6IxKbvYkHbbki5CamoEgXySIq//hfcru8atQNGlofY1wCbW7tcq3qGUJg1TsfkFoZPUX68oPf9YXkiy5OEaDkCwDk5GniyRoVvCrcxVZ4TxZglVAGJ14J54TWZzHMKQ9ufWh4gZJUo+TSQxMnKsF+7QT+sexAGyVX0iSgKalxwib5qw+gCZ9CuEwGUhGpq+om4lCoqt+2SXN0r38kxSMJGt30ZbRF5RAmQUTqWDOBY14Az9xm8dY281Jh+GlF98mBZ6gOe4rmqJoblElsDqRFU8WiuvQpUNUHlg6W1CsnND0iF78Gn/Maxz9K8nqdKFpHgv/HeHLP9q6sTJfPSTWN2nYe80WedgeazP59CwXIyNVZ/fkHPUyzJwJGxzc2L9lc2Gh//5ZGGYZNlLSEHC5sMZdXr1wUWjmoVAmEUvAtUURDezusap395ky/swOutcxRRij5fGm2c5Bbh4KpjdglF5hZmok4NRYnY5f4HlRywV0wTCjSmSNGKUt/JbZK7a9VTyZBTH5bVxPaheTRPURc0oBYBAUAIvl3+6FyCSqa9+j/WU5Rf0+keTUO5hbDbMcCW5BiFlqjTUgGj4KKFwmaOgymBJLllDaqIlFv2fwR1H6rbuCtz57fpCYZStj6acelFh5v8j69Ft0AJCBwQQNEFZppAUoObvFA90j08X2sDzG1ljBJLjM3pKRbPE8NfBMHcKKsoak5PhGhVNJan+bVCKDEliG4MzU9/82iwKYqwPBCfotVBKdsmFTQAyfLe5icFbvL1l97PjqECRRgTOGFTAjwuWpzjXQ2iySfJ6jeBHbi5WE4YbI5i8Hj9NBQYTl9ziMSoR5VX7qI1ORlVHtNA1CWW4EG0glfhqvVjPAWrArT1yDfbqJXYk9vaOKioAdXJfQwipLUPLErDDFbLETBeYw1r6BVkoKIZowkzjm8v8ejG46XdKzIwL3sTndOO6JwfN9O8A2f2M0Agozdf82ibM1hj6VRjlJ1T3TdOykOzt3rfzTdtFvWVCr51K0S7xsMOvdfFVvcoqI9B0D69LHTVc68tTMg1UJ6AjYEBeUVxKPd0nYVJiKci/f5/4coBnVNVo5J9FiHyATiVnLsG2diGHuWhmY2zZEXFzAkWBbaucpyDFf3IgyhprOZRlyEVErZ8huSA1oU3OfUkdbxf1dsEPF1yzgiqzQaG55hJx3xDVXWq5khwRZ7E3/2+adS9nW8ObQiJFha3KI1GXWcOJP8xTuto/C3mdIo3b8BtDcXm90BDTqnytu6ua07PryVzjuoLPvJV+uwcgiAiOZhIkqeso9fHj/GjppK0UFL9qqAJv14k2dsRbAEphSDwFUR0XfNd6xvUVn8qxa9ngybRxAAwm8dulG6u41SgFhRzHHVB8iI4oAVsesRnUUILRn5pTnDZdcmDcWGJW1Trg50cUvs9BTRYA0vSGQJ9xXzAUMJJxpp0JsJKdI0VWLh9hvTbii2W9+kbOYZ+S77b2hCdIltXGQmxDhTU8cYSqRif7rH6xTygkbFSYPPYWtD74mydx+xEWudESeOCRzAaWqh1ONdpneg6NiA2o9vLKxVjIqfJfMHHQrWZFUO9dn/HhXXjq2hFCNYhl13p8hZXOUfey5BdC7L2fvVQx/SXwCCst9lkI0yEtZ6UZuzWIJekbCRBqwglplzEQG4RLdhs50Fijke+zv8PIvv1f2kF9KYAAAAASUVORK5CYII=");content:"";display:block;height:300%;left:-100%;position:absolute;top:-100%;width:300%;z-index:2;pointer-events:none}@-moz-keyframes noise{0%,to{transform:translate(0)}10%{transform:translate(-5%,-10%)}20%{transform:translate(-15%,5%)}30%{transform:translate(7%,-25%)}40%{transform:translate(-5%,25%)}50%{transform:translate(-15%,10%)}60%{transform:translate(15%)}70%{transform:translateY(15%)}80%{transform:translate(3%,35%)}90%{transform:translate(-10%,10%)}}@-webkit-keyframes noise{0%,to{-webkit-transform:translate(0);transform:translate(0)}10%{-webkit-transform:translate(-5%,-10%);transform:translate(-5%,-10%)}20%{-webkit-transform:translate(-15%,5%);transform:translate(-15%,5%)}30%{-webkit-transform:translate(7%,-25%);transform:translate(7%,-25%)}40%{-webkit-transform:translate(-5%,25%);transform:translate(-5%,25%)}50%{-webkit-transform:translate(-15%,10%);transform:translate(-15%,10%)}60%{-webkit-transform:translate(15%);transform:translate(15%)}70%{-webkit-transform:translateY(15%);transform:translateY(15%)}80%{-webkit-transform:translate(3%,35%);transform:translate(3%,35%)}90%{-webkit-transform:translate(-10%,10%);transform:translate(-10%,10%)}}@-o-keyframes noise{0%,to{transform:translate(0)}10%{transform:translate(-5%,-10%)}20%{transform:translate(-15%,5%)}30%{transform:translate(7%,-25%)}40%{transform:translate(-5%,25%)}50%{transform:translate(-15%,10%)}60%{transform:translate(15%)}70%{transform:translateY(15%)}80%{transform:translate(3%,35%)}90%{transform:translate(-10%,10%)}}@keyframes noise{0%,to{-webkit-transform:translate(0);transform:translate(0)}10%{-webkit-transform:translate(-5%,-10%);transform:translate(-5%,-10%)}20%{-webkit-transform:translate(-15%,5%);transform:translate(-15%,5%)}30%{-webkit-transform:translate(7%,-25%);transform:translate(7%,-25%)}40%{-webkit-transform:translate(-5%,25%);transform:translate(-5%,25%)}50%{-webkit-transform:translate(-15%,10%);transform:translate(-15%,10%)}60%{-webkit-transform:translate(15%);transform:translate(15%)}70%{-webkit-transform:translateY(15%);transform:translateY(15%)}80%{-webkit-transform:translate(3%,35%);transform:translate(3%,35%)}90%{-webkit-transform:translate(-10%,10%);transform:translate(-10%,10%)}}#app .page-intro[_v-7d619fc2]{overflow:hidden;height:100%;position:relative}#app .page-intro[_v-7d619fc2]:after{opacity:0;-webkit-transition:opacity 4s 1s;transition:opacity 4s 1s}#app .page-intro.noisy[_v-7d619fc2]{cursor:-webkit-grab;cursor:grab}#app .page-intro.noisy[_v-7d619fc2]:after{opacity:1}#app .page-intro.noisy.grabbing[_v-7d619fc2]{cursor:-webkit-grabbing;cursor:grabbing}#app .page-intro.noisy .drag[_v-7d619fc2]{opacity:1;-webkit-transition:opacity 1s 3.5s;transition:opacity 1s 3.5s}#app .page-intro .debug-texts[_v-7d619fc2]{display:none;overflow-y:scroll;width:512px;background-color:rgba(255,0,255,.05)}#app .page-intro .debug[_v-7d619fc2]{position:absolute;z-index:20;left:auto;right:10px;top:100px;text-align:left;font-size:12px}#app .page-intro .debug li[_v-7d619fc2]{margin-bottom:5px}#app .page-intro .debug input[_v-7d619fc2]{font-size:12px;vertical-align:middle}#app .page-intro .debug input[type=text][_v-7d619fc2]{background-color:hsla(0,0%,100%,.1);border:none;width:50px;height:30px;margin-right:10px;text-align:center}#app .page-intro .debug input[type=text].debug-result[_v-7d619fc2]{margin-top:5px;width:100%}#app .page-intro .bloc-text[_v-7d619fc2]{font-size:60em;line-height:normal;font-weight:700;bottom:-.28em}#app .page-intro .bloc-text-sub[_v-7d619fc2]{font-size:14em;line-height:1.428571428571429em;font-weight:400;color:#71777b}#app .page-intro .wrapper-intro[_v-7d619fc2]{position:relative;display:table;margin:0 auto;height:50%;vertical-align:bottom}#app .page-intro .wrapper-intro.show .text-intro[_v-7d619fc2],#app .page-intro .wrapper-intro.show .text-outro[_v-7d619fc2]{opacity:1;left:0;-webkit-transition:opacity 1s .8s,left 1s cubic-bezier(.215,.61,.355,1) .7s;transition:opacity 1s .8s,left 1s cubic-bezier(.215,.61,.355,1) .7s}#app .page-intro .wrapper-intro.show .text-baseline[_v-7d619fc2]{opacity:1;left:48%;-webkit-transition:opacity .5s 1s,left .5s cubic-bezier(.215,.61,.355,1) 1s;transition:opacity .5s 1s,left .5s cubic-bezier(.215,.61,.355,1) 1s}#app .page-intro .text-intro[_v-7d619fc2]{position:relative;left:0;opacity:0;display:table-cell;vertical-align:bottom;text-align:left;-webkit-transition:opacity 1s 2s,left 1s cubic-bezier(.55,.055,.675,.19) .2s;transition:opacity 1s 2s,left 1s cubic-bezier(.55,.055,.675,.19) .2s}#app .page-intro .wrapper-outro[_v-7d619fc2]{position:absolute;bottom:-150em}#app .page-intro .wrapper-outro .bloc-text-sub[_v-7d619fc2],#app .page-intro .wrapper-outro .bloc-text[_v-7d619fc2]{position:absolute;top:auto;bottom:-3.846153846153846em;font-size:1em;color:#71777b;opacity:0;-webkit-transition:opacity 1s 0s;transition:opacity 1s 0s;white-space:nowrap}#app .page-intro .wrapper-outro .text-effect[_v-7d619fc2]{position:relative;display:inline-block;padding-bottom:10px}#app .page-intro .wrapper-outro .text-link[_v-7d619fc2]{position:relative;left:0;top:0;color:#71777b;padding-bottom:10px;font-weight:700;font-size:23em}#app .page-intro .wrapper-outro .text-link[_v-7d619fc2]:after{display:none}#app .page-intro .wrapper-outro.show .text-link[_v-7d619fc2]{position:relative;left:0;top:0;color:#71777b;padding-bottom:10px}#app .page-intro .wrapper-outro.show .text-link[_v-7d619fc2]:after{display:none;content:"";display:block;position:absolute;left:0;margin:10px 0 0;border-bottom:1px solid #fff;-webkit-animation-duration:.75s;animation-duration:.75s;-webkit-animation-name:swip;animation-name:swip;-webkit-animation-iteration-count:1;animation-iteration-count:1;-webkit-animation-delay:1.5s;animation-delay:1.5s}#app .page-intro .wrapper-outro div.effet[_v-7d619fc2]{width:0;height:15px;position:absolute;left:0;bottom:0;border-bottom:1px solid #fff;pointer-events:none}#app .page-intro .wrapper-outro:hover div.effet[_v-7d619fc2]{-webkit-animation-duration:.75s;animation-duration:.75s;-webkit-animation-name:swip;animation-name:swip;-webkit-animation-iteration-count:1;animation-iteration-count:1}@-moz-keyframes swip{0%{width:0;left:0}50%{width:100%;left:0}51%{width:100%;left:0}to{width:0;left:100%}}@-webkit-keyframes swip{0%{width:0;left:0}50%{width:100%;left:0}51%{width:100%;left:0}to{width:0;left:100%}}@-o-keyframes swip{0%{width:0;left:0}50%{width:100%;left:0}51%{width:100%;left:0}to{width:0;left:100%}}@keyframes swip{0%{width:0;left:0}50%{width:100%;left:0}51%{width:100%;left:0}to{width:0;left:100%}}#app .page-intro .text-link[_v-7d619fc2]{position:relative;font-size:26em;left:50%;top:3.846153846153846em;bottom:auto;line-height:1.153846153846154em;font-weight:500;text-decoration:none;color:#fff;-webkit-transition:opacity .5s cubic-bezier(.55,.055,.675,.19) 1s;transition:opacity .5s cubic-bezier(.55,.055,.675,.19) 1s;-webkit-transition:opacity .5s cubic-bezier(.55,.055,.675,.19) 1s,color .3s cubic-bezier(.55,.055,.675,.19);transition:opacity .5s cubic-bezier(.55,.055,.675,.19) 1s,color .3s cubic-bezier(.55,.055,.675,.19)}#app .page-intro .text-link[_v-7d619fc2]:after{content:"\\2192";margin-left:1.5em;font-size:.8em}#app .page-intro .text-baseline[_v-7d619fc2]{position:absolute;bottom:15.625em;left:38%;width:100%;color:#999;opacity:0;font-weight:500;font-size:16em;line-height:1.375em;-webkit-transition:opacity 1s .3s,left 1s cubic-bezier(.55,.055,.675,.19) .3s;transition:opacity 1s .3s,left 1s cubic-bezier(.55,.055,.675,.19) .3s}#app .page-intro .line[_v-7d619fc2]{position:absolute;top:0;left:0;width:100%;height:50%;border-bottom:1px solid hsla(0,0%,100%,.1);-webkit-transition:width 1s cubic-bezier(.755,.05,.855,.06);transition:width 1s cubic-bezier(.755,.05,.855,.06);z-index:2}#app .page-intro .drag[_v-7d619fc2]{position:absolute;top:50%;right:0;width:11vw;height:2vh;color:#fff;font-size:18em;line-height:1em;padding:0;margin:-.5em auto 0;z-index:3;opacity:0}#app .page-intro .drag[_v-7d619fc2]:after,#app .page-intro .drag[_v-7d619fc2]:before{width:0;display:inline-block;content:"";border-top:1px solid #fff;margin-right:.5vw;padding-bottom:4px;-webkit-animation-duration:2.5s;animation-duration:2.5s;-webkit-animation-name:glissementIntro;animation-name:glissementIntro;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}#app .page-intro .drag[_v-7d619fc2]:after{margin:0 0 0 .5vw;-webkit-animation-duration:2.5s;animation-duration:2.5s;-webkit-animation-name:glissementIntroInverse;animation-name:glissementIntroInverse;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}#app .page-intro .drag span[_v-7d619fc2]{display:inline-block;width:3vw;text-align:center}#app .page-intro .drag.hide[_v-7d619fc2]{opacity:0;-webkit-transition:opacity 1s .3s;transition:opacity 1s .3s;transition:opacity 1s .3s,}#app .page-intro .scroll-intro[_v-7d619fc2]{position:absolute;bottom:15.625em;left:48%;font-size:16px;bottom:90px;width:100%;text-align:center;color:#7ad71f;opacity:0;-webkit-transition:opacity .5s;transition:opacity .5s;cursor:pointer;z-index:5}#app .page-intro .scroll-intro.show[_v-7d619fc2]{opacity:1;-webkit-transition:opacity .5s 1.7s;transition:opacity .5s 1.7s;-webkit-animation:jump 2.8s infinite cubic-bezier(.215,.61,.355,1) 4s;animation:jump 2.8s infinite cubic-bezier(.215,.61,.355,1) 4s}#app .page-intro .scroll-intro.show[_v-7d619fc2]:hover{-webkit-animation:none;animation:none;opacity:1}#app .page-intro .scroll-intro .scroll[_v-7d619fc2]{position:relative;height:100px}#app .page-intro .scroll-intro .scroll div.top[_v-7d619fc2]{position:absolute;left:0;top:20px;font-size:14px;color:#fff}#app .page-intro .scroll-intro .scroll div.top[_v-7d619fc2]:after{display:block;content:"";width:10px;height:0;margin-left:17px;border-left:1px solid #fff;-webkit-animation-timing-function:cubic-bezier(1,.3,.3,1);animation-timing-function:cubic-bezier(1,.3,.3,1);-webkit-animation-duration:1.5s;animation-duration:1.5s;-webkit-animation-name:scroll;animation-name:scroll;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}#app .page-intro .scroll-intro .scroll div.bot[_v-7d619fc2]{position:absolute;left:0;bottom:20px;font-size:14px;color:#fff}#app .page-intro .scroll-intro .scroll div.bot[_v-7d619fc2]:after{display:block;content:"";width:10px;height:0;margin-left:17px;border-left:1px solid #fff;-webkit-animation-timing-function:cubic-bezier(1,.3,.3,1);animation-timing-function:cubic-bezier(1,.3,.3,1);-webkit-animation-duration:1.5s;animation-duration:1.5s;-webkit-animation-name:scrollInverse;animation-name:scrollInverse;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}#app .page-intro .scroll-intro .scroll div.text[_v-7d619fc2]{position:absolute;left:0;bottom:0;font-size:14px;color:#fff;-webkit-animation-timing-function:cubic-bezier(1,.3,.3,1);animation-timing-function:cubic-bezier(1,.3,.3,1);-webkit-animation-duration:1.5s;animation-duration:1.5s;-webkit-animation-name:descenteText;animation-name:descenteText;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}#app .page-intro .background[_v-7d619fc2]{z-index:0;position:absolute;height:100%;left:0;top:0;opacity:0;-webkit-transition:opacity 2s 1.2s;transition:opacity 2s 1.2s}#app .page-intro .background.show[_v-7d619fc2]{top:0;opacity:1}#app .page-intro .wrapper-text[_v-7d619fc2]{position:absolute;top:0;z-index:1;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end;width:100%;height:50%;opacity:0;-webkit-transition:opacity 1.5s 3s;transition:opacity 1.5s 3s}#app .page-intro .wrapper-text .bloc-wrapper:last-child .bloc-text-sub[_v-7d619fc2],#app .page-intro .wrapper-text .bloc-wrapper:last-child .bloc-text[_v-7d619fc2]{opacity:1;-webkit-transition:opacity 1s 1s;transition:opacity 1s 1s}#app .page-intro .wrapper-text .bloc-wrapper:last-child .wrapper-outro[_v-7d619fc2]{opacity:0;-webkit-transition:opacity 1s 0s;transition:opacity 1s 0s}#app .page-intro .wrapper-text .bloc-wrapper:last-child .wrapper-outro [_v-7d619fc2]{opacity:1}#app .page-intro .wrapper-text.end .bloc-wrapper:last-child .wrapper-outro[_v-7d619fc2]{opacity:1;-webkit-transition:opacity 1s 0s;transition:opacity 1s 0s}#app .page-intro .wrapper-text.end .bloc-wrapper:last-child .wrapper-outro [_v-7d619fc2],#app .page-intro .wrapper-text.show[_v-7d619fc2]{opacity:1}#app .page-intro .bloc-wrapper[_v-7d619fc2]{position:relative;width:100vw;text-align:center}#app .page-intro .bloc[_v-7d619fc2]{display:inline-block}#app .page-intro .text-top[_v-7d619fc2]{text-align:left;position:relative}#app .page-intro .text-bottom[_v-7d619fc2]{position:absolute;text-align:left;bottom:-5em}@-moz-keyframes glissementIntro{0%,to{width:1vw}50%{width:5vw}}@-webkit-keyframes glissementIntro{0%,to{width:1vw}50%{width:5vw}}@-o-keyframes glissementIntro{0%,to{width:1vw}50%{width:5vw}}@keyframes glissementIntro{0%,to{width:1vw}50%{width:5vw}}@-moz-keyframes glissementIntroInverse{0%,to{width:5vw}50%{width:1vw}}@-webkit-keyframes glissementIntroInverse{0%,to{width:5vw}50%{width:1vw}}@-o-keyframes glissementIntroInverse{0%,to{width:5vw}50%{width:1vw}}@keyframes glissementIntroInverse{0%,to{width:5vw}50%{width:1vw}}@-moz-keyframes scroll{0%{height:0;border:none}50%{height:0;border-left:1px solid #fff}to{height:60px;border-left:1px solid #fff}}@-webkit-keyframes scroll{0%{height:0;border:none}50%{height:0;border-left:1px solid #fff}to{height:60px;border-left:1px solid #fff}}@-o-keyframes scroll{0%{height:0;border:none}50%{height:0;border-left:1px solid #fff}to{height:60px;border-left:1px solid #fff}}@keyframes scroll{0%{height:0;border:none}50%{height:0;border-left:1px solid #fff}to{height:60px;border-left:1px solid #fff}}@-moz-keyframes scrollInverse{0%{height:60px;border-left:1px solid #fff}50%{height:0;border-left:1px solid #fff}to{height:0;border:none}}@-webkit-keyframes scrollInverse{0%{height:60px;border-left:1px solid #fff}50%{height:0;border-left:1px solid #fff}to{height:0;border:none}}@-o-keyframes scrollInverse{0%{height:60px;border-left:1px solid #fff}50%{height:0;border-left:1px solid #fff}to{height:0;border:none}}@keyframes scrollInverse{0%{height:60px;border-left:1px solid #fff}50%{height:0;border-left:1px solid #fff}to{height:0;border:none}}@-moz-keyframes descenteText{0%{opacity:0;top:0}30%{opacity:1}60%{opacity:1}to{opacity:0;top:100%}}@-webkit-keyframes descenteText{0%{opacity:0;top:0}30%{opacity:1}60%{opacity:1}to{opacity:0;top:100%}}@-o-keyframes descenteText{0%{opacity:0;top:0}30%{opacity:1}60%{opacity:1}to{opacity:0;top:100%}}@keyframes descenteText{0%{opacity:0;top:0}30%{opacity:1}60%{opacity:1}to{opacity:0;top:100%}}#app .page-intro.loading[_v-7d619fc2]{opacity:0}#app .page-intro.loading .wrapper-intro .text-intro[_v-7d619fc2]{opacity:0;left:-50px}#app .page-intro.loading .wrapper-intro .text-baseline[_v-7d619fc2]{opacity:0;left:38%}#app .page-intro.loading .line[_v-7d619fc2]{width:0}#app .page-intro.loading .scroll-intro[_v-7d619fc2],#app .page-intro.loading .text-link[_v-7d619fc2]{opacity:0}#app.is-mobile .page-intro .bloc-text[_v-7d619fc2]{font-size:25em}#app.is-mobile .page-intro .bloc-text-sub[_v-7d619fc2]{font-size:7em}#app.is-mobile .page-intro .text-baseline[_v-7d619fc2]{font-size:8em;bottom:12.5em}#app.is-mobile .page-intro .text-link[_v-7d619fc2]{font-size:13em;-webkit-transition:opacity .5s cubic-bezier(.55,.055,.675,.19) 1s;transition:opacity .5s cubic-bezier(.55,.055,.675,.19) 1s;-webkit-transition:opacity .5s cubic-bezier(.55,.055,.675,.19) 1s,color .3s cubic-bezier(.55,.055,.675,.19);transition:opacity .5s cubic-bezier(.55,.055,.675,.19) 1s,color .3s cubic-bezier(.55,.055,.675,.19)}');
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _gsap = require("../../node_modules/gsap")
            , _gsap2 = _interopRequireDefault(_gsap)
            , _THREE = require("THREE")
            , _THREE2 = _interopRequireDefault(_THREE)
            , _sceneManager = require("../scripts/threeTools/sceneManager")
            , _sceneManager2 = _interopRequireDefault(_sceneManager)
            , _mathTools = require("../scripts/mathTools")
            , _mathTools2 = _interopRequireDefault(_mathTools);
        exports.default = {
            data: function() {
                return {
                    inputDebug: {
                        x: 0,
                        y: 0,
                        z: 0,
                        scale: 0,
                        rotation: 0
                    },
                    selected: null,
                    titleScreen: !0,
                    endScreen: !1,
                    scrollX: 0,
                    bgX: 0,
                    bgWidth: 0,
                    textX: 0,
                    isWebGL: !1,
                    dragStart: !1,
                    dragStartX: 0,
                    dragDirection: 0,
                    dragDistanceX: 0,
                    scrollXDrag: 0,
                    smoothDrag: 200,
                    dragValue: 0,
                    mouseX: 0,
                    dragTimeout: !1,
                    dragStopPosition: 0,
                    dragEasing: .01,
                    velocity: [0, 0],
                    isTablet: !1,
                    dragShow: !1
                }
            },
            computed: {
                debugString: function() {
                    return '"position": "' + this.inputDebug.x + " " + this.inputDebug.y + " " + this.inputDebug.z + " " + this.inputDebug.scale + " " + this.inputDebug.rotation + '"'
                },
                texts: function() {
                    return this.$root.data.home.texts
                },
                textWidth: function() {
                    return 1.16 * this.bgWidth
                }
            },
            created: function() {
                var testCanvas = document.createElement("canvas");
                this.isWebGL = !(!testCanvas.getContext || !testCanvas.getContext("webgl") && !testCanvas.getContext("experimental-webgl") || this.$root.isMobile)
            },
            ready: function() {
                var scm, canvas;
                return this.$root.UILightFlag = !1,
                    this.$root.BGLightFlag = !1,
                    this.isWebGL ? (scm = new _sceneManager2.default,
                        canvas = scm.renderer.domElement,
                        canvas.setAttribute("v-show", "!titleScreen"),
                        canvas.style.position = "absolute",
                        canvas.style.top = 0,
                        canvas.style.zIndex = 2,
                        this.$el.appendChild(canvas),
                        this.$compile(canvas),
                        scm.renderer.setClearColor(16777215, 0),
                        scm.camera.position.set(0, 0, 1),
                        this.scm = scm,
                        this.raycaster = new _THREE2.default.Raycaster,
                        this.$once("onLoadAlready", this.onAppLoadingComplete),
                        this.$once("onLoadAnimStop", this.onAppLoadingComplete),
                        this.loadingQueue = this.$root.data.home.models,
                        this.meshes = [],
                        this.loadAssets(),
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) && (this.isTablet = !0),
                        void (this.$root.debug && (scm.renderer.domElement.onclick = this.onClick))) : void this.$dispatch("onEnterSplashScreen")
            },
            beforeDestroy: function() {
                this.titleScreen && this.$dispatch("onLeaveSplashScreen")
            },
            methods: {
                render: function() {
                    if (this.bgWidth = this.$el.querySelector(".background").offsetWidth,
                            this.bgX = -this.scrollX * (this.bgWidth - this.$root.size.w) + 8 * this.$root.mouse.x,
                            this.textX = -this.scrollX * (this.textWidth - this.$root.size.w) + 18 * this.$root.mouse.x,
                        1 == this.dragSmooth) {
                        Math.abs(this.velocity[0] - this.velocity[1]);
                        this.dragStopPosition = _mathTools2.default.clamp(this.dragStopPosition + this.dragDirection * this.dragEasing, 0, 1),
                            this.scrollX = _mathTools2.default.clamp(this.dragStopPosition, 0, 1),
                            this.dragEasing = .9 * this.dragEasing
                    }
                    1 == this.dragStart && this.onDrag(),
                        this.scm.camera.lookAt(new _THREE2.default.Vector3(this.scrollX,this.scm.camera.position.y,0)),
                        this.scm.camera.position.x = _mathTools2.default.ease(this.scm.camera.position.x, this.scrollX + .01 * this.$root.mouse.x, .05),
                        this.scm.camera.position.z = _mathTools2.default.ease(this.scm.camera.position.z, 1.08 - Math.abs(.01 * this.$root.mouse.x), .05),
                        this.scm.render()
                },
                buildMeshes: function() {
                    var modelsData = this.$get("$root.data.home.models");
                    modelsData.map(this.buildMesh)
                },
                buildMesh: function(data, index) {
                    var name = data.name
                        , img = this.$root.getLoadedAsset(data.pic)
                        , texture = new _THREE2.default.Texture(img)
                        , pos = data.position.split(" ");
                    if (texture.needsUpdate = !0,
                            data.mesh) {
                        var meshData = this.$root.getLoadedAsset(data.mesh)
                            , parsedData = (new _THREE2.default.JSONLoader).parse(meshData)
                            , geom = parsedData.geometry;
                        this.addModel(name, geom, texture, pos[0], pos[1], pos[2], pos[3], pos[4] || 0)
                    } else
                        this.addPlane(name, texture, pos[0], pos[1], pos[2], pos[3], pos[4] || 0)
                },
                loadAssets: function() {
                    var modelsData = this.$get("$root.data.home.models")
                        , queue = [];
                    modelsData.map(function(data, index) {
                        data.pic && queue.push(data.pic),
                        data.mesh && queue.push(data.mesh)
                    }),
                        this.$dispatch("onLoadRequest", queue, this._uid)
                },
                onAppLoadingComplete: function() {
                    this.$off("onLoadAlready", this.onAppLoadingComplete),
                        this.$off("onLoadAnimStop", this.onAppLoadingComplete),
                        this.buildMeshes(),
                        this.$on("onEnterFrame", this.render),
                        this.$once("onRawWheel", this.onFirstMouseWheel),
                        this.$dispatch("onEnterSplashScreen")
                },
                addModel: function(name, geom, texture, x, y, z, scale, rotation) {
                    var mat = new _THREE2.default.MeshStandardMaterial({
                        map: texture,
                        emissiveMap: texture,
                        emissive: "#ffffff"
                    })
                        , mesh = new _THREE2.default.Mesh(geom,mat);
                    mesh.position.set(x, y, z),
                        mesh.scale.set(scale, scale, scale),
                        mesh.rotation.set(0, rotation, 0),
                        this.meshes.push(mesh),
                        this.scm.scene.add(mesh)
                },
                addPlane: function(name, texture, x, y, z, scale, rotation) {
                    var ratio = texture.image.width / texture.image.height
                        , boxSize = ratio > 1 ? new _THREE2.default.Vector2(1,1 / ratio) : new _THREE2.default.Vector2(1 * ratio,1)
                        , g = new _THREE2.default.PlaneGeometry(boxSize.x,boxSize.y)
                        , m = new _THREE2.default.MeshStandardMaterial({
                        map: texture,
                        transparent: !0,
                        emissiveMap: texture,
                        emissive: "#ffffff"
                    })
                        , plane = new _THREE2.default.Mesh(g,m);
                    plane.rotation.x = 2 * Math.PI,
                        plane.position.set(x, y, z),
                        plane.scale.set(scale, scale, 1),
                        plane.rotation.set(0, rotation, 0),
                        this.meshes.push(plane),
                        this.scm.scene.add(plane)
                },
                onClick: function(e) {
                    var intersects, indexSelected, indexNewSelected;
                    this.raycaster.setFromCamera(this.$root.mouse, this.scm.camera),
                        intersects = this.raycaster.intersectObjects(this.meshes),
                        intersects.length > 1 ? (indexSelected = intersects.findIndex(function(el, index) {
                            return this.selected === el.object
                        }
                            .bind(this)),
                            indexNewSelected = (indexSelected + 1) % intersects.length,
                            this.selected = intersects[indexNewSelected].object) : this.selected = intersects[0] ? intersects[0].object : null,
                        this.meshes.map(function(mesh, index) {
                            mesh.material.emissive = this.selected && mesh === this.selected ? new _THREE2.default.Color(.5,1,.5) : new _THREE2.default.Color(1,1,1),
                                mesh.material.needUpdate = !0
                        }
                            .bind(this)),
                    this.selected && (this.inputDebug = {
                        x: this.selected.position.x,
                        y: this.selected.position.y,
                        z: this.selected.position.z,
                        scale: this.selected.scale.x,
                        rotation: this.selected.rotation.y
                    })
                },
                onMouseWheel: function(value) {
                    if (!this.isTablet) {
                        this.dragShow = !0;
                        var vRatio = Math.min(.05 / Math.abs(this.scm.camera.position.y), 1);
                        this.scrollX = _mathTools2.default.clamp(this.scrollX - 2e-4 * value * vRatio, 0, 1)
                    }
                },
                onFirstMouseWheel: function(value) {
                    this.scrollX = 0,
                        this.titleScreen = !1,
                        this.$dispatch("onLeaveSplashScreen"),
                        this.scm.camera.position.x = this.scrollX,
                        this.scm.camera.position.y = 4,
                        _gsap2.default.to(this.scm.camera.position, 4, {
                            y: 0,
                            ease: Cubic.easeOut,
                            onComplete: this.onAnimationComplete
                        })
                },
                onAnimationComplete: function() {
                    this.$on("onSmoothScroll", this.onMouseWheel)
                },
                startDrag: function(value) {
                    if (clearTimeout(this.dragTimeout),
                            this.dragStart = !0,
                            this.dragShow = !0,
                            this.dragSmooth = !1,
                            this.isTablet) {
                        if (1 == value.touches.length) {
                            var touch = value.touches[0];
                            this.dragStartX = touch.clientX
                        }
                    } else
                        this.dragStartX = value.offsetX
                },
                mousePosition: function(value) {
                    if (this.isTablet) {
                        if (1 == value.touches.length) {
                            var touch = value.touches[0];
                            this.mouseX = touch.clientX
                        }
                    } else
                        this.mouseX = value.offsetX
                },
                onDrag: function() {
                    1 == this.dragStart && (this.dragStartX - this.mouseX > 0 ? this.dragDirection = 1 : this.dragDirection = -1,
                        this.dragDistanceX = this.dragStartX - this.mouseX,
                    0 != this.dragDistanceX && (this.scrollX = _mathTools2.default.clamp(this.scrollX + 5e-6 * this.dragDistanceX, 0, 1)),
                        this.velocity[0] = this.velocity[1],
                        this.velocity[1] = this.mouseX)
                },
                stopDrag: function() {
                    this.dragStopPosition = this.scrollX,
                        this.dragSmooth = !0,
                        this.dragEasing = .01,
                        this.dragStart = !1,
                        this.dragTimeout = setTimeout(function() {
                            this.dragSmooth = !1
                        }
                            .bind(this), 2e3)
                },
                stopDragLeave: function() {
                    this.dragSmooth = !1,
                        this.dragStart = !1
                }
            },
            events: {
                onResize: function() {
                    this.scm && this.scm.resizeHandler()
                }
            },
            watch: {
                scrollX: function(value) {
                    this.endTimeout && clearTimeout(this.endTimeout),
                        value > .98 ? this.endTimeout = setTimeout(function() {
                            this.endScreen = !0
                        }
                            .bind(this), 700) : this.endScreen = !1
                },
                endScreen: function(value) {
                    this.$el.querySelector("canvas").style.pointerEvents = value ? "none" : "auto"
                },
                inputDebug: {
                    handler: function(value) {
                        this.$get("selected") && (this.selected.position.x = value.x,
                            this.selected.position.y = value.y,
                            this.selected.position.z = value.z,
                            this.selected.scale.x = value.scale,
                            this.selected.scale.y = value.scale,
                            this.selected.rotation.y = value.rotation)
                    },
                    deep: !0
                }
            }
        },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = '<div class="page-intro canvas-wrapper" :class="{\'noisy\':!titleScreen,\'grabbing\':dragStart}" @mousedown=startDrag @touchstart=startDrag @mousemove=mousePosition @touchmove=mousePosition @mouseup=stopDrag @touchend=stopDrag @mouseleave=stopDragLeave _v-7d619fc2=""><div class=debug v-if=selected _v-7d619fc2=""><ul _v-7d619fc2=""><li _v-7d619fc2=""><input type=text v-model=inputDebug.x _v-7d619fc2=""> <input type=range v-model=inputDebug.x max=3 min=-3 step=0.01 _v-7d619fc2="">&nbsp;x<li _v-7d619fc2=""><input type=text v-model=inputDebug.y _v-7d619fc2=""> <input type=range v-model=inputDebug.y max=3 min=-3 step=0.01 _v-7d619fc2="">&nbsp;y<li _v-7d619fc2=""><input type=text v-model=inputDebug.z _v-7d619fc2=""> <input type=range v-model=inputDebug.z max=3 min=-3 step=0.01 _v-7d619fc2="">&nbsp;z<li _v-7d619fc2=""><input type=text v-model=inputDebug.scale _v-7d619fc2=""> <input type=range v-model=inputDebug.scale max=2 min=0 step=0.01 _v-7d619fc2="">&nbsp;scale<li _v-7d619fc2=""><input type=text v-model=inputDebug.rotation _v-7d619fc2=""> <input type=range v-model=inputDebug.rotation max=1 min=-1 step=0.01 _v-7d619fc2="">&nbsp;rotation</ul><input type=text class=debug-result v-model=debugString _v-7d619fc2=""></div><img class=background v-if=isWebGL :class="{\'show\':!titleScreen}" :src=$root.data.home.pic :style="{\'transform\':\'translate3d(\' + bgX + \'px,0,0)\'}" _v-7d619fc2=""><div class=wrapper-intro :class="{\'show\':titleScreen}" _v-7d619fc2=""><p class="text-intro bloc-text" _v-7d619fc2="">{{{$root.data[\'home\'][\'intro\']}}}<p class=text-baseline _v-7d619fc2="">{{{$root.data[\'home\'][\'intro-baseline\']}}}</div><div class=scroll-intro v-if=isWebGL :class="{\'show\':titleScreen}" @click=onFirstMouseWheel _v-7d619fc2=""><div class=scroll _v-7d619fc2=""><div class=text _v-7d619fc2="">{{{$root.data[\'global-wording\'][\'scroll\']}}}</div><div class=top _v-7d619fc2=""></div><div class=bot _v-7d619fc2=""></div></div></div><a class=text-link v-if=!isWebGL v-link="{ path: ($root.prefixURL + $root.data[\'home\'][\'link\'][\'url\']), exact: true }" _v-7d619fc2="">{{$root.data.home.link.label}}</a><div class=wrapper-text v-if=isWebGL :class="{\'show\':!titleScreen, \'end\':endScreen}" :style="{\'transform\':\'translate3d(\' + textX + \'px,0,0)\',\'width\' : textWidth + \'px\'}" _v-7d619fc2=""><div class=bloc-wrapper v-for="bloc in texts" :style="{\'left\': bloc.offset + \'vh\'}" _v-7d619fc2=""><div class=bloc _v-7d619fc2=""><p class="text-top bloc-text" _v-7d619fc2="">{{{bloc.text}}}<p class="text-bottom bloc-text-sub" _v-7d619fc2="">{{{bloc.sub}}}<div v-if="$index == texts.length - 1" class=wrapper-outro :class="{\'show\':endScreen}" v-show=!titleScreen _v-7d619fc2=""><p class="text-top bloc-text" _v-7d619fc2=""><div class=text-effect _v-7d619fc2=""><a class=text-link v-link="{ path:(this.$root.prefixURL + $root.data[\'home\'][\'link\'][\'url\'])}" _v-7d619fc2="">{{{$root.data[\'home\'][\'outro\']}}}</a><div class=effet _v-7d619fc2=""></div></div><p _v-7d619fc2=""></div></div></div></div><div class=line _v-7d619fc2=""></div><div class=drag :class="{\'hide\':dragShow}" _v-7d619fc2=""><span _v-7d619fc2="">drag</span></div></div>'
    }
        , {
            "../../node_modules/gsap": 80,
            "../scripts/mathTools": 129,
            "../scripts/threeTools/sceneManager": 132,
            THREE: 1,
            "vueify/lib/insert-css": 103
        }],
    110: [function(require, module, exports) {
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full[_v-31f71770]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-absolute-full[_v-31f71770],.loader[_v-31f71770]{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full[_v-31f71770]{display:block;width:100%;height:100%}.common-center-cover[_v-31f71770]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover[_v-31f71770],.common-hover[_v-31f71770]:hover{color:#7ad71f}.common-hover[_v-31f71770]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-31f71770]{display:block;text-align:center}.loader[_v-31f71770]{z-index:3}.loader .progress[_v-31f71770]{position:relative;font-size:90em;font-weight:700;text-align:center;opacity:0;-webkit-transition:opacity .3s;transition:opacity .3s}.loader.fake[_v-31f71770]:after{content:'* fake loading';position:absolute;right:10px;bottom:10px;font-size:15px;opacity:.3}.loader.show .progress[_v-31f71770]{opacity:1}#app.is-mobile .loader .progress[_v-31f71770]{font-size:40em}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var preloader = require("preloader");
        exports.default = {
            filters: {
                "two-digits": function(value) {
                    return value < 10 ? "0" + value : value
                }
            },
            data: function() {
                return {
                    progress: 0,
                    smoothProgress: 0,
                    isAnimating: !1,
                    isFake: !1,
                    vueID: null
                }
            },
            computed: {},
            ready: function() {
                this.assets = []
            },
            attached: function() {},
            methods: {
                loadQueue: function(urls, vueID) {
                    var queue = [];
                    this.$set("progress", 0),
                        this.$set("smoothProgress", 0),
                        this.$set("vueID", vueID),
                        urls.constructor === Array ? urls.map(function(el, index) {
                            "" === el || this.getLoadedAsset(el) || queue.push(el)
                        }
                            .bind(this)) : "" === urls || this.getLoadedAsset(urls) || queue.push(urls);
                    var loader = preloader({
                        xhrImages: !1,
                        loadFullAudio: !1,
                        loadFullVideo: !1
                    });
                    loader.on("complete", this.onComplete),
                        loader.on("progress", this.onProgress),
                        queue.map(function(url) {
                            loader.add(url, {
                                onComplete: function(content) {
                                    this.assets[url] = content
                                }
                                    .bind(this)
                            })
                        }
                            .bind(this)),
                    0 === queue.length && this.$set("progress", 100),
                        this.$dispatch("onLoadStart", this.vueID),
                        loader.load(),
                        setTimeout(function() {
                            this.progress < 50 ? this.onStartAnim() : this.$dispatch("onLoadAlready", this.vueID)
                        }
                            .bind(this), 100)
                },
                startFakeLoading: function() {
                    this.$set("progress", 0),
                        this.$set("isFake", !0),
                        this.isAnimating = !0,
                        this.$dispatch("onLoadAnimStart", this.vueID),
                        this.$on("onEnterFrame", this.renderFake)
                },
                onStartAnim: function() {
                    this.isAnimating = !0,
                        this.$dispatch("onLoadAnimStart", this.vueID),
                        this.$on("onEnterFrame", this.render)
                },
                onStopAnim: function() {
                    this.isAnimating = !1,
                        setTimeout(function() {
                            this.$dispatch("onLoadAnimStop", this.vueID)
                        }
                            .bind(this), 500)
                },
                onProgress: function(progress) {
                    this.$set("progress", 100 * progress),
                        this.$dispatch("onLoadProgress", progress, this.vueID)
                },
                onComplete: function() {
                    this.$dispatch("onLoadComplete", this.vueID)
                },
                render: function() {
                    this.smoothProgress = Math.min(this.smoothProgress + .9 * (this.progress - this.smoothProgress), 100),
                        this.$dispatch("onLoadSmoothProgress", this.smoothProgress, this.vueID),
                    Math.round(this.smoothProgress) >= 100 && (this.$off("onEnterFrame", this.render),
                    this.isAnimating && this.onStopAnim())
                },
                renderFake: function() {
                    this.onProgress(.01 * this.progress + .05),
                        this.render(),
                    this.isAnimating || (this.onComplete(),
                        this.$set("isFake", !1),
                        this.$off("onEnterFrame", this.renderFake))
                },
                getLoadedAsset: function(url) {
                    return this.assets[url]
                }
            },
            components: {},
            events: {
                onLoadRequest: "loadQueue"
            }
        },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = "<div class=loader v-bind:class=\"{'show':isAnimating, 'fake':isFake}\" _v-31f71770=\"\"><p class=progress v-bind:style=\"{'line-height':$root.size.h+'px'}\" _v-31f71770=\"\">{{Math.round(smoothProgress) | two-digits}}</div>"
    }
        , {
            preloader: 83,
            "vueify/lib/insert-css": 103
        }],
    111: [function(require, module, exports) {
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full[_v-1cdfc49d]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app header .lang[_v-1cdfc49d],#app header .nav-burger[_v-1cdfc49d]:before,#app header[_v-1cdfc49d],.common-absolute-full[_v-1cdfc49d]{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full[_v-1cdfc49d]{display:block;width:100%;height:100%}.common-center-cover[_v-1cdfc49d]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover[_v-1cdfc49d],.common-hover[_v-1cdfc49d]:hover{color:#7ad71f}.common-hover[_v-1cdfc49d]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-1cdfc49d]{display:block;text-align:center}#app.is-mobile header.opened .text-sub-item a[_v-1cdfc49d],#app.is-mobile header.opened .text-sub-item a[_v-1cdfc49d]:active,#app.is-mobile header.opened .text-sub-item a[_v-1cdfc49d]:hover,#app.is-mobile header.opened .text-sub-item a[_v-1cdfc49d]:visited,#app.is-mobile header.opened a.logo[_v-1cdfc49d],#app.is-mobile header.opened a.logo[_v-1cdfc49d]:active,#app.is-mobile header.opened a.logo[_v-1cdfc49d]:hover,#app.is-mobile header.opened a.logo[_v-1cdfc49d]:visited,#app.is-mobile header.opened a.text-item[_v-1cdfc49d],#app.is-mobile header.opened a.text-item[_v-1cdfc49d]:active,#app.is-mobile header.opened a.text-item[_v-1cdfc49d]:hover,#app.is-mobile header.opened a.text-item[_v-1cdfc49d]:visited,#app.is-mobile header.opened a.text-sub-item[_v-1cdfc49d],#app.is-mobile header.opened a.text-sub-item[_v-1cdfc49d]:active,#app.is-mobile header.opened a.text-sub-item[_v-1cdfc49d]:hover,#app.is-mobile header.opened a.text-sub-item[_v-1cdfc49d]:visited,#app.theme-light .text-sub-item a[_v-1cdfc49d],#app.theme-light .text-sub-item a[_v-1cdfc49d]:active,#app.theme-light .text-sub-item a[_v-1cdfc49d]:hover,#app.theme-light .text-sub-item a[_v-1cdfc49d]:visited,#app.theme-light a.logo[_v-1cdfc49d],#app.theme-light a.logo[_v-1cdfc49d]:active,#app.theme-light a.logo[_v-1cdfc49d]:hover,#app.theme-light a.logo[_v-1cdfc49d]:visited,#app.theme-light a.text-item[_v-1cdfc49d],#app.theme-light a.text-item[_v-1cdfc49d]:active,#app.theme-light a.text-item[_v-1cdfc49d]:hover,#app.theme-light a.text-item[_v-1cdfc49d]:visited,#app.theme-light a.text-sub-item[_v-1cdfc49d],#app.theme-light a.text-sub-item[_v-1cdfc49d]:active,#app.theme-light a.text-sub-item[_v-1cdfc49d]:hover,#app.theme-light a.text-sub-item[_v-1cdfc49d]:visited{color:#151516}#app.is-mobile header.opened .nav-item[_v-1cdfc49d]:after,#app.theme-light .nav-item[_v-1cdfc49d]:after{border-color:#151516}#app.theme-light header a.logo[_v-1cdfc49d]{font-size:25px}#app.theme-light header a.logo.anim[_v-1cdfc49d],#app.theme-light header a.logo[_v-1cdfc49d]{background-image:url(/assets/img/header/RS-blanc.png);background-size:35px 35px;background-position:2px 0}#app.theme-light header a.logo.anim[_v-1cdfc49d]{-webkit-animation:logomobile 0s .5s forwards;animation:logomobile 0s .5s forwards}#app header[_v-1cdfc49d]{width:calc(100% - 20px);height:auto;bottom:auto;box-sizing:border-box;padding:40em calc(50em - 20px) 0 50em;color:#fff;z-index:10}#app header .text-sub-item a[_v-1cdfc49d],#app header .text-sub-item a[_v-1cdfc49d]:active,#app header .text-sub-item a[_v-1cdfc49d]:hover,#app header .text-sub-item a[_v-1cdfc49d]:visited,#app header a.logo[_v-1cdfc49d],#app header a.logo[_v-1cdfc49d]:active,#app header a.logo[_v-1cdfc49d]:hover,#app header a.logo[_v-1cdfc49d]:visited,#app header a.text-item[_v-1cdfc49d],#app header a.text-item[_v-1cdfc49d]:active,#app header a.text-item[_v-1cdfc49d]:hover,#app header a.text-item[_v-1cdfc49d]:visited,#app header a.text-sub-item[_v-1cdfc49d],#app header a.text-sub-item[_v-1cdfc49d]:active,#app header a.text-sub-item[_v-1cdfc49d]:hover,#app header a.text-sub-item[_v-1cdfc49d]:visited{color:#fff;-webkit-transition:opacity .3s;transition:opacity .3s;-webkit-transition:opacity .3s,color .5s cubic-bezier(.55,.055,.675,.19);transition:opacity .3s,color .5s cubic-bezier(.55,.055,.675,.19)}#app header .logo[_v-1cdfc49d]{float:left;margin:0;padding:0;text-indent:-250px;font-size:30em;line-height:normal;font-weight:700;text-transform:lowercase;text-decoration:none;vertical-align:middle;width:35px;height:35px;display:block;margin-top:-4px}#app header .logo.anim[_v-1cdfc49d]{background-image:url(/assets/img/header/reputationsquad-logo-blanc.png);background-size:1087px 35px;-webkit-animation:spritelogo 1s .5s steps(30) forwards;animation:spritelogo 1s .5s steps(30) forwards}#app header .text-item[_v-1cdfc49d]{text-transform:lowercase;font-size:18em;font-weight:600;text-decoration:none}#app header .text-sub-item[_v-1cdfc49d]{font-size:12em;font-weight:400;line-height:2.5em;text-decoration:underline}#app header .nav-items[_v-1cdfc49d]{text-align:right}#app header .nav-items li[_v-1cdfc49d]{display:inline}#app header .nav-item[_v-1cdfc49d]{position:relative;display:inline-block;margin-left:1.111111111111111em;padding:0 .555555555555556em;line-height:1.666666666666667em;vertical-align:middle}#app header .nav-item.highlighted[_v-1cdfc49d]:after,#app header .nav-item[_v-1cdfc49d]:hover:after{width:100%}#app header .nav-item[_v-1cdfc49d]:after{content:'';border-top:.111111111111111em solid #fff;position:absolute;margin:0 auto;width:0;left:0;right:0;top:50%;-webkit-transition:width .3s cubic-bezier(.68,0,.33,1) .1s;transition:width .3s cubic-bezier(.68,0,.33,1) .1s;-webkit-transition:width .3s cubic-bezier(.68,0,.33,1) .1s,border-color .5s cubic-bezier(.55,.055,.675,.19);transition:width .3s cubic-bezier(.68,0,.33,1) .1s,border-color .5s cubic-bezier(.55,.055,.675,.19)}#app header .nav-item-lang[_v-1cdfc49d]{position:relative;vertical-align:middle;-webkit-transition:opacity .3s;transition:opacity .3s;cursor:pointer}#app header .nav-item-lang[_v-1cdfc49d]:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%}#app header .nav-item-lang[_v-1cdfc49d]:after{display:none}#app header .nav-item-lang:hover .lang[_v-1cdfc49d]{display:block;opacity:.5;pointer-events:auto}#app header .nav-item-lang:hover .lang[_v-1cdfc49d]:first-child,#app header .nav-item-lang:hover .lang[_v-1cdfc49d]:hover{opacity:1}#app header .nav-item-lang[_v-1cdfc49d]:hover:before{height:200%}#app header .lang[_v-1cdfc49d]{position:absolute;pointer-events:none;top:3em;text-align:center;opacity:0;-webkit-transition:opacity .3s;transition:opacity .3s}#app header .lang.active[_v-1cdfc49d]{position:static;display:block;opacity:.5}#app header .nav-socials-wrapper[_v-1cdfc49d]{position:fixed;bottom:50em;right:50em;text-align:right}#app header .nav-socials-wrapper .nav-socials-button[_v-1cdfc49d]{opacity:.5;-webkit-transition:opacity .5s .4s;transition:opacity .5s .4s}#app header .nav-socials-wrapper .nav-socials .text-sub-item[_v-1cdfc49d]{opacity:.5}#app header .nav-socials-wrapper .nav-socials .text-sub-item[_v-1cdfc49d]:hover{opacity:1}#app header .nav-socials-wrapper:hover .nav-socials-button[_v-1cdfc49d]{opacity:0;-webkit-transition:opacity .5s 0s;transition:opacity .5s 0s}#app header .nav-socials-wrapper:hover .nav-socials[_v-1cdfc49d]{pointer-events:auto;opacity:1;-webkit-transition:opacity .5s .4s;transition:opacity .5s .4s}#app header .nav-socials[_v-1cdfc49d]{position:absolute;pointer-events:none;bottom:0;right:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse;opacity:0;-webkit-transition:opacity .5s 0s;transition:opacity .5s 0s}#app header .nav-mentions-wrapper[_v-1cdfc49d]{position:fixed;bottom:50em;left:50em}#app header .nav-mentions[_v-1cdfc49d]{opacity:.5}#app header .nav-mentions[_v-1cdfc49d]:hover{opacity:1}#app header .nav-burger[_v-1cdfc49d]{position:relative;width:46em;height:46em;box-sizing:border-box;cursor:pointer;position:absolute;top:25em;right:40em;display:none;padding:16em;z-index:1}#app header .nav-burger .button-label[_v-1cdfc49d]{position:relative;z-index:2;line-height:46em;text-align:center;font-size:10em;font-weight:700;opacity:1;-webkit-transition:opacity .3s;transition:opacity .3s}#app header .nav-burger[_v-1cdfc49d]:before{content:'';display:block;border-radius:50%;background-color:#fff;z-index:1;-webkit-transform:scale(1);transform:scale(1);-webkit-transition:-webkit-transform .3s;transition:-webkit-transform .3s;transition:transform .3s;transition:transform .3s,-webkit-transform .3s}#app header .nav-burger[_v-1cdfc49d]:hover:before{-webkit-transform:scale(1.05);transform:scale(1.05)}#app header .nav-burger .button-open-close[_v-1cdfc49d]{position:relative;z-index:1;fill:#151516}#app header .nav-burger .button-open[_v-1cdfc49d]{opacity:1}#app header .nav-burger .button-close[_v-1cdfc49d]{opacity:0}#app header .nav-burger .button-close[_v-1cdfc49d],#app header .nav-burger .button-open[_v-1cdfc49d]{-webkit-transition:opacity .1s;transition:opacity .1s}#app header .nav-burger[_v-1cdfc49d]:before{-webkit-transition:-webkit-transform .5s .25s;transition:-webkit-transform .5s .25s;transition:transform .5s .25s;transition:transform .5s .25s,-webkit-transform .5s .25s}@-moz-keyframes spritelogo{0%{background-position-x:0}to{background-position-x:-1050px}}@-webkit-keyframes spritelogo{0%{background-position-x:0}to{background-position-x:-1050px}}@-o-keyframes spritelogo{0%{background-position-x:0}to{background-position-x:-1050px}}@keyframes spritelogo{0%{background-position-x:0}to{background-position-x:-1050px}}#app.is-mobile header[_v-1cdfc49d]{padding:25em 40em 40em;height:100%;z-index:3;pointer-events:none}#app.is-mobile header nav[_v-1cdfc49d]{height:100%}#app.is-mobile header .logo[_v-1cdfc49d]{position:absolute;z-index:3;font-size:30em;line-height:1.533333333333333em;pointer-events:all;width:55px;height:55px;display:block;margin-top:-4px}#app.is-mobile header .logo.anim[_v-1cdfc49d]{background-image:url(/assets/img/header/reputationsquad-logo-blanc.png);background-size:1705px 55px;-webkit-animation:spritelogomobile 1s steps(30) forwards;animation:spritelogomobile 1s steps(30) forwards}#app.is-mobile header .nav-burger[_v-1cdfc49d]{display:block;pointer-events:all}#app.is-mobile header .text-item[_v-1cdfc49d]{font-size:25em;font-weight:700}#app.is-mobile header .text-sub-item[_v-1cdfc49d]{font-size:12em;font-weight:700;line-height:normal}#app.is-mobile header .nav-items[_v-1cdfc49d]{position:relative;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:100%;z-index:5}#app.is-mobile header .nav-items-wrapper[_v-1cdfc49d],#app.is-mobile header .nav-items[_v-1cdfc49d]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;pointer-events:none}#app.is-mobile header .nav-items-wrapper[_v-1cdfc49d]{opacity:0;-webkit-transition:opacity .5s cubic-bezier(.79,0,.24,1) 0s;transition:opacity .5s cubic-bezier(.79,0,.24,1) 0s}#app.is-mobile header .nav-items-wrapper .nav-item.text-item[_v-1cdfc49d]{display:inline-block;margin:.6em 0;line-height:normal;text-align:center;-webkit-transform:translateZ(0);transform:translateZ(0);color:#151516}#app.is-mobile header .nav-items-wrapper .nav-item.text-item[_v-1cdfc49d]:nth-of-type(1){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) 0s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) 0s;transition:transform .5s cubic-bezier(.79,0,.24,1) 0s;transition:transform .5s cubic-bezier(.79,0,.24,1) 0s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) 0s}#app.is-mobile header .nav-items-wrapper .nav-item.text-item[_v-1cdfc49d]:nth-of-type(2){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .03s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .03s;transition:transform .5s cubic-bezier(.79,0,.24,1) .03s;transition:transform .5s cubic-bezier(.79,0,.24,1) .03s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .03s}#app.is-mobile header .nav-items-wrapper .nav-item.text-item[_v-1cdfc49d]:nth-of-type(3){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .06s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .06s;transition:transform .5s cubic-bezier(.79,0,.24,1) .06s;transition:transform .5s cubic-bezier(.79,0,.24,1) .06s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .06s}#app.is-mobile header .nav-items-wrapper .nav-item.text-item[_v-1cdfc49d]:nth-of-type(4){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .09s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .09s;transition:transform .5s cubic-bezier(.79,0,.24,1) .09s;transition:transform .5s cubic-bezier(.79,0,.24,1) .09s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .09s}#app.is-mobile header .nav-items-wrapper .nav-item.text-item[_v-1cdfc49d]:nth-of-type(5){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .12s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .12s;transition:transform .5s cubic-bezier(.79,0,.24,1) .12s;transition:transform .5s cubic-bezier(.79,0,.24,1) .12s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .12s}#app.is-mobile header .nav-items-wrapper .nav-item.text-item[_v-1cdfc49d]:nth-of-type(6){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .15s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .15s;transition:transform .5s cubic-bezier(.79,0,.24,1) .15s;transition:transform .5s cubic-bezier(.79,0,.24,1) .15s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .15s}#app.is-mobile header .nav-items-wrapper .nav-item.text-item[_v-1cdfc49d]:nth-of-type(7){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .18s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .18s;transition:transform .5s cubic-bezier(.79,0,.24,1) .18s;transition:transform .5s cubic-bezier(.79,0,.24,1) .18s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .18s}#app.is-mobile header .nav-items-wrapper .nav-item.text-item[_v-1cdfc49d]:nth-of-type(8){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .21s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .21s;transition:transform .5s cubic-bezier(.79,0,.24,1) .21s;transition:transform .5s cubic-bezier(.79,0,.24,1) .21s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .21s}#app.is-mobile header .nav-items-wrapper .nav-item.text-item[_v-1cdfc49d]:nth-of-type(9){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .23s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .23s;transition:transform .5s cubic-bezier(.79,0,.24,1) .23s;transition:transform .5s cubic-bezier(.79,0,.24,1) .23s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .23s}#app.is-mobile header .nav-socials-wrapper[_v-1cdfc49d]{position:static;width:100%;pointer-events:none}#app.is-mobile header .nav-socials[_v-1cdfc49d]{position:absolute;bottom:40em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-pack:distribute;justify-content:space-around;width:100%;opacity:0;pointer-events:auto;pointer-events:none}#app.is-mobile header .nav-socials .text-sub-item[_v-1cdfc49d]{opacity:0;-webkit-transition:opacity .5s cubic-bezier(.79,0,.24,1) 0s;transition:opacity .5s cubic-bezier(.79,0,.24,1) 0s}#app.is-mobile header .nav-socials .text-sub-item[_v-1cdfc49d]:hover{opacity:0}#app.is-mobile header .nav-mentions-wrapper[_v-1cdfc49d],#app.is-mobile header .nav-socials-button[_v-1cdfc49d]{display:none}#app.is-mobile header .nav-lang-wrapper[_v-1cdfc49d]{position:absolute;bottom:0;width:100%;display:block;opacity:0;-webkit-transition:opacity .5s cubic-bezier(.79,0,.24,1) 0s;transition:opacity .5s cubic-bezier(.79,0,.24,1) 0s;pointer-events:none}#app.is-mobile header .nav-item-lang[_v-1cdfc49d]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:100%;margin:0;padding:0;pointer-events:none}#app.is-mobile header .nav-item-lang[_v-1cdfc49d]:before{display:none}#app.is-mobile header .lang[_v-1cdfc49d]{position:static;display:inline-block;opacity:.5;pointer-events:auto;width:auto;padding:0 1em;pointer-events:none}#app.is-mobile header .lang[_v-1cdfc49d]:first-child{font-weight:700}#app.is-mobile header .shapes[_v-1cdfc49d]{opacity:0;z-index:1;-webkit-transition:all .5s cubic-bezier(.79,0,.24,1) 0s;transition:all .5s cubic-bezier(.79,0,.24,1) 0s}#app.is-mobile header .shapes .svg-shapes[_v-1cdfc49d]{stroke:#ebeded;-webkit-transition:all 0s cubic-bezier(.79,0,.24,1) 0s;transition:all 0s cubic-bezier(.79,0,.24,1) 0s}#app.is-mobile header .shapes .svg-shapes-color[_v-1cdfc49d]{opacity:0;-webkit-transition:all 0s cubic-bezier(.79,0,.24,1) 0s;transition:all 0s cubic-bezier(.79,0,.24,1) 0s}@-moz-keyframes spritelogomobile{0%{background-position-x:0}to{background-position-x:-1650px}}@-webkit-keyframes spritelogomobile{0%{background-position-x:0}to{background-position-x:-1650px}}@-o-keyframes spritelogomobile{0%{background-position-x:0}to{background-position-x:-1650px}}@keyframes spritelogomobile{0%{background-position-x:0}to{background-position-x:-1650px}}#app.is-mobile header.opened[_v-1cdfc49d]{height:100%;pointer-events:all;z-index:11}#app.is-mobile header.opened .logo[_v-1cdfc49d]{z-index:6;pointer-events:all}#app.is-mobile header.opened .logo.anim[_v-1cdfc49d]{background-image:url(/assets/img/header/RS-blanc.png);background-size:55px 55px;background-position:0 0;-webkit-animation:logomobile 0s .5s forwards;animation:logomobile 0s .5s forwards}#app.is-mobile header.opened .nav-items[_v-1cdfc49d]{display:-webkit-box;display:-ms-flexbox;display:flex;height:100%;z-index:5;pointer-events:all}#app.is-mobile header.opened .nav-burger .button-open[_v-1cdfc49d]{opacity:0}#app.is-mobile header.opened .nav-burger .button-close[_v-1cdfc49d]{opacity:1}#app.is-mobile header.opened .nav-burger[_v-1cdfc49d]:before{-webkit-transform:scale(30);transform:scale(30);-webkit-transition:-webkit-transform .75s cubic-bezier(.79,0,.24,1) 0s;transition:-webkit-transform .75s cubic-bezier(.79,0,.24,1) 0s;transition:transform .75s cubic-bezier(.79,0,.24,1) 0s;transition:transform .75s cubic-bezier(.79,0,.24,1) 0s,-webkit-transform .75s cubic-bezier(.79,0,.24,1) 0s}#app.is-mobile header.opened .nav-items-wrapper[_v-1cdfc49d]{opacity:1;-webkit-transition:opacity .5s cubic-bezier(.79,0,.24,1) .25s;transition:opacity .5s cubic-bezier(.79,0,.24,1) .25s;pointer-events:all}#app.is-mobile header.opened .nav-items-wrapper .nav-item[_v-1cdfc49d]{-webkit-transform:translate3d(0,-30px,0);transform:translate3d(0,-30px,0)}#app.is-mobile header.opened .nav-items-wrapper .nav-item[_v-1cdfc49d]:nth-of-type(1){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .25s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .25s;transition:transform .5s cubic-bezier(.79,0,.24,1) .25s;transition:transform .5s cubic-bezier(.79,0,.24,1) .25s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .25s}#app.is-mobile header.opened .nav-items-wrapper .nav-item[_v-1cdfc49d]:nth-of-type(2){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .28s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .28s;transition:transform .5s cubic-bezier(.79,0,.24,1) .28s;transition:transform .5s cubic-bezier(.79,0,.24,1) .28s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .28s}#app.is-mobile header.opened .nav-items-wrapper .nav-item[_v-1cdfc49d]:nth-of-type(3){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .31s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .31s;transition:transform .5s cubic-bezier(.79,0,.24,1) .31s;transition:transform .5s cubic-bezier(.79,0,.24,1) .31s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .31s}#app.is-mobile header.opened .nav-items-wrapper .nav-item[_v-1cdfc49d]:nth-of-type(4){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .34s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .34s;transition:transform .5s cubic-bezier(.79,0,.24,1) .34s;transition:transform .5s cubic-bezier(.79,0,.24,1) .34s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .34s}#app.is-mobile header.opened .nav-items-wrapper .nav-item[_v-1cdfc49d]:nth-of-type(5){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .37s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .37s;transition:transform .5s cubic-bezier(.79,0,.24,1) .37s;transition:transform .5s cubic-bezier(.79,0,.24,1) .37s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .37s}#app.is-mobile header.opened .nav-items-wrapper .nav-item[_v-1cdfc49d]:nth-of-type(6){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .4s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .4s;transition:transform .5s cubic-bezier(.79,0,.24,1) .4s;transition:transform .5s cubic-bezier(.79,0,.24,1) .4s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .4s}#app.is-mobile header.opened .nav-items-wrapper .nav-item[_v-1cdfc49d]:nth-of-type(7){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .43s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .43s;transition:transform .5s cubic-bezier(.79,0,.24,1) .43s;transition:transform .5s cubic-bezier(.79,0,.24,1) .43s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .43s}#app.is-mobile header.opened .nav-items-wrapper .nav-item[_v-1cdfc49d]:nth-of-type(8){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .46s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .46s;transition:transform .5s cubic-bezier(.79,0,.24,1) .46s;transition:transform .5s cubic-bezier(.79,0,.24,1) .46s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .46s}#app.is-mobile header.opened .nav-items-wrapper .nav-item[_v-1cdfc49d]:nth-of-type(9){-webkit-transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .49s;transition:-webkit-transform .5s cubic-bezier(.79,0,.24,1) .49s;transition:transform .5s cubic-bezier(.79,0,.24,1) .49s;transition:transform .5s cubic-bezier(.79,0,.24,1) .49s,-webkit-transform .5s cubic-bezier(.79,0,.24,1) .49s}#app.is-mobile header.opened .nav-socials[_v-1cdfc49d]{opacity:1;-webkit-transition:opacity .5s cubic-bezier(.79,0,.24,1) .5s;transition:opacity .5s cubic-bezier(.79,0,.24,1) .5s;pointer-events:all}#app.is-mobile header.opened .nav-socials .text-sub-item[_v-1cdfc49d]{opacity:.5}#app.is-mobile header.opened .nav-socials .text-sub-item[_v-1cdfc49d]:hover{opacity:1}#app.is-mobile header.opened .nav-lang-wrapper[_v-1cdfc49d]{opacity:1;-webkit-transition:opacity .5s cubic-bezier(.79,0,.24,1) .8s;transition:opacity .5s cubic-bezier(.79,0,.24,1) .8s;pointer-events:all}#app.is-mobile header.opened .lang[_v-1cdfc49d]{pointer-events:all}#app.is-mobile header.opened .shapes[_v-1cdfc49d]{opacity:1;-webkit-transition:all .5s cubic-bezier(.79,0,.24,1) .25s;transition:all .5s cubic-bezier(.79,0,.24,1) .25s}#app.is-mobile header.opened .svg-shapes[_v-1cdfc49d]{stroke:#ebeded;-webkit-transition:all 0s cubic-bezier(.79,0,.24,1) 0s;transition:all 0s cubic-bezier(.79,0,.24,1) 0s}#app.is-mobile header.opened .svg-shapes-color[_v-1cdfc49d]{opacity:0;-webkit-transition:all 0s cubic-bezier(.79,0,.24,1) 0s;transition:all 0s cubic-bezier(.79,0,.24,1) 0s}@-moz-keyframes logomobile{0%{background-image:url(/assets/img/header/RS-blanc.png)}to{background-image:url(/assets/img/header/RS-noir.png)}}@-webkit-keyframes logomobile{0%{background-image:url(/assets/img/header/RS-blanc.png)}to{background-image:url(/assets/img/header/RS-noir.png)}}@-o-keyframes logomobile{0%{background-image:url(/assets/img/header/RS-blanc.png)}to{background-image:url(/assets/img/header/RS-noir.png)}}@keyframes logomobile{0%{background-image:url(/assets/img/header/RS-blanc.png)}to{background-image:url(/assets/img/header/RS-noir.png)}}#app.is-mobile.theme-light header a.logo.anim[_v-1cdfc49d]{background-image:url(/assets/img/header/RS-noir.png);background-size:55px 55px;background-position:0 0}.fade-transition[_v-1cdfc49d]{-webkit-transition:opacity 1s;transition:opacity 1s}.fade-enter[_v-1cdfc49d],.fade-leave[_v-1cdfc49d]{opacity:0}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }),
            exports.default = {
                data: function() {
                    return {
                        isOpen: !1,
                        animLogo: !1,
                        url: ""
                    }
                },
                computed: {
                    pageURL: function() {
                        return "/" + this.$route.path.split("/")[1]
                    },
                    legalData: function() {
                        var key = "fr" === this.$root.lang ? "mentions" : "legal"
                            , data = null;
                        return this.$root.data && this.$root.data[key] && this.$root.data[key][0] && (data = this.$root.data[key][0]),
                            data
                    },
                    urlForLogo: function() {
                        this.url != this.$root.url && (this.animLogo = !1),
                            this.url = this.$root.url,
                            setTimeout(function() {
                                this.animLogo = !0
                            }
                                .bind(this), 500)
                    }
                },
                ready: function() {
                    this.animLogo = !0
                },
                attached: function() {},
                methods: {
                    switchMenu: function() {
                        this.isOpen = !this.isOpen
                    },
                    closeMenu: function() {
                        this.isOpen = !1
                    },
                    isFacebookApp: function() {
                        var ua = navigator.userAgent || navigator.vendor || window.opera;
                        return ua.indexOf("FBAN") > -1 || ua.indexOf("FBAV") > -1
                    }
                },
                watch: {
                    isOpen: function(value) {
                        this.$dispatch(value ? "onOpenMobileNav" : "onCloseMobileNav")
                    },
                    urlForLogo: function() {
                        return !0
                    }
                },
                components: {}
            },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = '<header :class="{\'opened\':isOpen}" transition=fade _v-1cdfc49d=""><div class=nav-burger @click=switchMenu() _v-1cdfc49d=""><svg class=button-open-close viewBox="0 0 14 14" _v-1cdfc49d=""><g class=button-open _v-1cdfc49d=""><rect x=0 y=0 width=14 height=2 _v-1cdfc49d=""></rect><rect x=0 y=6 width=14 height=2 _v-1cdfc49d=""></rect><rect x=0 y=12 width=14 height=2 _v-1cdfc49d=""></rect></g><g class=button-close transform="translate(7, -3) rotate(45)" _v-1cdfc49d=""><rect x=0 y=6 width=14 height=2 _v-1cdfc49d=""></rect><rect x=6 y=0 width=2 height=14 _v-1cdfc49d=""></rect></g></svg></div><shapes v-if=$root.isMobile _v-1cdfc49d=""></shapes><nav _v-1cdfc49d=""><a class=logo v-link="{ path: \'/\', exact: true }" :class="{\'anim\':animLogo}" @click=closeMenu() title="Reputation Squad Home" _v-1cdfc49d="">RS</a><ul class=nav-items v-if=$root.data @click=closeMenu() _v-1cdfc49d=""><li class=nav-items-wrapper _v-1cdfc49d=""><a class="nav-item text-item" v-for="item in $root.data.menu" v-link="{\'path\':($root.prefixURL + item.url)}" :class="{\'highlighted\':pageURL === item.url}" _v-1cdfc49d="">{{item.label}}</a><li class=nav-socials-wrapper v-if="$root.data &amp;&amp; $root.data.social &amp;&amp; $root.data.social.networks.length" _v-1cdfc49d=""><a class="nav-socials-button text-sub-item" _v-1cdfc49d="">{{$root.data.social.label}}</a><ul class=nav-socials _v-1cdfc49d=""><li v-for="ntw in $root.data.social.networks" _v-1cdfc49d=""><a class=text-sub-item :href=ntw.url target=_blank _v-1cdfc49d="">{{ntw.name}}</a></ul><li class=nav-lang-wrapper _v-1cdfc49d=""><ul v-if="$root.lang === \'fr\'" class="nav-item nav-item-lang text-sub-item" _v-1cdfc49d=""><li class="lang active" _v-1cdfc49d=""><a _v-1cdfc49d="">fr</a><li class=lang _v-1cdfc49d=""><a v-link="{ path:\'/\', exact: true }" _v-1cdfc49d="">en</a></ul><ul v-else="" class="nav-item nav-item-lang text-sub-item" _v-1cdfc49d=""><li class="lang active" _v-1cdfc49d=""><a _v-1cdfc49d="">en</a><li class=lang _v-1cdfc49d=""><a v-link="{ path:\'/fr\', exact: true }" _v-1cdfc49d="">fr</a></ul></ul><div class=nav-mentions-wrapper v-if=legalData _v-1cdfc49d=""><a class="nav-mentions text-sub-item" v-link="{\'path\':($root.prefixURL + legalData.url)}" _v-1cdfc49d="">{{legalData.title}}</a></div></nav></header>'
    }
        , {
            "vueify/lib/insert-css": 103
        }],
    112: [function(require, module, exports) {
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full{position:fixed}.common-absolute-full,.common-fixed-full{top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-absolute-full{position:absolute}.common-block-full{display:block;width:100%;height:100%}.common-center-cover{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover,.common-hover:hover{color:#7ad71f}.common-hover{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center{display:block;text-align:center}.lost{position:absolute;bottom:0;left:0;right:0;margin:0 auto}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }),
            exports.default = {
                ready: function() {
                    this.$root.UILightFlag = !1,
                        this.$root.BGLightFlag = !1
                }
            },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = "<div><img class=lost src=https://2.bp.blogspot.com/-PMd9kQ1fbOo/VltfSOOubwI/AAAAAAAAAIk/n6v7sL_nOBY/s1600/john-travolta-pulp-fiction-tiempos-violentos-gif-transparente-4mb.gif></div>"
    }
        , {
            "vueify/lib/insert-css": 103
        }],
    113: [function(require, module, exports) {
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full[_v-6103792c]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-absolute-full[_v-6103792c]{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full[_v-6103792c],.page-content .content-list[_v-6103792c],.page-content .line-item-infos[_v-6103792c],.page-content[_v-6103792c]{display:block;width:100%;height:100%}.common-center-cover[_v-6103792c]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover[_v-6103792c],.common-hover[_v-6103792c]:hover{color:#7ad71f}.common-hover[_v-6103792c]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-6103792c]{display:block;text-align:center}.page-content.loading[_v-6103792c]{-webkit-transition:opacity 0s;transition:opacity 0s}.page-content[_v-6103792c]{position:relative;-webkit-transition:opacity 1s;transition:opacity 1s;z-index:1}.page-content .content-list[_v-6103792c]{position:relative;-webkit-transition:opacity 0s .5s;transition:opacity 0s .5s}.page-content .content-list .content-item[_v-6103792c]{position:relative;width:100%;padding-top:150vh}.page-content .content-list .content-item .content-block[_v-6103792c]{position:relative;z-index:2;margin:0 auto;padding:50px 0}.page-content .content-list .content-item.has-preview[_v-6103792c]{padding-bottom:235em}.page-content .content-list .content-item.on-preview[_v-6103792c]{-webkit-transform:translate3d(0,-30vh,0);transform:translate3d(0,-30vh,0);-webkit-transition:-webkit-transform .5s .7s;transition:-webkit-transform .5s .7s;transition:transform .5s .7s;transition:transform .5s .7s,-webkit-transform .5s .7s}.page-content .line-item-infos[_v-6103792c]{position:fixed;z-index:2;pointer-events:none;bottom:50%}.page-content .line-item-infos .line-item-label[_v-6103792c]{position:absolute;left:10%;text-transform:lowercase;bottom:-.2em}.page-content .line-item-infos .line-item-index[_v-6103792c]{position:absolute;right:10%;bottom:-.2em}.page-content .nav-open .content-list[_v-6103792c]{-webkit-transition:opacity .4s 0s;transition:opacity .4s 0s;opacity:0}.page-content .nav-open .line-item-infos[_v-6103792c]{display:none}.is-mobile .page-content .content-list .content-item.has-preview[_v-6103792c]{padding-bottom:115em}.fade-transition[_v-6103792c]{opacity:1;-webkit-transition:opacity .5s;transition:opacity .5s}.fade-enter[_v-6103792c],.fade-leave[_v-6103792c]{opacity:0}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _stringify = require("babel-runtime/core-js/json/stringify")
            , _stringify2 = _interopRequireDefault(_stringify)
            , _Scroller = require("./Scroller.vue")
            , _Scroller2 = _interopRequireDefault(_Scroller)
            , _PageThumbs = require("./PageThumbs.vue")
            , _PageThumbs2 = _interopRequireDefault(_PageThumbs)
            , _PageNav = require("./PageNav.vue")
            , _PageNav2 = _interopRequireDefault(_PageNav)
            , _PageMobileNav = require("./PageMobileNav.vue")
            , _PageMobileNav2 = _interopRequireDefault(_PageMobileNav)
            , _Cover = require("./Cover.vue")
            , _Cover2 = _interopRequireDefault(_Cover)
            , _RSTemplate = require("./RSTemplate.vue")
            , _RSTemplate2 = _interopRequireDefault(_RSTemplate)
            , _Preview = require("./Preview.vue")
            , _Preview2 = _interopRequireDefault(_Preview);
        exports.default = {
            filters: {
                "two-digits": function(value) {
                    return value < 10 ? "0" + value : value
                }
            },
            data: function() {
                return {
                    dataSection: null,
                    dataPopin: null,
                    navFlag: -1,
                    thumbs: [],
                    itemSelected: 0,
                    sliderValue: 0,
                    scrollVHRatio: 0,
                    scrollIsTop: !1,
                    scrollIsBottom: !1,
                    introIsInit: !0,
                    subNavIsOpen: !1,
                    previewNextSelected: !1,
                    urlPage: "",
                    urlItem: "",
                    urlPopin: "",
                    progressIntro: 0,
                    coverNoFade: !1,
                    lang: null
                }
            },
            computed: {
                coverIntroInit: function() {
                    return this.introIsInit || this.$root.isLoading && !this.coverNoFade
                },
                dataCurrent: function() {
                    return this.dataSection ? this.dataSection[this.itemSelected] : null
                },
                dataNext: function() {
                    return this.dataCurrent ? this.dataSection[this.itemSelected + 1] ? this.dataSection[this.itemSelected + 1] : this.dataNextSection ? this.dataNextSection : null : null
                },
                dataNextSection: function() {
                    var nextSectionName, nextSection, menuData = JSON.parse((0,
                        _stringify2.default)(this.$get("$root.data.menu"))), numSection = -2, nextUrl = "";
                    return menuData ? (menuData.map(function(item, index) {
                        item.url.split("/")[1] === this.urlPage && (numSection = index)
                    }
                        .bind(this)),
                        nextUrl = menuData[numSection + 1] ? menuData[numSection + 1].url : "",
                        "" === nextUrl ? null : (nextSectionName = nextUrl.split("/")[1],
                            nextSection = JSON.parse((0,
                                _stringify2.default)(this.$get("$root.data." + nextSectionName))),
                            nextSection = nextSection[0],
                            nextSection ? {
                                title: nextSection.title,
                                pic: nextSection.pic,
                                url: nextUrl,
                                newSection: !0
                            } : null)) : null
                },
                currentLabel: function() {
                    return this.dataSection ? this.dataSection[this.itemSelected].title : null
                }
            },
            ready: function() {
                this.updateSelectedFromPath()
            },
            methods: {
                forEachNode: function(nodeList, callback) {
                    Array.prototype.forEach.call(nodeList, callback)
                },
                updateSelectedFromPath: function(value) {
                    this.$set("urlPopin", this.$route.params.popin),
                        this.$set("urlPage", this.$route.params.page),
                        this.$set("urlItem", this.$route.params.item),
                        this.$set("previewNextSelected", !1),
                        this.$set("progressIntro", 0)
                },
                isThemeLight: function() {
                    return "light" === this.$eval("dataCurrent.theme|json")
                }
            },
            events: {
                onSetScroll: function(value) {
                    this.$broadcast("onSetScroll", value)
                },
                onEnterFrame: function(ratioDeltaTime, deltaTime, currentTime) {
                    this.$broadcast("onEnterFrame", ratioDeltaTime, deltaTime, currentTime)
                },
                onMouseLeave: function() {
                    this.$broadcast("onMouseLeave")
                },
                onMouseUp: function() {
                    this.$broadcast("onMouseUp")
                },
                onMouseDown: function() {
                    this.$broadcast("onMouseDown")
                },
                onMouseMove: function(e) {
                    this.$broadcast("onMouseMove", e)
                },
                onSliderStart: function() {
                    this.navFlag = 1,
                        this.$broadcast("onSliderStart")
                },
                onSliderOver: function() {
                    this.navFlag = 0,
                        this.$broadcast("onSliderOver")
                },
                onSliderStop: function() {
                    this.navFlag = -1,
                        this.$broadcast("onSliderStop")
                },
                onItemSelect: function(itemIndex) {
                    var url = this.$root.prefixURL + "/" + this.urlPage;
                    itemIndex > 0 && (url += "/" + this.dataSection[itemIndex].url),
                    this.urlPopin && (url += "/" + this.urlPopin),
                        this.$route.router.go(url)
                },
                onThumbItemSelect: function(itemIndex) {
                    itemIndex !== this.itemSelected && (this.coverNoFade = !0,
                        this.$emit("onItemSelect", itemIndex))
                },
                onThumbItemHighlight: function(value) {
                    this.$broadcast("onThumbItemHighlight", value)
                },
                onSlide: function(sliderValue) {
                    this.sliderValue = sliderValue
                },
                onIntroProgress: function(progress) {
                    this.progressIntro = 100 * progress
                },
                onNextItemStart: function() {
                    this.$set("previewNextSelected", !0)
                },
                onNextItemEnd: function() {
                    this.coverNoFade = !0,
                        this.dataNext.newSection ? this.$route.router.go(this.$root.prefixURL + this.dataNext.url) : this.$emit("onItemSelect", this.$get("itemSelected") + 1)
                },
                onContentScroll: function(ratio, scrollTop, remaining) {
                    this.previewNextSelected || this.$broadcast("onPageScroll", scrollTop),
                        this.$set("scrollVHRatio", scrollTop / this.$root.size.h),
                        this.$set("scrollIsTop", scrollTop < this.$root.size.h),
                        this.$set("scrollIsBottom", this.dataNext && remaining < 50)
                },
                onOpenPageNav: function() {
                    this.subNavIsOpen = !0,
                        this.$dispatch("onOpenSubNav")
                },
                onClosePageNav: function() {
                    this.subNavIsOpen = !1,
                        this.$dispatch("onCloseSubNav")
                }
            },
            watch: {
                $route: "updateSelectedFromPath",
                urlPage: function(value, oldValue) {
                    var thumbData, pageData = this.$root.data[value], thumbsData = [];
                    return pageData ? (this.$set("dataSection", pageData),
                        this.dataSection.map(function(el, index) {
                            thumbData = {
                                img: {
                                    src: el.pic
                                },
                                title: el.title
                            },
                                thumbsData.push(thumbData)
                        }
                            .bind(this)),
                        this.$set("thumbs", thumbsData),
                        this.$broadcast("onSetScroll", 0),
                        this.$set("scrollVHRatio", 0),
                        this.$set("scrollIsTop", !0),
                        void this.$set("scrollIsBottom", !1)) : void this.$route.router.go(this.$root.prefixURL + "/page-not-found")
                },
                urlItem: function(value, oldValue) {
                    var itemIndex = 0
                        , itemExist = !1;
                    this.dataSection.map(function(el, index) {
                        el.url === value && (itemExist = !0,
                            itemIndex = index)
                    }
                        .bind(this)),
                        itemExist || void 0 === value ? this.$set("itemSelected", itemIndex) : void 0 === this.urlPopin ? this.$set("urlPopin", value) : this.$route.router.go(this.$root.prefixURL + "/item-not-found"),
                        this.$broadcast("onSetScroll", 0),
                        this.$set("scrollVHRatio", 0),
                        this.$set("scrollIsTop", !0),
                        this.$set("scrollIsBottom", !1)
                },
                urlPopin: function(value, oldValue) {
                    var popinsData = JSON.parse(this.$eval("$root.data.popins|json"))
                        , popinData = null;
                    popinsData.map(function(el, index) {
                        el.url === value && (popinData = el)
                    }
                        .bind(this)),
                        this.$set("$root.dataPopin", popinData),
                    void 0 === value || popinData || this.$route.router.go(this.$root.prefixURL + "/popin-not-found")
                },
                dataSection: function(value) {
                    var assets = this.$root.getAssetInNode(value);
                    this.$dispatch("onLoadRequest", assets)
                },
                dataCurrent: function(value) {
                    this.introIsInit = !0,
                    this.$root.isLoading || setTimeout(function() {
                        this.introIsInit = !1,
                            this.coverNoFade = !1,
                            this.$root.UILightFlag = !1,
                            this.$root.BGLightFlag = !0
                    }
                        .bind(this), 10)
                },
                "$root.isLoading": function(value) {
                    value ? this.introIsInit = value : (this.$broadcast("onSetScroll", 0),
                        setTimeout(function() {
                            this.introIsInit = !1,
                                this.coverNoFade = !1,
                                this.$root.UILightFlag = !1,
                                this.$root.BGLightFlag = !0
                        }
                            .bind(this), 10))
                },
                scrollVHRatio: function(value, oldValue) {
                    oldValue < .3 && value > .3 ? this.$root.UILightFlag = this.isThemeLight() : oldValue > .3 && value < .3 && (this.$root.UILightFlag = !1),
                        0 === value ? this.$root.BGLightFlag = !1 : this.$root.BGLightFlag = this.isThemeLight()
                }
            },
            components: {
                scroller: _Scroller2.default,
                cover: _Cover2.default,
                pagethumbs: _PageThumbs2.default,
                pagenav: _PageNav2.default,
                "page-mobile-nav": _PageMobileNav2.default,
                rstemplate: _RSTemplate2.default,
                preview: _Preview2.default
            }
        },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = '<div _v-6103792c=""><scroller :enabled="!previewNextSelected &amp;&amp; !urlPopin &amp;&amp; !subNavIsOpen" :class="{\'nav-open\': navFlag==1, \'nav-preview\': navFlag==0, \'nav-close\': navFlag==-1}" _v-6103792c=""><template><pagethumbs :currentlabel=currentLabel :navstate=navFlag :items=thumbs :scroll=sliderValue :selected=itemSelected :class="{\'preview-enabled\':!scrollIsTop &amp;&amp; !scrollIsBottom}" v-if=!$root.isMobile _v-6103792c=""></pagethumbs><div class=content-list _v-6103792c=""><div class=content-item id=content-item :class="{\'has-preview\':dataNext,\'on-preview\':previewNextSelected}" v-if="dataSection &amp;&amp; dataCurrent" _v-6103792c=""><cover :init-intro=coverIntroInit :no-fade=coverNoFade :section=dataCurrent _v-6103792c=""></cover><p class=content-block v-if=dataCurrent.text _v-6103792c="">{{{dataCurrent.text}}}</p><rstemplate class=content-block v-if=dataCurrent.template :template-data=dataCurrent.template _v-6103792c=""></rstemplate></div><preview v-if=dataNext :show="scrollIsBottom || previewNextSelected" :title=dataNext.title :picture=dataNext.pic _v-6103792c=""></preview></div><div class=line-item-infos v-if="!$root.isMobile &amp;&amp; dataSection" v-show="!scrollIsTop &amp;&amp; !previewNextSelected" transition=fade _v-6103792c=""><p class="line-item-label text-nav-infos" _v-6103792c="">{{{currentLabel}}}<p class="line-item-index text-nav-infos" v-show="dataSection.length > 1" _v-6103792c="">{{{itemSelected+1 | two-digits}}}</div><pagenav :range=thumbs.length v-if=!$root.isMobile :class="{\'enable-reminder\':!scrollIsTop, \'init-intro\':coverIntroInit }" _v-6103792c=""></pagenav><page-mobile-nav :range=thumbs.length :page-data=dataSection :class="{\'hide\':scrollIsBottom || scrollIsTop}" v-if=$root.isMobile v-show="thumbs.length>1" _v-6103792c=""></page-mobile-nav></template></scroller></div>'
    }
        , {
            "./Cover.vue": 107,
            "./PageMobileNav.vue": 114,
            "./PageNav.vue": 115,
            "./PageThumbs.vue": 116,
            "./Preview.vue": 119,
            "./RSTemplate.vue": 120,
            "./Scroller.vue": 122,
            "babel-runtime/core-js/json/stringify": 3,
            "vueify/lib/insert-css": 103
        }],
    114: [function(require, module, exports) {
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert('.common-fixed-full{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app .page-nav-mobile .title,#app .page-nav-mobile .titles,.common-absolute-full{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app .page-nav-mobile .thumb-pic,#app .page-nav-mobile .thumbs,.common-block-full{display:block;width:100%;height:100%}#app .page-nav-mobile .thumb-pic,.common-center-cover{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover,.common-hover:hover{color:#7ad71f}.common-hover{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center{display:block;text-align:center}#app .page-nav-mobile{position:fixed;width:100%;height:90px;bottom:0;overflow:hidden;z-index:20;-webkit-transition:bottom .5s;transition:bottom .5s}#app .page-nav-mobile .gradient{position:absolute;z-index:0;bottom:0;width:100%;height:90px;opacity:1;background-image:-webkit-linear-gradient(top,transparent,#000);background-image:linear-gradient(top,transparent,#000);-webkit-transition:opacity .5s;transition:opacity .5s}#app .page-nav-mobile .cursor{position:absolute;z-index:1;bottom:0;-webkit-transform:translate3d(0,-30px,0);transform:translate3d(0,-30px,0);left:50%;width:42px;height:42px;padding:13px;margin-top:-21px;margin-left:-21px;box-sizing:border-box;cursor:pointer;opacity:1;-webkit-transition:-webkit-transform .5s cubic-bezier(.215,.61,.355,1) .1s;transition:-webkit-transform .5s cubic-bezier(.215,.61,.355,1) .1s;transition:transform .5s cubic-bezier(.215,.61,.355,1) .1s;transition:transform .5s cubic-bezier(.215,.61,.355,1) .1s,-webkit-transform .5s cubic-bezier(.215,.61,.355,1) .1s}#app .page-nav-mobile .cursor-line{position:absolute;top:0;left:0;fill:none;stroke:#fff;stroke-width:1.3px;vector-effect:non-scaling-stroke;-webkit-animation:bounce 2s infinite cubic-bezier(.645,.045,.355,1) 1s;animation:bounce 2s infinite cubic-bezier(.645,.045,.355,1) 1s}#app .page-nav-mobile .cursor-shape{width:100%;height:100%;border-radius:8px;background-color:#fff}#app .page-nav-mobile .thumbs{overflow:hidden;pointer-events:none;position:relative;z-index:2;background-color:transparent}#app .page-nav-mobile .thumbs.scrolling{background-color:#000}#app .page-nav-mobile .thumbs.scrolling .thumb.active{-webkit-transform:scale3d(.8,.8,1);transform:scale3d(.8,.8,1)}#app .page-nav-mobile .thumbs.scrolling .thumb-pic.active{-webkit-transform:scale3d(1.2,1.2,1);transform:scale3d(1.2,1.2,1)}#app .page-nav-mobile .thumbs.scrolling .thumbs-wrapper{-webkit-transition:-webkit-transform 0;transition:-webkit-transform 0;transition:transform 0;transition:transform 0,-webkit-transform 0}#app .page-nav-mobile .thumbs-wrapper{-webkit-writing-mode:vertical-lr;-ms-writing-mode:tb-lr;writing-mode:vertical-lr;background-color:#000;-webkit-transform:translate3d(100vw,0,0);transform:translate3d(100vw,0,0)}#app .page-nav-mobile .thumb{width:100vw;height:72vh;overflow:hidden;-webkit-transform:scale3d(.9,.9,1);transform:scale3d(.9,.9,1);-webkit-transition:-webkit-transform .5s;transition:-webkit-transform .5s;transition:transform .5s;transition:transform .5s,-webkit-transform .5s}#app .page-nav-mobile .thumb-pic{-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-transition:-webkit-transform .5s,-webkit-transform-origin 1s;transition:-webkit-transform .5s,-webkit-transform-origin 1s;transition:transform .5s,transform-origin 1s;transition:transform .5s,transform-origin 1s,-webkit-transform .5s,-webkit-transform-origin 1s;z-index:1}#app .page-nav-mobile .close{background-color:#000;width:100vw;height:4vh;color:#fff;font-size:20em;font-weight:700;text-align:center;text-decoration:underline;padding:5vh 0 3vh;opacity:0;z-index:555}#app .page-nav-mobile .drag{width:50vw;color:#fff;font-size:12em;padding:2vh 10vw 0;margin:0 auto;opacity:0}#app .page-nav-mobile .drag:after,#app .page-nav-mobile .drag:before{width:0;display:inline-block;content:"";border-top:1px solid #fff;margin-right:2vw;padding-bottom:4px;-webkit-animation-duration:2.5s;animation-duration:2.5s;-webkit-animation-name:glissement;animation-name:glissement;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}#app .page-nav-mobile .drag:after{margin:0 0 0 2vw;-webkit-animation-duration:2.5s;animation-duration:2.5s;-webkit-animation-name:glissementInverse;animation-name:glissementInverse;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}#app .page-nav-mobile .drag span{display:inline-block;width:15vw;text-align:center}#app .page-nav-mobile .title-page{position:absolute;top:42%;left:0;bottom:0;right:0;width:100%;height:60%;text-align:center;z-index:4;pointer-events:none;opacity:0}#app .page-nav-mobile .title-page p{font-size:16em;font-weight:700;color:#fff}#app .page-nav-mobile .titles{top:0;left:0;z-index:3;pointer-events:none;opacity:1}#app .page-nav-mobile .title{font-size:35em;font-weight:700;line-height:100vh;text-align:center;opacity:0;-webkit-transition:opacity .5s,-webkit-transform .5s;transition:opacity .5s,-webkit-transform .5s;transition:opacity .5s,transform .5s;transition:opacity .5s,transform .5s,-webkit-transform .5s}#app .page-nav-mobile .title.active{opacity:1;-webkit-transition:opacity .5s .5s,-webkit-transform .8s cubic-bezier(.215,.61,.355,1) .3s;transition:opacity .5s .5s,-webkit-transform .8s cubic-bezier(.215,.61,.355,1) .3s;transition:opacity .5s .5s,transform .8s cubic-bezier(.215,.61,.355,1) .3s;transition:opacity .5s .5s,transform .8s cubic-bezier(.215,.61,.355,1) .3s,-webkit-transform .8s cubic-bezier(.215,.61,.355,1) .3s}#app .page-nav-mobile .title.next{-webkit-transform:translate3d(20vw,0,0);transform:translate3d(20vw,0,0)}#app .page-nav-mobile .title.previous{-webkit-transform:translate3d(-20vw,0,0);transform:translate3d(-20vw,0,0)}#app .page-nav-mobile .title.select{opacity:0;-webkit-transition:opacity .5s cubic-bezier(.55,.055,.675,.19),-webkit-transform .8s cubic-bezier(.215,.61,.355,1) .3s;transition:opacity .5s cubic-bezier(.55,.055,.675,.19),-webkit-transform .8s cubic-bezier(.215,.61,.355,1) .3s;transition:opacity .5s cubic-bezier(.55,.055,.675,.19),transform .8s cubic-bezier(.215,.61,.355,1) .3s;transition:opacity .5s cubic-bezier(.55,.055,.675,.19),transform .8s cubic-bezier(.215,.61,.355,1) .3s,-webkit-transform .8s cubic-bezier(.215,.61,.355,1) .3s}#app .page-nav-mobile.hide .cursor,#app .page-nav-mobile.open .cursor{-webkit-transform:translate3d(0,-30px,0);transform:translate3d(0,-30px,0);-webkit-transition:bottom .5s cubic-bezier(.55,.055,.675,.19) .1s;transition:bottom .5s cubic-bezier(.55,.055,.675,.19) .1s}#app .page-nav-mobile.hide .gradient,#app .page-nav-mobile.open .gradient{opacity:0}#app .page-nav-mobile.hide{bottom:-90px}#app .page-nav-mobile.open{height:100%;bottom:0}#app .page-nav-mobile.open .thumbs{pointer-events:auto;opacity:1;height:100vh;background-color:#000;-webkit-transition:width 0s 0s,height 0s 0s,background-color .5s 0s,opacity .5s .2s;transition:width 0s 0s,height 0s 0s,background-color .5s 0s,opacity .5s .2s}#app .page-nav-mobile.open .thumbs .close,#app .page-nav-mobile.open .thumbs .drag,#app .page-nav-mobile.open .thumbs .title-page,#app .page-nav-mobile.open .thumbs .titles{opacity:1;-webkit-transition:opacity .2s cubic-bezier(.55,.055,.675,.19) .5s;transition:opacity .2s cubic-bezier(.55,.055,.675,.19) .5s}#app .page-nav-mobile.open .thumbs.closing{opacity:0;background-color:transparent;-webkit-transition:background-color 0s 0s,opacity .2s cubic-bezier(.55,.055,.675,.19) .5s;transition:background-color 0s 0s,opacity .2s cubic-bezier(.55,.055,.675,.19) .5s}#app .page-nav-mobile.open .thumbs.closing .close,#app .page-nav-mobile.open .thumbs.closing .drag{height:0;opacity:0;padding:0;background-color:transparent;-webkit-transition:height 0s 0s,background-color 0s 0s,opacity .2s cubic-bezier(.55,.055,.675,.19) .5s;transition:height 0s 0s,background-color 0s 0s,opacity .2s cubic-bezier(.55,.055,.675,.19) .5s}#app .page-nav-mobile.open .thumbs.closing .thumb,#app .page-nav-mobile.open .thumbs.closing .thumbs-wrapper{height:100vh;margin:0;padding:0;-webkit-transform:scaleX(1);transform:scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-transition:height .5s ease;transition:height .5s ease}#app .page-nav-mobile.open .thumbs.closing .title-page{opacity:0;-webkit-transition:opacity .1s cubic-bezier(.55,.055,.675,.19) 0s;transition:opacity .1s cubic-bezier(.55,.055,.675,.19) 0s}#app .page-nav-mobile.open .thumbs.isclosing,#app .page-nav-mobile.open .thumbs.isclosing .close,#app .page-nav-mobile.open .thumbs.isclosing .drag,#app .page-nav-mobile.open .thumbs.isclosing .titles{opacity:0;-webkit-transition:opacity .5s cubic-bezier(.55,.055,.675,.19);transition:opacity .5s cubic-bezier(.55,.055,.675,.19)}#app .page-nav-mobile.open .thumbs.isclosing .thumb{background-color:transparent;opacity:0;-webkit-transform:scale3d(.7,.7,1);transform:scale3d(.7,.7,1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-transition:height .5s ease,background-color 0s 0s,opacity .5s cubic-bezier(.55,.055,.675,.19) .5s,-webkit-transform .5s cubic-bezier(.215,.61,.355,1);transition:height .5s ease,background-color 0s 0s,opacity .5s cubic-bezier(.55,.055,.675,.19) .5s,-webkit-transform .5s cubic-bezier(.215,.61,.355,1);transition:height .5s ease,background-color 0s 0s,opacity .5s cubic-bezier(.55,.055,.675,.19) .5s,transform .5s cubic-bezier(.215,.61,.355,1);transition:height .5s ease,background-color 0s 0s,opacity .5s cubic-bezier(.55,.055,.675,.19) .5s,transform .5s cubic-bezier(.215,.61,.355,1),-webkit-transform .5s cubic-bezier(.215,.61,.355,1)}#app .page-nav-mobile.open .thumbs-wrapper{-webkit-transform:translateZ(0);transform:translateZ(0);-webkit-transition:-webkit-transform .7s cubic-bezier(.215,.61,.355,1);transition:-webkit-transform .7s cubic-bezier(.215,.61,.355,1);transition:transform .7s cubic-bezier(.215,.61,.355,1);transition:transform .7s cubic-bezier(.215,.61,.355,1),-webkit-transform .7s cubic-bezier(.215,.61,.355,1)}#app .page-nav-mobile.open .thumb.active{-webkit-transform:scale3d(.9,.9,1);transform:scale3d(.9,.9,1)}#app .page-nav-mobile.open .thumb.active .thumb-pic{-webkit-transform:scale3d(1.3,1.3,1);transform:scale3d(1.3,1.3,1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;z-index:2}#app .page-nav-mobile.open .thumb.select{-webkit-transform:scaleX(1);transform:scaleX(1)}#app .page-nav-mobile.open .thumb.select .thumb-pic{-webkit-transform:scaleX(1);transform:scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%}#app .page-nav-mobile.open .thumb.previous .thumb-pic{-webkit-transform-origin:100% 50%;transform-origin:100% 50%}#app .page-nav-mobile.open .thumb.next .thumb-pic{-webkit-transform-origin:0 50%;transform-origin:0 50%}#app.theme-light .page-nav-mobile .gradient{background-image:-webkit-linear-gradient(top,hsla(0,0%,100%,0),#fff);background-image:linear-gradient(top,hsla(0,0%,100%,0),#fff)}#app.theme-light .page-nav-mobile .cursor-line{stroke:#000}#app.theme-light .page-nav-mobile .cursor-shape{background-color:#000}@-moz-keyframes bounce{0%,to{opacity:.5;transform:scaleX(1)}50%{opacity:1;transform:scale3d(1.2,1.2,1)}}@-webkit-keyframes bounce{0%,to{opacity:.5;-webkit-transform:scaleX(1);transform:scaleX(1)}50%{opacity:1;-webkit-transform:scale3d(1.2,1.2,1);transform:scale3d(1.2,1.2,1)}}@-o-keyframes bounce{0%,to{opacity:.5;transform:scaleX(1)}50%{opacity:1;transform:scale3d(1.2,1.2,1)}}@keyframes bounce{0%,to{opacity:.5;-webkit-transform:scaleX(1);transform:scaleX(1)}50%{opacity:1;-webkit-transform:scale3d(1.2,1.2,1);transform:scale3d(1.2,1.2,1)}}@-moz-keyframes glissement{0%,to{width:10vw}50%{width:20vw}}@-webkit-keyframes glissement{0%,to{width:10vw}50%{width:20vw}}@-o-keyframes glissement{0%,to{width:10vw}50%{width:20vw}}@keyframes glissement{0%,to{width:10vw}50%{width:20vw}}@-moz-keyframes glissementInverse{0%,to{width:20vw}50%{width:10vw}}@-webkit-keyframes glissementInverse{0%,to{width:20vw}50%{width:10vw}}@-o-keyframes glissementInverse{0%,to{width:20vw}50%{width:10vw}}@keyframes glissementInverse{0%,to{width:20vw}50%{width:10vw}}');
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _getIterator2 = require("babel-runtime/core-js/get-iterator")
            , _getIterator3 = _interopRequireDefault(_getIterator2)
            , _gsap = require("../../node_modules/gsap")
            , _mathTools = (_interopRequireDefault(_gsap),
            require("../scripts/mathTools"))
            , _mathTools2 = _interopRequireDefault(_mathTools);
        exports.default = {
            data: function() {
                return {
                    navIsOpen: !1,
                    selected: -1,
                    activeIndex: 0,
                    scrollValueIndex: 0,
                    scrollValue: 0,
                    isScrolling: !1,
                    isClosing: !1,
                    touchStartX: 0,
                    moveX: 0
                }
            },
            props: ["range", "page-data"],
            computed: {
                translateValue: function() {
                    return "translate3d(" + (this.navIsOpen ? -this.scrollValue + "px" : "100vw") + ",0,0)"
                }
            },
            ready: function() {},
            attached: function() {},
            methods: {
                openNav: function() {
                    this.selected = -1,
                        this.navIsOpen = !0,
                        this.isClosing = !1
                },
                outerWidth: function(el) {
                    var width = el.offsetWidth
                        , style = getComputedStyle(el);
                    return width += parseInt(style.marginLeft) + parseInt(style.marginRight)
                },
                select: function(index) {
                    var item = this.$el.querySelector(".thumb");
                    this.scrollValueIndex = index * (item.offsetWidth + .5 * (this.outerWidth(item) - item.offsetWidth)),
                        this.scrollValue = this.scrollValueIndex,
                        this.activeIndex = index
                },
                onSlide: function(e) {
                    this.isScrolling = !0,
                        this.moveX = this.touchStartX - e.touches[0].pageX,
                    0 === this.activeIndex && this.moveX < 0 && (this.moveX *= .1),
                    this.activeIndex === this.pageData.length - 1 && this.moveX > 0 && (this.moveX *= .1),
                        this.scrollValue = this.scrollValueIndex + this.moveX
                },
                onStartSlide: function(e) {
                    this.touchStartX = e.touches[0].pageX
                },
                onEndSlide: function(e) {
                    var item = this.$el.querySelector(".thumb")
                        , slideRatio = this.moveX / (item.offsetWidth + .5 * (this.outerWidth(item) - item.offsetWidth));
                    Math.abs(slideRatio) > .3 && (this.activeIndex = _mathTools2.default.clamp(this.activeIndex + (slideRatio > 0 ? 1 : -1), 0, this.pageData.length - 1)),
                        this.moveX = 0,
                        this.select(this.activeIndex),
                        this.isScrolling = !1
                },
                selectPage: function() {
                    this.selected = this.activeIndex,
                        this.$dispatch("onThumbItemSelect", this.selected),
                        setTimeout(function() {
                            this.navIsOpen = !1
                        }
                            .bind(this), 1200)
                },
                closePopin: function() {
                    this.isClosing = !0,
                        setTimeout(function() {
                            this.navIsOpen = !1
                        }
                            .bind(this), 700)
                },
                getTitle: function() {
                    var route = this.$root.$route.params.page ? this.$root.$route.params.page : ""
                        , menus = this.$root.data.menu
                        , _iteratorNormalCompletion = !0
                        , _didIteratorError = !1
                        , _iteratorError = void 0;
                    try {
                        for (var _step, _iterator = (0,
                            _getIterator3.default)(menus); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
                            var element = _step.value;
                            if (route === element.url.substring(1))
                                return element.label
                        }
                    } catch (err) {
                        _didIteratorError = !0,
                            _iteratorError = err
                    } finally {
                        try {
                            !_iteratorNormalCompletion && _iterator.return && _iterator.return()
                        } finally {
                            if (_didIteratorError)
                                throw _iteratorError
                        }
                    }
                    return ""
                }
            },
            components: {},
            events: {},
            watch: {
                navIsOpen: function(value) {
                    value ? this.$dispatch("onOpenPageNav") : this.$dispatch("onClosePageNav")
                }
            }
        },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = "<div class=page-nav-mobile :class=\"{'open':navIsOpen}\"><div class=gradient></div><div class=cursor @click=openNav><div class=cursor-shape></div><svg class=cursor-line xmlns=http://www.w3.org/2000/svg width=100% height=100% viewBox=\"0 0 44 44\"><circle data-name=ellipse class=shape-path cx=22 cy=22 r=20 /></svg></div><div class=thumbs :class=\"{'scrolling':isScrolling, 'closing':(selected >= 0), 'isclosing':isClosing }\" v-if=pageData @touchstart=onStartSlide @touchend=onEndSlide @touchmove=onSlide><div class=close @click.prevent=closePopin>close</div><div class=thumbs-wrapper :style=\"{'transform':translateValue}\"><div class=thumb v-for=\"thumb in pageData\" :class=\"{'active':$index == activeIndex, 'previous':$index == (activeIndex - 1), 'next':$index == (activeIndex + 1),'select':$index == selected}\" @click.prevent=selectPage><div class=thumb-pic :style=\"{'background-image':'url(' + thumb.pic + ')'}\"></div></div></div><div class=drag><span>drag</span></div><div class=titles><h1 class=title v-for=\"thumb in pageData\" :class=\"{'active':$index == activeIndex, 'previous':$index == (activeIndex - 1), 'next':$index == (activeIndex + 1),'select':$index == selected}\">{{{thumb.title}}}</h1><h2 class=title-page><p>{{{ getTitle() }}}</h2></div></div></div>";
    }
        , {
            "../../node_modules/gsap": 80,
            "../scripts/mathTools": 129,
            "babel-runtime/core-js/get-iterator": 2,
            "vueify/lib/insert-css": 103
        }],
    115: [function(require, module, exports) {
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full{position:fixed}.common-absolute-full,.common-fixed-full{top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-absolute-full{position:absolute}.common-block-full{display:block;width:100%;height:100%}.common-center-cover{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover,.common-hover:hover{color:#7ad71f}.common-hover{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center{display:block;text-align:center}#app .page-nav .cursor.active,#app .page-nav .cursor:hover,#app .page-nav.open .cursor,#app .page-nav.over .cursor,.cursor-active{padding:18px 6px}#app .page-nav .cursor.active .cursor-shape,#app .page-nav .cursor:hover .cursor-shape,#app .page-nav.open .cursor .cursor-shape,#app .page-nav.over .cursor .cursor-shape,.cursor-active .cursor-shape{border-radius:0}#app.theme-light .page-nav .line{background-color:#151516}#app.theme-light .page-nav .cursor .cursor-line{stroke:#151516}#app.theme-light .page-nav .cursor .cursor-shape{background-color:#151516}#app.theme-light .page-nav .range .range-current{border-color:#151516}#app.theme-light .page-nav .range .range-arrows{fill:#151516}#app.theme-light .page-nav p{color:#151516}#app .page-nav{position:fixed;z-index:3;top:50%;left:0;right:0;height:0}#app .page-nav .line{position:relative;width:100%;height:1px;background-color:#fff;z-index:3;pointer-events:none;opacity:.2;-webkit-transition:width 1s cubic-bezier(.755,.05,.855,.06),background-color .5s cubic-bezier(.55,.055,.675,.19);transition:width 1s cubic-bezier(.755,.05,.855,.06),background-color .5s cubic-bezier(.55,.055,.675,.19);-webkit-transition:width 1s cubic-bezier(.755,.05,.855,.06);transition:width 1s cubic-bezier(.755,.05,.855,.06)}#app .page-nav .cursor{position:absolute;cursor:pointer;top:-21px;width:42px;height:42px;padding:13px;margin-left:-21px;box-sizing:border-box;-webkit-transform:scaleX(1);transform:scaleX(1);-webkit-transition:padding .5s,left .8s cubic-bezier(.175,.885,.285,1.085),-webkit-transform .5s cubic-bezier(.175,.885,.32,1.275) 1.2s;transition:padding .5s,left .8s cubic-bezier(.175,.885,.285,1.085),-webkit-transform .5s cubic-bezier(.175,.885,.32,1.275) 1.2s;transition:padding .5s,left .8s cubic-bezier(.175,.885,.285,1.085),transform .5s cubic-bezier(.175,.885,.32,1.275) 1.2s;transition:padding .5s,left .8s cubic-bezier(.175,.885,.285,1.085),transform .5s cubic-bezier(.175,.885,.32,1.275) 1.2s,-webkit-transform .5s cubic-bezier(.175,.885,.32,1.275) 1.2s;z-index:4}#app .page-nav .cursor .cursor-line{position:absolute;top:0;left:0;fill:none;stroke:#fff;stroke-width:1.3px;vector-effect:non-scaling-stroke;opacity:.4;stroke-dashoffset:-150;-webkit-transition:stroke-dashoffset .5s cubic-bezier(.55,.055,.675,.19);transition:stroke-dashoffset .5s cubic-bezier(.55,.055,.675,.19);-webkit-transition:stroke-dashoffset .5s cubic-bezier(.55,.055,.675,.19),stroke .5s cubic-bezier(.55,.055,.675,.19);transition:stroke-dashoffset .5s cubic-bezier(.55,.055,.675,.19),stroke .5s cubic-bezier(.55,.055,.675,.19);-webkit-animation:bounce 2s infinite cubic-bezier(.645,.045,.355,1) 1s;animation:bounce 2s infinite cubic-bezier(.645,.045,.355,1) 1s}#app .page-nav .cursor .cursor-shape{width:100%;height:100%;border-radius:8px;background-color:#fff;-webkit-transition:border-top-left-radius .5s cubic-bezier(.645,.045,.355,1),border-top-right-radius .3s cubic-bezier(.645,.045,.355,1) .1s,border-bottom-left-radius .3s cubic-bezier(.645,.045,.355,1) .1s,border-bottom-right-radius .5s cubic-bezier(.645,.045,.355,1);transition:border-top-left-radius .5s cubic-bezier(.645,.045,.355,1),border-top-right-radius .3s cubic-bezier(.645,.045,.355,1) .1s,border-bottom-left-radius .3s cubic-bezier(.645,.045,.355,1) .1s,border-bottom-right-radius .5s cubic-bezier(.645,.045,.355,1);-webkit-transition:border-top-left-radius .5s cubic-bezier(.645,.045,.355,1),border-top-right-radius .3s cubic-bezier(.645,.045,.355,1) .1s,border-bottom-left-radius .3s cubic-bezier(.645,.045,.355,1) .1s,border-bottom-right-radius .5s cubic-bezier(.645,.045,.355,1),background-color .5s cubic-bezier(.55,.055,.675,.19);transition:border-top-left-radius .5s cubic-bezier(.645,.045,.355,1),border-top-right-radius .3s cubic-bezier(.645,.045,.355,1) .1s,border-bottom-left-radius .3s cubic-bezier(.645,.045,.355,1) .1s,border-bottom-right-radius .5s cubic-bezier(.645,.045,.355,1),background-color .5s cubic-bezier(.55,.055,.675,.19)}#app .page-nav .range{width:20px;position:absolute;margin-left:-10px;margin-top:5px;-webkit-transition:left .1s;transition:left .1s;font-size:10px;text-align:center;z-index:0;opacity:0;-webkit-transition:opacity .2s,left .8s cubic-bezier(.175,.885,.285,1.085);transition:opacity .2s,left .8s cubic-bezier(.175,.885,.285,1.085)}#app .page-nav .range .range-current{display:inline-block;padding-bottom:3px;border-bottom:1px solid #fff}#app .page-nav .range .range-total{padding-top:3px}#app .page-nav .range .range-arrows{position:absolute;width:100%;top:-40px;left:0;fill:#fff;z-index:0}#app .page-nav.open .cursor,#app .page-nav.over .cursor{-webkit-transition:padding .5s,left 0s;transition:padding .5s,left 0s}#app .page-nav.open .range,#app .page-nav.over .range{opacity:1;-webkit-transition:opacity .2s .2s,left .2s cubic-bezier(.215,.61,.355,1);transition:opacity .2s .2s,left .2s cubic-bezier(.215,.61,.355,1)}#app .page-nav.enable-reminder .cursor-line{stroke-dasharray:150 150;stroke-dashoffset:0}#app .page-nav.init-intro .line{width:0;-webkit-transition:width 0s;transition:width 0s}#app .page-nav.init-intro .cursor{-webkit-transform:scale3d(0,0,1);transform:scale3d(0,0,1);-webkit-transition:-webkit-transform 0s 0s;transition:-webkit-transform 0s 0s;transition:transform 0s 0s;transition:transform 0s 0s,-webkit-transform 0s 0s}@-moz-keyframes bounce{0%,to{opacity:.5;transform:scaleX(1)}50%{opacity:1;transform:scale3d(1.2,1.2,1)}}@-webkit-keyframes bounce{0%,to{opacity:.5;-webkit-transform:scaleX(1);transform:scaleX(1)}50%{opacity:1;-webkit-transform:scale3d(1.2,1.2,1);transform:scale3d(1.2,1.2,1)}}@-o-keyframes bounce{0%,to{opacity:.5;transform:scaleX(1)}50%{opacity:1;transform:scale3d(1.2,1.2,1)}}@keyframes bounce{0%,to{opacity:.5;-webkit-transform:scaleX(1);transform:scaleX(1)}50%{opacity:1;-webkit-transform:scale3d(1.2,1.2,1);transform:scale3d(1.2,1.2,1)}}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _gsap = require("../../node_modules/gsap")
            , _gsap2 = _interopRequireDefault(_gsap);
        exports.default = {
            filters: {
                "two-digits": function(value) {
                    return value < 10 ? "0" + value : value
                }
            },
            data: function() {
                return {
                    sliderValue: .05,
                    state: -1,
                    currentRange: 1,
                    cursorClipY: 22
                }
            },
            props: {
                range: 0
            },
            ready: function() {
                this.update()
            },
            methods: {
                onMouseDown: function() {
                    this.$el.querySelector(":hover");
                    this.$el.querySelector(":hover") === this.$el.querySelector(".cursor") && this.openNav()
                },
                openNav: function() {
                    this.state = 1,
                        this.update(),
                        this.$dispatch("onOpenPageNav")
                },
                closeNav: function() {
                    this.state = -1,
                        this.sliderValue = .05,
                        this.$dispatch("onClosePageNav")
                },
                onMouseMove: function() {
                    1 == this.state && (this.sliderValue = Math.max(Math.min(.5 * (this.$root.mouse.x + 1), 1), 0))
                },
                cursorOver: function() {
                    this.range > 1 && this.state == -1 && (this.state = 0)
                },
                cursorOut: function() {
                    this.range > 1 && 0 == this.state && (this.state = -1)
                },
                update: function() {
                    this.state > 0 && this.$dispatch("onSlide", this.sliderValue)
                }
            },
            events: {
                onThumbItemHighlight: function(value) {
                    this.currentRange = value > -1 ? value + 1 : 0
                },
                onMouseLeave: function() {
                    1 == this.state && this.closeNav()
                },
                onMouseUp: function() {
                    1 == this.state && this.closeNav()
                },
                onMouseDown: "onMouseDown",
                onMouseMove: "onMouseMove"
            },
            watch: {
                state: function(value, oldValue) {
                    switch (value) {
                        case -1:
                            this.$dispatch("onSliderStop"),
                                _gsap2.default.to(this, .3, {
                                    cursorClipY: 22,
                                    ease: Cubic.easeOut
                                });
                            break;
                        case 0:
                            this.$dispatch("onSliderOver"),
                                _gsap2.default.to(this, .3, {
                                    cursorClipY: 100,
                                    ease: Cubic.easeIn
                                });
                            break;
                        case 1:
                            this.$dispatch("onSliderStart"),
                                _gsap2.default.to(this, .3, {
                                    cursorClipY: 100,
                                    ease: Cubic.easeIn
                                })
                    }
                },
                sliderValue: "update"
            }
        },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = '<div class=page-nav :class="{open:state==1, over:state==0}" @mouseover=cursorOver @mouseout=cursorOut><div class=line></div><div class=cursor :class="{active:state==1}" :style="{left:sliderValue * $root.size.w + \'px\'}" v-show="range > 1"><div class=cursor-shape></div><svg class=cursor-line xmlns=http://www.w3.org/2000/svg width=100% height=100% viewBox="0 0 44 44"><defs><clipPath id=ellipse-clip><circle data-name=ellipse-clip fill=#000000 class=shape-clip-path cx=22 v-bind:cy=cursorClipY r=22></circle></clipPath></defs><circle data-name=ellipse clip-path=url(#ellipse-clip) class=shape-path cx=22 cy=22 r=20></circle></svg></div><div class=range v-show="range > 0" :style="{left:sliderValue * $root.size.w + \'px\'}"><svg class=range-arrows xmlns=http://www.w3.org/2000/svg viewBox="0 0 8.5 5"><polygon points="0 2.55 2.07 5 2.42 4.59 0.7 2.55 2.5 0.41 2.15 0 0.35 2.13 0.35 2.13 0 2.55"></polygon><polygon points="8.5 2.45 6.43 0 6.08 0.41 7.8 2.45 6 4.59 6.35 5 8.15 2.87 8.15 2.87 8.5 2.45"></polygon></svg><p class=range-current v-show="currentRange > 0">{{currentRange | two-digits}}<p class=range-total v-show="currentRange > 0">{{range | two-digits}}</div></div>'
    }
        , {
            "../../node_modules/gsap": 80,
            "vueify/lib/insert-css": 103
        }],
    116: [function(require, module, exports) {
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app .page-nav-thumbs .page-nav-thumb .page-nav-pic-wrapper:after,.common-absolute-full{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full{display:block;width:100%;height:100%}#app .page-nav-thumbs .page-nav-thumb .page-nav-pic-wrapper,.common-center-cover{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover,.common-hover:hover{color:#7ad71f}.common-hover{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center{display:block;text-align:center}#app .page-nav-thumbs{position:fixed;top:0;left:0;width:100%;height:100%;z-index:2;pointer-events:none;-webkit-transition:-webkit-transform .6s cubic-bezier(.215,.61,.355,1);transition:-webkit-transform .6s cubic-bezier(.215,.61,.355,1);transition:transform .6s cubic-bezier(.215,.61,.355,1);transition:transform .6s cubic-bezier(.215,.61,.355,1),-webkit-transform .6s cubic-bezier(.215,.61,.355,1)}#app .page-nav-thumbs .page-nav-thumbs{-webkit-transition:none;transition:none}#app .page-nav-thumbs .page-nav-thumb{position:absolute;left:0;display:inline-block;opacity:0;z-index:-2;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-transform:scale(.3) translateZ(0);transform:scale(.3) translateZ(0)}#app .page-nav-thumbs .page-nav-thumb .page-nav-pic-wrapper{overflow:hidden}#app .page-nav-thumbs .page-nav-thumb .page-nav-pic-wrapper:after{content:'';background-color:#fff;opacity:0;-webkit-transition:opacity .4s cubic-bezier(.645,.045,.355,1) 0s;transition:opacity .4s cubic-bezier(.645,.045,.355,1) 0s}#app .page-nav-thumbs .page-nav-thumb .page-nav-title{text-transform:lowercase;position:absolute;bottom:-200px;width:100%;text-align:center;font-size:60em;font-weight:700;opacity:0;-webkit-transition:bottom .3s 0s,opacity .1s 0s;transition:bottom .3s 0s,opacity .1s 0s}#app .page-nav-thumbs .page-nav-thumb.selected{-webkit-transform:scale(1);transform:scale(1);opacity:0;-webkit-transition:opacity .5s 0s,-webkit-transform .5s cubic-bezier(.645,.045,.355,1);transition:opacity .5s 0s,-webkit-transform .5s cubic-bezier(.645,.045,.355,1);transition:transform .5s cubic-bezier(.645,.045,.355,1),opacity .5s 0s;transition:transform .5s cubic-bezier(.645,.045,.355,1),opacity .5s 0s,-webkit-transform .5s cubic-bezier(.645,.045,.355,1)}#app .page-nav-thumbs .page-nav-thumb.selected .page-nav-pic-wrapper:after{opacity:0}#app .page-nav-thumbs.preview-enabled.state-preview{-webkit-transition:left 0s;transition:left 0s}#app .page-nav-thumbs.preview-enabled.state-preview .page-nav-thumb.selected{-webkit-transition:opacity .6s cubic-bezier(.645,.045,.355,1) 0s,-webkit-transform .6s cubic-bezier(.645,.045,.355,1);transition:opacity .6s cubic-bezier(.645,.045,.355,1) 0s,-webkit-transform .6s cubic-bezier(.645,.045,.355,1);transition:transform .6s cubic-bezier(.645,.045,.355,1),opacity .6s cubic-bezier(.645,.045,.355,1) 0s;transition:transform .6s cubic-bezier(.645,.045,.355,1),opacity .6s cubic-bezier(.645,.045,.355,1) 0s,-webkit-transform .6s cubic-bezier(.645,.045,.355,1);-webkit-transform:scale(.9);transform:scale(.9);opacity:.2}#app .page-nav-thumbs.state-open{-webkit-transition:left 0s;transition:left 0s}#app .page-nav-thumbs.state-open .page-nav-thumb{-webkit-transition:opacity .5s cubic-bezier(.215,.61,.355,1) .4s,-webkit-transform .6s cubic-bezier(.215,.61,.355,1);transition:opacity .5s cubic-bezier(.215,.61,.355,1) .4s,-webkit-transform .6s cubic-bezier(.215,.61,.355,1);transition:transform .6s cubic-bezier(.215,.61,.355,1),opacity .5s cubic-bezier(.215,.61,.355,1) .4s;transition:transform .6s cubic-bezier(.215,.61,.355,1),opacity .5s cubic-bezier(.215,.61,.355,1) .4s,-webkit-transform .6s cubic-bezier(.215,.61,.355,1);opacity:1}#app .page-nav-thumbs.state-open .page-nav-thumb .page-nav-title{opacity:1;bottom:-150px;-webkit-transition:bottom .4s .5s,opacity .5s .5s;transition:bottom .4s .5s,opacity .5s .5s}#app .page-nav-thumbs.state-open .page-nav-thumb.selected{-webkit-transition:opacity .5s 0s,-webkit-transform .5s;transition:opacity .5s 0s,-webkit-transform .5s;transition:transform .5s,opacity .5s 0s;transition:transform .5s,opacity .5s 0s,-webkit-transform .5s;-webkit-transform:scale(.3);transform:scale(.3);opacity:1}#app .page-nav-thumbs.state-open .page-nav-thumb.selected .page-nav-pic-wrapper:after{opacity:.25}#app .page-nav-thumbs.state-open .page-nav-thumb.selected .page-nav-title{-webkit-transition:bottom .4s .3s,opacity .5s .3s;transition:bottom .4s .3s,opacity .5s .3s}#app .page-nav-thumbs.state-open .page-title{opacity:.3}#app .page-nav-thumbs.state-close .page-nav-thumb.selected{-webkit-transition:opacity .4s .5s,-webkit-transform .5s;transition:opacity .4s .5s,-webkit-transform .5s;transition:transform .5s,opacity .4s .5s;transition:transform .5s,opacity .4s .5s,-webkit-transform .5s}#app .page-title{height:50%;top:0;left:0;bottom:0;right:0;opacity:0;color:#fff;-webkit-transition:opacity .4s .5s;transition:opacity .4s .5s}#app .page-title,#app .page-title p{width:100%;position:absolute;text-align:center}#app .page-title p{font-size:300em;font-weight:700;bottom:-.15em;text-transform:lowercase}#app.shape-light .page-nav-title,#app.shape-light .page-title p{color:#151516}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _getIterator2 = require("babel-runtime/core-js/get-iterator")
            , _getIterator3 = _interopRequireDefault(_getIterator2)
            , _mathTools = require("../scripts/mathTools")
            , _mathTools2 = _interopRequireDefault(_mathTools);
        exports.default = {
            data: function() {
                return {
                    widthItem: 0,
                    widthNav: 0,
                    offsetLeft: 0,
                    targetOffsetLeft: 0,
                    state: -1,
                    isTransitionEnd: !0,
                    highlighted: -1
                }
            },
            props: {
                items: [],
                scroll: 0,
                selected: 0,
                currentlabel: []
            },
            ready: function() {
                this.resize(),
                    this.update()
            },
            methods: {
                resize: function() {
                    var lastItem = this.getItemAtIndex(this.items.length - 1);
                    lastItem && (this.widthItem = lastItem.offsetWidth,
                        this.widthNav = lastItem ? this.widthItem + lastItem.offsetLeft : 0,
                        this.scrollToSelected())
                },
                update: function() {
                    this.transitionEnd && (this.targetOffsetLeft = .5 * (this.$root.size.w - this.widthItem) - (this.widthNav - this.$root.size.w) * this.scroll,
                        this.updateSelected())
                },
                updateSelected: function() {
                    for (var item, bounds, mousex = .5 * (this.$root.mouse.x + 1) * this.$root.size.w, items = this.$el.querySelectorAll(".page-nav-thumb"), hitItem = null, count = 0; null == hitItem && count < items.length; ) {
                        if (item = items[count],
                                bounds = item.getBoundingClientRect(),
                            mousex > bounds.left && mousex < bounds.right) {
                            hitItem = item;
                            break
                        }
                        count++
                    }
                    this.$set("highlighted", hitItem ? count : -1)
                },
                scrollToSelected: function() {
                    var item = this.getItemAtIndex(this.$get("selected"));
                    item && (this.targetOffsetLeft = -item.offsetLeft,
                        this.offsetLeft = this.targetOffsetLeft)
                },
                getItemAtIndex: function(index) {
                    var items = this.$el.querySelectorAll(".page-nav-thumb");
                    return items[index]
                },
                getTitle: function() {
                    var route = this.$root.$route.params.page ? this.$root.$route.params.page : ""
                        , menus = this.$root.data.menu
                        , _iteratorNormalCompletion = !0
                        , _didIteratorError = !1
                        , _iteratorError = void 0;
                    try {
                        for (var _step, _iterator = (0,
                            _getIterator3.default)(menus); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
                            var element = _step.value;
                            if (route === element.url.substring(1))
                                return element.label
                        }
                    } catch (err) {
                        _didIteratorError = !0,
                            _iteratorError = err
                    } finally {
                        try {
                            !_iteratorNormalCompletion && _iterator.return && _iterator.return()
                        } finally {
                            if (_didIteratorError)
                                throw _iteratorError
                        }
                    }
                    return ""
                }
            },
            events: {
                onResize: "resize",
                onEnterFrame: function() {
                    this.offsetLeft = _mathTools2.default.ease(this.offsetLeft, this.targetOffsetLeft, .1)
                },
                onSliderStart: function() {
                    this.resize(),
                        this.transitionEnd = !1,
                        this.state = 1;
                    var thumbSelected = this.$el.querySelectorAll(".page-nav-thumb.selected")[0];
                    thumbSelected ? thumbSelected.addEventListener("transitionend", function() {
                        this.transitionEnd = !0
                    }
                        .bind(this), !1) : this.transitionEnd = !0
                },
                onSliderStop: function() {
                    this.state = -1,
                        this.resize(),
                        this.$get("highlighted") > -1 ? this.$set("selected", this.$get("highlighted")) : this.$set("highlighted", this.$get("selected")),
                        this.scrollToSelected()
                },
                onSliderOver: function() {
                    this.state = 0
                }
            },
            watch: {
                scroll: "update",
                items: "resize",
                selected: function(value, oldValue) {
                    this.$set("highlighted", value),
                        this.$dispatch("onThumbItemSelect", value)
                },
                highlighted: function(value, oldValue) {
                    this.$dispatch("onThumbItemHighlight", value)
                }
            }
        },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = "<div class=page-nav-thumbs v-bind:class=\"{'state-preview':state==0, 'state-open':state==1, 'state-close':state==-1}\"><div class=page-title><p>{{{ getTitle() }}}</div><ul class=page-nav-thumbs v-bind:style=\"{'transform':'translate3d(' + offsetLeft + 'px, 0, 0)', width:widthNav}\"><li class=page-nav-thumb v-for=\"item in items\" v-bind:class=\"{selected:$index==(highlighted > -1 ? highlighted : selected)}\" v-bind:style=\"{width:$root.size.w + 'px', height:$root.size.h + 'px',left:$root.size.w * 0.4 * $index + 'px','z-index':-($index + 1) * 10}\"><div class=page-nav-pic-wrapper v-bind:style=\"{'background-image':'url('+item.img.src+')'}\"></div><p class=page-nav-title>{{{item.title}}}</ul></div>"
    }
        , {
            "../scripts/mathTools": 129,
            "babel-runtime/core-js/get-iterator": 2,
            "vueify/lib/insert-css": 103
        }],
    117: [function(require, module, exports) {
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert("#app.is-mobile .popin-mobile[_v-540cc3e9],#app .popin[_v-540cc3e9],.common-fixed-full[_v-540cc3e9]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app.is-mobile .popin-mobile .button-close-popin[_v-540cc3e9]:before,#app .popin .form .button-open[_v-540cc3e9]:before,#app .popin .form .button-send[_v-540cc3e9]:before,#app .popin .form .form-message[_v-540cc3e9],#app .popin .form[_v-540cc3e9],.common-absolute-full[_v-540cc3e9]{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app .popin .content-block[_v-540cc3e9],.common-block-full[_v-540cc3e9]{display:block;width:100%;height:100%}.common-center-cover[_v-540cc3e9],.picture-cover[_v-540cc3e9]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover[_v-540cc3e9],.common-hover[_v-540cc3e9]:hover{color:#7ad71f}.common-hover[_v-540cc3e9]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-540cc3e9]{display:block;text-align:center}#app .popin.ready .part-left[_v-540cc3e9],.border-popin[_v-540cc3e9]{border-top:40em solid #151516;border-left:40em solid #151516;border-bottom:40em solid #151516}#app .popin.closing .part-left[_v-540cc3e9],#app .popin .part-left[_v-540cc3e9],.border-popin-zero[_v-540cc3e9]{border-top:0 solid #151516;border-left:0 solid #151516;border-bottom:0 solid #151516}#app .popin[_v-540cc3e9]{z-index:3}#app .popin .close-cursor[_v-540cc3e9]{position:fixed;z-index:5;opacity:0;margin-top:-13px;margin-left:-13px;pointer-events:none}#app .popin.cursor-cancel-show[_v-540cc3e9]{cursor:none}#app .popin.cursor-cancel-show .close-cursor[_v-540cc3e9]{opacity:1;-webkit-transition:opacity .5s;transition:opacity .5s}#app .popin .part-left[_v-540cc3e9],#app .popin .part-right[_v-540cc3e9]{position:relative;box-sizing:border-box;float:left;width:100%;height:100%;overflow:hidden;opacity:0}#app .popin .part-left[_v-540cc3e9]{width:0;background-color:#fff;-webkit-transform:scale3d(1.2,1.2,1);transform:scale3d(1.2,1.2,1)}#app .popin .popin-title-wrapper[_v-540cc3e9]{float:left;box-sizing:border-box;width:115em;color:#000;height:100%;opacity:0;border-right:1px solid rgba(0,0,0,.2)}#app .popin .popin-title[_v-540cc3e9]{text-align:center;-webkit-writing-mode:vertical-lr;-ms-writing-mode:tb-lr;writing-mode:vertical-lr;height:100%;line-height:6.388888888888889em;-webkit-transform:rotate(180deg);transform:rotate(180deg)}#app .popin .content-block[_v-540cc3e9]{overflow:hidden;width:calc(100% - 115em);box-sizing:border-box;border:110em solid #fff;opacity:0}#app .popin .popin-template[_v-540cc3e9]{display:table-cell;width:100%;vertical-align:middle}#app .popin .no-title .popin-title-wrapper[_v-540cc3e9]{display:none}#app .popin .no-title .content-block[_v-540cc3e9]{width:100%}#app .popin .form[_v-540cc3e9]{display:table;z-index:1}#app .popin .form .button-open[_v-540cc3e9]{position:relative;width:215px;height:215px;box-sizing:border-box;cursor:pointer;position:absolute;top:calc(50% - 107.5px);left:calc(50% - 107.5px);z-index:5}#app .popin .form .button-open .button-label[_v-540cc3e9]{position:relative;z-index:2;line-height:215px;text-align:center;font-size:47px;font-weight:700;opacity:1;-webkit-transition:opacity .3s;transition:opacity .3s}#app .popin .form .button-open[_v-540cc3e9]:before{content:'';display:block;border-radius:50%;background-color:#7ad71f;z-index:1;-webkit-transform:scale(1);transform:scale(1);-webkit-transition:-webkit-transform .3s;transition:-webkit-transform .3s;transition:transform .3s;transition:transform .3s,-webkit-transform .3s}#app .popin .form .button-open[_v-540cc3e9]:hover:before{-webkit-transform:scale(1.05);transform:scale(1.05)}#app .popin .form .button-open a.button-label[_v-540cc3e9]{display:block;text-decoration:none;color:#fff}#app .popin .form .button-send[_v-540cc3e9]{position:relative;width:100px;height:100px;box-sizing:border-box;cursor:pointer;position:absolute;bottom:10%;left:calc(50% - 50px);z-index:4;opacity:0;pointer-events:none;-webkit-transition:opacity .5s;transition:opacity .5s}#app .popin .form .button-send .button-label[_v-540cc3e9]{position:relative;z-index:2;line-height:100px;text-align:center;font-size:18px;font-weight:700;opacity:1;-webkit-transition:opacity .3s;transition:opacity .3s}#app .popin .form .button-send[_v-540cc3e9]:before{content:'';display:block;border-radius:50%;background-color:#fff;z-index:1;-webkit-transform:scale(1);transform:scale(1);-webkit-transition:-webkit-transform .3s;transition:-webkit-transform .3s;transition:transform .3s;transition:transform .3s,-webkit-transform .3s}#app .popin .form .button-send[_v-540cc3e9]:hover:before{-webkit-transform:scale(1.05);transform:scale(1.05)}#app .popin .form .button-send .button-label[_v-540cc3e9]{color:#151516;font-weight:400}#app .popin .form .fields[_v-540cc3e9]{position:relative;display:table-cell;vertical-align:middle;z-index:3;width:70%;opacity:0;pointer-events:none;-webkit-transition:opacity .5s;transition:opacity .5s}#app .popin .form .fields .field[_v-540cc3e9]{width:100%;text-align:center;font-size:18px;padding-bottom:15px;border-bottom:1px solid #fff;margin-bottom:30px;cursor:text}#app .popin .form .fields .field[_v-540cc3e9]::-webkit-input-placeholder{color:#fff}#app .popin .form .fields .field[_v-540cc3e9]:-moz-placeholder,#app .popin .form .fields .field[_v-540cc3e9]::-moz-placeholder{color:#fff}#app .popin .form .fields .field[_v-540cc3e9]:-ms-input-placeholder{color:#fff}#app .popin .form .fields textarea[_v-540cc3e9]{outline:none;resize:none;overflow:hidden;height:100px;padding-bottom:50px}#app .popin .form .form-message[_v-540cc3e9]{z-index:1;text-align:center;font-size:25px;font-weight:700;top:50%;opacity:0;-webkit-transition:opacity .5s;transition:opacity .5s}#app .popin .form.open .button-open[_v-540cc3e9]{z-index:2;pointer-events:none}#app .popin .form.open .button-open[_v-540cc3e9]:before{-webkit-transform:scale(10);transform:scale(10)}#app .popin .form.open .button-open .button-label[_v-540cc3e9]{opacity:0}#app .popin .form.open .fields[_v-540cc3e9]{z-index:3;opacity:1;pointer-events:auto}#app .popin .form.open .button-send[_v-540cc3e9]{z-index:4;opacity:1;pointer-events:auto}#app .popin .form.message .button-send[_v-540cc3e9],#app .popin .form.message .fields[_v-540cc3e9]{opacity:0}#app .popin .form.message .form-message[_v-540cc3e9]{z-index:5;opacity:1}#app .popin.ready .part-left[_v-540cc3e9],#app .popin.ready .part-right[_v-540cc3e9]{opacity:1;width:50%;-webkit-transition:width 1s cubic-bezier(.165,.84,.44,1) .3s,border 0s 1s,opacity .3s,-webkit-transform 1s cubic-bezier(.165,.84,.44,1) 1s;transition:width 1s cubic-bezier(.165,.84,.44,1) .3s,border 0s 1s,opacity .3s,-webkit-transform 1s cubic-bezier(.165,.84,.44,1) 1s;transition:width 1s cubic-bezier(.165,.84,.44,1) .3s,transform 1s cubic-bezier(.165,.84,.44,1) 1s,border 0s 1s,opacity .3s;transition:width 1s cubic-bezier(.165,.84,.44,1) .3s,transform 1s cubic-bezier(.165,.84,.44,1) 1s,border 0s 1s,opacity .3s,-webkit-transform 1s cubic-bezier(.165,.84,.44,1) 1s}#app .popin.ready .part-left[_v-540cc3e9]{-webkit-transform:scaleX(1);transform:scaleX(1)}#app .popin.ready .content-block[_v-540cc3e9]{opacity:1;-webkit-transition:opacity .5s 1.3s;transition:opacity .5s 1.3s}#app .popin.ready .popin-title-wrapper[_v-540cc3e9]{opacity:1;-webkit-transition:opacity 1s 1.4s;transition:opacity 1s 1.4s}#app .popin.closing .part-left[_v-540cc3e9]{width:0;-webkit-transform:scale3d(1.2,1.2,1);transform:scale3d(1.2,1.2,1)}#app .popin.closing .part-right[_v-540cc3e9]{width:100%}#app .popin.closing .part-left[_v-540cc3e9],#app .popin.closing .part-right[_v-540cc3e9]{opacity:0;-webkit-transition:width 1s cubic-bezier(.165,.84,.44,1) .3s,border 0s .4s,opacity .5s 1s,-webkit-transform .8s cubic-bezier(.165,.84,.44,1);transition:width 1s cubic-bezier(.165,.84,.44,1) .3s,border 0s .4s,opacity .5s 1s,-webkit-transform .8s cubic-bezier(.165,.84,.44,1);transition:width 1s cubic-bezier(.165,.84,.44,1) .3s,transform .8s cubic-bezier(.165,.84,.44,1),border 0s .4s,opacity .5s 1s;transition:width 1s cubic-bezier(.165,.84,.44,1) .3s,transform .8s cubic-bezier(.165,.84,.44,1),border 0s .4s,opacity .5s 1s,-webkit-transform .8s cubic-bezier(.165,.84,.44,1)}#app .popin.closing .content-block[_v-540cc3e9],#app .popin.closing .popin-title-wrapper[_v-540cc3e9]{opacity:0;-webkit-transition:opacity .3s;transition:opacity .3s}#app.is-mobile .popin-mobile[_v-540cc3e9]{background-color:#fff;z-index:3}#app.is-mobile .popin-mobile .logo[_v-540cc3e9]{position:absolute;margin:40px 0 0 40px;padding:0;color:#151516;font-size:30px;font-weight:700;text-transform:lowercase}#app.is-mobile .popin-mobile .button-close-popin[_v-540cc3e9]{position:relative;width:46em;height:46em;box-sizing:border-box;cursor:pointer;position:absolute;top:25em;right:40em;padding:16em;z-index:0}#app.is-mobile .popin-mobile .button-close-popin .button-label[_v-540cc3e9]{position:relative;z-index:2;line-height:46em;text-align:center;font-size:10em;font-weight:700;opacity:1;-webkit-transition:opacity .3s;transition:opacity .3s}#app.is-mobile .popin-mobile .button-close-popin[_v-540cc3e9]:before{content:'';display:block;border-radius:50%;background-color:#fff;z-index:1;-webkit-transform:scale(1);transform:scale(1);-webkit-transition:-webkit-transform .3s;transition:-webkit-transform .3s;transition:transform .3s;transition:transform .3s,-webkit-transform .3s}#app.is-mobile .popin-mobile .button-close-popin[_v-540cc3e9]:hover:before{-webkit-transform:scale(1.05);transform:scale(1.05)}#app.is-mobile .popin-mobile .button-close-popin .button-open-close[_v-540cc3e9]{position:relative;z-index:1;fill:#151516}#app.is-mobile .popin-mobile .popin-content[_v-540cc3e9]{display:table-cell;vertical-align:middle;padding:100em 12.5% 0}#app.is-mobile .popin-mobile .popin-template[_v-540cc3e9]{margin:25em 0;width:100%}#app.is-mobile .popin-mobile .button-open[_v-540cc3e9]{display:table-cell;vertical-align:middle}#app.is-mobile .popin-mobile .button-open .button-label[_v-540cc3e9]{display:block;color:#7ad71f;font-size:25px;font-weight:700;padding-bottom:1em;margin-bottom:1em}#app.is-mobile .popin-mobile.mobile-nav-opened[_v-540cc3e9]{opacity:0}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _RSTemplate = require("./RSTemplate.vue")
            , _RSTemplate2 = _interopRequireDefault(_RSTemplate)
            , _Scroller = require("./Scroller.vue")
            , _Scroller2 = _interopRequireDefault(_Scroller);
        exports.default = {
            data: function() {
                return {
                    formIsOpen: !1,
                    formIsOver: !1,
                    formDataValue: {},
                    formMessage: "",
                    popinReady: !1,
                    popinClosing: !1
                }
            },
            props: ["data"],
            computed: {
                scrollBox: function() {
                    return this.$el.querySelector(".content-block")
                },
                formData: function formData() {
                    var formsData = JSON.parse(this.$eval("$root.data.forms|json"))
                        , formID = this.data.form
                        , formData = formsData[formID];
                    return formData
                },
                cursorX: function() {
                    return .5 * (this.$root.mouse.x + 1) * this.$root.size.w
                },
                cursorY: function() {
                    return .5 * (this.$root.mouse.y + 1) * this.$root.size.h
                },
                cursorShow: function() {
                    return !this.$root.mouse.out && !this.formIsOver && this.cursorX > 10 && this.cursorX < this.$root.size.w - 10 && this.cursorY > 10 && this.cursorY < this.$root.size.h - 10
                }
            },
            ready: function() {
                setTimeout(function() {
                    this.popinReady = !0
                }
                    .bind(this), 100)
            },
            methods: {
                closePopin: function() {
                    this.popinClosing || (this.popinClosing = !0,
                        this.formMessage = "",
                        setTimeout(function() {
                            this.$route.router.go(this.$route.path.substr(0, this.$route.path.lastIndexOf("/")))
                        }
                            .bind(this), this.$root.isMobile ? 0 : 1700))
                },
                onMouseOver: function(e) {
                    this.formIsOpen || "button-label" !== e.target.className ? this.formIsOpen && (this.formIsOver = !0) : this.formIsOver = !0
                },
                onMouseOut: function(e) {
                    this.formIsOpen || "button-label" !== e.target.className ? this.formIsOpen && (this.formIsOver = !1) : this.formIsOver = !1
                },
                openForm: function() {
                    this.formIsOpen = !0
                },
                sendForm: function() {
                    var sendData = JSON.parse(this.$eval("formDataValue | json"));
                    this.$http.post(this.formData.service, sendData, {
                        emulateJSON: !0
                    }).then(function(response) {
                        response.data.success ? this.formMessage = response.data.success : (this.formMessage = response.data.error,
                            this.removeMessageDelay())
                    }, function(error) {
                        this.formMessage = this.$root.wordingData["server-error"],
                            console.log(error),
                            this.removeMessageDelay()
                    })
                },
                removeMessageDelay: function() {
                    setTimeout(function() {
                        this.formMessage = ""
                    }
                        .bind(this), 2e3)
                },
                textareaClick: function() {
                    var textarea = this.$el.querySelector("textarea");
                    textarea.focus()
                },
                mailTo: function() {
                    var mailto = this.$root.data.careers[1].template.components[3].link.url;
                    window.open(mailto, "_blank")
                }
            },
            events: {},
            components: {
                rstemplate: _RSTemplate2.default,
                scroller: _Scroller2.default
            }
        },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = '<div :class="{\'popin-mobile\' : $root.isMobile, \'popin\': !$root.isMobile, \'ready\':popinReady, \'closing\':popinClosing, \'cursor-cancel-show\':cursorShow}" @click=closePopin() _v-540cc3e9=""><template v-if=$root.isMobile><div class=button-close-popin @click=closePopin() _v-540cc3e9=""><svg class=button-open-close viewBox="0 0 14 14" _v-540cc3e9=""><g class=button-close transform="translate(7, -3) rotate(45)" _v-540cc3e9=""><rect x=0 y=6 width=14 height=2 _v-540cc3e9=""></rect><rect x=6 y=0 width=2 height=14 _v-540cc3e9=""></rect></g></svg></div><scroller :enabled=true class=content-block _v-540cc3e9=""><div class=popin-content _v-540cc3e9=""><h1 class=popin-title _v-540cc3e9="">{{data.title}}</h1><h2 class=popin-subtitle _v-540cc3e9="">{{data.subtitle}}</h2><rstemplate v-if=data.template :template-data=data.template class=popin-template _v-540cc3e9=""></rstemplate><div v-if=data.mailto class=button-open @mouseover=onMouseOver @mouseout=onMouseOut _v-540cc3e9=""><a href=mailto:{{data.mailto}} class=button-label target=_blank _v-540cc3e9="">{{formData.open}}</a></div></div></scroller></template><template v-else=""><img class=close-cursor src=/assets/cancel.png :style="{\'top\':cursorY + \'px\', \'left\':cursorX + \'px\'}" _v-540cc3e9=""><div class=part-left :class="{\'no-title\':!data.title}" _v-540cc3e9=""><div class=popin-title-wrapper _v-540cc3e9=""><h1 class=popin-title _v-540cc3e9="">{{data.title}}</h1></div><scroller :enabled=true class=content-block _v-540cc3e9=""><rstemplate v-if=data.template :template-data=data.template class=popin-template _v-540cc3e9=""></rstemplate></scroller></div><div class=part-right _v-540cc3e9=""><div class=picture-cover :style="{\'background-image\':\'url(\' + data.pic + \')\'}" _v-540cc3e9=""></div><div v-if=formData class=form :class="{\'open\':formIsOpen,\'message\':formMessage}" @mouseover=onMouseOver @mouseout=onMouseOut _v-540cc3e9=""><div v-if=data.mailto class=button-open @mouseover=onMouseOver @mouseout=onMouseOut _v-540cc3e9=""><a href=mailto:{{data.mailto}} class=button-label target=_blank _v-540cc3e9="">{{formData.open}}</a></div><div class=fields _v-540cc3e9=""><template v-for="field in formData.fields"><input v-if="field != \'message\'" class=field type=text @click.stop="" v-model=formDataValue[field] :placeholder=field _v-540cc3e9=""><textarea v-if="field == \'message\'" class=field @click.stop.prevent=textareaClick v-model=formDataValue[field] :placeholder=field _v-540cc3e9=""></textarea></template></div><p class=form-message _v-540cc3e9="">{{{formMessage}}}<div class=button-send @click.stop.prevent=sendForm() _v-540cc3e9=""><p class=button-label _v-540cc3e9="">{{formData.valid}}</div></div></div></template></div>'
    }
        , {
            "./RSTemplate.vue": 120,
            "./Scroller.vue": 122,
            "vueify/lib/insert-css": 103
        }],
    118: [function(require, module, exports) {
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app .popin-preview,.common-absolute-full{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full{display:block;width:100%;height:100%}#app .popin-preview,.common-center-cover{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover,.common-hover:hover{color:#7ad71f}.common-hover{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center{display:block;text-align:center}#app .popin-preview{opacity:0;-webkit-transition:opacity .2s .1s;transition:opacity .2s .1s}#app .popin-preview.show{opacity:.3;-webkit-transition:opacity .5s;transition:opacity .5s}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }),
            exports.default = {
                data: function() {
                    return {
                        show: !1,
                        src: ""
                    }
                },
                computed: {},
                attached: function() {},
                components: {},
                events: {
                    popinPreviewShow: function(url) {
                        this.show = !0,
                            this.src = url
                    },
                    popinPreviewHide: function() {
                        this.show = !1
                    }
                }
            },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = "<div class=popin-preview v-if=!$root.isMobile :class=\"{'show':show}\" :style=\"{'background-image':'url(' + src + ')'}\"></div>"
    }
        , {
            "vueify/lib/insert-css": 103
        }],
    119: [function(require, module, exports) {
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full[_v-c4e0768a]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-absolute-full[_v-c4e0768a],.preview .picture[_v-c4e0768a]:after{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full[_v-c4e0768a],.preview .wrapper[_v-c4e0768a],.preview[_v-c4e0768a],.preview[_v-c4e0768a]:before{display:block;width:100%;height:100%}.common-center-cover[_v-c4e0768a],.preview .picture[_v-c4e0768a]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover[_v-c4e0768a],.common-hover[_v-c4e0768a]:hover{color:#7ad71f}.common-hover[_v-c4e0768a]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-c4e0768a]{display:block;text-align:center}.preview[_v-c4e0768a]{position:fixed;bottom:0;z-index:-1;overflow:hidden;opacity:0;cursor:pointer;pointer-events:none;box-sizing:border-box;height:235em;-webkit-transition:opacity .5s,height .5s .7s;transition:opacity .5s,height .5s .7s}.preview[_v-c4e0768a]:before{content:'';-webkit-transition:height .5s;transition:height .5s}.preview .title[_v-c4e0768a]{font-size:50em;top:65%;left:18%;z-index:1;font-weight:700;text-align:left}.preview .next[_v-c4e0768a],.preview .title[_v-c4e0768a]{position:absolute;display:block;text-transform:lowercase;opacity:0}.preview .next[_v-c4e0768a]{font-size:25em;line-height:normal;vertical-align:middle;bottom:0;right:18%;text-align:right;z-index:2}.preview .wrapper[_v-c4e0768a]{position:relative;overflow:hidden;margin:0 auto;width:80%}.preview .picture[_v-c4e0768a]{position:absolute;left:0;right:0;-webkit-transform:scale3d(1.15,1.15,1) translateY(10%);transform:scale3d(1.15,1.15,1) translateY(10%);-webkit-transition:-webkit-transform .8s cubic-bezier(.215,.61,.355,1);transition:-webkit-transform .8s cubic-bezier(.215,.61,.355,1);transition:transform .8s cubic-bezier(.215,.61,.355,1);transition:transform .8s cubic-bezier(.215,.61,.355,1),-webkit-transform .8s cubic-bezier(.215,.61,.355,1)}.preview .picture[_v-c4e0768a]:after{content:'';background-color:#000;opacity:.5;-webkit-transition:opacity .5s;transition:opacity .5s}.preview .timer[_v-c4e0768a]{position:relative;top:0;left:0;height:1px;background-color:#fff;z-index:1}.preview.show[_v-c4e0768a]{opacity:1;z-index:5;pointer-events:auto}.preview.show[_v-c4e0768a]:before{-webkit-transition:height .8s cubic-bezier(.215,.61,.355,1);transition:height .8s cubic-bezier(.215,.61,.355,1);height:0}.preview.show .title[_v-c4e0768a]{-webkit-transition:opacity 1.2s .4s,top 1.2s cubic-bezier(.215,.61,.355,1) .3s;transition:opacity 1.2s .4s,top 1.2s cubic-bezier(.215,.61,.355,1) .3s;top:45%;opacity:1}.preview.show .next[_v-c4e0768a]{-webkit-transition:opacity .7s .4s,bottom .7s cubic-bezier(.215,.61,.355,1) .3s;transition:opacity .7s .4s,bottom .7s cubic-bezier(.215,.61,.355,1) .3s;bottom:40%;opacity:1}.preview.show .picture[_v-c4e0768a]{-webkit-transform:scale3d(1.15,1.15,1) translate(0);transform:scale3d(1.15,1.15,1) translate(0)}.preview:hover .picture[_v-c4e0768a]{-webkit-transform:scale3d(1.14,1.14,1) translate(0);transform:scale3d(1.14,1.14,1) translate(0)}.preview:hover .picture[_v-c4e0768a]:after{opacity:0}.preview.selected[_v-c4e0768a]{height:100%}.preview.selected .title[_v-c4e0768a]{-webkit-transition:opacity 1.2s,top 1.2s cubic-bezier(.215,.61,.355,1);transition:opacity 1.2s,top 1.2s cubic-bezier(.215,.61,.355,1);opacity:0;top:25%}.preview.selected .next[_v-c4e0768a]{-webkit-transition:opacity .7s,bottom .7s cubic-bezier(.215,.61,.355,1);transition:opacity .7s,bottom .7s cubic-bezier(.215,.61,.355,1);opacity:0;bottom:40%}.preview.selected .picture[_v-c4e0768a]{-webkit-transition:-webkit-transform 2s .5s;transition:-webkit-transform 2s .5s;transition:transform 2s .5s;transition:transform 2s .5s,-webkit-transform 2s .5s;-webkit-transform:scaleX(1) translate(0);transform:scaleX(1) translate(0)}.preview.selected .picture[_v-c4e0768a]:after{opacity:0}.preview.selected .timer[_v-c4e0768a]{display:none}#app .preview.closing[_v-c4e0768a]{-webkit-transition:opacity 0s 0s,height 0s 0s;transition:opacity 0s 0s,height 0s 0s}#app.is-mobile .preview[_v-c4e0768a]{height:115em;-webkit-transition:opacity .5s,height .5s 0;transition:opacity .5s,height .5s 0}#app.is-mobile .preview .wrapper[_v-c4e0768a]{width:100%!important}#app.is-mobile .preview .title[_v-c4e0768a]{font-size:16em}#app.is-mobile .preview .next[_v-c4e0768a]{font-size:10em}#app.is-mobile .preview.show[_v-c4e0768a]{opacity:1}#app.is-mobile .preview.show[_v-c4e0768a]:before{-webkit-transition:height .5s;transition:height .5s;height:0}#app.is-mobile .preview.selected[_v-c4e0768a]{height:100%}#app.is-mobile .preview.selected .picture[_v-c4e0768a]{-webkit-transition:height .5s 0,-webkit-transform .8s 0;transition:height .5s 0,-webkit-transform .8s 0;transition:height .5s 0,transform .8s 0;transition:height .5s 0,transform .8s 0,-webkit-transform .8s 0}#app.is-mobile .preview.selected .next[_v-c4e0768a],#app.is-mobile .preview.selected .title[_v-c4e0768a]{-webkit-transition:opacity 0s 0;transition:opacity 0s 0}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _gsap = require("../../node_modules/gsap")
            , _gsap2 = _interopRequireDefault(_gsap);
        exports.default = {
            data: function() {
                return {
                    selected: !1,
                    closing: !1,
                    timerPercent: 0
                }
            },
            props: ["title", "picture", "show"],
            ready: function() {},
            attached: function() {},
            methods: {
                onMouseOver: function() {
                    if (!this.selected && !this.$root.isMobile) {
                        var wrapper = this.$el.querySelector(".wrapper");
                        _gsap2.default.to(wrapper, .5, {
                            width: "85%",
                            onUpdate: this.onUpdateWrapper
                        })
                    }
                },
                onMouseOut: function() {
                    if (!this.selected && !this.$root.isMobile) {
                        var wrapper = this.$el.querySelector(".wrapper");
                        _gsap2.default.to(wrapper, .5, {
                            width: "80%",
                            onUpdate: this.onUpdateWrapper
                        })
                    }
                },
                onUpdateWrapper: function() {
                    if (this.$el) {
                        var wrapper = this.$el.querySelector(".wrapper")
                            , picture = this.$el.querySelector(".picture");
                        picture.style.left = .5 * -(picture.offsetWidth - wrapper.offsetWidth) + "px"
                    }
                },
                onSelect: function() {
                    if (!this.selected) {
                        var wrapper = this.$el.querySelector(".wrapper");
                        this.$set("selected", !0),
                            this.$dispatch("onNextItemStart"),
                            this.$off("onEnterFrame", this.updateTimer),
                            _gsap2.default.to(wrapper, .5, {
                                width: "100%",
                                onUpdate: this.onUpdateWrapper
                            }),
                            setTimeout(this.onAnimationEnd.bind(this), 2500)
                    }
                },
                onAnimationEnd: function() {
                    var wrapper = this.$el.querySelector(".wrapper");
                    this.closing = !0,
                        this.$dispatch("onNextItemEnd"),
                        _gsap2.default.to(wrapper, 0, {
                            width: "80%",
                            delay: .1,
                            onUpdate: this.onUpdateWrapper
                        })
                },
                updateTimer: function() {
                    this.$set("timerPercent", Math.min(this.timerPercent + .4, 100))
                }
            },
            events: {},
            watch: {
                show: function(value) {
                    this.selected = !1,
                    value && (this.closing = !1),
                        this.onUpdateWrapper(),
                        this.timerPercent = 0,
                        value ? this.$on("onEnterFrame", this.updateTimer) : this.$off("onEnterFrame", this.updateTimer)
                },
                timerPercent: function(value) {
                    value >= 100 && this.onSelect()
                }
            },
            components: {}
        },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = "<div class=preview :class=\"{'show':show, 'selected':selected, 'closing':closing}\" @click=onSelect @mouseover=onMouseOver @mouseout=onMouseOut _v-c4e0768a=\"\"><h1 class=title _v-c4e0768a=\"\">{{{title}}}</h1><p class=next _v-c4e0768a=\"\">{{{$root.wordingData['next']}}}<div class=wrapper _v-c4e0768a=\"\"><div class=timer :style=\"{'width':timerPercent + '%'}\" _v-c4e0768a=\"\"></div><div class=picture :style=\"{'background-image':'url(' + picture + ')', 'width':$root.size.w + 'px', 'height':$root.size.h + 'px'}\" _v-c4e0768a=\"\"></div></div></div>"
    }
        , {
            "../../node_modules/gsap": 80,
            "vueify/lib/insert-css": 103
        }],
    120: [function(require, module, exports) {
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert('.common-fixed-full[_v-5845b698]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-absolute-full[_v-5845b698],.video-cta[_v-5845b698]:after{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full[_v-5845b698]{display:block;width:100%;height:100%}.common-center-cover[_v-5845b698]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}#app .rs-template .action:hover h1[_v-5845b698],#app .rs-template .action h1[_v-5845b698]:hover,#app .rs-template .split-view .text-normal.text-link[_v-5845b698]:hover,#app .rs-template .text-link[_v-5845b698]:hover,.common-force-hover[_v-5845b698],.common-hover[_v-5845b698]:hover{color:#7ad71f}#app .rs-template .action h1[_v-5845b698],#app .rs-template .split-view .text-normal.text-link[_v-5845b698],#app .rs-template .text-link[_v-5845b698],.common-hover[_v-5845b698]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-5845b698]{display:block;text-align:center}#app .rs-template.rs-template-case .case-title[_v-5845b698],#app .rs-template.rs-template-case .items[_v-5845b698],#app .rs-template.rs-template-case .text-list[_v-5845b698],#app .rs-template.rs-template-case .text-regular[_v-5845b698],#app .rs-template.rs-template-case .text-title[_v-5845b698],#app .rs-template.rs-template-case .video-cta[_v-5845b698],#app .rs-template.rs-template-case .video[_v-5845b698]{width:53%;margin-left:auto;margin-right:auto}#app .rs-template.rs-template-case .video-cta[_v-5845b698],#app .rs-template.rs-template-case .video-full[_v-5845b698]{width:100%;margin-bottom:22vh}#app .rs-template.rs-template-case .video-full img[_v-5845b698],#app .rs-template.rs-template-case .video-full video[_v-5845b698],#app .rs-template.rs-template-case .video img[_v-5845b698],#app .rs-template.rs-template-case .video video[_v-5845b698]{width:100%;height:auto}#app .rs-template.rs-template-case .video+.parallax[_v-5845b698]{margin-top:22vh}#app .rs-template.rs-template-case .split-view .case-title[_v-5845b698],#app .rs-template.rs-template-case .split-view .text-regular[_v-5845b698],#app .rs-template.rs-template-case .split-view .text-title[_v-5845b698]{width:61%}#app .rs-template.rs-template-case .split-view .text-regular[_v-5845b698]{margin-bottom:0}#app .rs-template.rs-template-case .split-view .video-cta[_v-5845b698]{width:100%;margin-bottom:0}#app .rs-template.rs-template-case .box-pic[_v-5845b698]{width:100%;box-sizing:border-box;padding:22vh 23.5%}#app .rs-template.rs-template-case h1.text-title+.box-pic[_v-5845b698]{padding-top:18vh}#app .rs-template.rs-template-case .case-title[_v-5845b698]{margin-top:140em;margin-bottom:60em;width:1024em}#app .rs-template.rs-template-case .text-case-title[_v-5845b698]{font-size:18em;line-height:1.1em;font-weight:500;margin-bottom:1.11em}#app .rs-template.rs-template-case .text-case-title-info[_v-5845b698]{font-size:50em;line-height:1.2em;font-weight:700}#app .rs-template.rs-template-case .text-title[_v-5845b698]{font-size:50em;line-height:1.3em;margin-bottom:4vh}#app .rs-template.rs-template-case .text-list .text-medium[_v-5845b698],#app .rs-template.rs-template-case .text-regular[_v-5845b698]{font-size:25em;font-weight:400;line-height:1.66em;margin-bottom:22vh}#app .rs-template.rs-template-case .text-list .text-medium[_v-5845b698]{margin-bottom:0}#app .rs-template.rs-template-case .text-list[_v-5845b698]{padding:0}#app .rs-template.rs-template-case .text-list li[_v-5845b698]{position:relative;list-style:none}#app .rs-template.rs-template-case .text-list li[_v-5845b698]:before{content:"";display:inline-block;height:2vh;width:1vw;border-left:1px solid #7ad71f}#app .rs-template.rs-template-case .text-item-sub[_v-5845b698]{color:#37383a}#app .rs-template.rs-template-case .block-dark[_v-5845b698]{background-color:#131313;padding:22vh 0}#app .rs-template.rs-template-case .block-dark .text-title[_v-5845b698]{color:#fff}#app .rs-template.rs-template-case .block-dark .text-credit[_v-5845b698],#app .rs-template.rs-template-case .block-dark .text-lines[_v-5845b698],#app .rs-template.rs-template-case .block-dark .text-list li[_v-5845b698],#app .rs-template.rs-template-case .block-dark .text-normal[_v-5845b698],#app .rs-template.rs-template-case .block-dark .text-regular[_v-5845b698],#app .rs-template.rs-template-case .block-dark .text-title-highlight[_v-5845b698]{color:#5e5f64}#app .rs-template.rs-template-case .block-dark [_v-5845b698]:last-child{margin-bottom:0}#app .rs-template.rs-template-case .block-dark+.text-title[_v-5845b698]{margin-top:22vh}#app .rs-template.rs-template-case .block-grey[_v-5845b698]{background-color:#e9edee;padding:22vh 0 0;margin-bottom:22vh}#app .rs-template.rs-template-case .block-grey [_v-5845b698]:last-child{margin-bottom:0}#app .rs-template.rs-template-case .items[_v-5845b698]{font-size:50em}#app .rs-template.rs-template-case .items .item[_v-5845b698]{width:100%;padding:0}#app .rs-template.rs-template-case .items .item span[_v-5845b698]{width:auto;font-size:100%;line-height:normal;font-weight:700}#app .rs-template.rs-template-case h1.text-title+.items[_v-5845b698]{margin:18vh auto}#app .rs-template.rs-template-case.fia .items .item span.text-item-title[_v-5845b698],#app .rs-template.rs-template-case.fia .text-highlight[_v-5845b698]{color:#d3b16e}#app .rs-template.rs-template-case.maif .items .item .text-item-sub .text-highlight[_v-5845b698],#app .rs-template.rs-template-case.maif .items .item span.text-item-title[_v-5845b698],#app .rs-template.rs-template-case.maif .text-highlight[_v-5845b698]{color:#e51106}#app .rs-template.rs-template-case.maif .text-regular+img[_v-5845b698]{padding-top:0;margin-top:-12vh}#app .rs-template.rs-template-case.maif .block-grey[_v-5845b698]{padding-bottom:22vh}#app .rs-template.rs-template-case.bpi .items .item .text-item-sub .text-highlight[_v-5845b698],#app .rs-template.rs-template-case.bpi .items .item span.text-item-title[_v-5845b698],#app .rs-template.rs-template-case.bpi .text-highlight[_v-5845b698]{color:#ffba00}#app .rs-template.rs-template-case.bpi .text-regular+img[_v-5845b698]{padding-top:0;margin-top:-12vh}#app .rs-template.rs-template-case.bpi .text-list+.video-cta[_v-5845b698]{margin-top:22vh}#app .rs-template.rs-template-case.bpi .video-cta+.block-grey[_v-5845b698]{margin-top:-22vh}#app .rs-template.rs-template-case.bpi .block-grey+.block-grey[_v-5845b698]{margin-top:-22vh;padding:0 0 22vh}#app .rs-template.rs-template-case.bpi .text-title+.parallax[_v-5845b698]{margin-top:22vh}#app.is-mobile .rs-template.rs-template-case .case-title[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .items[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .text-list[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .text-regular[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .text-title[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .video-cta[_v-5845b698]{width:75%}#app.is-mobile .rs-template.rs-template-case .case-title .item[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .items .item[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .text-list .item[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .text-regular .item[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .text-title .item[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .video-cta .item[_v-5845b698]{padding:0;margin-bottom:45em}#app.is-mobile .rs-template.rs-template-case .video-full[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .video[_v-5845b698]{width:100%}#app.is-mobile .rs-template.rs-template-case .video-full img[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .video-full video[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .video img[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .video video[_v-5845b698]{width:100%;height:auto}#app.is-mobile .rs-template.rs-template-case .split-view .rs-template-split-view-left[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .split-view .rs-template-split-view-right[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .split-view .video-cta[_v-5845b698]{width:100%;margin-bottom:0}#app.is-mobile .rs-template.rs-template-case .split-view .rs-template-split-view-right[_v-5845b698]{padding:55em 0}#app.is-mobile .rs-template.rs-template-case .split-view .text-regular[_v-5845b698]{margin-bottom:0}#app.is-mobile .rs-template.rs-template-case .box-pic[_v-5845b698]{padding:40em 0}#app.is-mobile .rs-template.rs-template-case .full-pic[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .video-cta[_v-5845b698]{margin-bottom:90em}#app.is-mobile .rs-template.rs-template-case .case-title[_v-5845b698]{margin-top:63em;margin-bottom:32em}#app.is-mobile .rs-template.rs-template-case .text-case-title[_v-5845b698]{font-size:13em;line-height:1.5em;margin-bottom:1.153846153846154em}#app.is-mobile .rs-template.rs-template-case .text-case-title-info[_v-5845b698]{font-size:20em;line-height:normal}#app.is-mobile .rs-template.rs-template-case .text-title[_v-5845b698]{font-size:16em;line-height:normal}#app.is-mobile .rs-template.rs-template-case .text-list .text-medium[_v-5845b698],#app.is-mobile .rs-template.rs-template-case .text-regular[_v-5845b698]{font-size:13em;font-weight:400;line-height:1.846153846153846em;margin-bottom:4.615384615384615em}#app.is-mobile .rs-template.rs-template-case .text-list .text-medium[_v-5845b698]{margin-bottom:0}#app.is-mobile .rs-template.rs-template-case .text-item-title[_v-5845b698]{font-size:15em;margin-bottom:1.333333333333333em}#app.is-mobile .rs-template.rs-template-case .items[_v-5845b698]{margin:2vh auto;padding:0}#app.is-mobile .rs-template.rs-template-case .items .item[_v-5845b698]{margin-bottom:0;line-height:.3em}#app.is-mobile .rs-template.rs-template-case .items .item span[_v-5845b698]{font-size:.3em}#app.is-mobile .rs-template.rs-template-case.bpi .text-regular+img[_v-5845b698],#app.is-mobile .rs-template.rs-template-case.bpi .video-cta+.block-grey[_v-5845b698]{margin-top:0}#app .rs-template.rs-template-manifesto .text-normal[_v-5845b698]{font-size:50em;line-height:1.2em;margin-bottom:2.6em}#app.is-mobile .rs-template.rs-template-manifesto .text-normal[_v-5845b698]{font-size:16em;line-height:1.25em;margin-bottom:2.8125em;font-weight:700}#app .rs-template.rs-template-networker[_v-5845b698]{margin-bottom:150em}#app .rs-template.rs-template-networker .split-view[_v-5845b698]{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;position:relative;background-color:transparent}#app .rs-template.rs-template-networker .text-title[_v-5845b698]{font-size:50em;margin-bottom:1.2em}#app .rs-template.rs-template-networker .text-normal[_v-5845b698]{font-size:25em;line-height:1.6em;margin:0}#app .rs-template.rs-template-networker .text-link[_v-5845b698]{position:absolute;bottom:0;margin:0}#app .rs-template.rs-template-networker .full-pic[_v-5845b698]{box-sizing:border-box;padding:50em 0 0 200em}#app .rs-template.rs-template-networker .box-pic[_v-5845b698]{max-width:100%}#app.is-mobile .rs-template.rs-template-networker[_v-5845b698]{margin-bottom:80em}#app.is-mobile .rs-template.rs-template-networker .text-title[_v-5845b698]{font-size:20em;line-height:normal;margin-bottom:2.5em}#app.is-mobile .rs-template.rs-template-networker .text-normal[_v-5845b698]{font-size:13em;line-height:1.846153846153846em}#app.is-mobile .rs-template.rs-template-networker .rs-template-split-view-left[_v-5845b698],#app.is-mobile .rs-template.rs-template-networker .rs-template-split-view-right[_v-5845b698]{width:100%}#app.is-mobile .rs-template.rs-template-networker .full-pic[_v-5845b698]{padding:70em 0 100em}#app.is-mobile .rs-template.rs-template-networker .text-link[_v-5845b698]{margin:0;font-weight:700}#app .rs-template.rs-template-collaboration[_v-5845b698]{padding-bottom:150em}#app .rs-template.rs-template-collaboration .text-title[_v-5845b698]{line-height:normal;margin-bottom:1.2em}#app .rs-template.rs-template-collaboration .text-normal[_v-5845b698]{line-height:1.6em;font-weight:700}#app .rs-template.rs-template-collaboration .parallax[_v-5845b698]{margin:4vh auto 12vh}#app .rs-template.rs-template-collaboration .parallax .full-pic[_v-5845b698]{margin:0;-webkit-transform:translateZ(0) scale(1)!important;transform:translateZ(0) scale(1)!important}#app .rs-template.rs-template-collaboration .items[_v-5845b698]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-top:105em;padding:0}#app .rs-template.rs-template-collaboration .items .item[_v-5845b698]{width:auto!important;padding:0;margin:0}#app .rs-template.rs-template-collaboration .items .text-item-title[_v-5845b698]{font-size:90em;line-height:normal;margin-bottom:0;padding-right:1em}#app .rs-template.rs-template-collaboration .items .text-normal[_v-5845b698]{line-height:normal;margin:0}#app .rs-template.rs-template-collaboration .items .item:nth-child(3) .text-item-title[_v-5845b698]{padding-left:1.5em}#app.is-mobile .rs-template.rs-template-collaboration .full-pic[_v-5845b698]{margin-bottom:80em}#app.is-mobile .rs-template.rs-template-collaboration .text-normal[_v-5845b698]{font-weight:700}#app.is-mobile .rs-template.rs-template-collaboration .items[_v-5845b698]{-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;margin-top:50em}#app.is-mobile .rs-template.rs-template-collaboration .items .item[_v-5845b698]{width:auto!important;border:none;padding:0;margin:0}#app.is-mobile .rs-template.rs-template-collaboration .items .item:nth-child(3) .text-item-title[_v-5845b698]{padding-left:0}#app.is-mobile .rs-template.rs-template-collaboration .items .text-item-title[_v-5845b698]{font-size:46.8em;padding-right:.7em}#app .rs-template.rs-template-opportunities[_v-5845b698]{padding-bottom:160em}#app .rs-template.rs-template-opportunities .text-title[_v-5845b698]{margin-bottom:0}#app .rs-template.rs-template-opportunities .text-normal[_v-5845b698]{font-size:25em;font-weight:1.6em;margin-bottom:0}#app .rs-template.rs-template-opportunities .items[_v-5845b698]{margin-top:120em;margin-bottom:100em}#app .rs-template.rs-template-opportunities .items .item .text-item-sub[_v-5845b698]{display:block}#app.is-mobile .rs-template.rs-template-opportunities[_v-5845b698]{padding-bottom:80em}#app.is-mobile .rs-template.rs-template-opportunities .text-title[_v-5845b698]{font-size:13em;margin-bottom:0}#app.is-mobile .rs-template.rs-template-opportunities .text-normal[_v-5845b698]{margin-bottom:0;font-weight:400;font-size:13em}#app.is-mobile .rs-template.rs-template-opportunities .items[_v-5845b698]{margin-top:70em;margin-bottom:60em}#app .rs-template.rs-template-team .text-title[_v-5845b698]{font-size:50em;margin-bottom:1.4em}#app .rs-template.rs-template-team .text-normal .text-highlight[_v-5845b698],#app .rs-template.rs-template-team .text-normal[_v-5845b698]{font-size:25em;line-height:1.6em;margin:0}#app .rs-template.rs-template-team .items[_v-5845b698]{margin:120em 0}#app .rs-template.rs-template-team .items .item span[_v-5845b698]{display:block;width:100%}#app .rs-template.rs-template-team .text-item-sub[_v-5845b698]{font-weight:700;clear:both}#app.is-mobile .rs-template.rs-template-team .text-title[_v-5845b698]{font-size:20em;margin-bottom:1.5em}#app.is-mobile .rs-template.rs-template-team .text-normal[_v-5845b698]{font-size:13em;line-height:1.846153846153846em;font-weight:400;margin:0}#app.is-mobile .rs-template.rs-template-team .items[_v-5845b698]{margin:100em 0}#app .rs-template.rs-template-contact[_v-5845b698]{margin-bottom:180em}#app .rs-template.rs-template-contact .text-title[_v-5845b698]{margin:0;padding:0}#app .rs-template.rs-template-contact .text-normal[_v-5845b698]{line-height:normal;margin:0;padding:0}#app .rs-template.rs-template-contact .split-view[_v-5845b698]{margin:70em 0 110em;padding:0;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;background-color:transparent}#app .rs-template.rs-template-contact .split-view .rs-template[_v-5845b698]{width:auto;padding-right:50em}#app .rs-template.rs-template-contact .split-view .split-view[_v-5845b698]{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;margin:0;padding:0}#app .rs-template.rs-template-contact .split-view .text-title[_v-5845b698]{font-size:25em;line-height:normal;margin-bottom:1.28em}#app .rs-template.rs-template-contact .split-view .text-normal[_v-5845b698]{font-size:18em;color:#606267;font-weight:400}#app.is-mobile .rs-template.rs-template-contact[_v-5845b698]{margin-bottom:90em}#app.is-mobile .rs-template.rs-template-contact .text-title[_v-5845b698]{margin:0;padding:0}#app.is-mobile .rs-template.rs-template-contact .text-normal[_v-5845b698]{line-height:normal;margin:0;padding:0;font-weight:700}#app.is-mobile .rs-template.rs-template-contact .split-view[_v-5845b698]{width:100%;margin:35em 0 55em}#app.is-mobile .rs-template.rs-template-contact .split-view .rs-template[_v-5845b698]{width:100%;padding:0}#app.is-mobile .rs-template.rs-template-contact .split-view .rs-template[_v-5845b698]:nth-child(1){margin-bottom:20em}#app.is-mobile .rs-template.rs-template-contact .split-view .split-view[_v-5845b698]{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;margin:0;padding:0}#app.is-mobile .rs-template.rs-template-contact .split-view .split-view .rs-template[_v-5845b698]{width:50%}#app.is-mobile .rs-template.rs-template-contact .split-view .split-view .rs-template[_v-5845b698]:nth-child(1){margin-bottom:0}#app.is-mobile .rs-template.rs-template-contact .split-view .text-title[_v-5845b698]{font-size:13em;line-height:normal}#app.is-mobile .rs-template.rs-template-contact .split-view .text-normal[_v-5845b698]{font-size:10em;font-weight:400}#app .rs-template[_v-5845b698]{width:53%}#app.is-mobile .rs-template[_v-5845b698]{width:75%}#app.is-mobile .rs-template-case[_v-5845b698],#app .rs-template-case[_v-5845b698]{width:100%}#app .rs-template .text-credit[_v-5845b698],#app .rs-template .text-lines[_v-5845b698],#app .rs-template .text-normal[_v-5845b698],#app .rs-template .text-regular[_v-5845b698],#app .rs-template .text-title-highlight[_v-5845b698],#app .rs-template .text-title[_v-5845b698]{margin-bottom:50px}#app .rs-template .action[_v-5845b698]{cursor:pointer}#app .rs-template .columns[_v-5845b698]{margin-bottom:80px;display:inline-block}#app .rs-template .columns .column[_v-5845b698]{overflow:hidden;border-right:50px solid transparent;box-sizing:border-box;float:left}#app .rs-template .columns .column[_v-5845b698]:last-child{float:none}#app .rs-template .columns .column .text-normal[_v-5845b698]{margin-bottom:0}#app .rs-template .text-small[_v-5845b698]{margin-bottom:25px}#app .rs-template .text-list[_v-5845b698]{list-style:disc;padding-left:25px}#app .rs-template .text-list .text[_v-5845b698]{margin-bottom:0}#app .rs-template .text-link[_v-5845b698]{display:block;text-decoration:none}#app .rs-template .clear-float[_v-5845b698]{clear:left}#app .rs-template .items[_v-5845b698]{padding-top:35px;padding-bottom:15px;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}#app .rs-template .items .item[_v-5845b698]{display:block;width:24%;padding:0 1% 5% 0;pointer-events:auto}#app .rs-template .items .item [_v-5845b698]{pointer-events:none}#app .rs-template .items .item-preview[_v-5845b698]{display:none;width:100%;margin-bottom:10em}#app .rs-template .medium-feed[_v-5845b698]{margin-bottom:100em;min-height:100em;display:inline-block}#app .rs-template .medium-feed .post[_v-5845b698]{display:block;width:45%;padding-right:5%;padding-bottom:90em;float:left;height:20%;text-decoration:none}#app .rs-template .medium-feed .post[_v-5845b698]:nth-child(even):after{content:"";display:block;clear:both}#app .rs-template .split-view[_v-5845b698]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:#e9edee}.expertise[_v-5845b698]{margin:80px 0 160px}.expertise .text-expertise[_v-5845b698]{cursor:pointer}.expertise .text-expertise .text-highlight[_v-5845b698]{opacity:0;-webkit-transition:opacity .5s .1s;transition:opacity .5s .1s}.expertise .text-expertise:hover .text-highlight[_v-5845b698]{opacity:1}.parallax[_v-5845b698]{position:relative;width:100%;overflow:hidden;margin-bottom:22vh}.parallax .full-pic[_v-5845b698]{display:block;width:100%;height:auto}.video-cta[_v-5845b698]{position:relative;width:100%;cursor:pointer}.video-cta[_v-5845b698]:after{content:\'\';background-color:#000;opacity:.3;-webkit-transition:opacity .5s;transition:opacity .5s}.video-cta[_v-5845b698]:hover:after{opacity:0}.video-cover[_v-5845b698]{width:100%}.play-picto[_v-5845b698]{position:absolute;top:50%;left:50%;margin:-41px 0 0 -41px;z-index:1}.slider-auto[_v-5845b698],.slider[_v-5845b698]{margin-bottom:230em}h1.text-title+.slider-auto[_v-5845b698]{margin-top:18vh}#app.is-mobile .rs-template .text-credit[_v-5845b698],#app.is-mobile .rs-template .text-normal[_v-5845b698],#app.is-mobile .rs-template .text-regular[_v-5845b698],#app.is-mobile .rs-template .text-title-highlight[_v-5845b698],#app.is-mobile .rs-template .text-title[_v-5845b698]{margin-bottom:25px}#app.is-mobile .rs-template .items[_v-5845b698]{width:100%;padding-top:10em}#app.is-mobile .rs-template .items .item[_v-5845b698]{width:100%!important;border-bottom:1px solid hsla(0,0%,100%,.4);padding-bottom:20em;margin-bottom:20em;cursor:pointer}#app.is-mobile .rs-template .items .item-preview[_v-5845b698]{display:block}#app.is-mobile .rs-template .columns[_v-5845b698]{margin-bottom:0}#app.is-mobile .rs-template .columns .column[_v-5845b698]{float:none;max-width:100%!important;min-width:100%!important;padding-bottom:50em;border:none}#app.is-mobile .rs-template .expertise[_v-5845b698]{margin:0 0 50em}#app.is-mobile .rs-template .expertise .text-expertise[_v-5845b698]{font-size:17em}#app.is-mobile .rs-template .expertise .text-expertise .text-highlight[_v-5845b698]{display:none}#app.is-mobile .rs-template .medium-feed .post[_v-5845b698]{display:block;width:100%;padding-right:0;padding-bottom:30em;float:none;height:auto}#app.is-mobile .rs-template .split-view[_v-5845b698]{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}#app.is-mobile .rs-template .slider[_v-5845b698]{margin-bottom:4vh}#app.is-mobile .rs-template .slider-auto[_v-5845b698]{width:100%;margin-bottom:4vh;padding:0}#app.is-mobile .rs-template .slider-auto .slider-wrapper[_v-5845b698]{width:100%}#app.is-mobile .rs-template .slider-auto .slider-item h3[_v-5845b698]{font-size:10em}#app.is-mobile .rs-template .slider-auto .slider-item p[_v-5845b698]{padding:20vh 0 60vh;font-size:10em}');
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _Slider = require("./Slider.vue")
            , _Slider2 = _interopRequireDefault(_Slider)
            , _SliderAuto = require("./SliderAuto.vue")
            , _SliderAuto2 = _interopRequireDefault(_SliderAuto)
            , _Clock = require("./Clock.vue")
            , _Clock2 = _interopRequireDefault(_Clock);
        exports.default = {
            name: "rstemplate",
            filters: {
                "string-date": function(timestamp) {
                    return new Date(timestamp).toLocaleString("fr" == this.$root.lang ? "fr-FR" : "en-GB", {
                        year: "numeric",
                        month: "2-digit",
                        day: "2-digit"
                    }).replace(new RegExp("/","g"), ".")
                }
            },
            data: function() {
                return {
                    posts: null,
                    users: null,
                    screenHeight: 0,
                    documentHeight: 0,
                    templateColor: "",
                    scrollPosition: 0,
                    scrolled: !1,
                    scrollchanged: !1,
                    parallaxImgs: [],
                    scrollValue: 0,
                    top: 0,
                    scale: 1.5
                }
            },
            props: ["template-data"],
            computed: {
                screenHeight: function() {
                    return window.innerHeight
                },
                documentHeight: function() {
                    return document.getElementById("app").offsetHeight
                },
                templateColor: function() {
                    return void 0 !== this.templateData.color ? this.templateColor = this.templateData.color : this.templateColor = ""
                }
            },
            created: function() {},
            ready: function() {
                this.loadFeed(),
                    window.addEventListener("scroll", this.onMouseWheel),
                    templateCase = document.getElementsByClassName("rs-template-case"),
                templateCase.length > 0 && (this.parallaxImgs = document.getElementsByClassName("parallax"))
            },
            attached: function() {},
            methods: {
                loadFeed: function() {
                    var components = this.$get("templateData.components")
                        , urlFeed = components && components[0] ? components[0]["medium-feed"] : null;
                    urlFeed && this.$http.get(urlFeed).then(function(response) {
                        var data = response.data
                            , subStart = data.indexOf("{")
                            , subEnd = data.lastIndexOf("}");
                        data = data.substr(subStart, subEnd),
                        "" != data && (this.users = JSON.parse(data).payload.references.User,
                            this.posts = JSON.parse(data).payload.references.Post)
                    }, function(error) {
                        console.log(error)
                    }),
                        setTimeout(function() {
                            null === this.posts && this.loadFeed()
                        }
                            .bind(this), 1e3)
                },
                openPopin: function(popinURL) {
                    popinURL && this.$route.router.go(this.$route.path + "/" + popinURL)
                },
                openVideo: function(videoID) {
                    this.$dispatch("onPlayVideo", videoID)
                },
                overPopinLink: function(popinUrl) {
                    var popinsData = this.$eval("$root.data.popins | json")
                        , popinData = JSON.parse(popinsData).find(function(el) {
                        return el.url === popinUrl
                    });
                    popinData && popinData.pic && void 0 != popinData.pic && this.$dispatch("popinPreviewShow", popinData.pic)
                },
                outPopinLink: function() {
                    this.$dispatch("popinPreviewHide")
                },
                getPopinDataFromURL: function(url) {
                    this.$get("$root.data.popins")
                },
                getOffset: function(el) {
                    return el = el.getBoundingClientRect(),
                        {
                            left: el.left + window.scrollX,
                            top: el.top + window.scrollY
                        }
                },
                topOfLine: function(element) {
                    var offsetTop = this.getOffset(element).top;
                    return offsetTop < this.screenHeight / 2 - 30
                },
                parallax: function(element) {
                    var offsetTopImg = this.getOffset(element).top
                        , imgHeight = element.offsetHeight
                        , curPos = offsetTopImg + this.screenHeight / 2;
                    this.top = (imgHeight * this.scale - imgHeight) / 2,
                    offsetTopImg <= this.screenHeight && curPos > -imgHeight && (this.scrollValue = this.top * (offsetTopImg / this.screenHeight))
                }
            },
            watch: {
                screenHeight: function() {
                    return window.innerHeight
                },
                documentHeight: function() {
                    return document.getElementById("app").offsetHeight
                },
                templateColor: function() {
                    return void 0 !== this.templateData.color ? this.templateColor = this.templateData.color : this.templateColor = ""
                }
            },
            events: {
                onPageScroll: function(value) {
                    for (var elementsFade = document.querySelectorAll(".rs-template-manifesto p [data-active]"), i = 0; i < elementsFade.length; i++) {
                        var thisDiv = elementsFade[i];
                        this.topOfLine(thisDiv) ? thisDiv.classList.add("topline") : thisDiv.classList.remove("topline")
                    }
                    for (var i = 0, len = this.parallaxImgs.length; i < len; i++)
                        this.parallax(this.parallaxImgs[i])
                }
            },
            components: {
                slider: _Slider2.default,
                "slider-auto": _SliderAuto2.default,
                clock: _Clock2.default
            }
        },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = "<div class=\"rs-template rs-template-{{templateData.name}} {{this.templateColor}}\" s=\"\" _v-5845b698=\"\"><template v-for=\"comp in templateData['components']\"><h1 v-if=\"comp['title']\" class=text-title _v-5845b698=\"\">{{{comp['title']}}}</h1><h1 v-if=\"comp['title-highlight']\" class=text-title-highlight _v-5845b698=\"\">{{{comp['title-highlight']}}}</h1><p v-if=\"comp['text']\" class=text-normal _v-5845b698=\"\">{{{comp['text']}}}<p v-if=\"comp['regular']\" class=text-regular _v-5845b698=\"\">{{{comp['regular']}}}<p v-if=\"comp['medium']\" class=text-medium _v-5845b698=\"\">{{{comp['medium']}}}<p v-if=\"comp['small']\" class=text-small _v-5845b698=\"\">{{{comp['small']}}}<p v-if=\"comp['text-lines']\" class=text-lines _v-5845b698=\"\">{{{comp['text-lines']}}}<ul v-if=\"comp['text-list']\" class=text-list _v-5845b698=\"\"><li v-for=\"text in comp['text-list']\" :class=\"{'text-medium':(text['text'] || text['medium']),'text-regular':text['regular'],'text-small':text['small']}\" _v-5845b698=\"\">{{{text['text']}}}{{{text['regular']}}}{{{text['medium']}}}{{{text['small']}}}</ul><a v-if=\"comp['link']\" :href=\"comp['link']['url']\" target=_blank class=\"text-normal text-link\" _v-5845b698=\"\">{{{comp['link']['label']}}}</a><div v-if=\"comp['item-list']\" class=items _v-5845b698=\"\"><div v-for=\"item in comp['item-list']\" class=item :class=\"{'action':item.popin}\" @click=openPopin(item.popin) @mouseover=overPopinLink(item.popin) @mouseout=outPopinLink() _v-5845b698=\"\"><img v-if=item.pic class=item-preview :src=item.pic _v-5845b698=\"\"> <span v-if=item.title class=text-item-title _v-5845b698=\"\">{{{item.title}}}</span> <span v-if=item.sub class=text-item-sub _v-5845b698=\"\">{{{item.sub}}}</span><p v-if=item.text class=text-normal _v-5845b698=\"\">{{{item.text}}}</div></div><div v-if=\"comp['columns']\" class=columns _v-5845b698=\"\"><div class=column v-for=\"column in comp['columns']\" :style=\"{'max-width':100/comp['columns'].length+'%','min-width':40/comp['columns'].length+'%'}\" _v-5845b698=\"\"><p v-for=\"text in column\" class=text-normal _v-5845b698=\"\">{{{text}}}</div></div><div v-if=\"comp['expertise']\" class=expertise _v-5845b698=\"\"><div class=text-expertise v-for=\"line in comp['expertise']['list']\" @click=openPopin(line.popin) @mouseover=overPopinLink(line.popin) @mouseout=outPopinLink() _v-5845b698=\"\">{{{line['text']}}}&nbsp;<span class=text-highlight _v-5845b698=\"\">{{{comp['expertise']['hover']}}}</span></div></div><div v-if=\"comp['medium-feed']\" class=medium-feed _v-5845b698=\"\"><a href=\"https://www.medium.com/reputation-squad/{{post['uniqueSlug']}}\" target=_blank class=\"post action\" v-for=\"post in posts\" :class=\"{'clear-float':$index % 2 === 0}\" _v-5845b698=\"\"><h1 class=text-item-title _v-5845b698=\"\">{{post['title']}}</h1><h2 class=text-item-sub _v-5845b698=\"\">{{post['firstPublishedAt'] | string-date}} - {{users[post['creatorId']].name}}</h2></a></div><div v-if=\"comp['split-view']\" class=split-view _v-5845b698=\"\"><rstemplate :template-data=\"comp['split-view']['template-left']\" _v-5845b698=\"\"></rstemplate><rstemplate :template-data=\"comp['split-view']['template-right']\" _v-5845b698=\"\"></rstemplate></div><slider v-if=\"comp['slider']\" :items=\"comp['slider']\" _v-5845b698=\"\"></slider><slider-auto v-if=\"comp['slider-auto']\" :slider-data=\"comp['slider-auto']\" _v-5845b698=\"\"></slider-auto><div v-if=\"comp['case-title']\" class=case-title _v-5845b698=\"\"><h1 class=text-case-title _v-5845b698=\"\">{{{comp['case-title']['left']}}}</h1><p class=text-case-title-info _v-5845b698=\"\">{{{comp['case-title']['right']}}}</div><div class=parallax v-if=\"comp['pic']\" _v-5845b698=\"\"><img :src=\"comp['pic']\" class=full-pic :style=\"{'margin-top':top+'px','transform':'translate3d(0,'+(-scrollValue)+'px,0) scale('+scale+')'}\" _v-5845b698=\"\"></div><img v-if=\"comp['box-pic']\" :src=\"comp['box-pic']\" class=box-pic _v-5845b698=\"\"><div v-if=\"comp['credit-title']\" class=text-credit-title _v-5845b698=\"\">{{{comp['credit-title']}}}</div><div v-if=\"comp['credit']\" class=text-credit _v-5845b698=\"\">{{{comp['credit']}}}</div><div v-if=\"comp['dark']\" class=block-dark _v-5845b698=\"\"><h1 v-if=\"comp['dark']['title-highlight']\" class=text-title-highlight _v-5845b698=\"\">{{{comp['dark']['title-highlight']}}}</h1><h1 v-if=\"comp['dark']['title']\" class=text-title _v-5845b698=\"\">{{{comp['dark']['title']}}}</h1><p v-if=\"comp['dark']['text']\" class=text-normal _v-5845b698=\"\">{{{comp['dark']['text']}}}<p v-if=\"comp['dark']['regular']\" class=text-regular _v-5845b698=\"\">{{{comp['dark']['regular']}}}<div class=parallax v-if=\"comp['dark']['pic']\" _v-5845b698=\"\"><img :src=\"comp['dark']['pic']\" class=full-pic :style=\"{'margin-top':top+'px','transform':'translate3d(0,'+(-scrollValue)+'px,0) scale('+scale+')'}\" _v-5845b698=\"\"></div><img v-if=\"comp['dark']['box-pic']\" :src=\"comp['dark']['box-pic']\" class=box-pic _v-5845b698=\"\"><slider v-if=\"comp['dark']['slider']\" :items=\"comp['dark']['slider']\" _v-5845b698=\"\"></slider><slider-auto v-if=\"comp['dark']['slider-auto']\" :slider-data=\"comp['dark']['slider-auto']\" _v-5845b698=\"\"></slider-auto><ul v-if=\"comp['dark']['text-list']\" class=text-list _v-5845b698=\"\"><li v-for=\"text in comp['dark']['text-list']\" :class=\"{'text-medium':(text['text'] || text['medium']),'text-regular':text['regular'],'text-small':text['small']}\" _v-5845b698=\"\">{{{text['text']}}}{{{text['regular']}}}{{{text['medium']}}}{{{text['small']}}}</ul><div v-if=\"comp['dark']['video']\" class=video _v-5845b698=\"\"><img v-if=$root.isMobile :src=\"comp['dark']['video']['pic']\" _v-5845b698=\"\"><video v-else=\"\" autoplay loop _v-5845b698=\"\"><source v-if=\"comp['dark']['video']['mp4']\" :src=\"comp['dark']['video']['mp4']\" type=video/mp4 _v-5845b698=\"\"></video></div><div v-if=\"comp['dark']['video-full']\" class=video-full _v-5845b698=\"\"><img v-if=$root.isMobile :src=\"comp['dark']['video-full']['pic']\" _v-5845b698=\"\"><video v-else=\"\" autoplay loop _v-5845b698=\"\"><source v-if=\"comp['dark']['video-full']['mp4']\" :src=\"comp['dark']['video-full']['mp4']\" type=video/mp4 _v-5845b698=\"\"></video></div></div><div v-if=\"comp['grey']\" class=block-grey _v-5845b698=\"\"><h1 v-if=\"comp['grey']['title-highlight']\" class=text-title-highlight _v-5845b698=\"\">{{{comp['grey']['title-highlight']}}}</h1><h1 v-if=\"comp['grey']['title']\" class=text-title _v-5845b698=\"\">{{{comp['grey']['title']}}}</h1><p v-if=\"comp['grey']['text']\" class=text-normal _v-5845b698=\"\">{{{comp['grey']['text']}}}<p v-if=\"comp['grey']['regular']\" class=text-regular _v-5845b698=\"\">{{{comp['grey']['regular']}}}<div class=parallax v-if=\"comp['grey']['pic']\" _v-5845b698=\"\"><img :src=\"comp['grey']['pic']\" class=full-pic :style=\"{'margin-top':top+'px','transform':'translate3d(0,'+(-scrollValue)+'px,0) scale('+scale+')'}\" _v-5845b698=\"\"></div><img v-if=\"comp['grey']['box-pic']\" :src=\"comp['grey']['box-pic']\" class=box-pic _v-5845b698=\"\"><slider v-if=\"comp['grey']['slider']\" :items=\"comp['grey']['slider']\" _v-5845b698=\"\"></slider><slider-auto v-if=\"comp['grey']['slider-auto']\" :slider-data=\"comp['grey']['slider-auto']\" _v-5845b698=\"\"></slider-auto><ul v-if=\"comp['grey']['text-list']\" class=text-list _v-5845b698=\"\"><li v-for=\"text in comp['grey']['text-list']\" :class=\"{'text-medium':(text['text'] || text['medium']),'text-regular':text['regular'],'text-small':text['small']}\" _v-5845b698=\"\">{{{text['text']}}}{{{text['regular']}}}{{{text['medium']}}}{{{text['small']}}}</ul><div v-if=\"comp['grey']['video']\" class=video _v-5845b698=\"\"><img v-if=$root.isMobile :src=\"comp['grey']['video']['pic']\" _v-5845b698=\"\"><video v-else=\"\" autoplay loop _v-5845b698=\"\"><source v-if=\"comp['grey']['video']['mp4']\" :src=\"comp['grey']['video']['mp4']\" type=video/mp4 _v-5845b698=\"\"></video></div><div v-if=\"comp['grey']['video-full']\" class=video-full _v-5845b698=\"\"><img v-if=$root.isMobile :src=\"comp['grey']['video-full']['pic']\" _v-5845b698=\"\"><video v-else=\"\" autoplay loop _v-5845b698=\"\"><source v-if=\"comp['grey']['video-full']['mp4']\" :src=\"comp['grey']['video-full']['mp4']\" type=video/mp4 _v-5845b698=\"\"></video></div></div><div v-if=\"comp['youtube']\" class=video-cta @click=\"openVideo(comp['youtube']['id'])\" _v-5845b698=\"\"><img :src=\"comp['youtube']['pic']\" class=video-cover _v-5845b698=\"\"> <svg class=play-picto xmlns=http://www.w3.org/2000/svg width=82 height=82 _v-5845b698=\"\"><circle cx=41 cy=41 r=40.5 stroke=#ffffff fill=none _v-5845b698=\"\"></circle><path stroke=none fill=#ffffff d=M1441,2347.49a0.413,0.413,0,0,0-.24-0.34l-14.16-8.08a0.367,0.367,0,0,0-.59.36v16.12a0.367,0.367,0,0,0,.59.36l14.16-8.08A0.413,0.413,0,0,0,1441,2347.49Z transform=\"translate(-1390 -2306)\" _v-5845b698=\"\"></path></svg><div v-if=\"comp['youtube']['video']\" class=video _v-5845b698=\"\"><img v-if=$root.isMobile :src=\"comp['youtube']['video']['pic']\" _v-5845b698=\"\"><video v-else=\"\" autoplay loop _v-5845b698=\"\"><source v-if=\"comp['youtube']['video']['mp4']\" :src=\"comp['youtube']['video']['mp4']\" type=video/mp4 _v-5845b698=\"\"></video></div><div v-if=\"comp['youtube']['video-full']\" class=video-full _v-5845b698=\"\"><img v-if=$root.isMobile :src=\"comp['youtube']['video-full']['pic']\" _v-5845b698=\"\"><video v-else=\"\" autoplay loop _v-5845b698=\"\"><source v-if=\"comp['youtube']['video-full']['mp4']\" :src=\"comp['youtube']['video-full']['mp4']\" type=video/mp4 _v-5845b698=\"\"></video></div></div><p v-if=\"comp['clock']\" class=\"text-title clock\" _v-5845b698=\"\"><clock :zone=\"comp['clock']\" _v-5845b698=\"\"></clock><div v-if=\"comp['video']\" class=video _v-5845b698=\"\"><img v-if=$root.isMobile :src=\"comp['video']['pic']\" _v-5845b698=\"\"><video v-else=\"\" autoplay loop _v-5845b698=\"\"><source v-if=\"comp['video']['mp4']\" :src=\"comp['video']['mp4']\" type=video/mp4 _v-5845b698=\"\"></video></div><div v-if=\"comp['video-full']\" class=video-full _v-5845b698=\"\"><img v-if=$root.isMobile :src=\"comp['video-full']['pic']\" _v-5845b698=\"\"><video v-else=\"\" autoplay loop _v-5845b698=\"\"><source v-if=\"comp['video-full']['mp4']\" :src=\"comp['video-full']['mp4']\" type=video/mp4 _v-5845b698=\"\"></video></div></template></div>"
    }
        , {
            "./Clock.vue": 106,
            "./Slider.vue": 124,
            "./SliderAuto.vue": 125,
            "vueify/lib/insert-css": 103
        }],
    121: [function(require, module, exports) {
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full[_v-4a57491c]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-absolute-full[_v-4a57491c]{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full[_v-4a57491c]{display:block;width:100%;height:100%}.common-center-cover[_v-4a57491c]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover[_v-4a57491c],.common-hover[_v-4a57491c]:hover{color:#7ad71f}.common-hover[_v-4a57491c]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-4a57491c]{display:block;text-align:center}.svg-shapes-color path[_v-4a57491c]{fill:#000}.svg-shapes-color .fill-green[_v-4a57491c]{fill:#7ad71f}.svg-shapes-color .fill-grey[_v-4a57491c]{fill:#37383a}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }),
            exports.default = {
                data: function() {
                    return {}
                },
                computed: {},
                ready: function() {},
                attached: function() {},
                methods: {},
                components: {}
            },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = '<path d=M937,790.26V921.07H873.65V669.21h63.29V790.26Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M156.56,1143.28v130.81H93.26V1022.23h63.29v121.05Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M498.71,907.29q0-57,36.18-93.61t91.78-36.62q52.45,0,86,33.89t33.68,90.43a140.76,140.76,0,0,1-1.8,23.07H500.09A144.31,144.31,0,0,1,498.71,907.29Zm125.62-76.85a55.94,55.94,0,0,0-38.42,14q-15.82,14-21.24,39.34H681.75q-2.27-24.43-18.77-38.89a56.8,56.8,0,0,0-38.66-14.47h0Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M1542.91,35.31q32.56,36.49,83.65,36.49l0.19-55.39a54.75,54.75,0,0,1-33.66-20.08Q1575.91-25,1575.91-58.4q-0.44-33.89,16.63-54.92a56,56,0,0,1,34.74-20.33l0.19-55.43q-52-.21-84.56,36.49t-32.56,94Q1510.35-1.18,1542.91,35.31Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M1911.86,796.29q32.56,36.49,83.65,36.49l0.19-55.39A54.75,54.75,0,0,1,1962,757.32q-17.18-21.3-17.18-54.74-0.44-33.89,16.63-54.92a56,56,0,0,1,34.74-20.33l0.19-55.43q-52-.21-84.56,36.49t-32.56,94Q1879.31,759.79,1911.86,796.29Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M151.11-9.88Q118.56-46.37,67.47-46.38L67.27,9a54.75,54.75,0,0,1,33.66,20.08q17.18,21.3,17.18,54.74,0.44,33.89-16.63,54.92a56,56,0,0,1-34.74,20.33L66.55,214.5q52,0.21,84.56-36.49t32.56-94Q183.67,26.61,151.11-9.88Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M841.51,289.7l-61.91-.26V238h0V176.23h63.76v61.94h56.51V289.7H841.51Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M1237.12,1079.46l-61.91-.26V1027.8h0V966H1239v61.94h56.51v51.53h-58.37Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M654.75,722.76H624.93V671.23H775v51.53H654.75Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M1634,971.59h-29.82V920.06H1754.3v51.53H1634Z transform="translate(80 189.07)" _v-4a57491c=""></path><path class=fill-green d=M38.65,964.88H8.83V913.35H158.93v51.53H38.65Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M1633.17,1073.15h-29.82v-51.53h150.09v51.53H1633.17Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M1474.06,325.17h-29.82V273.64h150.09v51.53H1474.06Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M1497.82,911.39a37,37,0,0,1-27.14-11.31,39.31,39.31,0,0,1,0-55.16,37,37,0,0,1,27.14-11.31,38.89,38.89,0,1,1,0,77.78h0Z transform="translate(80 189.07)" _v-4a57491c=""></path><path class=fill-green d=M1126.87,152.62a37,37,0,0,1-27.14-11.31,39.31,39.31,0,0,1,0-55.16,37,37,0,0,1,27.14-11.31,38.89,38.89,0,1,1,0,77.78h0Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M776.93,119.32q0-34.3-18.25-54.9l0.08,0a60,60,0,0,0-46.92-20.57,61.23,61.23,0,0,0-47.26,20.57Q645.81,85,645.81,119.32l-65.51-.42q0-56.51,38-93.14t94.57-36.65q56.07,0,92.93,36.62t36.86,93.61Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M1696.53,575.24q56.07,0,92.93,36.62t36.86,93.61q0,56.51-37.54,93.61t-93.61,37.07q-56.51,0-93.84-37.07T1564,705q0-56.51,38-93.14T1696.53,575.24Zm45.9,75.28A60,60,0,0,0,1695.52,630a61.23,61.23,0,0,0-47.26,20.57q-18.77,20.57-18.77,54.92,0,34.83,18.53,55.39a63.79,63.79,0,0,0,90.13,3.7q2-1.88,3.92-3.94,18.53-20.85,18.53-55.16t-18.25-54.9Z transform="translate(80 189.07)" _v-4a57491c=""></path><path class=fill-green d=M1316.9,670.29q44.31,0,72.13,23.46t32.32,67.77h-61.94a50,50,0,0,0-14.23-30.08,39.26,39.26,0,0,0-28.26-11.08Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M476,467.09q44.31,0,72.13,23.46t32.32,67.77H518.5a50,50,0,0,0-14.23-30.08A39.26,39.26,0,0,0,476,517.16Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M1316.93,581.75a39.26,39.26,0,0,0,28.26-11.08,50,50,0,0,0,14.23-30.08h61.94q-4.51,44.31-32.32,67.77t-72.13,23.46Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M1321.77,912.36c0-9.38-4.89-16.21-14.68-21.34a162.86,162.86,0,0,0-35.5-13l-42.31-10.77a70.64,70.64,0,0,1-36.18-22c-9.8-11-14.7-26.58-14.7-44.37l63.29,0c0,7.33,3.6,10.71,10.79,15.25a88.62,88.62,0,0,0,26.33,10.64l34.54,8.52a231.51,231.51,0,0,1,34.77,11.34,59.25,59.25,0,0,1,26.33,22.5c7.06,10.55,10.58,28,10.58,43.29Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M234.41,421.64c0-9.38-4.89-16.21-14.68-21.34a162.86,162.86,0,0,0-35.5-13l-42.31-10.77a70.64,70.64,0,0,1-36.18-22C95.94,343.53,91,328,91,310.16l63.29,0c0,7.33,3.6,10.71,10.79,15.25a88.62,88.62,0,0,0,26.33,10.64L226,344.6a231.51,231.51,0,0,1,34.77,11.34,59.25,59.25,0,0,1,26.33,22.5c7.06,10.55,10.58,28,10.58,43.29Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M711,360.79a47.16,47.16,0,0,1-18.71-13.26c-7-8.14-11.18-19.54-12.85-32.54h-64c0.71,34,9.41,56.9,26.15,75.21,17.48,19.12,39.86,28.88,67,28.88l2.43,0V360.79Z transform="translate(80 189.07)" _v-4a57491c=""></path><path class=fill-grey d=M468,360.79a53.92,53.92,0,0,1-18.27-13.26c-7-8.14-10.75-19.54-12.41-32.54h-64c0.71,34,9.41,56.9,26.15,75.21,17.48,19.12,39.43,28.88,66.55,28.88,0.88,0,2,0,2,0V360.79Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M160,801.81c-6-2.7-13.29-7.22-18.49-13.27-7-8.14-11-18.55-12.63-32.55h-64c0.71,31,9.41,56.91,26.15,75.22,17.48,19.12,39.64,28.89,66.77,28.89,0.88,0,2.21,0,2.21,0V801.81Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M1724.19,93.8c9.35,10.71,13.81,25.85,13.81,45.43V167h64V129.93c0-33.49-9-59.79-26.52-78.91s-40.67-28.67-68.09-28.67A124,124,0,0,0,1683,24.88V77.77s1.67,0,2.19,0C1701.46,77.74,1714.84,83.09,1724.19,93.8Z transform="translate(80 189.07)" _v-4a57491c=""></path><path class=fill-grey d=M1045.78,1006c9.35,10.71,14.22,25.85,14.22,45.43V1079h63v-36.83c0-33.49-8.93-59.79-26.43-78.91s-40.71-28.67-68.14-28.67c-8.46,0-14.43.85-24.43,2.53V990s2,0,2.49,0C1022.75,990,1036.43,995.34,1045.78,1006Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M1083.67,777.16c-9.19-10.69-13.67-25.83-13.67-45.43V670h-66v70.77c0,33.54,9.86,59.87,27.34,79s40.49,28.67,67.62,28.67a125.26,125.26,0,0,0,17-1.23V793C1103,791.9,1091.82,786.63,1083.67,777.16Z transform="translate(80 189.07)" _v-4a57491c=""></path><path d=M-2.33,287.14C-11.52,276.45-16,261.3-16,241.7V179H-80v71.75c0,33.54,9.23,59.87,26.72,79s39.8,28.67,66.93,28.67A105.32,105.32,0,0,0,30,357.17V303C17,301.88,5.82,296.61-2.33,287.14Z transform="translate(80 189.07)" _v-4a57491c=""></path><path class=fill-grey d=M421.93,630.74A60,60,0,0,0,375,610.17a61.23,61.23,0,0,0-47.26,20.57Q309,651.31,309,685.66q0,34.83,18.53,55.39a63.79,63.79,0,0,0,90.13,3.7q2-1.88,3.92-3.94Q440.1,720,440.1,685.66t-18.25-54.9Z transform="translate(80 189.07)" _v-4a57491c=""></path>'
    }
        , {
            "vueify/lib/insert-css": 103
        }],
    122: [function(require, module, exports) {
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert('.common-fixed-full[_v-5ac872d7]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-absolute-full[_v-5ac872d7]{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app .popin .scroll-content[_v-5ac872d7],#app .scroll-content[_v-5ac872d7],#app .scrollbox[_v-5ac872d7],.common-block-full[_v-5ac872d7]{display:block;width:100%;height:100%}.common-center-cover[_v-5ac872d7]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover[_v-5ac872d7],.common-hover[_v-5ac872d7]:hover{color:#7ad71f}.common-hover[_v-5ac872d7]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-5ac872d7]{display:block;text-align:center}#app .scroller[_v-5ac872d7]:after{background-color:rgba(55,55,55,.5)}#app .scrollbox[_v-5ac872d7]{overflow-y:hidden}#app .scrollbox.no-custom[_v-5ac872d7]{overflow-y:scroll}#app .scrollbox.no-custom .scroller[_v-5ac872d7]{display:none}#app .scrollerdiv[_v-5ac872d7]{position:absolute;width:17px;height:100%;z-index:11;top:0;right:0}#app .scroller[_v-5ac872d7]{position:absolute;width:100px;height:50px;z-index:10;right:0;border-radius:1px;box-sizing:border-box;opacity:.7}#app .scroller[_v-5ac872d7]:after{content:"";position:absolute;width:7px;top:10px;right:10px;bottom:10px}#app .popin .scroll-content[_v-5ac872d7]{display:table}');
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }),
            exports.default = {
                data: function() {
                    return {
                        ratio: 0,
                        top: 0,
                        height: 0,
                        scrollable: !1,
                        scrollBox: null,
                        dragStart: !1,
                        scrollY: 0,
                        mouseY: 0,
                        mouseYFirst: 0,
                        scrollBoxTopFirst: 0,
                        isTablet: !1
                    }
                },
                computed: {},
                props: ["enabled"],
                ready: function() {
                    this.updateHeight(),
                        this.updateTop(),
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) && (this.isTablet = !0)
                },
                attached: function() {},
                methods: {
                    updateHeight: function() {
                        if (this.scrollBox) {
                            var heightParent = this.getHeight(this.scrollBox)
                                , heightContent = this.scrollBox.scrollHeight
                                , heightRatio = heightParent / heightContent;
                            this.height = heightRatio * heightParent,
                                this.scrollable = heightParent < .9 * heightContent
                        }
                    },
                    getHeight: function(el) {
                        var style = getComputedStyle(el);
                        return el.offsetHeight - parseInt(style.getPropertyValue("border-top-width")) - parseInt(style.getPropertyValue("border-bottom-width"))
                    },
                    updateTop: function() {
                        this.scrollBox && (this.ratio = this.scrollBox.scrollTop / (this.scrollBox.scrollHeight - this.getHeight(this.scrollBox)),
                        this.$root.scrollCustom && (this.top = this.ratio * (this.scrollBox.offsetHeight - this.height)))
                    },
                    onContentScroll: function() {
                        this.$dispatch("onContentScroll", this.ratio, this.scrollBox.scrollTop, this.scrollBox.scrollHeight - this.getHeight(this.scrollBox) - this.scrollBox.scrollTop)
                    },
                    startDrag: function(event) {
                        this.dragStart = !0,
                            this.mouseYFirst = event.pageY,
                            this.scrollBoxTopFirst = this.scrollBox.scrollTop,
                            console.log(this.dragStart)
                    },
                    stopDrag: function() {
                        this.dragStart = !1,
                            console.log(this.dragStart)
                    },
                    mousePosition: function(value) {
                        if (this.dragStart)
                            if (this.isTablet) {
                                if (1 == value.touches.length) {
                                    var touch = value.touches[0];
                                    this.mouseY < touch.clientY && console.log("up"),
                                    this.mouseY > touch.clientY && console.log("down"),
                                        this.mouseY = touch.clientY
                                }
                            } else
                                delta = this.mouseY - value.clientY,
                                    contentHeight = document.getElementById("content-item").clientHeight,
                                    dragValue = contentHeight / window.innerHeight,
                                    diffMouse = this.mouseYFirst - value.pageY,
                                0 != diffMouse && this.onDrag(diffMouse * dragValue)
                    },
                    onDrag: function(value) {
                        this.scrollBox.scrollTop = this.scrollBoxTopFirst - value
                    }
                },
                components: {},
                events: {
                    onSmoothScroll: function(delta) {
                        this.enabled && this.$root.scrollCustom && (this.scrollBox.scrollTop -= delta,
                            this.updateHeight(),
                            this.updateTop())
                    },
                    onEnterFrame: function(ratioDeltaTime, deltaTime, currentTime) {
                        this.$broadcast("onEnterFrame", ratioDeltaTime, deltaTime, currentTime),
                            this.scrollBox = this.$el,
                            this.updateHeight(),
                            this.updateTop()
                    },
                    onSetScroll: function(value) {
                        this.scrollBox && (this.scrollBox.scrollTop = value,
                            this.updateHeight(),
                            this.updateTop(),
                            this.onContentScroll())
                    }
                },
                watch: {}
            },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = '<div class=scrollbox @scroll=onContentScroll :class="{\'no-custom\':!$root.scrollCustom}" _v-5ac872d7=""><div class=scrollerdiv v-show="enabled &amp;&amp; scrollable" _v-5ac872d7=""><div class=scroller id=scroller :style="{\'top\':top + \'px\', \'height\': height + \'px\'}" @mousedown=startDrag @touchstart=startDrag @mousemove=mousePosition @touchmove=mousePosition @mouseup=stopDrag @touchend=stopDrag _v-5ac872d7=""></div></div><div class=scroll-content id=scroll-content _v-5ac872d7=""><slot _v-5ac872d7=""></slot></div></div>'
    }
        , {
            "vueify/lib/insert-css": 103
        }],
    123: [function(require, module, exports) {
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full[_v-4cf304cf]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app .shapes[_v-4cf304cf],.common-absolute-full[_v-4cf304cf]{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full[_v-4cf304cf]{display:block;width:100%;height:100%}.common-center-cover[_v-4cf304cf]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover[_v-4cf304cf],.common-hover[_v-4cf304cf]:hover{color:#7ad71f}.common-hover[_v-4cf304cf]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-4cf304cf]{display:block;text-align:center}#app.shape-light .svg-shapes[_v-4cf304cf]{stroke:#ebeded}#app.shape-light .svg-shapes-color[_v-4cf304cf]{display:none}#app .shapes[_v-4cf304cf]{z-index:0;pointer-events:none}#app .shapes .svg-defs[_v-4cf304cf]{position:absolute;width:0;height:0;fill:#000}#app .shapes .svg-loading-path[_v-4cf304cf],#app .shapes .svg-shapes-color[_v-4cf304cf],#app .shapes .svg-shapes[_v-4cf304cf]{position:absolute;top:0;left:0;width:100%;height:100%}#app .shapes .svg-loading-path[_v-4cf304cf]{opacity:0;-webkit-transition:opacity .5s cubic-bezier(.55,.055,.675,.19);transition:opacity .5s cubic-bezier(.55,.055,.675,.19)}#app .shapes .svg-loading-path.animate[_v-4cf304cf]{opacity:1}#app .shapes .svg-clipping-test[_v-4cf304cf]{width:100%;height:100%;-webkit-clip-path:url(#shapes-clipping);clip-path:url(#shapes-clipping)}#app .shapes .svg-shapes-color[_v-4cf304cf]{-webkit-clip-path:url(#circle-clipping);clip-path:url(#circle-clipping)}#app.is-mobile .shapes .svg-shapes-color[_v-4cf304cf]{-webkit-clip-path:inherit;clip-path:inherit}.fade-transition[_v-4cf304cf]{opacity:1;-webkit-transition:opacity 1s cubic-bezier(.55,.055,.675,.19) .5s;transition:opacity 1s cubic-bezier(.55,.055,.675,.19) .5s}.fade-enter[_v-4cf304cf],.fade-leave[_v-4cf304cf]{opacity:0}.fade-leave[_v-4cf304cf]{-webkit-transition:opacity .5s cubic-bezier(.215,.61,.355,1) 0s;transition:opacity .5s cubic-bezier(.215,.61,.355,1) 0s}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _gsap = require("../../node_modules/gsap")
            , _gsap2 = _interopRequireDefault(_gsap)
            , _mathTools = require("../scripts/mathTools")
            , _mathTools2 = _interopRequireDefault(_mathTools);
        exports.default = {
            data: function() {
                return {
                    tx: 0,
                    ty: 0,
                    sx: 0,
                    sy: 0,
                    dashoffset: 0,
                    dashvalue: 900,
                    isAnimating: !1,
                    isInteracting: !1,
                    scaleMask: 0,
                    maskX: 0,
                    maskY: 0
                }
            },
            computed: {
                shapeTransform: function() {
                    return "translate(" + this.tx + " " + this.ty + ") scale(" + this.sx + " " + this.sy + ")"
                },
                maskRadius: function() {
                    return this.scaleMask * Math.min(this.$root.size.w, this.$root.size.h) * .2
                }
            },
            ready: function() {
                this.render(0),
                    this.resize()
            },
            attached: function() {},
            methods: {
                resize: function() {
                    var w = 1910.3156
                        , h = 1463.16 * .92
                        , ratioW = this.$root.size.w / w
                        , ratioH = this.$root.size.h / h
                        , ratio = ratioW > ratioH ? ratioW : ratioH;
                    this.$set("tx", .5 * (this.$root.size.w - w * ratio)),
                        this.$set("ty", .5 * (this.$root.size.h - h * ratio)),
                        this.$set("sx", ratio),
                        this.$set("sy", ratio)
                },
                render: function(progress) {
                    this.dashoffset = this.dashvalue - this.dashvalue * Math.pow(.01 * progress, 5)
                },
                renderMask: function() {
                    var animated = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    this.maskX = _mathTools2.default.ease(this.maskX, .5 * (this.$root.mouse.x + 1) * this.$root.size.w, animated ? .1 : 1),
                        this.maskY = _mathTools2.default.ease(this.maskY, .5 * (this.$root.mouse.y + 1) * this.$root.size.h, animated ? .1 : 1)
                }
            },
            events: {
                onLoadAnimStart: function() {
                    this.$set("isAnimating", !0),
                        this.render(0)
                },
                onLoadAnimStop: function() {
                    this.$set("isAnimating", !1)
                },
                startShapeInteract: function() {
                    this.isInteracting = !0,
                        this.$on("onEnterFrame", this.renderMask)
                },
                stopShapeInteract: function() {
                    this.isInteracting = !1,
                        this.$off("onEnterFrame", this.renderMask)
                },
                onMouseMove: function() {
                    0 === this.scaleMask && _gsap2.default.to(this, .5, {
                        scaleMask: 1,
                        ease: Ease.cubicIn
                    })
                },
                onResize: "resize",
                onLoadSmoothProgress: "render"
            },
            watch: {
                "$root.mouse.out": function(value) {
                    _gsap2.default.to(this, .5, {
                        scaleMask: value ? 0 : 1,
                        ease: Ease.cubicIn
                    }),
                    value || this.renderMask(!1)
                }
            }
        },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = '<div class=shapes :class="{\'interacting\':(isInteracting &amp;&amp; ((!this.$root.isMobile &amp;&amp; !this.$root.mouse.out) || this.$root.isMobile))}" _v-4cf304cf=""><svg class=svg-defs xmlns=http://www.w3.org/2000/svg _v-4cf304cf=""><defs _v-4cf304cf=""><clipPath id=shapes-clipping v-bind:transform=shapeTransform _v-4cf304cf=""><svg-path _v-4cf304cf=""></svg-path></clipPath><clipPath id=circle-clipping fill=none _v-4cf304cf=""><circle :cx=maskX :cy=maskY :r=maskRadius _v-4cf304cf=""></circle></clipPath></defs></svg> <svg class=svg-shapes stroke=#262628 fill=none preserveAspectRatio="xMidYMid slice" _v-4cf304cf=""><g v-bind:transform=shapeTransform _v-4cf304cf=""><svg-path _v-4cf304cf=""></svg-path></g></svg> <svg class=svg-loading-path :class="{\'animate\':isAnimating}" stroke=#4e4e51 fill=none stroke-dasharray="{{dashvalue}} {{dashvalue}}" stroke-dashoffset={{dashoffset}} preserveAspectRatio="xMidYMid slice" _v-4cf304cf=""><g v-bind:transform=shapeTransform _v-4cf304cf=""><svg-path _v-4cf304cf=""></svg-path></g></svg> <svg class=svg-shapes-color stroke=#262628 fill=none preserveAspectRatio="xMidYMid slice" v-show="isInteracting &amp;&amp; !$root.isLoading" transition=fade _v-4cf304cf=""><g v-bind:transform=shapeTransform _v-4cf304cf=""><svg-path _v-4cf304cf=""></svg-path></g></svg></div>';
    }
        , {
            "../../node_modules/gsap": 80,
            "../scripts/mathTools": 129,
            "vueify/lib/insert-css": 103
        }],
    124: [function(require, module, exports) {
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full[_v-6235493e]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}#app .slider .slider-item[_v-6235493e]:after,.common-absolute-full[_v-6235493e]{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full[_v-6235493e]{display:block;width:100%;height:100%}#app .slider .slider-item[_v-6235493e],.common-center-cover[_v-6235493e]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover[_v-6235493e],.common-hover[_v-6235493e]:hover{color:#7ad71f}.common-hover[_v-6235493e]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-6235493e]{display:block;text-align:center}#app .slider[_v-6235493e]{position:relative;overflow:hidden}#app .slider .slider-wrapper[_v-6235493e]{width:auto;height:29.81vw;-webkit-writing-mode:vertical-lr;-ms-writing-mode:tb-lr;writing-mode:vertical-lr;overflow:hidden;padding:0 12.5vw;box-sizing:border-box;-webkit-transition:-webkit-transform .4s;transition:-webkit-transform .4s;transition:transform .4s;transition:transform .4s,-webkit-transform .4s}#app .slider .slider-item[_v-6235493e]{position:relative;width:53vw;height:100%;margin:0 11vw;cursor:pointer;z-index:0}#app .slider .slider-item[_v-6235493e]:after{content:'';background-color:#e9edee;z-index:1;-webkit-transition:opacity .5s;transition:opacity .5s}#app .slider .slider-item[_v-6235493e]:hover:after{opacity:.9}#app .slider .slider-item.active[_v-6235493e]:after,#app .slider .slider-item.active[_v-6235493e]:hover:after{opacity:0}#app .slider.scrolling .slider-wrapper[_v-6235493e]{-webkit-transition:-webkit-transform 0s;transition:-webkit-transform 0s;transition:transform 0s;transition:transform 0s,-webkit-transform 0s}#app.is-mobile .slider .slider-wrapper[_v-6235493e]{height:42.18vw;padding:0 6.25vw}#app.is-mobile .slider .slider-item[_v-6235493e]{width:75vw;height:100%;margin:0 6.25vw}#app.is-mobile .slider .slider-item[_v-6235493e]:hover:after{opacity:intial}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _gsap = require("../../node_modules/gsap");
        _interopRequireDefault(_gsap);
        exports.default = {
            data: function() {
                return {
                    activeIndex: 0,
                    sHeight: 0,
                    scrollValueIndex: 0,
                    scrollValue: 0,
                    isScrolling: !1,
                    touchStartX: 0
                }
            },
            props: ["items"],
            computed: {},
            ready: function() {
                this.updateSlider()
            },
            attached: function() {},
            methods: {
                select: function(index) {
                    var item = this.$el.querySelector(".slider-item");
                    this.scrollValueIndex = index * (item.offsetWidth + .5 * (this.outerWidth(item) - item.offsetWidth)),
                        this.scrollValue = this.scrollValueIndex,
                        this.activeIndex = index
                },
                outerWidth: function(el) {
                    var width = el.offsetWidth
                        , style = getComputedStyle(el);
                    return width += parseInt(style.marginLeft) + parseInt(style.marginRight)
                },
                onSlide: function(e) {
                    var item = this.$el.querySelector(".slider-item");
                    this.scrollValue = this.scrollValueIndex + this.touchStartX - e.touches[0].pageX,
                        this.activeIndex = Math.round(this.scrollValue / (item.offsetWidth + .5 * (this.outerWidth(item) - item.offsetWidth))),
                        this.activeIndex = Math.min(Math.max(this.activeIndex, 0), this.items.length - 1)
                },
                onStartSlide: function(e) {
                    this.isScrolling = !0,
                        this.touchStartX = e.touches[0].pageX
                },
                onEndSlide: function(e) {
                    this.isScrolling = !1,
                        this.select(this.activeIndex)
                },
                updateSlider: function() {
                    var bounds = this.$el.querySelector(".slider-wrapper").getBoundingClientRect();
                    this.sHeight = bounds.height,
                        this.select(this.activeIndex)
                }
            },
            events: {
                onResize: function() {
                    this.updateSlider()
                }
            }
        },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = "<div class=slider :class=\"{'disable':disable, 'scrolling': isScrolling}\" @touchstart=onStartSlide @touchend=onEndSlide @touchmove=onSlide _v-6235493e=\"\"><div class=slider-wrapper :style=\"{'transform':'translate3d('+(-scrollValue)+'px,0,0)'}\" _v-6235493e=\"\"><div class=slider-item v-for=\"item in items\" :class=\"{'active':$index == activeIndex}\" :style=\"{'background-image':'url('+item+')'}\" @click=select($index) _v-6235493e=\"\"></div></div></div>"
    }
        , {
            "../../node_modules/gsap": 80,
            "vueify/lib/insert-css": 103
        }],
    125: [function(require, module, exports) {
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full[_v-70dd4ee6]{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-absolute-full[_v-70dd4ee6]{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full[_v-70dd4ee6]{display:block;width:100%;height:100%}#app .slider-auto[_v-70dd4ee6],.common-center-cover[_v-70dd4ee6]{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover[_v-70dd4ee6],.common-hover[_v-70dd4ee6]:hover{color:#7ad71f}.common-hover[_v-70dd4ee6]{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center[_v-70dd4ee6]{display:block;text-align:center}#app .slider-auto[_v-70dd4ee6]{position:relative;margin-bottom:22vh;box-sizing:border-box}#app .slider-auto .slider-wrapper[_v-70dd4ee6]{width:100%;height:100%;z-index:2;overflow:hidden}#app .slider-auto .slider-items[_v-70dd4ee6]{width:100%;height:100%}#app .slider-auto .slider-item[_v-70dd4ee6]{display:none;background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%;-webkit-transition:opacity .8s cubic-bezier(.55,.055,.675,.19);transition:opacity .8s cubic-bezier(.55,.055,.675,.19)}#app .slider-auto .slider-item img[_v-70dd4ee6]{display:block;margin:auto;padding:28vh 0}#app .slider-auto .slider-item h3[_v-70dd4ee6]{width:58%;display:block;margin:auto;padding-top:5vh;font-size:25em;font-weight:400;text-align:center}#app .slider-auto .slider-item p[_v-70dd4ee6]{width:58%;height:8vh;display:block;margin:auto;padding:40vh 0;font-size:25em;font-weight:400;text-align:center}#app .slider-auto .slider-item.active[_v-70dd4ee6]{position:relative;display:block;opacity:1;z-index:2}#app .slider-auto .slider-item.previous[_v-70dd4ee6]{position:absolute;top:0;display:block;opacity:0;z-index:1;width:100%}#app .slider-auto .slider-item.next[_v-70dd4ee6]{position:absolute;display:block;opacity:0;z-index:3;width:100%}#app .slider-auto .title[_v-70dd4ee6]{position:absolute;top:14vh;width:100%;color:#fff;font-weight:400;font-size:17em;text-align:center;z-index:3;font-size:25em}#app .slider-auto .slider-indicators[_v-70dd4ee6]{position:absolute;bottom:14vh;width:100%;color:#71777b;text-align:center;font-weight:400;font-size:20em;margin-top:3.25em;z-index:3}#app .slider-auto .slider-indicators .highlight[_v-70dd4ee6]{font-weight:700;color:#fff}#app.is-mobile .slider-auto[_v-70dd4ee6]{padding:60em 0}#app.is-mobile .slider-auto .slider-wrapper[_v-70dd4ee6]{width:100%;margin:auto}#app.is-mobile .slider-auto .slider-item img[_v-70dd4ee6]{width:100%}#app.is-mobile .slider-auto .slider-item h3[_v-70dd4ee6],#app.is-mobile .slider-auto .slider-item p[_v-70dd4ee6]{width:80%;font-size:12em;line-height:1.4em}#app.is-mobile .slider-auto .title[_v-70dd4ee6]{font-size:13em;line-height:1.846153846153846em;margin-bottom:3.076923076923077em}#app.is-mobile .slider-auto .slider-indicators[_v-70dd4ee6]{font-size:13em;margin-top:2.307692307692307em}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }),
            exports.default = {
                filters: {
                    "two-digits": function(value) {
                        return value < 10 ? "0" + value : value
                    }
                },
                data: function() {
                    return {
                        current: -1,
                        ellapsed: 0
                    }
                },
                props: ["slider-data"],
                computed: {
                    total: function() {
                        return this.sliderData.images.length
                    },
                    previous: function() {
                        return this.mod(this.current - 1, this.total)
                    },
                    next: function() {
                        return this.mod(this.current + 1, this.total)
                    }
                },
                ready: function() {},
                attached: function() {},
                methods: {
                    nextSlide: function() {
                        this.current = (this.current + 1) % this.total
                    },
                    mod: function(n, m) {
                        return (n % m + m) % m
                    }
                },
                events: {
                    onEnterFrame: function(ratioDeltaTime, deltaTime, currentTime) {
                        currentTime - this.ellapsed > 4e3 && (this.ellapsed = currentTime,
                            this.nextSlide())
                    }
                },
                components: {}
            },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = '<div class=slider-auto _v-70dd4ee6=""><div class=slider-wrapper v-show="current>=0" _v-70dd4ee6=""><p class="title text-title" _v-70dd4ee6="">{{sliderData.title}}<div class=slider-items _v-70dd4ee6=""><div class=slider-item v-for="item in sliderData.images" :class="{\'active\':$index == current, \'previous\':$index == previous, \'next\':$index == next}" :style="{\'background-image\':\'url(\'+item.background+\')\'}" _v-70dd4ee6=""><h3 v-if=item.titletext v-html=item.titletext _v-70dd4ee6=""></h3><p v-if=item.regular v-html=item.regular _v-70dd4ee6=""></p><img v-if=item.image :src=item.image _v-70dd4ee6=""></div></div><p class="slider-indicators text-normal" _v-70dd4ee6=""><span class=highlight _v-70dd4ee6="">{{current + 1 | two-digits}}</span> {{total | two-digits}}</div></div>'
    }
        , {
            "vueify/lib/insert-css": 103
        }],
    126: [function(require, module, exports) {
        var __vueify_insert__ = require("vueify/lib/insert-css");
        __vueify_insert__.insert(".common-fixed-full{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-absolute-full,.youtube-overlay{position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.common-block-full{display:block;width:100%;height:100%}.common-center-cover{background-size:cover;background-position:50%;background-repeat:no-repeat;width:100%;height:100%}.common-force-hover,.common-hover:hover{color:#7ad71f}.common-hover{-webkit-transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:color .3s cubic-bezier(.55,.055,.675,.19);transition:,color .3s cubic-bezier(.55,.055,.675,.19)}.common-center{display:block;text-align:center}.youtube-overlay{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;z-index:4;background-color:rgba(0,0,0,.8);cursor:pointer}");
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }),
            exports.default = {
                data: function() {
                    return {
                        isOpen: !1,
                        videoID: null
                    }
                },
                computed: {
                    playerWidth: function() {
                        var pw, w = this.$root.size.w;
                        return pw = w > 1024 ? 1024 : w > 720 ? 720 : .9 * w
                    },
                    playerHeight: function() {
                        return 9 * this.playerWidth / 16
                    }
                },
                ready: function() {},
                attached: function() {},
                methods: {
                    closeVideo: function() {
                        this.$emit("onCloseVideo")
                    },
                    onPlayerReady: function() {
                        this.player = this.$refs.player.player
                    },
                    onPlayerPlaying: function() {}
                },
                components: {},
                events: {
                    onPlayVideo: function(videoID) {
                        this.videoID = videoID,
                            this.isOpen = !0
                    },
                    onCloseVideo: function() {
                        this.player.stopVideo(),
                            this.isOpen = !1
                    }
                }
            },
        module.exports.__esModule && (module.exports = module.exports.default),
            ("function" == typeof module.exports ? module.exports.options : module.exports).template = "<div v-show=isOpen :class=\"{'show':isOpen}\" class=youtube-overlay @click=closeVideo()><youtube v-if=videoID v-ref:player :video-id=videoID :player-width=playerWidth :player-height=playerHeight :player-vars={rel:0,showinfo:0,autoplay:1} class=youtube-player @ready=onPlayerReady() @playing=onPlayerPlaying()></youtube></div>"
    }
        , {
            "vueify/lib/insert-css": 103
        }],
    127: [function(require, module, exports) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var _vue = require("vue")
            , _vue2 = _interopRequireDefault(_vue)
            , _vueRouter = require("vue-router")
            , _vueRouter2 = _interopRequireDefault(_vueRouter)
            , _vueHead = require("vue-head")
            , _vueHead2 = _interopRequireDefault(_vueHead)
            , _routeConfig = require("./route-config")
            , _vueResource = require("vue-resource")
            , _vueResource2 = _interopRequireDefault(_vueResource)
            , _vueYoutubeEmbed = require("vue-youtube-embed")
            , _vueYoutubeEmbed2 = _interopRequireDefault(_vueYoutubeEmbed)
            , _App = require("./App.vue")
            , _App2 = _interopRequireDefault(_App)
            , _AppDebug = require("./components/AppDebug.vue")
            , _AppDebug2 = _interopRequireDefault(_AppDebug)
            , _SVGPath = require("./components/SVGPath.vue")
            , _SVGPath2 = _interopRequireDefault(_SVGPath)
            , _Shapes = require("./components/Shapes.vue")
            , _Shapes2 = _interopRequireDefault(_Shapes)
            , _Glitch = require("./components/Glitch.vue")
            , _Glitch2 = _interopRequireDefault(_Glitch)
            , _Intro = require("./components/Intro.vue")
            , _Intro2 = _interopRequireDefault(_Intro)
            , _Notfound = require("./components/Notfound.vue")
            , _Notfound2 = _interopRequireDefault(_Notfound)
            , _Popin = require("./components/Popin.vue")
            , _Popin2 = _interopRequireDefault(_Popin);
        require("es6-promise").polyfill(),
            _vue2.default.use(_vueHead2.default),
            _vue2.default.use(_vueRouter2.default),
            _vue2.default.use(_vueResource2.default),
            _vue2.default.use(_vueYoutubeEmbed2.default),
            _vue2.default.component("appdebug", _AppDebug2.default),
            _vue2.default.component("svg-path", _SVGPath2.default),
            _vue2.default.component("shapes", _Shapes2.default),
            _vue2.default.component("glitch", _Glitch2.default),
            _vue2.default.component("intro", _Intro2.default),
            _vue2.default.component("notfound", _Notfound2.default),
            _vue2.default.component("popin", _Popin2.default);
        var router = new _vueRouter2.default({
            history: "8080" !== window.location.port,
            saveScrollPosition: !0,
            transitionOnLoad: !0
        });
        (0,
            _routeConfig.configRouter)(router),
            router.start(_App2.default, "#app"),
            window.router = router
    }
        , {
            "./App.vue": 104,
            "./components/AppDebug.vue": 105,
            "./components/Glitch.vue": 108,
            "./components/Intro.vue": 109,
            "./components/Notfound.vue": 112,
            "./components/Popin.vue": 117,
            "./components/SVGPath.vue": 121,
            "./components/Shapes.vue": 123,
            "./route-config": 128,
            "es6-promise": 78,
            vue: 102,
            "vue-head": 98,
            "vue-resource": 99,
            "vue-router": 100,
            "vue-youtube-embed": 101
        }],
    128: [function(require, module, exports) {
        "use strict";
        function configRouter(router) {
            var Page = require("./components/Page.vue")
                , Intro = require("./components/Intro.vue")
                , Notfound = require("./components/Notfound.vue");
            router.map({
                "*": {
                    component: Notfound
                },
                "/notfound": {
                    component: Notfound
                },
                "/:page": {
                    component: Page
                },
                "/:page/:item": {
                    component: Page
                },
                "/:page/:item/:popin": {
                    component: Page
                },
                "/": {
                    component: Intro
                },
                "fr/notfound": {
                    component: Notfound
                },
                "fr/:page": {
                    component: Page
                },
                "fr/:page/:item": {
                    component: Page
                },
                "fr/:page/:item/:popin": {
                    component: Page
                },
                "fr/": {
                    component: Intro
                }
            }),
                router.redirect({
                    "/404": "/notfound",
                    "/page-not-found": "/notfound",
                    "/item-not-found": "/notfound",
                    "/popin-not-found": "/notfound",
                    en: "/",
                    "en/": "/",
                    "fr/404": "/notfound",
                    "fr/page-not-found": "/notfound",
                    "fr/item-not-found": "/notfound",
                    "fr/popin-not-found": "/notfound"
                })
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }),
            exports.configRouter = configRouter
    }
        , {
            "./components/Intro.vue": 109,
            "./components/Notfound.vue": 112,
            "./components/Page.vue": 113
        }],
    129: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var MathTools = {
            ease: function(value, targetValue, easeValue) {
                return (targetValue - value) * easeValue + value
            },
            clamp: function(value, min, max) {
                return Math.max(Math.min(value, max), min)
            }
        };
        exports.default = MathTools
    }
        , {}],
    130: [function(require, module, exports) {
        "use strict";
        var ScrollManager = function() {
            this.callback = null,
                this.callbackHorizontal = null,
                this.delta = 0,
                this.deltas = [],
                this.deltaTouchX = null,
                this.deltaTouchY = null,
                this.checkTimeout = null,
                this.flushTimeout = null,
                this.swipeTimeout = null,
                this.scrollID = 0,
                this.preventEvents = !0,
                this.swippingAvg = 0,
                this.debug = !1
        };
        ScrollManager.prototype = {
            listen: function(callback, callbackHorizontal) {
                window.addEventListener ? (this.callback = callback,
                    this.callbackHorizontal = callbackHorizontal,
                    window.addEventListener("mousewheel", this.onMouseWheel.bind(this), !1),
                    window.addEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), !1)) : window.attachEvent("onmousewheel", this.onMouseWheel.bind(this)),
                    document.addEventListener("touchmove", this.onTouchmove.bind(this), !0)
            },
            onTouchmove: function(e) {
                this.preventEvents && e.preventDefault();
                var id = e.touches[0].identifier
                    , x = e.touches[0].clientX
                    , y = e.touches[0].clientY;
                this.deltaTouchY && this.scrollID === id && this.callback(e.touches[0].clientY - this.deltaTouchY, null, this.scrollID, !0),
                this.deltaTouchX && this.scrollID === id && this.callbackHorizontal(e.touches[0].clientX - this.deltaTouchX, null, this.scrollID, !0),
                    this.deltaTouchX = x,
                    this.deltaTouchY = y,
                    this.scrollID = id
            },
            onMouseWheel: function(e) {
                this.preventEvents && e.preventDefault(),
                    clearTimeout(this.flushTimeout),
                    this.delta = e.wheelDelta || 40 * -e.detail,
                    this.deltas.push(this.delta),
                this.checkTimeout || (this.checkTimeout = setTimeout(this.checkDeltas.bind(this), 50)),
                    this.flushTimeout = setTimeout(this.flushDeltas.bind(this), 200)
            },
            checkDeltas: function() {
                var deltasSum = this.deltas.length > 1 ? this.deltas.reduce(function(a, b) {
                    return a + b
                }, 0) : 0;
                if (this.deltas.length > 1) {
                    this.debug && console.log("many scroll delta", this.deltas.toString());
                    var prv = this.deltas[0]
                        , crr = this.delta
                        , aPrv = Math.abs(prv)
                        , aCrr = Math.abs(crr)
                        , acc = aCrr - aPrv
                        , avg = this.avgArray(this.deltas);
                    this.swipeTimeout ? this.swippingAvg > 0 && avg < 0 || this.swippingAvg < 0 && avg > 0 ? this.startSwipe() : this.updateSwipe() : acc < 10 ? (this.debug && console.log("ONE (computed)", avg),
                        this.flushDeltas(),
                        this.delta = avg,
                        this.scrollID++) : this.startSwipe(),
                        this.swippingAvg = avg
                } else
                    this.debug && console.log("ONE", this.delta),
                        this.flushDeltas(),
                        this.scrollID++;
                0 !== this.delta && "function" == typeof this.callback && this.callback(deltasSum || this.delta, this.swipeTimeout > 0, this.scrollID),
                    this.checkTimeout = clearTimeout(this.checkTimeout)
            },
            flushDeltas: function() {
                this.debug && console.log("FLUSH"),
                    this.deltas = [],
                    this.flushTimeout = clearTimeout(this.flushTimeout)
            },
            startSwipe: function() {
                this.swipeTimeout ? (this.debug && console.log("xx> ABORT AND RESTART SWIPE"),
                    this.swipeTimeout = clearTimeout(this.swipeTimeout)) : this.debug && console.log(">>> START SWIPE"),
                    this.scrollID++,
                    this.flushDeltas(),
                    this.swipeTimeout = setTimeout(this.endSwipe.bind(this, "from START"), 100)
            },
            updateSwipe: function() {
                this.debug && console.log("--- ALREADY SWIPE"),
                    this.flushDeltas(),
                    this.swipeTimeout = clearTimeout(this.swipeTimeout),
                    this.swipeTimeout = setTimeout(this.endSwipe.bind(this, "from UPDATE"), 100)
            },
            endSwipe: function(infos) {
                this.debug && console.log("<<< END SWIPE", infos),
                    this.swipeTimeout = clearTimeout(this.swipeTimeout)
            },
            avgArray: function(list) {
                var total = 0;
                return list.map(function(value) {
                    total += value
                }),
                total / list.length
            }
        },
            module.exports = ScrollManager
    }
        , {}],
    131: [function(require, module, exports) {
        "use strict";
        var Timer = function() {
            this.initialize()
        };
        Timer.prototype = {
            initialize: function() {
                this.deltaTime = 0,
                    this.ratioDeltaTime = 0,
                    this.currentTime = 0,
                    this.targetFPS = 30,
                    this.frameTime = 0,
                    this.previousTime = null,
                    this.requestID = null
            },
            start: function(targetFPS) {
                this.targetFPS = targetFPS || this.targetFPS,
                    this.frameTime = 1e3 / this.targetFPS,
                    this.requestID = window.requestAnimationFrame(this.timer.bind(this))
            },
            stop: function() {
                window.cancelAnimationFrame(this.requestID),
                    this.requestID = null,
                    this.previousTime = null,
                    this.currentTime = 0,
                    this.ratioDeltaTime = 0,
                    this.deltaTime = 0
            },
            timer: function() {
                this.currentTime = (new Date).getTime(),
                    null == this.previousTime ? this.previousTime = this.currentTime : this.currentTime - this.previousTime >= this.frameTime && (this.deltaTime = this.currentTime - this.previousTime,
                        this.ratioDeltaTime = this.deltaTime / this.frameTime,
                        this.previousTime = this.currentTime,
                        this.onTimer(this.ratioDeltaTime, this.deltaTime, this.currentTime)),
                null != this.requestID && (this.requestID = window.requestAnimationFrame(this.timer.bind(this)))
            },
            onTimer: function(ratioDeltaTime, deltaTime, currentTime) {}
        },
            module.exports = Timer
    }
        , {}],
    132: [function(require, module, exports) {
        "use strict";
        var THREE = require("THREE")
            , SceneManager = function() {
            this.initialize()
        };
        SceneManager.prototype = {
            initialize: function() {
                this.renderer = new THREE.WebGLRenderer({
                    antialias: !0,
                    alpha: !0
                }),
                    this.scene = new THREE.Scene,
                    this.camera = new THREE.PerspectiveCamera(35,0,.1,1e4),
                    this.camera.position.set(0, 0, 0),
                    this.camera.lookAt(new THREE.Vector3(0,0,0)),
                    this.scene.add(this.camera),
                    this.renderer.setClearColor(16777215, 1),
                    this.resizeHandler()
            },
            addDefaultBox: function() {
                var geom = new THREE.BoxGeometry(1,1,1)
                    , mat = new THREE.MeshNormalMaterial;
                this.scene.add(new THREE.Mesh(geom,mat))
            },
            resizeHandler: function() {
                var w = window.innerWidth
                    , h = window.innerHeight;
                this.camera.aspect = w / h,
                    this.camera.updateProjectionMatrix(),
                    this.renderer.setSize(w, h)
            },
            render: function() {
                this.renderer.render(this.scene, this.camera)
            }
        },
            module.exports = SceneManager
    }
        , {
            THREE: 1
        }]
}, {}, [127]);
